id,repo_owner,repo_name,sha,raw_patch
GO-2020-0016,ulikunitz,xz,69c6093c7b2397b923acf82cb378f55ab2652b9b," var errOverflowU64 = errors.New(""xz: uvarint overflows 64-bit unsigned integer"")
 
 // readUvarint reads a uvarint from the given byte reader.
 func readUvarint(r io.ByteReader) (x uint64, n int, err error) {
+	const maxUvarintLen = 10
+
 	var s uint
 	i := 0
 	for {
"
GO-2020-0016,ulikunitz,xz,69c6093c7b2397b923acf82cb378f55ab2652b9b," func readUvarint(r io.ByteReader) (x uint64, n int, err error) {
 			return x, i, err
 		}
 		i++
+		if i > maxUvarintLen {
+			return x, i, errOverflowU64
+		}
 		if b < 0x80 {
-			if i > 10 || i == 10 && b > 1 {
+			if i == maxUvarintLen && b > 1 {
 				return x, i, errOverflowU64
 			}
 			return x | uint64(b)<<s, i, nil
"
GO-2022-1008,containers,buildah,4a8bf740e862f2438279c6feee2ea59ddf0cda0b," func (b *Builder) configureUIDGID(g *generate.Generator, mountPoint string, opti
 	}
 	g.SetProcessUID(user.UID)
 	g.SetProcessGID(user.GID)
+	g.AddProcessAdditionalGid(user.GID)
 	for _, gid := range user.AdditionalGids {
 		g.AddProcessAdditionalGid(gid)
 	}
"
GO-2023-2116,gofiber,fiber,8c3916dbf4ad2ed427d02c6eb63ae8b2fa8f019a," func New(config ...Config) fiber.Handler {
 			cookieToken := c.Cookies(cfg.CookieName)
 
 			if cookieToken != """" {
-				rawToken := getTokenFromStorage(c, cookieToken, cfg, sessionManager, storageManager)
+				raw := getRawFromStorage(c, cookieToken, cfg, sessionManager, storageManager)
 
-				if rawToken != nil {
-					token = string(rawToken)
+				if raw != nil {
+					token = cookieToken // Token is valid, safe to set it
 				}
 			}
 		default:
"
GO-2023-2116,gofiber,fiber,8c3916dbf4ad2ed427d02c6eb63ae8b2fa8f019a," func New(config ...Config) fiber.Handler {
 			// If not using CsrfFromCookie extractor, check that the token matches the cookie
 			// This is to prevent CSRF attacks by using a Double Submit Cookie method
 			// Useful when we do not have access to the users Session
-			if !isCsrfFromCookie(cfg.Extractor) && extractedToken != c.Cookies(cfg.CookieName) {
+			if !isCsrfFromCookie(cfg.Extractor) && !compareStrings(extractedToken, c.Cookies(cfg.CookieName)) {
 				return cfg.ErrorHandler(c, ErrTokenInvalid)
 			}
 
-			rawToken := getTokenFromStorage(c, extractedToken, cfg, sessionManager, storageManager)
+			raw := getRawFromStorage(c, extractedToken, cfg, sessionManager, storageManager)
 
-			if rawToken == nil {
+			if raw == nil {
 				// If token is not in storage, expire the cookie
 				expireCSRFCookie(c, cfg)
 				// and return an error
"
GO-2023-2116,gofiber,fiber,8c3916dbf4ad2ed427d02c6eb63ae8b2fa8f019a," func New(config ...Config) fiber.Handler {
 				// If token is single use, delete it from storage
 				deleteTokenFromStorage(c, extractedToken, cfg, sessionManager, storageManager)
 			} else {
-				token = string(rawToken)
+				token = extractedToken // Token is valid, safe to set it
 			}
 		}
 
"
GO-2023-2116,gofiber,fiber,8c3916dbf4ad2ed427d02c6eb63ae8b2fa8f019a," func CsrfFromParam(param string) func(c *fiber.Ctx) (string, error) {
 	return func(c *fiber.Ctx) (string, error) {
 		token := c.Params(param)
 		if token == """" {
-			return """", errMissingParam
+			return """", ErrMissingParam
 		}
 		return token, nil
 	}
"
GO-2023-2116,gofiber,fiber,8c3916dbf4ad2ed427d02c6eb63ae8b2fa8f019a," func CsrfFromForm(param string) func(c *fiber.Ctx) (string, error) {
 	return func(c *fiber.Ctx) (string, error) {
 		token := c.FormValue(param)
 		if token == """" {
-			return """", errMissingForm
+			return """", ErrMissingForm
 		}
 		return token, nil
 	}
"
GO-2023-2116,gofiber,fiber,8c3916dbf4ad2ed427d02c6eb63ae8b2fa8f019a," func CsrfFromCookie(param string) func(c *fiber.Ctx) (string, error) {
 	return func(c *fiber.Ctx) (string, error) {
 		token := c.Cookies(param)
 		if token == """" {
-			return """", errMissingCookie
+			return """", ErrMissingCookie
 		}
 		return token, nil
 	}
"
GO-2023-2116,gofiber,fiber,8c3916dbf4ad2ed427d02c6eb63ae8b2fa8f019a," func CsrfFromHeader(param string) func(c *fiber.Ctx) (string, error) {
 	return func(c *fiber.Ctx) (string, error) {
 		token := c.Get(param)
 		if token == """" {
-			return """", errMissingHeader
+			return """", ErrMissingHeader
 		}
 		return token, nil
 	}
"
GO-2023-2116,gofiber,fiber,8c3916dbf4ad2ed427d02c6eb63ae8b2fa8f019a," func CsrfFromQuery(param string) func(c *fiber.Ctx) (string, error) {
 	return func(c *fiber.Ctx) (string, error) {
 		token := c.Query(param)
 		if token == """" {
-			return """", errMissingQuery
+			return """", ErrMissingQuery
 		}
 		return token, nil
 	}
"
GO-2023-2116,gofiber,fiber,b50d91d58ecdff2a330bf07950244b6c4caf65b1," func configDefault(config ...Config) Config {
 	if cfg.ErrorHandler == nil {
 		cfg.ErrorHandler = ConfigDefault.ErrorHandler
 	}
+	if cfg.SessionKey == """" {
+		cfg.SessionKey = ConfigDefault.SessionKey
+	}
+	if cfg.HandlerContextKey == """" {
+		cfg.HandlerContextKey = ConfigDefault.HandlerContextKey
+	}
 
 	// Generate the correct extractor to get the token from the correct location
 	selectors := strings.Split(cfg.KeyLookup, "":"")
"
GO-2023-2116,gofiber,fiber,b50d91d58ecdff2a330bf07950244b6c4caf65b1," func configDefault(config ...Config) Config {
 		case ""param"":
 			cfg.Extractor = CsrfFromParam(selectors[1])
 		case ""cookie"":
+			if cfg.Session == nil {
+				log.Warn(""[CSRF] Cookie extractor is not recommended without a session store"")
+			}
+			if cfg.CookieSameSite == ""None"" || cfg.CookieSameSite != ""Lax"" && cfg.CookieSameSite != ""Strict"" {
+				log.Warn(""[CSRF] Cookie extractor is only recommended for use with SameSite=Lax or SameSite=Strict"")
+			}
 			cfg.Extractor = CsrfFromCookie(selectors[1])
+			cfg.CookieName = selectors[1] // Cookie name is the same as the key
 		}
 	}
 
"
GO-2023-2116,gofiber,fiber,b50d91d58ecdff2a330bf07950244b6c4caf65b1," package csrf
 
 import (
 	""errors""
+	""reflect""
 	""time""
 
 	""github.com/gofiber/fiber/v2""
 )
 
-var errTokenNotFound = errors.New(""csrf token not found"")
+var (
+	ErrTokenNotFound = errors.New(""csrf token not found"")
+	ErrTokenInvalid  = errors.New(""csrf token invalid"")
+	ErrNoReferer     = errors.New(""referer not supplied"")
+	ErrBadReferer    = errors.New(""referer invalid"")
+	dummyValue       = []byte{'+'}
+)
+
+type CSRFHandler struct {
+	config         *Config
+	sessionManager *sessionManager
+	storageManager *storageManager
+}
 
 // New creates a new middleware handler
 func New(config ...Config) fiber.Handler {
 	// Set default config
 	cfg := configDefault(config...)
 
-	// Create manager to simplify storage operations ( see manager.go )
-	manager := newManager(cfg.Storage)
+	// Create manager to simplify storage operations ( see *_manager.go )
+	var sessionManager *sessionManager
+	var storageManager *storageManager
+	if cfg.Session != nil {
+		// Register the Token struct in the session store
+		cfg.Session.RegisterType(Token{})
 
-	dummyValue := []byte{'+'}
+		sessionManager = newSessionManager(cfg.Session, cfg.SessionKey)
+	} else {
+		storageManager = newStorageManager(cfg.Storage)
+	}
 
 	// Return new handler
 	return func(c *fiber.Ctx) error {
"
GO-2023-2116,gofiber,fiber,b50d91d58ecdff2a330bf07950244b6c4caf65b1," func New(config ...Config) fiber.Handler {
 			return c.Next()
 		}
 
+		// Store the CSRF handler in the context if a context key is specified
+		if cfg.HandlerContextKey != """" {
+			c.Locals(cfg.HandlerContextKey, &CSRFHandler{
+				config:         &cfg,
+				sessionManager: sessionManager,
+				storageManager: storageManager,
+			})
+		}
+
 		var token string
 
 		// Action depends on the HTTP method
 		switch c.Method() {
 		case fiber.MethodGet, fiber.MethodHead, fiber.MethodOptions, fiber.MethodTrace:
-			// Declare empty token and try to get existing CSRF from cookie
-			token = c.Cookies(cfg.CookieName)
+			cookieToken := c.Cookies(cfg.CookieName)
+
+			if cookieToken != """" {
+				rawToken := getTokenFromStorage(c, cookieToken, cfg, sessionManager, storageManager)
+
+				if rawToken != nil {
+					token = string(rawToken)
+				}
+			}
 		default:
 			// Assume that anything not defined as 'safe' by RFC7231 needs protection
 
+			// Enforce an origin check for HTTPS connections.
+			if c.Protocol() == ""https"" {
+				if err := refererMatchesHost(c); err != nil {
+					return cfg.ErrorHandler(c, err)
+				}
+			}
+
 			// Extract token from client request i.e. header, query, param, form or cookie
-			token, err := cfg.Extractor(c)
+			extractedToken, err := cfg.Extractor(c)
 			if err != nil {
 				return cfg.ErrorHandler(c, err)
 			}
 
-			// if token does not exist in Storage
-			if manager.getRaw(token) == nil {
-				// Expire cookie
-				c.Cookie(&fiber.Cookie{
-					Name:        cfg.CookieName,
-					Domain:      cfg.CookieDomain,
-					Path:        cfg.CookiePath,
-					Expires:     time.Now().Add(-1 * time.Minute),
-					Secure:      cfg.CookieSecure,
-					HTTPOnly:    cfg.CookieHTTPOnly,
-					SameSite:    cfg.CookieSameSite,
-					SessionOnly: cfg.CookieSessionOnly,
-				})
-				return cfg.ErrorHandler(c, errTokenNotFound)
+			if extractedToken == """" {
+				return cfg.ErrorHandler(c, ErrTokenNotFound)
+			}
+
+			// If not using CsrfFromCookie extractor, check that the token matches the cookie
+			// This is to prevent CSRF attacks by using a Double Submit Cookie method
+			// Useful when we do not have access to the users Session
+			if !isCsrfFromCookie(cfg.Extractor) && extractedToken != c.Cookies(cfg.CookieName) {
+				return cfg.ErrorHandler(c, ErrTokenInvalid)
+			}
+
+			rawToken := getTokenFromStorage(c, extractedToken, cfg, sessionManager, storageManager)
+
+			if rawToken == nil {
+				// If token is not in storage, expire the cookie
+				expireCSRFCookie(c, cfg)
+				// and return an error
+				return cfg.ErrorHandler(c, ErrTokenNotFound)
+			}
+			if cfg.SingleUseToken {
+				// If token is single use, delete it from storage
+				deleteTokenFromStorage(c, extractedToken, cfg, sessionManager, storageManager)
+			} else {
+				token = string(rawToken)
 			}
 		}
 
"
GO-2023-2116,gofiber,fiber,b50d91d58ecdff2a330bf07950244b6c4caf65b1," func New(config ...Config) fiber.Handler {
 			token = cfg.KeyGenerator()
 		}
 
-		// Add/update token to Storage
-		manager.setRaw(token, dummyValue, cfg.Expiration)
-
-		// Create cookie to pass token to client
-		cookie := &fiber.Cookie{
-			Name:        cfg.CookieName,
-			Value:       token,
-			Domain:      cfg.CookieDomain,
-			Path:        cfg.CookiePath,
-			Expires:     time.Now().Add(cfg.Expiration),
-			Secure:      cfg.CookieSecure,
-			HTTPOnly:    cfg.CookieHTTPOnly,
-			SameSite:    cfg.CookieSameSite,
-			SessionOnly: cfg.CookieSessionOnly,
-		}
-		// Set cookie to response
-		c.Cookie(cookie)
+		// Create or extend the token in the storage
+		createOrExtendTokenInStorage(c, token, cfg, sessionManager, storageManager)
 
-		// Protect clients from caching the response by telling the browser
-		// a new header value is generated
+		// Update the CSRF cookie
+		updateCSRFCookie(c, cfg, token)
+
+		// Tell the browser that a new header value is generated
 		c.Vary(fiber.HeaderCookie)
 
-		// Store token in context if set
+		// Store the token in the context if a context key is specified
 		if cfg.ContextKey != """" {
 			c.Locals(cfg.ContextKey, token)
 		}
"
GO-2023-2115,gofiber,fiber,8c3916dbf4ad2ed427d02c6eb63ae8b2fa8f019a," func New(config ...Config) fiber.Handler {
 			cookieToken := c.Cookies(cfg.CookieName)
 
 			if cookieToken != """" {
-				rawToken := getTokenFromStorage(c, cookieToken, cfg, sessionManager, storageManager)
+				raw := getRawFromStorage(c, cookieToken, cfg, sessionManager, storageManager)
 
-				if rawToken != nil {
-					token = string(rawToken)
+				if raw != nil {
+					token = cookieToken // Token is valid, safe to set it
 				}
 			}
 		default:
"
GO-2023-2115,gofiber,fiber,8c3916dbf4ad2ed427d02c6eb63ae8b2fa8f019a," func New(config ...Config) fiber.Handler {
 			// If not using CsrfFromCookie extractor, check that the token matches the cookie
 			// This is to prevent CSRF attacks by using a Double Submit Cookie method
 			// Useful when we do not have access to the users Session
-			if !isCsrfFromCookie(cfg.Extractor) && extractedToken != c.Cookies(cfg.CookieName) {
+			if !isCsrfFromCookie(cfg.Extractor) && !compareStrings(extractedToken, c.Cookies(cfg.CookieName)) {
 				return cfg.ErrorHandler(c, ErrTokenInvalid)
 			}
 
-			rawToken := getTokenFromStorage(c, extractedToken, cfg, sessionManager, storageManager)
+			raw := getRawFromStorage(c, extractedToken, cfg, sessionManager, storageManager)
 
-			if rawToken == nil {
+			if raw == nil {
 				// If token is not in storage, expire the cookie
 				expireCSRFCookie(c, cfg)
 				// and return an error
"
GO-2023-2115,gofiber,fiber,8c3916dbf4ad2ed427d02c6eb63ae8b2fa8f019a," func New(config ...Config) fiber.Handler {
 				// If token is single use, delete it from storage
 				deleteTokenFromStorage(c, extractedToken, cfg, sessionManager, storageManager)
 			} else {
-				token = string(rawToken)
+				token = extractedToken // Token is valid, safe to set it
 			}
 		}
 
"
GO-2023-2115,gofiber,fiber,8c3916dbf4ad2ed427d02c6eb63ae8b2fa8f019a," func CsrfFromParam(param string) func(c *fiber.Ctx) (string, error) {
 	return func(c *fiber.Ctx) (string, error) {
 		token := c.Params(param)
 		if token == """" {
-			return """", errMissingParam
+			return """", ErrMissingParam
 		}
 		return token, nil
 	}
"
GO-2023-2115,gofiber,fiber,8c3916dbf4ad2ed427d02c6eb63ae8b2fa8f019a," func CsrfFromForm(param string) func(c *fiber.Ctx) (string, error) {
 	return func(c *fiber.Ctx) (string, error) {
 		token := c.FormValue(param)
 		if token == """" {
-			return """", errMissingForm
+			return """", ErrMissingForm
 		}
 		return token, nil
 	}
"
GO-2023-2115,gofiber,fiber,8c3916dbf4ad2ed427d02c6eb63ae8b2fa8f019a," func CsrfFromCookie(param string) func(c *fiber.Ctx) (string, error) {
 	return func(c *fiber.Ctx) (string, error) {
 		token := c.Cookies(param)
 		if token == """" {
-			return """", errMissingCookie
+			return """", ErrMissingCookie
 		}
 		return token, nil
 	}
"
GO-2023-2115,gofiber,fiber,8c3916dbf4ad2ed427d02c6eb63ae8b2fa8f019a," func CsrfFromHeader(param string) func(c *fiber.Ctx) (string, error) {
 	return func(c *fiber.Ctx) (string, error) {
 		token := c.Get(param)
 		if token == """" {
-			return """", errMissingHeader
+			return """", ErrMissingHeader
 		}
 		return token, nil
 	}
"
GO-2023-2115,gofiber,fiber,8c3916dbf4ad2ed427d02c6eb63ae8b2fa8f019a," func CsrfFromQuery(param string) func(c *fiber.Ctx) (string, error) {
 	return func(c *fiber.Ctx) (string, error) {
 		token := c.Query(param)
 		if token == """" {
-			return """", errMissingQuery
+			return """", ErrMissingQuery
 		}
 		return token, nil
 	}
"
GO-2023-2115,gofiber,fiber,b50d91d58ecdff2a330bf07950244b6c4caf65b1," func configDefault(config ...Config) Config {
 	if cfg.ErrorHandler == nil {
 		cfg.ErrorHandler = ConfigDefault.ErrorHandler
 	}
+	if cfg.SessionKey == """" {
+		cfg.SessionKey = ConfigDefault.SessionKey
+	}
+	if cfg.HandlerContextKey == """" {
+		cfg.HandlerContextKey = ConfigDefault.HandlerContextKey
+	}
 
 	// Generate the correct extractor to get the token from the correct location
 	selectors := strings.Split(cfg.KeyLookup, "":"")
"
GO-2023-2115,gofiber,fiber,b50d91d58ecdff2a330bf07950244b6c4caf65b1," func configDefault(config ...Config) Config {
 		case ""param"":
 			cfg.Extractor = CsrfFromParam(selectors[1])
 		case ""cookie"":
+			if cfg.Session == nil {
+				log.Warn(""[CSRF] Cookie extractor is not recommended without a session store"")
+			}
+			if cfg.CookieSameSite == ""None"" || cfg.CookieSameSite != ""Lax"" && cfg.CookieSameSite != ""Strict"" {
+				log.Warn(""[CSRF] Cookie extractor is only recommended for use with SameSite=Lax or SameSite=Strict"")
+			}
 			cfg.Extractor = CsrfFromCookie(selectors[1])
+			cfg.CookieName = selectors[1] // Cookie name is the same as the key
 		}
 	}
 
"
GO-2023-2115,gofiber,fiber,b50d91d58ecdff2a330bf07950244b6c4caf65b1," package csrf
 
 import (
 	""errors""
+	""reflect""
 	""time""
 
 	""github.com/gofiber/fiber/v2""
 )
 
-var errTokenNotFound = errors.New(""csrf token not found"")
+var (
+	ErrTokenNotFound = errors.New(""csrf token not found"")
+	ErrTokenInvalid  = errors.New(""csrf token invalid"")
+	ErrNoReferer     = errors.New(""referer not supplied"")
+	ErrBadReferer    = errors.New(""referer invalid"")
+	dummyValue       = []byte{'+'}
+)
+
+type CSRFHandler struct {
+	config         *Config
+	sessionManager *sessionManager
+	storageManager *storageManager
+}
 
 // New creates a new middleware handler
 func New(config ...Config) fiber.Handler {
 	// Set default config
 	cfg := configDefault(config...)
 
-	// Create manager to simplify storage operations ( see manager.go )
-	manager := newManager(cfg.Storage)
+	// Create manager to simplify storage operations ( see *_manager.go )
+	var sessionManager *sessionManager
+	var storageManager *storageManager
+	if cfg.Session != nil {
+		// Register the Token struct in the session store
+		cfg.Session.RegisterType(Token{})
 
-	dummyValue := []byte{'+'}
+		sessionManager = newSessionManager(cfg.Session, cfg.SessionKey)
+	} else {
+		storageManager = newStorageManager(cfg.Storage)
+	}
 
 	// Return new handler
 	return func(c *fiber.Ctx) error {
"
GO-2023-2115,gofiber,fiber,b50d91d58ecdff2a330bf07950244b6c4caf65b1," func New(config ...Config) fiber.Handler {
 			return c.Next()
 		}
 
+		// Store the CSRF handler in the context if a context key is specified
+		if cfg.HandlerContextKey != """" {
+			c.Locals(cfg.HandlerContextKey, &CSRFHandler{
+				config:         &cfg,
+				sessionManager: sessionManager,
+				storageManager: storageManager,
+			})
+		}
+
 		var token string
 
 		// Action depends on the HTTP method
 		switch c.Method() {
 		case fiber.MethodGet, fiber.MethodHead, fiber.MethodOptions, fiber.MethodTrace:
-			// Declare empty token and try to get existing CSRF from cookie
-			token = c.Cookies(cfg.CookieName)
+			cookieToken := c.Cookies(cfg.CookieName)
+
+			if cookieToken != """" {
+				rawToken := getTokenFromStorage(c, cookieToken, cfg, sessionManager, storageManager)
+
+				if rawToken != nil {
+					token = string(rawToken)
+				}
+			}
 		default:
 			// Assume that anything not defined as 'safe' by RFC7231 needs protection
 
+			// Enforce an origin check for HTTPS connections.
+			if c.Protocol() == ""https"" {
+				if err := refererMatchesHost(c); err != nil {
+					return cfg.ErrorHandler(c, err)
+				}
+			}
+
 			// Extract token from client request i.e. header, query, param, form or cookie
-			token, err := cfg.Extractor(c)
+			extractedToken, err := cfg.Extractor(c)
 			if err != nil {
 				return cfg.ErrorHandler(c, err)
 			}
 
-			// if token does not exist in Storage
-			if manager.getRaw(token) == nil {
-				// Expire cookie
-				c.Cookie(&fiber.Cookie{
-					Name:        cfg.CookieName,
-					Domain:      cfg.CookieDomain,
-					Path:        cfg.CookiePath,
-					Expires:     time.Now().Add(-1 * time.Minute),
-					Secure:      cfg.CookieSecure,
-					HTTPOnly:    cfg.CookieHTTPOnly,
-					SameSite:    cfg.CookieSameSite,
-					SessionOnly: cfg.CookieSessionOnly,
-				})
-				return cfg.ErrorHandler(c, errTokenNotFound)
+			if extractedToken == """" {
+				return cfg.ErrorHandler(c, ErrTokenNotFound)
+			}
+
+			// If not using CsrfFromCookie extractor, check that the token matches the cookie
+			// This is to prevent CSRF attacks by using a Double Submit Cookie method
+			// Useful when we do not have access to the users Session
+			if !isCsrfFromCookie(cfg.Extractor) && extractedToken != c.Cookies(cfg.CookieName) {
+				return cfg.ErrorHandler(c, ErrTokenInvalid)
+			}
+
+			rawToken := getTokenFromStorage(c, extractedToken, cfg, sessionManager, storageManager)
+
+			if rawToken == nil {
+				// If token is not in storage, expire the cookie
+				expireCSRFCookie(c, cfg)
+				// and return an error
+				return cfg.ErrorHandler(c, ErrTokenNotFound)
+			}
+			if cfg.SingleUseToken {
+				// If token is single use, delete it from storage
+				deleteTokenFromStorage(c, extractedToken, cfg, sessionManager, storageManager)
+			} else {
+				token = string(rawToken)
 			}
 		}
 
"
GO-2023-2115,gofiber,fiber,b50d91d58ecdff2a330bf07950244b6c4caf65b1," func New(config ...Config) fiber.Handler {
 			token = cfg.KeyGenerator()
 		}
 
-		// Add/update token to Storage
-		manager.setRaw(token, dummyValue, cfg.Expiration)
-
-		// Create cookie to pass token to client
-		cookie := &fiber.Cookie{
-			Name:        cfg.CookieName,
-			Value:       token,
-			Domain:      cfg.CookieDomain,
-			Path:        cfg.CookiePath,
-			Expires:     time.Now().Add(cfg.Expiration),
-			Secure:      cfg.CookieSecure,
-			HTTPOnly:    cfg.CookieHTTPOnly,
-			SameSite:    cfg.CookieSameSite,
-			SessionOnly: cfg.CookieSessionOnly,
-		}
-		// Set cookie to response
-		c.Cookie(cookie)
+		// Create or extend the token in the storage
+		createOrExtendTokenInStorage(c, token, cfg, sessionManager, storageManager)
 
-		// Protect clients from caching the response by telling the browser
-		// a new header value is generated
+		// Update the CSRF cookie
+		updateCSRFCookie(c, cfg, token)
+
+		// Tell the browser that a new header value is generated
 		c.Vary(fiber.HeaderCookie)
 
-		// Store token in context if set
+		// Store the token in the context if a context key is specified
 		if cfg.ContextKey != """" {
 			c.Locals(cfg.ContextKey, token)
 		}
"
GO-2022-0253,cloudflare,cfrpki,648658b1b176a747b52645989cfddc73a81eacad," func (f *HTTPFetcher) GetXML(url string) (string, error) {
 		return """", NewRRDPErrorFetch(req, errors.New(fmt.Sprintf(""status is %d"", res.StatusCode)))
 	}
 
-	data, err := ioutil.ReadAll(res.Body)
+	// GHSA-g9wh-3vrx-r7hg: Do not process responses that are excessively large
+	r := http.MaxBytesReader(nil, res.Body, ResponseLimit)
+	data, err := ioutil.ReadAll(r)
+
 	if err != nil {
 		return """", err
 	}
"
GO-2020-0019,gorilla,websocket,5b740c29263eb386f33f265561c8262522f19d37," func (c *Conn) advanceFrame() (int, error) {
 	final := p[0]&finalBit != 0
 	frameType := int(p[0] & 0xf)
 	mask := p[1]&maskBit != 0
-	c.readRemaining = int64(p[1] & 0x7f)
+	c.setReadRemaining(int64(p[1] & 0x7f))
 
 	c.readDecompress = false
 	if c.newDecompressionReader != nil && (p[0]&rsv1Bit) != 0 {
"
GO-2020-0019,gorilla,websocket,5b740c29263eb386f33f265561c8262522f19d37," func (c *Conn) advanceFrame() (int, error) {
 		return noFrame, c.handleProtocolError(""unknown opcode "" + strconv.Itoa(frameType))
 	}
 
-	// 3. Read and parse frame length.
+	// 3. Read and parse frame length as per
+	// https://tools.ietf.org/html/rfc6455#section-5.2
+	//
+	// The length of the ""Payload data"", in bytes: if 0-125, that is the payload
+	// length.
+	// - If 126, the following 2 bytes interpreted as a 16-bit unsigned
+	// integer are the payload length.
+	// - If 127, the following 8 bytes interpreted as
+	// a 64-bit unsigned integer (the most significant bit MUST be 0) are the
+	// payload length. Multibyte length quantities are expressed in network byte
+	// order.
 
 	switch c.readRemaining {
 	case 126:
"
GO-2020-0019,gorilla,websocket,5b740c29263eb386f33f265561c8262522f19d37," func (c *Conn) advanceFrame() (int, error) {
 		if err != nil {
 			return noFrame, err
 		}
-		c.readRemaining = int64(binary.BigEndian.Uint16(p))
+
+		if err := c.setReadRemaining(int64(binary.BigEndian.Uint16(p))); err != nil {
+			return noFrame, err
+		}
 	case 127:
 		p, err := c.read(8)
 		if err != nil {
 			return noFrame, err
 		}
-		c.readRemaining = int64(binary.BigEndian.Uint64(p))
+
+		if err := c.setReadRemaining(int64(binary.BigEndian.Uint64(p))); err != nil {
+			return noFrame, err
+		}
 	}
 
 	// 4. Handle frame masking.
"
GO-2020-0019,gorilla,websocket,5b740c29263eb386f33f265561c8262522f19d37," func (c *Conn) advanceFrame() (int, error) {
 	if frameType == continuationFrame || frameType == TextMessage || frameType == BinaryMessage {
 
 		c.readLength += c.readRemaining
+		// Don't allow readLength to overflow in the presence of a large readRemaining
+		// counter.
+		if c.readLength < 0 {
+			return noFrame, ErrReadLimit
+		}
+
 		if c.readLimit > 0 && c.readLength > c.readLimit {
 			c.WriteControl(CloseMessage, FormatCloseMessage(CloseMessageTooBig, """"), time.Now().Add(writeWait))
 			return noFrame, ErrReadLimit
"
GO-2020-0019,gorilla,websocket,5b740c29263eb386f33f265561c8262522f19d37," func (c *Conn) advanceFrame() (int, error) {
 	var payload []byte
 	if c.readRemaining > 0 {
 		payload, err = c.read(int(c.readRemaining))
-		c.readRemaining = 0
+		c.setReadRemaining(0)
 		if err != nil {
 			return noFrame, err
 		}
"
GO-2020-0019,gorilla,websocket,5b740c29263eb386f33f265561c8262522f19d37," func (r *messageReader) Read(b []byte) (int, error) {
 			if c.isServer {
 				c.readMaskPos = maskBytes(c.readMaskKey, c.readMaskPos, b[:n])
 			}
-			c.readRemaining -= int64(n)
+			rem := c.readRemaining
+			rem -= int64(n)
+			c.setReadRemaining(rem)
 			if c.readRemaining > 0 && c.readErr == io.EOF {
 				c.readErr = errUnexpectedEOF
 			}
"
GO-2022-1002,pandatix,go-cvss,d9d478ff0c13b8b09ace030db9262f3c2fe031f4," package gocvss20
 import (
 	""math""
 	""strings""
+	""sync""
+	""unsafe""
 )
 
+var order = [][]string{
+	{""AV"", ""AC"", ""Au"", ""C"", ""I"", ""A""}, // Base metrics
+	{""E"", ""RL"", ""RC""},                 // Temporal metrics
+	{""CDP"", ""TD"", ""CR"", ""IR"", ""AR""},   // Environmental metrics
+}
+
 // ParseVector parses a CVSS v2.0 vector.
 func ParseVector(vector string) (*CVSS20, error) {
 	// Split parts
-	pts := strings.Split(vector, ""/"")
-	if len(pts) != 6 && len(pts) != 9 && len(pts) != 14 {
+	pts, l := split(vector)
+	if l != 6 && l != 9 && l != 14 {
 		return nil, ErrTooShortVector
 	}
+	pts = pts[:l]
 
 	// Work on each CVSS part
 	cvss20 := &CVSS20{
-		Base: Base{},
-		Temporal: Temporal{
-			Exploitability:   ""ND"",
-			RemediationLevel: ""ND"",
-			ReportConfidence: ""ND"",
+		base: base{},
+		temporal: temporal{
+			exploitability:   ""ND"",
+			remediationLevel: ""ND"",
+			reportConfidence: ""ND"",
 		},
-		Environmental: Environmental{
-			CollateralDamagePotential:  ""ND"",
-			TargetDistribution:         ""ND"",
-			ConfidentialityRequirement: ""ND"",
-			IntegrityRequirement:       ""ND"",
-			AvailabilityRequirement:    ""ND"",
+		environmental: environmental{
+			collateralDamagePotential:  ""ND"",
+			targetDistribution:         ""ND"",
+			confidentialityRequirement: ""ND"",
+			integrityRequirement:       ""ND"",
+			availabilityRequirement:    ""ND"",
 		},
 	}
 
-	// Parse metrics in order
-	slcs := [][]string{
-		{""AV"", ""AC"", ""Au"", ""C"", ""I"", ""A""}, // Base metrics
-		{""E"", ""RL"", ""RC""},                 // Temporal metrics
-		{""CDP"", ""TD"", ""CR"", ""IR"", ""AR""},   // Environmental metrics
-	}
 	slci := 0
-	currSlc := slcs[slci]
 	i := 0
 	for _, pt := range pts {
 		abv, v, _ := strings.Cut(pt, "":"")
-		if abv != currSlc[i] {
+		if slci == 4 {
+			return nil, &ErrDefinedN{Abv: abv}
+		}
+		if abv != order[slci][i] {
 			return nil, ErrInvalidMetricOrder
 		}
+
 		if err := cvss20.Set(abv, v); err != nil {
 			return nil, err
 		}
+
 		// Go to next element in slice, or next slice if fully consumed
 		i++
-		if i == len(currSlc) {
+		if i == len(order[slci]) {
 			slci++
-			currSlc = slcs[slci]
 			i = 0
 		}
 	}
"
GO-2023-1597,kitabisa,teler-waf,d1d49cfddfa3ec2adad962870f14b85cd1aaf739," func (t *Teler) checkCustomRules(r *http.Request) error {
 	// Converts map of headers to RAW string
 	headers := headersToRawString(r.Header)
 
-	// Decode the URL-encoded request URI of the URL
-	uri := toURLDecode(r.URL.RequestURI())
+	// Decode the URL-encoded and unescape HTML entities request URI of the URL
+	uri := stringDeUnescape(r.URL.RequestURI())
 
 	// Declare byte slice for request body.
 	var body string
"
GO-2023-1597,kitabisa,teler-waf,d1d49cfddfa3ec2adad962870f14b85cd1aaf739," func (t *Teler) checkCustomRules(r *http.Request) error {
 		body = buf.String()
 	}
 
-	// Decode the URL-encoded of body
-	body = toURLDecode(body)
+	// Decode the URL-encoded and unescape HTML entities of body
+	body = stringDeUnescape(body)
 
 	// Iterate over the Customs field of the Teler struct, which is a slice of custom rules
 	for _, rule := range t.opt.Customs {
"
GO-2022-0534,runatlantis,atlantis,48870911974adddaa4c99c8089e79b7d787fa820," func (d *DefaultGitlabRequestParserValidator) ParseAndValidate(r *http.Request,
 
 	// Validate secret if specified.
 	headerSecret := r.Header.Get(secretHeader)
-	secretStr := string(secret)
-	if len(secret) != 0 && headerSecret != secretStr {
+	if len(secret) != 0 && subtle.ConstantTimeCompare(secret, []byte(headerSecret)) != 1 {
 		return nil, fmt.Errorf(""header %s=%s did not match expected secret"", secretHeader, headerSecret)
 	}
 
"
GO-2021-0079,Bytom,bytom,1ac3c8ac4f2b1e1df9675228290bda6b9586ba42," func (net *Network) checkTopicRegister(data *topicRegister) (*pong, error) {
 	if hash != pongpkt.data.(*pong).TopicHash {
 		return nil, errors.New(""topic hash mismatch"")
 	}
-	if data.Idx < 0 || int(data.Idx) >= len(data.Topics) {
+	if int(data.Idx) < 0 || int(data.Idx) >= len(data.Topics) {
 		return nil, errors.New(""topic index out of range"")
 	}
 	return pongpkt.data.(*pong), nil
"
GO-2022-0701,kubernetes,kubernetes,37f730f68c7f06e060f90714439bfb0dbb2df5e7," func BeforeCreate(strategy RESTCreateStrategy, ctx api.Context, obj runtime.Obje
 	if errs := strategy.Validate(ctx, obj); len(errs) > 0 {
 		return errors.NewInvalid(kind, objectMeta.Name, errs)
 	}
+
+	// Custom validation (including name validation) passed
+	// Now run common validation on object meta
+	// Do this *after* custom validation so that specific error messages are shown whenever possible
+	if errs := validation.ValidateObjectMeta(objectMeta, strategy.NamespaceScoped(), validation.ValidatePathSegmentName); len(errs) > 0 {
+		return errors.NewInvalid(kind, objectMeta.Name, errs)
+	}
+
 	return nil
 }
 
"
GO-2022-0701,kubernetes,kubernetes,37f730f68c7f06e060f90714439bfb0dbb2df5e7," func NewREST(s storage.Interface) (*REST, *StatusREST, *FinalizeREST) {
 			return prefix
 		},
 		KeyFunc: func(ctx api.Context, name string) (string, error) {
-			return path.Join(prefix, name), nil
+			return etcdgeneric.NoNamespaceKeyFunc(ctx, prefix, name)
 		},
 		ObjectNameFunc: func(obj runtime.Object) (string, error) {
 			return obj.(*api.Namespace).Name, nil
"
GO-2022-0701,kubernetes,kubernetes,37f730f68c7f06e060f90714439bfb0dbb2df5e7," func NewREST(s storage.Interface, useCacher bool, connection client.ConnectionIn
 			return prefix
 		},
 		KeyFunc: func(ctx api.Context, name string) (string, error) {
-			return prefix + ""/"" + name, nil
+			return etcdgeneric.NoNamespaceKeyFunc(ctx, prefix, name)
 		},
 		ObjectNameFunc: func(obj runtime.Object) (string, error) {
 			return obj.(*api.Node).Name, nil
"
GO-2022-0701,kubernetes,kubernetes,37f730f68c7f06e060f90714439bfb0dbb2df5e7," func NewREST(s storage.Interface) (*REST, *StatusREST) {
 			return prefix
 		},
 		KeyFunc: func(ctx api.Context, name string) (string, error) {
-			return path.Join(prefix, name), nil
+			return etcdgeneric.NoNamespaceKeyFunc(ctx, prefix, name)
 		},
 		ObjectNameFunc: func(obj runtime.Object) (string, error) {
 			return obj.(*api.PersistentVolume).Name, nil
"
GO-2022-0701,kubernetes,kubernetes,37f730f68c7f06e060f90714439bfb0dbb2df5e7," func NamespaceKeyFunc(prefix string, obj runtime.Object) (string, error) {
 	if err != nil {
 		return """", err
 	}
+	name := meta.Name()
+	if ok, msg := validation.ValidatePathSegmentName(name, false); !ok {
+		return """", fmt.Errorf(""invalid name: %v"", msg)
+	}
 	return prefix + ""/"" + meta.Namespace() + ""/"" + meta.Name(), nil
 }
 
"
GO-2022-0701,kubernetes,kubernetes,37f730f68c7f06e060f90714439bfb0dbb2df5e7," func NoNamespaceKeyFunc(prefix string, obj runtime.Object) (string, error) {
 	if err != nil {
 		return """", err
 	}
+	name := meta.Name()
+	if ok, msg := validation.ValidatePathSegmentName(name, false); !ok {
+		return """", fmt.Errorf(""invalid name: %v"", msg)
+	}
 	return prefix + ""/"" + meta.Name(), nil
 }
"
GO-2021-0085,opencontainers,runc,cad42f6e0932db0ce08c3a3d9e89e6063ec283e4," func readCon(fpath string) (string, error) {
 	}
 	defer in.Close()
 
+	if ok, err := isProcHandle(in); err != nil {
+		return """", err
+	} else if !ok {
+		return """", fmt.Errorf(""%s not on procfs"", fpath)
+	}
+
 	var retval string
 	if _, err := fmt.Fscanf(in, ""%s"", &retval); err != nil {
 		return """", err
"
GO-2021-0085,opencontainers,runc,cad42f6e0932db0ce08c3a3d9e89e6063ec283e4," func writeCon(fpath string, val string) error {
 	}
 	defer out.Close()
 
+	if ok, err := isProcHandle(out); err != nil {
+		return err
+	} else if !ok {
+		return fmt.Errorf(""%s not on procfs"", fpath)
+	}
+
 	if val != """" {
 		_, err = out.Write([]byte(val))
 	} else {
"
GO-2021-0085,opencontainers,selinux,03b517dc4fd57245b1cf506e8ba7b817b6d309da," func readCon(fpath string) (string, error) {
 	}
 	defer in.Close()
 
+	if ok, err := isProcHandle(in); err != nil {
+		return """", err
+	} else if !ok {
+		return """", fmt.Errorf(""%s not on procfs"", fpath)
+	}
+
 	var retval string
 	if _, err := fmt.Fscanf(in, ""%s"", &retval); err != nil {
 		return """", err
"
GO-2021-0085,opencontainers,selinux,03b517dc4fd57245b1cf506e8ba7b817b6d309da," func writeCon(fpath string, val string) error {
 	}
 	defer out.Close()
 
+	if ok, err := isProcHandle(out); err != nil {
+		return err
+	} else if !ok {
+		return fmt.Errorf(""%s not on procfs"", fpath)
+	}
+
 	if val != """" {
 		_, err = out.Write([]byte(val))
 	} else {
"
GO-2021-0075,ethereum,go-ethereum,a5237a27eaf81946a3edb4fafe13ed6359d119e4," func (pm *ProtocolManager) handleMsg(p *peer) error {
 
 			// Advance to the next header of the query
 			switch {
-			case query.Origin.Hash != (common.Hash{}) && query.Reverse:
+			case hashMode && query.Reverse:
 				// Hash based traversal towards the genesis block
 				for i := 0; i < int(query.Skip)+1; i++ {
 					if header := pm.blockchain.GetHeader(query.Origin.Hash, number); header != nil {
"
GO-2021-0075,ethereum,go-ethereum,a5237a27eaf81946a3edb4fafe13ed6359d119e4," func (pm *ProtocolManager) handleMsg(p *peer) error {
 						break
 					}
 				}
-			case query.Origin.Hash != (common.Hash{}) && !query.Reverse:
+			case hashMode && !query.Reverse:
 				// Hash based traversal towards the leaf block
-				if header := pm.blockchain.GetHeaderByNumber(origin.Number.Uint64() + query.Skip + 1); header != nil {
-					if pm.blockchain.GetBlockHashesFromHash(header.Hash(), query.Skip+1)[query.Skip] == query.Origin.Hash {
-						query.Origin.Hash = header.Hash()
+				var (
+					current = origin.Number.Uint64()
+					next    = current + query.Skip + 1
+				)
+				if next <= current {
+					infos, _ := json.MarshalIndent(p.Peer.Info(), """", ""  "")
+					p.Log().Warn(""GetBlockHeaders skip overflow attack"", ""current"", current, ""skip"", query.Skip, ""next"", next, ""attacker"", infos)
+					unknown = true
+				} else {
+					if header := pm.blockchain.GetHeaderByNumber(next); header != nil {
+						if pm.blockchain.GetBlockHashesFromHash(header.Hash(), query.Skip+1)[query.Skip] == query.Origin.Hash {
+							query.Origin.Hash = header.Hash()
+						} else {
+							unknown = true
+						}
 					} else {
 						unknown = true
 					}
-				} else {
-					unknown = true
 				}
 			case query.Reverse:
 				// Number based traversal towards the genesis block
"
GO-2021-0265,tidwall,gjson,77a57fda87dca6d0d7d4627d512a630f89a91c96," func parseObject(c *parseContext, i int, path string) (int, bool) {
 		}
 		if rp.wild {
 			if kesc {
-				pmatch = match.Match(unescape(key), rp.part)
+				pmatch = matchLimit(unescape(key), rp.part)
 			} else {
-				pmatch = match.Match(key, rp.part)
+				pmatch = matchLimit(key, rp.part)
 			}
 		} else {
 			if kesc {
"
GO-2021-0265,tidwall,gjson,77a57fda87dca6d0d7d4627d512a630f89a91c96," func queryMatches(rp *arrayPathResult, value Result) bool {
 		case "">="":
 			return value.Str >= rpv
 		case ""%"":
-			return match.Match(value.Str, rpv)
+			return matchLimit(value.Str, rpv)
 		case ""!%"":
-			return !match.Match(value.Str, rpv)
+			return !matchLimit(value.Str, rpv)
 		}
 	case Number:
 		rpvn, _ := strconv.ParseFloat(rpv, 64)
"
GO-2021-0107,ecnepsnai,web,5a78f8d5c41ce60dcf9f61aaf47a7a8dc3e0002f," var upgrader = websocket.Upgrader{
 
 func (s *Server) socketHandler(endpointHandle SocketHandle, options HandleOptions) httprouter.Handle {
 	return func(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
+		var userData interface{}
+
+		if options.AuthenticateMethod != nil {
+			userData = options.AuthenticateMethod(r)
+			if isUserdataNil(userData) {
+				if options.UnauthorizedMethod == nil {
+					s.log.Warn(""Rejected authenticated request"")
+					w.Header().Set(""Content-Type"", ""application/json"")
+					w.WriteHeader(http.StatusUnauthorized)
+					json.NewEncoder(w).Encode(Error{401, ""Unauthorized""})
+					return
+				}
+
+				options.UnauthorizedMethod(w, r)
+				return
+			}
+		}
+
 		conn, err := upgrader.Upgrade(w, r, nil)
 		if err != nil {
 			s.log.Error(""Error upgrading client for websocket connection: %s"", err.Error())
 			return
 		}
 		endpointHandle(Request{
-			Params: ps,
-			log:    s.log,
+			Params:   ps,
+			UserData: userData,
+			log:      s.log,
 		}, WSConn{
 			c: conn,
 		})
"
GO-2021-0100,containers,storage,306fcabc964470e4b3b87a43a8f6b7d698209ee1," func remapIDs(readIDMappings, writeIDMappings *idtools.IDMappings, chownOpts *id
 	return nil
 }
 
-// cmdStream executes a command, and returns its stdout as a stream.
-// If the command fails to run or doesn't complete successfully, an error
-// will be returned, including anything written on stderr.
-func cmdStream(cmd *exec.Cmd, input io.Reader) (io.ReadCloser, <-chan struct{}, error) {
-	chdone := make(chan struct{})
-	cmd.Stdin = input
-	pipeR, pipeW := io.Pipe()
-	cmd.Stdout = pipeW
-	var errBuf bytes.Buffer
-	cmd.Stderr = &errBuf
-
-	// Run the command and return the pipe
-	if err := cmd.Start(); err != nil {
-		return nil, nil, err
-	}
-
-	// Copy stdout to the returned pipe
-	go func() {
-		if err := cmd.Wait(); err != nil {
-			pipeW.CloseWithError(fmt.Errorf(""%s: %s"", err, errBuf.String()))
-		} else {
-			pipeW.Close()
-		}
-		close(chdone)
-	}()
-
-	return pipeR, chdone, nil
-}
-
 // NewTempArchive reads the content of src into a temporary file, and returns the contents
 // of that file as an archive. The archive can only be read once - as soon as reading completes,
 // the file will be deleted.
"
GO-2023-2052,gofiber,fiber,b8c9ede6efa231116c4bd8bb9d5e03eac1cb76dc," func (c *Ctx) IsProxyTrusted() bool {
 	return false
 }
 
-var localHosts = [...]string{""127.0.0.1"", ""0.0.0.0"", ""::1""}
+var localHosts = [...]string{""127.0.0.1"", ""::1""}
 
 // IsLocalHost will return true if address is a localhost address.
 func (*Ctx) isLocalHost(address string) bool {
 	for _, h := range localHosts {
-		if strings.Contains(address, h) {
+		if address == h {
 			return true
 		}
 	}
"
GO-2022-0463,beego,beego,64cf44d725c8cc35d782327d333df9cbeb1bf2dd," func (t *Tree) match(treePattern string, pattern string, wildcardValues []string
 	if runObject == nil && len(t.fixrouters) > 0 {
 		// Filter the .json .xml .html extension
 		for _, str := range allowSuffixExt {
-			if strings.HasSuffix(seg, str) && strings.HasSuffix(treePattern, seg) {
+			// pattern == """" avoid cases: /aaa.html/aaa.html could access /aaa/:bbb
+			if strings.HasSuffix(seg, str) && pattern == """" {
 				for _, subTree := range t.fixrouters {
-					// strings.HasSuffix(treePattern, seg) avoid cases: /aaa.html/bbb could access /aaa/bbb
 					if subTree.prefix == seg[:len(seg)-len(str)] {
 						runObject = subTree.match(treePattern, pattern, wildcardValues, ctx)
 						if runObject != nil {
"
GO-2022-0252,cloudflare,cfrpki,2882307febd66801de97b2a2ce4d93fe58132005," func (ipn *IPNet) GetAfi() uint8 {
 }
 
 func (ipn *IPNet) GetRange() (net.IP, net.IP, bool) {
-	min, max := GetRangeIP(ipn.IPNet)
+	err, min, max := GetRangeIP(ipn.IPNet)
+	if err != nil {
+		return nil, nil, false
+	}
 	return min, max, false
 }
 
"
GO-2022-0252,cloudflare,cfrpki,2882307febd66801de97b2a2ce4d93fe58132005," func ValidateIPCertificateList(list []IPCertificateInformation, parent *RPKICert
 			valids = append(valids, ip)
 			continue
 		}
+		if min == nil && max == nil {
+			invalids = append(invalids, ip)
+		}
 		valid, checkParent := parent.IsIPRangeInCertificate(min, max)
 		if valid {
 			valids = append(valids, ip)
"
GO-2022-0252,cloudflare,cfrpki,2882307febd66801de97b2a2ce4d93fe58132005," func EncodeROAEntries(asn int, entries []*ROAEntry) (*ROA, error) {
 	return roa, nil
 }
 
-func GetRangeIP(ipnet *net.IPNet) (net.IP, net.IP) {
+func GetRangeIP(ipnet *net.IPNet) (error, net.IP, net.IP) {
 	ip := ipnet.IP
 	mask := ipnet.Mask
 
 	beginIP := make([]byte, len(ip))
 	endIP := make([]byte, len(ip))
 	for i := range []byte(ip) {
+		// GHSA-w6ww-fmfx-2x22: Prevent oob read
+		if i >= len(mask) {
+			return errors.New(""Invalid IP address mask""), nil, nil
+		}
 		beginIP[i] = ip[i] & mask[i]
 		endIP[i] = ip[i] | ^mask[i]
 	}
-	return net.IP(beginIP), net.IP(endIP)
+	return nil, net.IP(beginIP), net.IP(endIP)
 }
 
 // https://tools.ietf.org/html/rfc6480#section-2.3
"
GO-2022-0252,cloudflare,cfrpki,2882307febd66801de97b2a2ce4d93fe58132005," func ValidateIPRoaCertificateList(entries []*ROAEntry, cert *RPKICertificate) ([
 	invalids := make([]*ROAEntry, 0)
 	checkParents := make([]*ROAEntry, 0)
 	for _, entry := range entries {
-		min, max := GetRangeIP(entry.IPNet)
+		err, min, max := GetRangeIP(entry.IPNet)
+		if err != nil {
+			invalids = append(invalids, entry)
+		}
 		valid, checkParent := cert.IsIPRangeInCertificate(min, max)
 		if valid {
 			valids = append(valids, entry)
"
GO-2020-0021,gogs,gogs,83283bca4cb4e0f4ec48a28af680f0d88db3d2c8," func GetIssues(uid, rid, pid, mid int64, page int, isClosed bool, labelIds, sort
 
 	if len(labelIds) > 0 {
 		for _, label := range strings.Split(labelIds, "","") {
-			sess.And(""label_ids like '%$"" + label + ""|%'"")
+			// Prevent SQL inject.
+			if com.StrTo(label).MustInt() > 0 {
+				sess.And(""label_ids like '%$"" + label + ""|%'"")
+			}
 		}
 	}
 
"
GO-2020-0021,gogs,gogs,83283bca4cb4e0f4ec48a28af680f0d88db3d2c8," func SearchRepositoryByName(opt SearchOption) (repos []*Repository, err error) {
 	if opt.Uid > 0 {
 		sess.Where(""owner_id=?"", opt.Uid)
 	}
+	if !opt.Private {
+		sess.And(""is_private=false"")
+	}
 	sess.And(""lower_name like '%"" + opt.Keyword + ""%'"").Find(&repos)
 	return repos, err
 }
"
GO-2020-0021,gogs,gogs,83283bca4cb4e0f4ec48a28af680f0d88db3d2c8," func GetUserByEmail(email string) (*User, error) {
 
 // SearchUserByName returns given number of users whose name contains keyword.
 func SearchUserByName(opt SearchOption) (us []*User, err error) {
-	// Prevent SQL inject.
-	opt.Keyword = strings.TrimSpace(opt.Keyword)
-	if len(opt.Keyword) == 0 {
-		return us, nil
-	}
-
-	opt.Keyword = strings.Split(opt.Keyword, "" "")[0]
+	opt.Keyword = FilterSQLInject(opt.Keyword)
 	if len(opt.Keyword) == 0 {
 		return us, nil
 	}
"
GO-2020-0028,miekg,dns,501e858f679edecd4a38a86317ce50271014a80d," func setTA(h RR_Header, c chan lex, o, f string) (RR, *ParseError, string) {
 		return nil, &ParseError{f, ""bad TA DigestType"", l}, """"
 	}
 	rr.DigestType = uint8(i)
-	s, e, c1 := endingToString(c, ""bad TA Digest"", f)
-	if e != nil {
-		return nil, e.(*ParseError), c1
+	s, err, c1 := endingToString(c, ""bad TA Digest"", f)
+	if err != nil {
+		return nil, err, c1
 	}
 	rr.Digest = s
 	return rr, nil, c1
"
GO-2020-0035,yi-ge,unzip,2adbaa4891b9690853ef10216189189f5ad7dc73," func (uz Unzip) Extract() error {
 		}()
 
 		path := filepath.Join(uz.Dest, f.Name)
+		if !strings.HasPrefix(path, filepath.Clean(uz.Dest)+string(os.PathSeparator)) {
+            return fmt.Errorf(""%s: illegal file path"", path)
+        }
 
 		if f.FileInfo().IsDir() {
 			os.MkdirAll(path, f.Mode())
"
GO-2022-0370,mellium,xmpp,0d92aa486da69b71f2f4a30e62aa722c711b98ac," func (d *Dialer) config(addr string) (cfg *websocket.Config, err error) {
 	cfg.TlsConfig = d.TLSConfig
 	if cfg.TlsConfig == nil {
 		cfg.TlsConfig = &tls.Config{
-			ServerName: cfg.Location.Host,
+			ServerName: remoteAddr,
 			MinVersion: tls.VersionTLS12,
 		}
 	}
"
GO-2020-0017,dgrijalva,jwt-go,ec0a89a131e3e8567adcb21254a5cd20a70ea4ab," type MapClaims map[string]interface{}
 // Compares the aud claim against cmp.
 // If required is false, this method will return true if the value matches or is unset
 func (m MapClaims) VerifyAudience(cmp string, req bool) bool {
-	aud, _ := m[""aud""].(string)
-	return verifyAud(aud, cmp, req)
+	aud, ok := m[""aud""]
+	if !ok {
+		return !req
+	}
+
+	switch v := aud.(type) {
+	case string:
+		return verifyAud(ClaimStrings{v}, cmp, req)
+	case []string:
+		return verifyAud(ClaimStrings(v), cmp, req)
+	default:
+		return false
+	}
 }
 
 // Compares the exp claim against cmp.
"
GO-2022-0400,ntbosscher,gobase,a8d40bce9c429d324122d18c446924dab809e812," func (c Config) getAccessTokenCookieName() string {
 	return strs.Coalesce(c.AccessTokenCookieName, ""token"")
 }
 
+const defaultLoginEndpoint = ""/api/auth/login""
+const defaultRefreshEndpoint = ""/api/auth/refresh""
+const defaultLogoutEndpoint = ""/api/auth/logout""
+const defaultRegisterEndpoint = ""/api/auth/register""
+
 func Setup(router *res.Router, config Config) *AuthRouter {
 	loginPath := strs.Coalesce(config.LoginPath, defaultLoginEndpoint)
 	router.Post(loginPath, loginHandler(&config))
"
GO-2022-0400,ntbosscher,gobase,a8d40bce9c429d324122d18c446924dab809e812," func Setup(router *res.Router, config Config) *AuthRouter {
 		oauth.Setup(router, config.OAuth, sessionSetter)
 	}
 
-	server := middleware(config)
+	server := newServer(config)
 
-	router.Use(func(h http.Handler) http.Handler {
-		server.next = h
-		return server
+	router.Use(func(handler http.Handler) http.Handler {
+		return cloneServer(server, handler)
 	})
 
 	return &AuthRouter{
"
GO-2022-1184,sajari,docconv,b19021ade3d0b71c89d35cb00eb9e589a121faa5," func ConvertPDFImages(path string) (BodyResult, error) {
 // PdfHasImage verify if `path` (PDF) has images
 func PDFHasImage(path string) bool {
 	cmd := ""pdffonts -l 5 %s | tail -n +3 | cut -d' ' -f1 | sort | uniq""
-	out, err := exec.Command(""bash"", ""-c"", fmt.Sprintf(cmd, path)).Output()
+	out, err := exec.Command(""bash"", ""-c"", fmt.Sprintf(cmd, shellEscape(path))).CombinedOutput()
+
 	if err != nil {
 		log.Println(err)
 		return false
"
GO-2022-0643,elastic,beats,aeca65779d573976981587ca1d1461399e1b59dd," func pgsqlFieldsParser(s *pgsqlStream, buf []byte) error {
 		off += 4
 
 		// read format (int16)
+		if len(buf) < off+2 {
+			return errFieldBufferShort
+		}
 		format := common.BytesNtohs(buf[off : off+2])
 		off += 2
 		fieldsFormat = append(fieldsFormat, byte(format))
"
GO-2022-1165,helm,helm,638ebffbc2e445156f3978f02fd83d9af1e56f5b," func LoadIndexFile(path string) (*IndexFile, error) {
 // MustAdd adds a file to the index
 // This can leave the index in an unsorted state
 func (i IndexFile) MustAdd(md *chart.Metadata, filename, baseURL, digest string) error {
+	if i.Entries == nil {
+		return errors.New(""entries not initialized"")
+	}
+
 	if md.APIVersion == """" {
 		md.APIVersion = chart.APIVersionV1
 	}
"
GO-2022-1165,helm,helm,638ebffbc2e445156f3978f02fd83d9af1e56f5b," func loadIndex(data []byte, source string) (*IndexFile, error) {
 
 	for name, cvs := range i.Entries {
 		for idx := len(cvs) - 1; idx >= 0; idx-- {
+			if cvs[idx] == nil {
+				log.Printf(""skipping loading invalid entry for chart %q from %s: empty entry"", name, source)
+				continue
+			}
 			if cvs[idx].APIVersion == """" {
 				cvs[idx].APIVersion = chart.APIVersionV1
 			}
"
GO-2022-1165,helm,helm,638ebffbc2e445156f3978f02fd83d9af1e56f5b," func (r *File) Remove(name string) bool {
 	cp := []*Entry{}
 	found := false
 	for _, rf := range r.Repositories {
+		if rf == nil {
+			continue
+		}
 		if rf.Name == name {
 			found = true
 			continue
"
GO-2022-1052,tendermint,tendermint,a2a6852ab99e4a0f9e79f0ea8c1726e262e25c76," func (cs *State) tryAddVote(vote *types.Vote, peerID p2p.ID) (bool, error) {
 					vote.Type)
 				return added, err
 			}
-			var timestamp time.Time
-			if voteErr.VoteA.Height == cs.state.InitialHeight {
-				timestamp = cs.state.LastBlockTime // genesis time
-			} else {
-				timestamp = sm.MedianTime(cs.LastCommit.MakeCommit(), cs.LastValidators)
-			}
-			// form duplicate vote evidence from the conflicting votes and send it across to the
-			// evidence pool
-			ev := types.NewDuplicateVoteEvidence(voteErr.VoteA, voteErr.VoteB, timestamp, cs.Validators)
-			evidenceErr := cs.evpool.AddEvidenceFromConsensus(ev)
-			if evidenceErr != nil {
-				cs.Logger.Error(""Failed to add evidence to the evidence pool"", ""err"", evidenceErr)
-			} else {
-				cs.Logger.Debug(""Added evidence to the evidence pool"", ""ev"", ev)
-			}
+			// report conflicting votes to the evidence pool
+			cs.evpool.ReportConflictingVotes(voteErr.VoteA, voteErr.VoteB)
+			cs.Logger.Info(""Found and sent conflicting votes to the evidence pool"",
+				""VoteA"", voteErr.VoteA,
+				""VoteB"", voteErr.VoteB,
+			)
 			return added, err
 		} else if err == types.ErrVoteNonDeterministicSignature {
 			cs.Logger.Debug(""Vote has non-deterministic signature"", ""err"", err)
"
GO-2022-1052,tendermint,tendermint,a2a6852ab99e4a0f9e79f0ea8c1726e262e25c76," func (evpool *Pool) PendingEvidence(maxBytes int64) ([]types.Evidence, int64) {
 	return evidence, size
 }
 
-// Update pulls the latest state to be used for expiration and evidence params and then prunes all expired evidence
+// Update takes both the new state and the evidence committed at that height and performs
+// the following operations:
+// 1. Take any conflicting votes from consensus and use the state's LastBlockTime to form
+//    DuplicateVoteEvidence and add it to the pool.
+// 2. Update the pool's state which contains evidence params relating to expiry.
+// 3. Moves pending evidence that has now been committed into the committed pool.
+// 4. Removes any expired evidence based on both height and time.
 func (evpool *Pool) Update(state sm.State, ev types.EvidenceList) {
 	// sanity check
 	if state.LastBlockHeight <= evpool.state.LastBlockHeight {
 		panic(fmt.Sprintf(
-			""Failed EvidencePool.Update new state height is less than or equal to previous state height: %d <= %d"",
+			""failed EvidencePool.Update new state height is less than or equal to previous state height: %d <= %d"",
 			state.LastBlockHeight,
 			evpool.state.LastBlockHeight,
 		))
 	}
-	evpool.logger.Info(""Updating evidence pool"", ""last_block_height"", state.LastBlockHeight,
+	evpool.logger.Debug(""Updating evidence pool"", ""last_block_height"", state.LastBlockHeight,
 		""last_block_time"", state.LastBlockTime)
 
-	evpool.logger.Info(
-		""updating evidence pool"",
-		""last_block_height"", state.LastBlockHeight,
-		""last_block_time"", state.LastBlockTime,
-	)
-
-	evpool.mtx.Lock()
-	// flush awaiting evidence from consensus into pool
-	evpool.flushConsensusBuffer()
+	// flush conflicting vote pairs from the buffer, producing DuplicateVoteEvidence and
+	// adding it to the pool
+	evpool.processConsensusBuffer(state)
 	// update state
-	evpool.state = state
-	evpool.mtx.Unlock()
+	evpool.updateState(state)
 
 	// move committed evidence out from the pending pool and into the committed pool
 	evpool.markEvidenceAsCommitted(ev)
"
GO-2022-1052,tendermint,tendermint,a2a6852ab99e4a0f9e79f0ea8c1726e262e25c76," func (evpool *Pool) CheckEvidence(evList types.EvidenceList) error {
 
 			err := evpool.verify(ev)
 			if err != nil {
-				return &types.ErrInvalidEvidence{Evidence: ev, Reason: err}
+				return err
 			}
 
 			if err := evpool.addPendingEvidence(ev); err != nil {
"
GO-2022-0346,quay,claircore,691f2023a1720a0579e688b69a2f4bfe1f4b7821," func (ps *Scanner) Scan(ctx context.Context, layer *claircore.Layer) ([]*clairco
 			continue
 		}
 		// Build the path on the filesystem.
-		tgt := filepath.Join(root, filepath.Clean(h.Name))
+		tgt := relPath(root, h.Name)
 		// Since tar, as a format, doesn't impose ordering requirements, make
 		// sure to create all parent directories of the current entry.
 		d := filepath.Dir(tgt)
"
GO-2022-0346,quay,claircore,691f2023a1720a0579e688b69a2f4bfe1f4b7821," func (ps *Scanner) Scan(ctx context.Context, layer *claircore.Layer) ([]*clairco
 			stats.Reg++
 		case tar.TypeSymlink:
 			// Normalize the link target into the root.
-			ln := filepath.Join(root, filepath.Clean(h.Linkname))
+			ln := relPath(root, h.Linkname)
 			err = os.Symlink(ln, tgt)
 			stats.Symlink++
 		case tar.TypeLink:
 			// Normalize the link target into the root.
-			ln := filepath.Join(root, filepath.Clean(h.Linkname))
+			ln := relPath(root, h.Linkname)
 			_, exists := os.Lstat(ln)
 			switch {
 			case errors.Is(exists, nil):
"
GO-2020-0050,russellhaering,goxmldsig,f6188febf0c29d7ffe26a0436212b19cb9615e64," func (ctx *ValidationContext) findSignature(el *etree.Element) (*types.Signature
 	var sig *types.Signature
 
 	// Traverse the tree looking for a Signature element
-	err := etreeutils.NSFindIterate(el, Namespace, SignatureTag, func(ctx etreeutils.NSContext, el *etree.Element) error {
-
+	err := etreeutils.NSFindIterate(root, Namespace, SignatureTag, func(ctx etreeutils.NSContext, signatureEl *etree.Element) error {
+		err := validateShape(signatureEl)
+		if err != nil {
+			return err
+		}
 		found := false
-		err := etreeutils.NSFindChildrenIterateCtx(ctx, el, Namespace, SignedInfoTag,
+		err = etreeutils.NSFindChildrenIterateCtx(ctx, signatureEl, Namespace, SignedInfoTag,
 			func(ctx etreeutils.NSContext, signedInfo *etree.Element) error {
 				detachedSignedInfo, err := etreeutils.NSDetatch(ctx, signedInfo)
 				if err != nil {
"
GO-2020-0050,russellhaering,goxmldsig,f6188febf0c29d7ffe26a0436212b19cb9615e64," func (ctx *ValidationContext) findSignature(el *etree.Element) (*types.Signature
 					return fmt.Errorf(""invalid CanonicalizationMethod on Signature: %s"", c14NAlgorithm)
 				}
 
-				el.RemoveChild(signedInfo)
-				el.AddChild(canonicalSignedInfo)
+				signatureEl.RemoveChild(signedInfo)
+				signatureEl.AddChild(canonicalSignedInfo)
 
 				found = true
 
"
GO-2020-0050,russellhaering,goxmldsig,f6188febf0c29d7ffe26a0436212b19cb9615e64," func (ctx *ValidationContext) findSignature(el *etree.Element) (*types.Signature
 
 		// Unmarshal the signature into a structured Signature type
 		_sig := &types.Signature{}
-		err = etreeutils.NSUnmarshalElement(ctx, el, _sig)
+		err = etreeutils.NSUnmarshalElement(ctx, signatureEl, _sig)
 		if err != nil {
 			return err
 		}
"
GO-2022-1166,helm,helm,bafafa8bb1b571b61d7a9528da8d40c307dade3d," func ValidateAgainstSchema(chrt *chart.Chart, values map[string]interface{}) err
 }
 
 // ValidateAgainstSingleSchema checks that values does not violate the structure laid out in this schema
-func ValidateAgainstSingleSchema(values Values, schemaJSON []byte) error {
+func ValidateAgainstSingleSchema(values Values, schemaJSON []byte) (reterr error) {
+	defer func() {
+		if r := recover(); r != nil {
+			reterr = fmt.Errorf(""unable to validate schema: %s"", r)
+		}
+	}()
+
 	valuesData, err := yaml.Marshal(values)
 	if err != nil {
 		return err
"
GO-2022-0587,open-policy-agent,opa,e9d3828db670cbe11129885f37f08cbf04935264," func (p *Parser) parseSome() *Expr {
 	if term := p.parseTermInfixCall(); term != nil {
 		if call, ok := term.Value.(Call); ok {
 			switch call[0].String() {
-			case Member.Name, MemberWithKey.Name: // OK
+			case Member.Name:
+				if len(call) != 3 {
+					p.illegal(""illegal domain"")
+					return nil
+				}
+			case MemberWithKey.Name:
+				if len(call) != 4 {
+					p.illegal(""illegal domain"")
+					return nil
+				}
 			default:
 				p.illegal(""expected `x in xs` or `x, y in xs` expression"")
 				return nil
"
GO-2022-0587,open-policy-agent,opa,e9d3828db670cbe11129885f37f08cbf04935264," func (p *Parser) parseEvery() *Expr {
 	}
 	switch call[0].String() {
 	case Member.Name: // x in xs
+		if len(call) != 3 {
+			p.illegal(""illegal domain"")
+			return nil
+		}
 		qb.Value = call[1]
 		qb.Domain = call[2]
 	case MemberWithKey.Name: // k, v in xs
+		if len(call) != 4 {
+			p.illegal(""illegal domain"")
+			return nil
+		}
 		qb.Key = call[1]
 		qb.Value = call[2]
 		qb.Domain = call[3]
"
GO-2021-0064,kubernetes,kubernetes,e99df0e5a75eb6e86123b56d53e9b7ca0fd00419," func (r *requestInfo) toCurl() string {
 	headers := """"
 	for key, values := range r.RequestHeaders {
 		for _, value := range values {
+			value = maskValue(key, value)
 			headers += fmt.Sprintf(` -H %q`, fmt.Sprintf(""%s: %s"", key, value))
 		}
 	}
"
GO-2023-1874,corazawaf,coraza,a5239ba3ce839e14d9b4f9486e1b4a403dcade8c," func (mbp *multipartBodyProcessor) ProcessRequest(reader io.Reader, v plugintype
 	storagePath := options.StoragePath
 	mediaType, params, err := mime.ParseMediaType(mimeType)
 	if err != nil {
-		log.Fatalf(""failed to parse media type: %s"", err.Error())
+		return err
 	}
 	if !strings.HasPrefix(mediaType, ""multipart/"") {
 		return errors.New(""not a multipart body"")
"
GO-2021-0076,evanphx,json-patch,4c9aadca8f89e349c999f04e28199e96e81aba03," func (d *partialArray) add(key string, val *lazyNode) error {
 		}
 		idx = len(ary) - idx
 	}
-
+	if idx < 0 || idx >= len(ary) || idx > len(cur) {
+		return fmt.Errorf(""Unable to access invalid index: %d"", idx)
+	}
 	copy(ary[0:idx], cur[0:idx])
 	ary[idx] = val
 	copy(ary[idx+1:], cur[idx:])
"
GO-2020-0005,etcd-io,etcd,f4b650b51dc4a53a8700700dc12e1242ac56ba07," func (d *decoder) decode(rec *walpb.Record) error {
 	return d.decodeRecord(rec)
 }
 
+// raft max message size is set to 1 MB in etcd server
+// assume projects set reasonable message size limit,
+// thus entry size should never exceed 10 MB
+const maxWALEntrySizeLimit = int64(10 * 1024 * 1024)
+
 func (d *decoder) decodeRecord(rec *walpb.Record) error {
 	if len(d.brs) == 0 {
 		return io.EOF
"
GO-2020-0005,etcd-io,etcd,f4b650b51dc4a53a8700700dc12e1242ac56ba07," func (d *decoder) decodeRecord(rec *walpb.Record) error {
 	}
 
 	recBytes, padBytes := decodeFrameSize(l)
+	if recBytes >= maxWALEntrySizeLimit-padBytes {
+		return ErrMaxWALEntrySizeLimitExceeded
+	}
 
 	data := make([]byte, recBytes+padBytes)
 	if _, err = io.ReadFull(d.brs[0], data); err != nil {
"
GO-2020-0005,etcd-io,etcd,f4b650b51dc4a53a8700700dc12e1242ac56ba07," func (w *WAL) ReadAll() (metadata []byte, state raftpb.HardState, ents []raftpb.
 		switch rec.Type {
 		case entryType:
 			e := mustUnmarshalEntry(rec.Data)
+			// 0 <= e.Index-w.start.Index - 1 < len(ents)
 			if e.Index > w.start.Index {
-				ents = append(ents[:e.Index-w.start.Index-1], e)
+				// prevent ""panic: runtime error: slice bounds out of range [:13038096702221461992] with capacity 0""
+				up := e.Index - w.start.Index - 1
+				if up > uint64(len(ents)) {
+					// return error before append call causes runtime panic
+					return nil, state, nil, ErrSliceOutOfRange
+				}
+				ents = append(ents[:up], e)
 			}
 			w.enti = e.Index
 
"
GO-2020-0037,tendermint,tendermint,03085c2da23b179c4a51f59a03cb40aa4e85a613," func makeHTTPClient(remoteAddr string) (string, *http.Client) {
 	protocol, address, dialer := makeHTTPDialer(remoteAddr)
 	return protocol + ""://"" + address, &http.Client{
 		Transport: &http.Transport{
-			Dial: dialer,
+			// Set to true to prevent GZIP-bomb DoS attacks
+			DisableCompression: true,
+			Dial:               dialer,
 		},
 	}
 }
"
GO-2022-1129,crewjam,saml,aee3fb1edeeaf1088fcb458727e0fd863d277f8b," func (sp *ServiceProvider) validateSignature(el *etree.Element) error {
 
 	ctx, err := etreeutils.NSBuildParentContext(el)
 	if err != nil {
-		return err
+		return fmt.Errorf(""cannot validate signature on %s: %v"", el.Tag, err)
 	}
 	ctx, err = ctx.SubContext(el)
 	if err != nil {
-		return err
+		return fmt.Errorf(""cannot validate signature on %s: %v"", el.Tag, err)
 	}
 	el, err = etreeutils.NSDetatch(ctx, el)
 	if err != nil {
-		return err
+		return fmt.Errorf(""cannot validate signature on %s: %v"", el.Tag, err)
 	}
 
 	if sp.SignatureVerifier != nil {
 		return sp.SignatureVerifier.VerifySignature(validationContext, el)
 	}
 
-	_, err = validationContext.Validate(el)
-	return err
+	if _, err := validationContext.Validate(el); err != nil {
+		return fmt.Errorf(""cannot validate signature on %s: %v"", el.Tag, err)
+	}
+
+	return nil
 }
 
 // SignLogoutRequest adds the `Signature` element to the `LogoutRequest`.
"
GO-2021-0066,kubernetes,kubernetes,11793434dac97a49bfed0150b56ac63e5dc34634," func ReadDockerConfigFileFromURL(url string, client *http.Client, header *http.H
 
 func readDockerConfigFileFromBytes(contents []byte) (cfg DockerConfig, err error) {
 	if err = json.Unmarshal(contents, &cfg); err != nil {
-		klog.Errorf(""while trying to parse blob %q: %v"", contents, err)
-		return nil, err
+		return nil, errors.New(""error occurred while trying to unmarshal json"")
 	}
 	return
 }
"
GO-2021-0066,kubernetes,kubernetes,11793434dac97a49bfed0150b56ac63e5dc34634," func readDockerConfigFileFromBytes(contents []byte) (cfg DockerConfig, err error
 func readDockerConfigJSONFileFromBytes(contents []byte) (cfg DockerConfig, err error) {
 	var cfgJSON DockerConfigJSON
 	if err = json.Unmarshal(contents, &cfgJSON); err != nil {
-		klog.Errorf(""while trying to parse blob %q: %v"", contents, err)
-		return nil, err
+		return nil, errors.New(""error occurred while trying to unmarshal json"")
 	}
 	cfg = cfgJSON.Auths
 	return
"
GO-2022-0945,square,go-jose,789a4c4bd4c118f7564954f441b29c153ccd6a96," func (ctx *cbcAEAD) Overhead() int {
 // Seal encrypts and authenticates the plaintext.
 func (ctx *cbcAEAD) Seal(dst, nonce, plaintext, data []byte) []byte {
 	// Output buffer -- must take care not to mangle plaintext input.
-	ciphertext := make([]byte, len(plaintext)+ctx.Overhead())[:len(plaintext)]
+	ciphertext := make([]byte, uint64(len(plaintext))+uint64(ctx.Overhead()))[:len(plaintext)]
 	copy(ciphertext, plaintext)
 	ciphertext = padBuffer(ciphertext, ctx.blockCipher.BlockSize())
 
"
GO-2022-0945,square,go-jose,789a4c4bd4c118f7564954f441b29c153ccd6a96," func (ctx *cbcAEAD) Seal(dst, nonce, plaintext, data []byte) []byte {
 	cbc.CryptBlocks(ciphertext, ciphertext)
 	authtag := ctx.computeAuthTag(data, nonce, ciphertext)
 
-	ret, out := resize(dst, len(dst)+len(ciphertext)+len(authtag))
+	ret, out := resize(dst, uint64(len(dst))+uint64(len(ciphertext))+uint64(len(authtag)))
 	copy(out, ciphertext)
 	copy(out[len(ciphertext):], authtag)
 
"
GO-2022-0945,square,go-jose,789a4c4bd4c118f7564954f441b29c153ccd6a96," func (ctx *cbcAEAD) Open(dst, nonce, ciphertext, data []byte) ([]byte, error) {
 
 // Compute an authentication tag
 func (ctx *cbcAEAD) computeAuthTag(aad, nonce, ciphertext []byte) []byte {
-	buffer := make([]byte, len(aad)+len(nonce)+len(ciphertext)+8)
+	buffer := make([]byte, uint64(len(aad))+uint64(len(nonce))+uint64(len(ciphertext))+8)
 	n := 0
 	n += copy(buffer, aad)
 	n += copy(buffer[n:], nonce)
 	n += copy(buffer[n:], ciphertext)
-	binary.BigEndian.PutUint64(buffer[n:], uint64(len(aad)*8))
+	binary.BigEndian.PutUint64(buffer[n:], uint64(len(aad))*8)
 
 	// According to documentation, Write() on hash.Hash never fails.
 	hmac := hmac.New(ctx.hash, ctx.integrityKey)
"
GO-2022-0945,square,go-jose,789a4c4bd4c118f7564954f441b29c153ccd6a96," func (ctx *cbcAEAD) computeAuthTag(aad, nonce, ciphertext []byte) []byte {
 // resize ensures the the given slice has a capacity of at least n bytes.
 // If the capacity of the slice is less than n, a new slice is allocated
 // and the existing data will be copied.
-func resize(in []byte, n int) (head, tail []byte) {
-	if cap(in) >= n {
+func resize(in []byte, n uint64) (head, tail []byte) {
+	if uint64(cap(in)) >= n {
 		head = in[:n]
 	} else {
 		head = make([]byte, n)
"
GO-2022-0945,square,go-jose,789a4c4bd4c118f7564954f441b29c153ccd6a96," func resize(in []byte, n int) (head, tail []byte) {
 // Apply padding
 func padBuffer(buffer []byte, blockSize int) []byte {
 	missing := blockSize - (len(buffer) % blockSize)
-	ret, out := resize(buffer, len(buffer)+missing)
+	ret, out := resize(buffer, uint64(len(buffer))+uint64(missing))
 	padding := bytes.Repeat([]byte{byte(missing)}, missing)
 	copy(out, padding)
 	return ret
"
GO-2022-0945,square,go-jose,789a4c4bd4c118f7564954f441b29c153ccd6a96," type concatKDF struct {
 
 // NewConcatKDF builds a KDF reader based on the given inputs.
 func NewConcatKDF(hash crypto.Hash, z, algID, ptyUInfo, ptyVInfo, supPubInfo, supPrivInfo []byte) io.Reader {
-	buffer := make([]byte, len(algID)+len(ptyUInfo)+len(ptyVInfo)+len(supPubInfo)+len(supPrivInfo))
+	buffer := make([]byte, uint64(len(algID))+uint64(len(ptyUInfo))+uint64(len(ptyVInfo))+uint64(len(supPubInfo))+uint64(len(supPrivInfo)))
 	n := 0
 	n += copy(buffer, algID)
 	n += copy(buffer[n:], ptyUInfo)
"
GO-2022-0945,square,go-jose,789a4c4bd4c118f7564954f441b29c153ccd6a96," import (
 
 // DeriveECDHES derives a shared encryption key using ECDH/ConcatKDF as described in JWE/JWA.
 // It is an error to call this function with a private/public key that are not on the same
-// curve. Callers must ensure that the keys are valid before calling this function.
+// curve. Callers must ensure that the keys are valid before calling this function. Output
+// size may be at most 1<<16 bytes (64 KiB).
 func DeriveECDHES(alg string, apuData, apvData []byte, priv *ecdsa.PrivateKey, pub *ecdsa.PublicKey, size int) []byte {
+	if size > 1<<16 {
+		panic(""ECDH-ES output size too large, must be less than 1<<16"")
+	}
+
 	// algId, partyUInfo, partyVInfo inputs must be prefixed with the length
 	algID := lengthPrefixed([]byte(alg))
 	ptyUInfo := lengthPrefixed(apuData)
"
GO-2022-0945,square,go-jose,c7581939a3656bb65e89d64da0a52364a33d2507," func (ctx ecDecrypterSigner) decryptKey(headers rawHeader, recipient *recipientI
 		return nil, errors.New(""square/go-jose: invalid epk header"")
 	}
 
+	if !ctx.privateKey.Curve.IsOnCurve(publicKey.X, publicKey.Y) {
+		return nil, errors.New(""square/go-jose: invalid public key in epk header"")
+	}
+
 	apuData := headers.Apu.bytes()
 	apvData := headers.Apv.bytes()
 
"
GO-2022-0945,square,go-jose,c7581939a3656bb65e89d64da0a52364a33d2507," func DeriveECDHES(alg string, apuData, apvData []byte, priv *ecdsa.PrivateKey, p
 	supPubInfo := make([]byte, 4)
 	binary.BigEndian.PutUint32(supPubInfo, uint32(size)*8)
 
+	if !priv.PublicKey.Curve.IsOnCurve(pub.X, pub.Y) {
+		panic(""public key not on same curve as private key"")
+	}
+
 	z, _ := priv.PublicKey.Curve.ScalarMult(pub.X, pub.Y, priv.D.Bytes())
 	reader := NewConcatKDF(crypto.SHA256, z.Bytes(), algID, ptyUInfo, ptyVInfo, supPubInfo, []byte{})
 
"
GO-2022-0945,square,go-jose,c7581939a3656bb65e89d64da0a52364a33d2507," func (key rawJsonWebKey) ecPublicKey() (*ecdsa.PublicKey, error) {
 	}
 
 	if key.X == nil || key.Y == nil {
-		return nil, fmt.Errorf(""square/go-jose: invalid EC key, missing x/y values"")
+		return nil, errors.New(""square/go-jose: invalid EC key, missing x/y values"")
+	}
+
+	x := key.X.bigInt()
+	y := key.Y.bigInt()
+
+	if !curve.IsOnCurve(x, y) {
+		return nil, errors.New(""square/go-jose: invalid EC key, X/Y are not on declared curve"")
 	}
 
 	return &ecdsa.PublicKey{
 		Curve: curve,
-		X:     key.X.bigInt(),
-		Y:     key.Y.bigInt(),
+		X:     x,
+		Y:     y,
 	}, nil
 }
 
"
GO-2020-0009,square,go-jose,789a4c4bd4c118f7564954f441b29c153ccd6a96," func (ctx *cbcAEAD) Open(dst, nonce, ciphertext, data []byte) ([]byte, error) {
 
 // Compute an authentication tag
 func (ctx *cbcAEAD) computeAuthTag(aad, nonce, ciphertext []byte) []byte {
-	buffer := make([]byte, len(aad)+len(nonce)+len(ciphertext)+8)
+	buffer := make([]byte, uint64(len(aad))+uint64(len(nonce))+uint64(len(ciphertext))+8)
 	n := 0
 	n += copy(buffer, aad)
 	n += copy(buffer[n:], nonce)
 	n += copy(buffer[n:], ciphertext)
-	binary.BigEndian.PutUint64(buffer[n:], uint64(len(aad)*8))
+	binary.BigEndian.PutUint64(buffer[n:], uint64(len(aad))*8)
 
 	// According to documentation, Write() on hash.Hash never fails.
 	hmac := hmac.New(ctx.hash, ctx.integrityKey)
"
GO-2020-0010,square,go-jose,c7581939a3656bb65e89d64da0a52364a33d2507," func (ctx ecDecrypterSigner) decryptKey(headers rawHeader, recipient *recipientI
 		return nil, errors.New(""square/go-jose: invalid epk header"")
 	}
 
+	if !ctx.privateKey.Curve.IsOnCurve(publicKey.X, publicKey.Y) {
+		return nil, errors.New(""square/go-jose: invalid public key in epk header"")
+	}
+
 	apuData := headers.Apu.bytes()
 	apvData := headers.Apv.bytes()
 
"
GO-2020-0010,square,go-jose,c7581939a3656bb65e89d64da0a52364a33d2507," func DeriveECDHES(alg string, apuData, apvData []byte, priv *ecdsa.PrivateKey, p
 	supPubInfo := make([]byte, 4)
 	binary.BigEndian.PutUint32(supPubInfo, uint32(size)*8)
 
+	if !priv.PublicKey.Curve.IsOnCurve(pub.X, pub.Y) {
+		panic(""public key not on same curve as private key"")
+	}
+
 	z, _ := priv.PublicKey.Curve.ScalarMult(pub.X, pub.Y, priv.D.Bytes())
 	reader := NewConcatKDF(crypto.SHA256, z.Bytes(), algID, ptyUInfo, ptyVInfo, supPubInfo, []byte{})
 
"
GO-2020-0010,square,go-jose,c7581939a3656bb65e89d64da0a52364a33d2507," func (key rawJsonWebKey) ecPublicKey() (*ecdsa.PublicKey, error) {
 	}
 
 	if key.X == nil || key.Y == nil {
-		return nil, fmt.Errorf(""square/go-jose: invalid EC key, missing x/y values"")
+		return nil, errors.New(""square/go-jose: invalid EC key, missing x/y values"")
+	}
+
+	x := key.X.bigInt()
+	y := key.Y.bigInt()
+
+	if !curve.IsOnCurve(x, y) {
+		return nil, errors.New(""square/go-jose: invalid EC key, X/Y are not on declared curve"")
 	}
 
 	return &ecdsa.PublicKey{
 		Curve: curve,
-		X:     key.X.bigInt(),
-		Y:     key.Y.bigInt(),
+		X:     x,
+		Y:     y,
 	}, nil
 }
 
"
GO-2023-1664,crewjam,saml,8e9236867d176ad6338c870a84e2039aef8a5021," func NewIdpAuthnRequest(idp *IdentityProvider, r *http.Request) (*IdpAuthnReques
 		if err != nil {
 			return nil, fmt.Errorf(""cannot decode request: %s"", err)
 		}
-		req.RequestBuffer, err = ioutil.ReadAll(flate.NewReader(bytes.NewReader(compressedRequest)))
+		req.RequestBuffer, err = ioutil.ReadAll(newSaferFlateReader(bytes.NewReader(compressedRequest)))
 		if err != nil {
 			return nil, fmt.Errorf(""cannot decompress request: %s"", err)
 		}
"
GO-2023-1664,crewjam,saml,8e9236867d176ad6338c870a84e2039aef8a5021," func (sp *ServiceProvider) ValidateLogoutResponseRedirect(queryParameterData str
 	}
 	retErr.Response = string(rawResponseBuf)
 
-	gr, err := ioutil.ReadAll(flate.NewReader(bytes.NewBuffer(rawResponseBuf)))
+	gr, err := ioutil.ReadAll(newSaferFlateReader(bytes.NewBuffer(rawResponseBuf)))
 	if err != nil {
 		retErr.PrivateErr = err
 		return retErr
"
GO-2023-2119,Consensys,gnark,3421eaa7d544286abf3de8c46282b8d4da6d5da0," func Verify(proof *Proof, vk *VerifyingKey, publicWitness fr.Vector) error {
 		&proof.BatchedProof,
 		zeta,
 		hFunc,
+		zu.Marshal(),
 	)
 	if err != nil {
 		return err
"
GO-2022-0762,microcosm-cc,bluemonday,524f142fe46e945b7dcd291d7805c4b7dcf75bee," func (p *Policy) sanitize(r io.Reader) *bytes.Buffer {
 
 		case html.StartTagToken:
 
-			mostRecentlyStartedToken = strings.ToLower(token.Data)
+			mostRecentlyStartedToken = normaliseElementName(token.Data)
 
 			aps, ok := p.elsAndAttrs[token.Data]
 			if !ok {
"
GO-2022-0762,microcosm-cc,bluemonday,524f142fe46e945b7dcd291d7805c4b7dcf75bee," func (p *Policy) sanitize(r io.Reader) *bytes.Buffer {
 
 		case html.EndTagToken:
 
-			if mostRecentlyStartedToken == strings.ToLower(token.Data) {
+			if mostRecentlyStartedToken == normaliseElementName(token.Data) {
 				mostRecentlyStartedToken = """"
 			}
 
"
GO-2022-0762,microcosm-cc,bluemonday,524f142fe46e945b7dcd291d7805c4b7dcf75bee," func (p *Policy) sanitize(r io.Reader) *bytes.Buffer {
 
 			if !skipElementContent {
 				switch mostRecentlyStartedToken {
-				case ""script"":
+				case `script`:
 					// not encouraged, but if a policy allows JavaScript we
 					// should not HTML escape it as that would break the output
 					buff.WriteString(token.Data)
-				case ""style"":
+				case `style`:
 					// not encouraged, but if a policy allows CSS styles we
 					// should not HTML escape it as that would break the output
 					buff.WriteString(token.Data)
"
GO-2022-0274,opencontainers,runc,f50369af4b571e358f20b139eea52d612eb55eed," type Bytemsg struct {
 
 func (msg *Bytemsg) Serialize() []byte {
 	l := msg.Len()
+	if l > math.MaxUint16 {
+		// We cannot return nil nor an error here, so we panic with
+		// a specific type instead, which is handled via recover in
+		// bootstrapData.
+		panic(netlinkError{fmt.Errorf(""netlink: cannot serialize bytemsg of length %d (larger than UINT16_MAX)"", l)})
+	}
 	buf := make([]byte, (l+unix.NLA_ALIGNTO-1) & ^(unix.NLA_ALIGNTO-1))
 	native := nl.NativeEndian()
 	native.PutUint16(buf[0:2], uint16(l))
"
GO-2021-0106,whyrusleeping,tar-utils,20a61371de5b51380bbdb0c7935b30b0625ac227," func (te *Extractor) Sanitize(toggle bool) {
 
 // outputPath returns the path at which to place tarPath
 func (te *Extractor) outputPath(tarPath string) (outPath string, err error) {
-	elems := strings.Split(tarPath, ""/"")    // break into elems
+	elems := strings.Split(tarPath, ""/"") // break into elems
+	for _, e := range elems {
+		if e == "".."" {
+			return """", fmt.Errorf(""%s : path contains '..'"", tarPath)
+		}
+	}
 	elems = elems[1:]                       // remove original root
 	outPath = strings.Join(elems, ""/"")      // join elems
 	outPath = gopath.Join(te.Path, outPath) // rebase on to extraction target root
"
GO-2022-0574,open-policy-agent,opa,064f6168a8dfebdeb2ea147f7882bb9f5d2b7f67," func rewriteDeclaredVarsInTerm(g *localVarGenerator, stack *localDeclaredVars, t
 			return true, errs
 		}
 		return false, errs
+	case Call:
+		ref := v[0]
+		WalkVars(ref, func(v Var) bool {
+			if gv, ok := stack.Declared(v); ok && !gv.Equal(v) {
+				// We will rewrite the ref of a function call, which is never ok since we don't have first-class functions.
+				errs = append(errs, NewError(CompileErr, term.Location, ""called function %s shadowed"", ref))
+				return true
+			}
+			return false
+		})
+		return false, errs
 	case *object:
 		cpy, _ := v.Map(func(k, v *Term) (*Term, *Term, error) {
 			kcpy := k.Copy()
"
GO-2020-0008,miekg,dns,8ebf2e419df7857ac8919baa05248789a8ffbf33," var (
 	ErrTime          error = &Error{err: ""bad time""}      // ErrTime indicates a timing error in TSIG authentication.
 )
 
-// Id by default, returns a 16 bits random number to be used as a
-// message id. The random provided should be good enough. This being a
-// variable the function can be reassigned to a custom function.
-// For instance, to make it return a static value:
+// Id by default returns a 16-bit random number to be used as a message id. The
+// number is drawn from a cryptographically secure random number generator.
+// This being a variable the function can be reassigned to a custom function.
+// For instance, to make it return a static value for testing:
 //
 //	dns.Id = func() uint16 { return 3 }
 var Id = id
 
-var (
-	idLock sync.Mutex
-	idRand *rand.Rand
-)
-
 // id returns a 16 bits random number to be used as a
 // message id. The random provided should be good enough.
 func id() uint16 {
-	idLock.Lock()
-
-	if idRand == nil {
-		// This (partially) works around
-		// https://github.com/golang/go/issues/11833 by only
-		// seeding idRand upon the first call to id.
-
-		var seed int64
-		var buf [8]byte
-
-		if _, err := crand.Read(buf[:]); err == nil {
-			seed = int64(binary.LittleEndian.Uint64(buf[:]))
-		} else {
-			seed = rand.Int63()
-		}
-
-		idRand = rand.New(rand.NewSource(seed))
+	var output uint16
+	err := binary.Read(rand.Reader, binary.BigEndian, &output)
+	if err != nil {
+		panic(""dns: reading random id failed: "" + err.Error())
 	}
-
-	// The call to idRand.Uint32 must be within the
-	// mutex lock because *rand.Rand is not safe for
-	// concurrent use.
-	//
-	// There is no added performance overhead to calling
-	// idRand.Uint32 inside a mutex lock over just
-	// calling rand.Uint32 as the global math/rand rng
-	// is internally protected by a sync.Mutex.
-	id := uint16(idRand.Uint32())
-
-	idLock.Unlock()
-	return id
+	return output
 }
 
 // MsgHdr is a a manually-unpacked version of (id, bits).
"
GO-2022-1045,sylabs,sif,07fb86029a12e3210f6131e065570124605daeaa," func verifyAndDecode(data []byte, kr openpgp.KeyRing) (*openpgp.Entity, []byte,
 	}
 
 	// Check signature.
-	e, err := openpgp.CheckDetachedSignature(kr, bytes.NewReader(b.Bytes), b.ArmoredSignature.Body, nil)
+	e, err := openpgp.CheckDetachedSignatureAndHash(
+		kr,
+		bytes.NewReader(b.Bytes),
+		b.ArmoredSignature.Body,
+		supportedPGPAlgorithms,
+		nil,
+	)
 	return e, b.Plaintext, rest, err
 }
 
"
GO-2022-1045,sylabs,sif,07fb86029a12e3210f6131e065570124605daeaa," type digest struct {
 // newDigest returns a new digest. If h is not supported, errHashUnsupported is returned. If digest
 // is malformed, errDigestMalformed is returned.
 func newDigest(h crypto.Hash, value []byte) (digest, error) {
-	if _, ok := supportedAlgorithms[h]; !ok {
+	if _, ok := supportedDigestAlgorithms[h]; !ok {
 		return digest{}, errHashUnsupported
 	}
 
"
GO-2022-1045,sylabs,sif,07fb86029a12e3210f6131e065570124605daeaa," func (d digest) matches(r io.Reader) (bool, error) {
 
 // MarshalJSON marshals d into string of format ""alg:value"".
 func (d digest) MarshalJSON() ([]byte, error) {
-	n, ok := supportedAlgorithms[d.hash]
+	n, ok := supportedDigestAlgorithms[d.hash]
 	if !ok {
 		return nil, errHashUnsupported
 	}
"
GO-2022-1130,prometheus,exporter-toolkit,5b1eab34484ddd353986bce736cd119d863e4ff5," func (u *webHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
 			hashedPassword = ""$2y$10$QOauhQNbBCuQDKes6eFzPeMqBSjb7Mr5DUmpZ/VcEd00UAV/LDeSi""
 		}
 
-		cacheKey := hex.EncodeToString(append(append([]byte(user), []byte(hashedPassword)...), []byte(pass)...))
+		cacheKey := strings.Join(
+			[]string{
+				hex.EncodeToString([]byte(user)),
+				hex.EncodeToString([]byte(hashedPassword)),
+				hex.EncodeToString([]byte(pass)),
+			}, "":"")
 		authOk, ok := u.cache.get(cacheKey)
 
 		if !ok {
"
GO-2022-1130,prometheus,exporter-toolkit,5b1eab34484ddd353986bce736cd119d863e4ff5," func (u *webHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
 			err := bcrypt.CompareHashAndPassword([]byte(hashedPassword), []byte(pass))
 			u.bcryptMtx.Unlock()
 
-			authOk = err == nil
+			authOk = validUser && err == nil
 			u.cache.set(cacheKey, authOk)
 		}
 
"
GO-2023-1717,vitessio,vitess,adf10196760ad0b3991a7aa7a8580a544e6ddf88," func (ki *KeyspaceInfo) ComputeCellServedFrom(cell string) []*topodatapb.SrvKeys
 // CreateKeyspace wraps the underlying Conn.Create
 // and dispatches the event.
 func (ts *Server) CreateKeyspace(ctx context.Context, keyspace string, value *topodatapb.Keyspace) error {
+	if err := ValidateKeyspaceName(keyspace); err != nil {
+		return vterrors.Wrapf(err, ""CreateKeyspace: %s"", err)
+	}
+
 	data, err := proto.Marshal(value)
 	if err != nil {
 		return err
"
GO-2023-1717,vitessio,vitess,adf10196760ad0b3991a7aa7a8580a544e6ddf88," func (ts *Server) CreateKeyspace(ctx context.Context, keyspace string, value *to
 
 // GetKeyspace reads the given keyspace and returns it
 func (ts *Server) GetKeyspace(ctx context.Context, keyspace string) (*KeyspaceInfo, error) {
+	if err := ValidateKeyspaceName(keyspace); err != nil {
+		return nil, vterrors.Wrapf(err, ""GetKeyspace: %s"", err)
+	}
+
 	keyspacePath := path.Join(KeyspacesPath, keyspace, KeyspaceFile)
 	data, version, err := ts.globalCell.Get(ctx, keyspacePath)
 	if err != nil {
"
GO-2023-1717,vitessio,vitess,adf10196760ad0b3991a7aa7a8580a544e6ddf88," var ErrKeyspaceNotFound = errors.New(""keyspace not found"")
 
 // ReadKeyspace reads the vitess keyspace record.
 func ReadKeyspace(keyspaceName string) (*topo.KeyspaceInfo, error) {
+	if err := topo.ValidateKeyspaceName(keyspaceName); err != nil {
+		return nil, err
+	}
+
 	query := `
 		select
 			keyspace_type,
"
GO-2023-1574,containerd,containerd,133f6bb6cd827ce35a5fb279c1ead12b9d21460a," func WithNamespacedCgroup() SpecOpts {
 //	user, uid, user:group, uid:gid, uid:group, user:gid
 func WithUser(userstr string) SpecOpts {
 	return func(ctx context.Context, client Client, c *containers.Container, s *Spec) error {
+		defer ensureAdditionalGids(s)
 		setProcess(s)
+		s.Process.User.AdditionalGids = nil
 
 		// For LCOW it's a bit harder to confirm that the user actually exists on the host as a rootfs isn't
 		// mounted on the host and shared into the guest, but rather the rootfs is constructed entirely in the
"
GO-2023-1574,containerd,containerd,133f6bb6cd827ce35a5fb279c1ead12b9d21460a," func WithUser(userstr string) SpecOpts {
 // WithUIDGID allows the UID and GID for the Process to be set
 func WithUIDGID(uid, gid uint32) SpecOpts {
 	return func(_ context.Context, _ Client, _ *containers.Container, s *Spec) error {
+		defer ensureAdditionalGids(s)
 		setProcess(s)
+		s.Process.User.AdditionalGids = nil
 		s.Process.User.UID = uid
 		s.Process.User.GID = gid
 		return nil
"
GO-2023-1574,containerd,containerd,133f6bb6cd827ce35a5fb279c1ead12b9d21460a," func WithUIDGID(uid, gid uint32) SpecOpts {
 // additionally sets the gid to 0, and does not return an error.
 func WithUserID(uid uint32) SpecOpts {
 	return func(ctx context.Context, client Client, c *containers.Container, s *Spec) (err error) {
+		defer ensureAdditionalGids(s)
 		setProcess(s)
-		if c.Snapshotter == """" && c.SnapshotKey == """" {
-			if !isRootfsAbs(s.Root.Path) {
-				return errors.New(""rootfs absolute path is required"")
-			}
-			user, err := UserFromPath(s.Root.Path, func(u user.User) bool {
+		s.Process.User.AdditionalGids = nil
+		setUser := func(root string) error {
+			user, err := UserFromPath(root, func(u user.User) bool {
 				return u.Uid == int(uid)
 			})
 			if err != nil {
"
GO-2023-1574,containerd,containerd,133f6bb6cd827ce35a5fb279c1ead12b9d21460a," func WithUserID(uid uint32) SpecOpts {
 			}
 			s.Process.User.UID, s.Process.User.GID = uint32(user.Uid), uint32(user.Gid)
 			return nil
-
+		}
+		if c.Snapshotter == """" && c.SnapshotKey == """" {
+			if !isRootfsAbs(s.Root.Path) {
+				return errors.New(""rootfs absolute path is required"")
+			}
+			return setUser(s.Root.Path)
 		}
 		if c.Snapshotter == """" {
 			return errors.New(""no snapshotter set for container"")
"
GO-2023-1574,containerd,containerd,133f6bb6cd827ce35a5fb279c1ead12b9d21460a," func WithUserID(uid uint32) SpecOpts {
 		}
 
 		mounts = tryReadonlyMounts(mounts)
-		return mount.WithTempMount(ctx, mounts, func(root string) error {
-			user, err := UserFromPath(root, func(u user.User) bool {
-				return u.Uid == int(uid)
-			})
-			if err != nil {
-				if os.IsNotExist(err) || err == ErrNoUsersFound {
-					s.Process.User.UID, s.Process.User.GID = uid, 0
-					return nil
-				}
-				return err
-			}
-			s.Process.User.UID, s.Process.User.GID = uint32(user.Uid), uint32(user.Gid)
-			return nil
-		})
+		return mount.WithTempMount(ctx, mounts, setUser)
 	}
 }
 
"
GO-2023-1574,containerd,containerd,133f6bb6cd827ce35a5fb279c1ead12b9d21460a," func WithUserID(uid uint32) SpecOpts {
 // the container.
 func WithUsername(username string) SpecOpts {
 	return func(ctx context.Context, client Client, c *containers.Container, s *Spec) (err error) {
+		defer ensureAdditionalGids(s)
 		setProcess(s)
+		s.Process.User.AdditionalGids = nil
 		if s.Linux != nil {
-			if c.Snapshotter == """" && c.SnapshotKey == """" {
-				if !isRootfsAbs(s.Root.Path) {
-					return errors.New(""rootfs absolute path is required"")
-				}
-				user, err := UserFromPath(s.Root.Path, func(u user.User) bool {
+			setUser := func(root string) error {
+				user, err := UserFromPath(root, func(u user.User) bool {
 					return u.Name == username
 				})
 				if err != nil {
"
GO-2023-1574,containerd,containerd,133f6bb6cd827ce35a5fb279c1ead12b9d21460a," func WithUsername(username string) SpecOpts {
 				s.Process.User.UID, s.Process.User.GID = uint32(user.Uid), uint32(user.Gid)
 				return nil
 			}
+			if c.Snapshotter == """" && c.SnapshotKey == """" {
+				if !isRootfsAbs(s.Root.Path) {
+					return errors.New(""rootfs absolute path is required"")
+				}
+				return setUser(s.Root.Path)
+			}
 			if c.Snapshotter == """" {
 				return errors.New(""no snapshotter set for container"")
 			}
"
GO-2023-1574,containerd,containerd,133f6bb6cd827ce35a5fb279c1ead12b9d21460a," func WithUsername(username string) SpecOpts {
 			}
 
 			mounts = tryReadonlyMounts(mounts)
-			return mount.WithTempMount(ctx, mounts, func(root string) error {
-				user, err := UserFromPath(root, func(u user.User) bool {
-					return u.Name == username
-				})
-				if err != nil {
-					return err
-				}
-				s.Process.User.UID, s.Process.User.GID = uint32(user.Uid), uint32(user.Gid)
-				return nil
-			})
+			return mount.WithTempMount(ctx, mounts, setUser)
 		} else if s.Windows != nil {
 			s.Process.User.Username = username
 		} else {
"
GO-2023-1574,containerd,containerd,133f6bb6cd827ce35a5fb279c1ead12b9d21460a," func WithAdditionalGIDs(userstr string) SpecOpts {
 			return nil
 		}
 		setProcess(s)
+		s.Process.User.AdditionalGids = nil
 		setAdditionalGids := func(root string) error {
+			defer ensureAdditionalGids(s)
 			var username string
 			uid, err := strconv.Atoi(userstr)
 			if err == nil {
"
GO-2023-1574,containerd,containerd,133f6bb6cd827ce35a5fb279c1ead12b9d21460a," func (c *criService) containerSpecOpts(config *runtime.ContainerConfig, imageCon
 		// Because it is still useful to get additional gids for uid 0.
 		userstr = strconv.FormatInt(securityContext.GetRunAsUser().GetValue(), 10)
 	}
-	specOpts = append(specOpts, customopts.WithAdditionalGIDs(userstr))
+	specOpts = append(specOpts, customopts.WithAdditionalGIDs(userstr),
+		customopts.WithSupplementalGroups(securityContext.GetSupplementalGroups()))
 
 	asp := securityContext.GetApparmor()
 	if asp == nil {
"
GO-2020-0041,unknwon,cae,07971c00a1bfd9dc171c3ad0bfab5b67c2287e11," func (tz *TzArchive) syncFiles() {
 	for i, f := range tz.File {
 		tz.files[i] = &File{}
 		tz.files[i].Header = f
-		tz.files[i].Name = strings.Replace(f.Name, ""\\"", ""/"", -1)
+		tz.files[i].Name = cae.Clean(strings.ReplaceAll(f.Name, ""\\"", ""/""))
 		if f.FileInfo().IsDir() && !strings.HasSuffix(tz.files[i].Name, ""/"") {
 			tz.files[i].Name += ""/""
 		}
"
GO-2020-0041,unknwon,cae,07971c00a1bfd9dc171c3ad0bfab5b67c2287e11," var defaultExtractFunc = func(fullName string, fi os.FileInfo) error {
 // specified destination.
 // It accepts a function as a middleware for custom operations.
 func (tz *TzArchive) ExtractToFunc(destPath string, fn cae.HookFunc, entries ...string) (err error) {
-	destPath = strings.Replace(destPath, ""\\"", ""/"", -1)
+	destPath = strings.ReplaceAll(destPath, ""\\"", ""/"")
 	isHasEntry := len(entries) > 0
 	if Verbose {
 		fmt.Println(""Extracting "" + tz.FileName + ""..."")
"
GO-2020-0041,unknwon,cae,07971c00a1bfd9dc171c3ad0bfab5b67c2287e11," func (tz *TzArchive) ExtractToFunc(destPath string, fn cae.HookFunc, entries ...
 			return err
 		}
 
-		h.Name = strings.Replace(h.Name, ""\\"", ""/"", -1)
+		h.Name = cae.Clean(strings.ReplaceAll(h.Name, ""\\"", ""/""))
 
 		// Directory.
 		if h.Typeflag == tar.TypeDir {
"
GO-2020-0041,unknwon,cae,07971c00a1bfd9dc171c3ad0bfab5b67c2287e11," func (z *ZipArchive) Open(name string, flag int, perm os.FileMode) error {
 		if err != nil {
 			return err
 		}
-		z.files[i].Name = strings.Replace(f.Name, ""\\"", ""/"", -1)
+		z.files[i].Name = cae.Clean(strings.ReplaceAll(f.Name, ""\\"", ""/""))
 		if f.FileInfo().IsDir() && !strings.HasSuffix(z.files[i].Name, ""/"") {
 			z.files[i].Name += ""/""
 		}
"
GO-2020-0041,unknwon,cae,07971c00a1bfd9dc171c3ad0bfab5b67c2287e11," func (z *ZipArchive) ExtractToFunc(destPath string, fn cae.HookFunc, entries ...
 	}
 	os.MkdirAll(destPath, os.ModePerm)
 	for _, f := range z.File {
-		f.Name = strings.Replace(f.Name, ""\\"", ""/"", -1)
+		f.Name = cae.Clean(strings.ReplaceAll(f.Name, ""\\"", ""/""))
 
 		// Directory.
 		if strings.HasSuffix(f.Name, ""/"") {
"
GO-2021-0228,unknwon,cae,07971c00a1bfd9dc171c3ad0bfab5b67c2287e11," func (tz *TzArchive) syncFiles() {
 	for i, f := range tz.File {
 		tz.files[i] = &File{}
 		tz.files[i].Header = f
-		tz.files[i].Name = strings.Replace(f.Name, ""\\"", ""/"", -1)
+		tz.files[i].Name = cae.Clean(strings.ReplaceAll(f.Name, ""\\"", ""/""))
 		if f.FileInfo().IsDir() && !strings.HasSuffix(tz.files[i].Name, ""/"") {
 			tz.files[i].Name += ""/""
 		}
"
GO-2021-0228,unknwon,cae,07971c00a1bfd9dc171c3ad0bfab5b67c2287e11," var defaultExtractFunc = func(fullName string, fi os.FileInfo) error {
 // specified destination.
 // It accepts a function as a middleware for custom operations.
 func (tz *TzArchive) ExtractToFunc(destPath string, fn cae.HookFunc, entries ...string) (err error) {
-	destPath = strings.Replace(destPath, ""\\"", ""/"", -1)
+	destPath = strings.ReplaceAll(destPath, ""\\"", ""/"")
 	isHasEntry := len(entries) > 0
 	if Verbose {
 		fmt.Println(""Extracting "" + tz.FileName + ""..."")
"
GO-2021-0228,unknwon,cae,07971c00a1bfd9dc171c3ad0bfab5b67c2287e11," func (tz *TzArchive) ExtractToFunc(destPath string, fn cae.HookFunc, entries ...
 			return err
 		}
 
-		h.Name = strings.Replace(h.Name, ""\\"", ""/"", -1)
+		h.Name = cae.Clean(strings.ReplaceAll(h.Name, ""\\"", ""/""))
 
 		// Directory.
 		if h.Typeflag == tar.TypeDir {
"
GO-2021-0228,unknwon,cae,07971c00a1bfd9dc171c3ad0bfab5b67c2287e11," func (z *ZipArchive) Open(name string, flag int, perm os.FileMode) error {
 		if err != nil {
 			return err
 		}
-		z.files[i].Name = strings.Replace(f.Name, ""\\"", ""/"", -1)
+		z.files[i].Name = cae.Clean(strings.ReplaceAll(f.Name, ""\\"", ""/""))
 		if f.FileInfo().IsDir() && !strings.HasSuffix(z.files[i].Name, ""/"") {
 			z.files[i].Name += ""/""
 		}
"
GO-2021-0228,unknwon,cae,07971c00a1bfd9dc171c3ad0bfab5b67c2287e11," func (z *ZipArchive) ExtractToFunc(destPath string, fn cae.HookFunc, entries ...
 	}
 	os.MkdirAll(destPath, os.ModePerm)
 	for _, f := range z.File {
-		f.Name = strings.Replace(f.Name, ""\\"", ""/"", -1)
+		f.Name = cae.Clean(strings.ReplaceAll(f.Name, ""\\"", ""/""))
 
 		// Directory.
 		if strings.HasSuffix(f.Name, ""/"") {
"
GO-2022-0246,cloudflare,cfrpki,a8db4e009ef217484598ba1fd1c595b54e0f6422," func (entry *ROAEntry) Validate() error {
 	if entry.MaxLength < s {
 		return errors.New(fmt.Sprintf(""Max length (%v) is smaller than prefix length (%v)"", entry.MaxLength, s))
 	}
+
+	if entry.MaxLength < 0 {
+		return fmt.Errorf(""max length (%d) is less than 0"", entry.MaxLength)
+	}
+
+	if entry.IPNet.IP.To4() != nil && entry.MaxLength > 32 { // If IPv4
+		return fmt.Errorf(""max length (%d) too small for IPv4 prefix"", entry.MaxLength)
+	} else if entry.MaxLength > 128 { // If IPv6
+		return fmt.Errorf(""max length (%d) too small for IPv6 prefix"", entry.MaxLength)
+	}
+
 	return nil
 }
 
"
GO-2021-0065,kubernetes,kubernetes,4441f1d9c3e94d9a3d93b4f184a591cab02a5245," func (rt *debuggingRoundTripper) RoundTrip(req *http.Request) (*http.Response, e
 		klog.Infof(""Request Headers:"")
 		for key, values := range reqInfo.RequestHeaders {
 			for _, value := range values {
+				value = maskValue(key, value)
 				klog.Infof(""    %s: %s"", key, value)
 			}
 		}
"
GO-2023-2077,SagerNet,sing,5b05b5c147d9650e8accb4441e216c72a61f4859," func HandleConnection0(ctx context.Context, conn net.Conn, version byte, authent
 			if err != nil {
 				return err
 			}
+			if response.Status != socks5.UsernamePasswordStatusSuccess {
+				return E.New(""socks5: authentication failed, username="", usernamePasswordAuthRequest.Username, "", password="", usernamePasswordAuthRequest.Password)
+			}
 		}
 		request, err := socks5.ReadRequest(conn)
 		if err != nil {
"
GO-2020-0020,gorilla,handlers,90663712d74cb411cbef281bc1e08c19d1a76145," func (ch *cors) ServeHTTP(w http.ResponseWriter, r *http.Request) {
 		w.Header().Set(corsVaryHeader, corsOriginHeader)
 	}
 
-	w.Header().Set(corsAllowOriginHeader, origin)
+	returnOrigin := origin
+	for _, o := range ch.allowedOrigins {
+		// A configuration of * is different than explicitly setting an allowed
+		// origin. Returning arbitrary origin headers an an access control allow
+		// origin header is unsafe and is not required by any use case.
+		if o == corsOriginMatchAll {
+			returnOrigin = ""*""
+			break
+		}
+	}
+	w.Header().Set(corsAllowOriginHeader, returnOrigin)
 
 	if r.Method == corsOptionMethod {
 		return
"
GO-2021-0094,hashicorp,go-slug,28cafc59c8da6126a3ae94dfa84181df4073454f," func Unpack(r io.Reader, dst string) error {
 		}
 		path = filepath.Join(dst, path)
 
+		// Check for paths outside our directory, they are forbidden
+		target := filepath.Clean(path)
+		if !strings.HasPrefix(target, dst) {
+			return fmt.Errorf(""Invalid filename, traversal with \""..\"" outside of current directory"")
+		}
+
+		// Ensure the destination is not through any symlinks. This prevents
+		// any files from being deployed through symlinks defined in the slug.
+		// There are malicious cases where this could be used to escape the
+		// slug's boundaries (zipslip), and any legitimate use is questionable
+		// and likely indicates a hand-crafted tar file, which we are not in
+		// the business of supporting here.
+		//
+		// The strategy is to Lstat each path  component from dst up to the
+		// immediate parent directory of the file name in the tarball, checking
+		// the mode on each to ensure we wouldn't be passing through any
+		// symlinks.
+		currentPath := dst // Start at the root of the unpacked tarball.
+		components := strings.Split(header.Name, ""/"")
+
+		for i := 0; i < len(components)-1; i++ {
+			currentPath = filepath.Join(currentPath, components[i])
+			fi, err := os.Lstat(currentPath)
+			if os.IsNotExist(err) {
+				// Parent directory structure is incomplete. Technically this
+				// means from here upward cannot be a symlink, so we cancel the
+				// remaining path tests.
+				break
+			}
+			if err != nil {
+				return fmt.Errorf(""Failed to evaluate path %q: %v"", header.Name, err)
+			}
+			if fi.Mode()&os.ModeSymlink != 0 {
+				return fmt.Errorf(""Cannot extract %q through symlink"",
+					header.Name)
+			}
+		}
+
 		// Make the directories to the path.
 		dir := filepath.Dir(path)
 		if err := os.MkdirAll(dir, 0755); err != nil {
"
GO-2023-1494,elgs,gosqljson,2740b331546cb88eb61771df4c07d389e9f0363a," func QueryDbToArray(db *sql.DB, toLower bool, sqlStatement string, sqlParams ...
 			fmt.Println(err)
 		}
 	}()
+
+	SqlSafe(&sqlStatement)
+
 	var results [][]string
 	if strings.HasPrefix(strings.ToUpper(sqlStatement), ""SELECT"") {
 		rows, err := db.Query(sqlStatement, sqlParams...)
"
GO-2023-1494,elgs,gosqljson,2740b331546cb88eb61771df4c07d389e9f0363a," func QueryDbToMap(db *sql.DB, toLower bool, sqlStatement string, sqlParams ...in
 		}
 	}()
 
+	SqlSafe(&sqlStatement)
+
 	var results []map[string]string
 	if strings.HasPrefix(strings.ToUpper(sqlStatement), ""SELECT "") {
 		rows, err := db.Query(sqlStatement, sqlParams...)
"
GO-2023-1494,elgs,gosqljson,2740b331546cb88eb61771df4c07d389e9f0363a," func ExecDb(db *sql.DB, sqlStatement string, sqlParams ...interface{}) (int64, e
 		}
 	}()
 
+	SqlSafe(&sqlStatement)
+
 	sqlUpper := strings.ToUpper(sqlStatement)
 	if strings.HasPrefix(sqlUpper, ""UPDATE "") ||
 		strings.HasPrefix(sqlUpper, ""INSERT "") ||
"
GO-2021-0112,mongodb,mongo-go-driver,2aca31d5986a9e1c65a92264736de9fdc3b9b4ca," func (vw *valueWriter) invalidTransitionError(destination mode, name string, mod
 func (vw *valueWriter) writeElementHeader(t bsontype.Type, destination mode, callerName string, addmodes ...mode) error {
 	switch vw.stack[vw.frame].mode {
 	case mElement:
-		vw.buf = bsoncore.AppendHeader(vw.buf, t, vw.stack[vw.frame].key)
+		key := vw.stack[vw.frame].key
+		if !isValidCString(key) {
+			return errors.New(""BSON element key cannot contain null bytes"")
+		}
+
+		vw.buf = bsoncore.AppendHeader(vw.buf, t, key)
 	case mValue:
 		// TODO: Do this with a cache of the first 1000 or so array keys.
 		vw.buf = bsoncore.AppendHeader(vw.buf, t, strconv.Itoa(vw.stack[vw.frame].arrkey))
"
GO-2021-0112,mongodb,mongo-go-driver,2aca31d5986a9e1c65a92264736de9fdc3b9b4ca," func AppendKey(dst []byte, key string) []byte { return append(dst, key+nullTermi
 // AppendHeader will append Type t and key to dst and return the extended
 // buffer.
 func AppendHeader(dst []byte, t bsontype.Type, key string) []byte {
+	if !isValidCString(key) {
+		panic(invalidKeyPanicMsg)
+	}
+
 	dst = AppendType(dst, t)
 	dst = append(dst, key...)
 	return append(dst, 0x00)
"
GO-2021-0112,mongodb,mongo-go-driver,2aca31d5986a9e1c65a92264736de9fdc3b9b4ca," func AppendNullElement(dst []byte, key string) []byte { return AppendHeader(dst,
 
 // AppendRegex will append pattern and options to dst and return the extended buffer.
 func AppendRegex(dst []byte, pattern, options string) []byte {
+	if !isValidCString(pattern) || !isValidCString(options) {
+		panic(invalidRegexPanicMsg)
+	}
+
 	return append(dst, pattern+nullTerminator+options+nullTerminator...)
 }
 
"
GO-2022-0706,elastic,apm-agent-go,dd3e8c593580e7b80a98b57e1cc6e017e56747b4," func (w *modelWriter) buildModelTransaction(out *model.Transaction, tx *Transact
 	if sampled {
 		out.Context = td.Context.build()
 	}
-
-	if len(td.sanitizedFieldNames) != 0 && out.Context != nil {
-		if out.Context.Request != nil {
-			sanitizeRequest(out.Context.Request, td.sanitizedFieldNames)
-		}
-		if out.Context.Response != nil {
-			sanitizeResponse(out.Context.Response, td.sanitizedFieldNames)
-		}
-	}
 }
 
 func (w *modelWriter) buildModelSpan(out *model.Span, span *Span, sd *SpanData) {
"
GO-2021-0051,labstack,echo,4422e3b66b9fd498ed1ae1d0242d660d0ed3faaa," func (common) static(prefix, root string, get func(string, HandlerFunc, ...Middl
 			return err
 		}
 
-		name := filepath.Join(root, path.Clean(""/""+p)) // ""/""+ for security
+		name := filepath.Join(root, filepath.Clean(""/""+p)) // ""/""+ for security
 		fi, err := os.Stat(name)
 		if err != nil {
 			// The access path does not exist
"
GO-2022-0422,ipld,go-codec-dagpb,a17ace35cc760a2698645c09868f9050fa219f57," func DecodeBytes(na ipld.NodeAssembler, src []byte) error {
 			haveData = true
 
 		case 2:
-			bytesLen, n := protowire.ConsumeVarint(remaining)
+			chunk, n := protowire.ConsumeBytes(remaining)
 			if n < 0 {
 				return protowire.ParseError(n)
 			}
"
GO-2022-0422,ipld,go-codec-dagpb,a17ace35cc760a2698645c09868f9050fa219f57," func DecodeBytes(na ipld.NodeAssembler, src []byte) error {
 			if err != nil {
 				return err
 			}
-			if err := unmarshalLink(remaining[:bytesLen], curLink); err != nil {
+			if err := unmarshalLink(chunk, curLink); err != nil {
 				return err
 			}
-			remaining = remaining[bytesLen:]
 			if err := curLink.Finish(); err != nil {
 				return err
 			}
"
GO-2020-0048,antchfx,xmlquery,5648b2f39e8d5d3fc903c45a4f1274829df71821," func LoadURL(url string) (*Node, error) {
 		return nil, err
 	}
 	defer resp.Body.Close()
-	return Parse(resp.Body)
+	// Checking the HTTP Content-Type value from the response headers.(#39)
+	v := strings.ToLower(resp.Header.Get(""Content-Type""))
+	if v == ""text/xml"" || v == ""application/xml"" {
+		return Parse(resp.Body)
+	}
+	return nil, fmt.Errorf(""invalid XML document(%s)"", v)
 }
 
 // Parse returns the parse tree for the XML from the given Reader.
"
GO-2020-0039,go-macaron,macaron,addc7461c3a90a040e79aa75bfd245107a210245," func staticHandler(ctx *Context, log *log.Logger, opt StaticOptions) bool {
 	// Try to serve index file
 	if fi.IsDir() {
 		// Redirect if missing trailing slash.
-		if !strings.HasSuffix(ctx.Req.URL.Path, ""/"") {
-			http.Redirect(ctx.Resp, ctx.Req.Request, ctx.Req.URL.Path+""/"", http.StatusFound)
+		redirPath := path.Clean(ctx.Req.URL.Path)
+		if !strings.HasSuffix(redirPath, ""/"") {
+			http.Redirect(ctx.Resp, ctx.Req.Request, redirPath+""/"", http.StatusFound)
 			return true
 		}
 
"
GO-2023-2048,cyphar,filepath-securejoin,c121231e1276e11049547bee5ce68d5a2cfe2d9b," func IsNotExist(err error) bool {
 // components in the returned string are not modified (in other words are not
 // replaced with symlinks on the filesystem) after this function has returned.
 // Such a symlink race is necessarily out-of-scope of SecureJoin.
+//
+// Volume names in unsafePath are always discarded, regardless if they are
+// provided via direct input or when evaluating symlinks. Therefore:
+//
+// ""C:\Temp"" + ""D:\path\to\file.txt"" results in ""C:\Temp\path\to\file.txt""
 func SecureJoinVFS(root, unsafePath string, vfs VFS) (string, error) {
 	// Use the os.* VFS implementation if none was specified.
 	if vfs == nil {
 		vfs = osVFS{}
 	}
 
+	unsafePath = filepath.FromSlash(unsafePath)
 	var path bytes.Buffer
 	n := 0
 	for unsafePath != """" {
 		if n > 255 {
-			return """", &os.PathError{Op: ""SecureJoin"", Path: root + ""/"" + unsafePath, Err: syscall.ELOOP}
+			return """", &os.PathError{Op: ""SecureJoin"", Path: root + string(filepath.Separator) + unsafePath, Err: syscall.ELOOP}
+		}
+
+		if v := filepath.VolumeName(unsafePath); v != """" {
+			unsafePath = unsafePath[len(v):]
 		}
 
 		// Next path component, p.
"
GO-2022-0251,cloudflare,cfrpki,76f0f7a98da001fa04e5bc0407c6702f91096bfa," func readObject(ber []byte, offset int) (asn1Object, int, error) {
 	*/
 	// read length
 	var length int
+	// GHSA-5mxh-2qfv-4g7j: Prevent a BER w/ NUL contents from being processed
+	if len(ber) <= offset {
+		return nil, 0, errors.New(""ber2der: invalid BER tag length"")
+	}
 	l := ber[offset]
 	offset++
 	indefinite := false
"
GO-2023-1515,rancher,wrangler,341018c8fef3e12867c7cb2649bd2cecac75f287," func (g *Git) Head(branch string) (string, error) {
 // Clone runs git clone with depth 1
 func (g *Git) Clone(branch string) error {
 	if branch == """" {
-		return g.git(""clone"", ""--depth=1"", ""-n"", g.URL, g.Directory)
+		return g.git(""clone"", ""--depth=1"", ""-n"", ""--"", g.URL, g.Directory)
 	}
-	return g.git(""clone"", ""--depth=1"", ""-n"", ""--branch"", branch, g.URL, g.Directory)
+	return g.git(""clone"", ""--depth=1"", ""-n"", ""--branch=""+branch, ""--"", g.URL, g.Directory)
 }
 
 // Update updates git repo if remote sha has changed
"
GO-2023-1515,rancher,wrangler,341018c8fef3e12867c7cb2649bd2cecac75f287," func (g *Git) currentCommit() (string, error) {
 }
 
 func (g *Git) gitCmd(output io.Writer, args ...string) error {
-	kv := fmt.Sprintf(""credential.helper=%s"", ""/bin/sh -c 'echo password=$GIT_PASSWORD'"")
+	kv := fmt.Sprintf(""credential.helper=%s"", `/bin/sh -c 'echo ""password=$GIT_PASSWORD""'`)
 	cmd := exec.Command(""git"", append([]string{""-c"", kv}, args...)...)
 	cmd.Env = append(os.Environ(), fmt.Sprintf(""GIT_PASSWORD=%s"", g.password))
 	stderrBuf := &bytes.Buffer{}
"
GO-2022-0586,hashicorp,go-getter,38e97387488f5439616be60874979433a12edb48," import (
 
 // Getter is a Getter implementation that will download a module from
 // a GCS bucket.
-type Getter struct{}
+type Getter struct {
+
+	// Timeout sets a deadline which all GCS operations should
+	// complete within. Zero value means no timeout.
+	Timeout time.Duration
+}
 
 func (g *Getter) Mode(ctx context.Context, u *url.URL) (getter.Mode, error) {
 
+	if g.Timeout > 0 {
+		var cancel context.CancelFunc
+		ctx, cancel = context.WithTimeout(ctx, g.Timeout)
+		defer cancel()
+	}
+
 	// Parse URL
 	bucket, object, err := g.parseURL(u)
 	if err != nil {
"
GO-2022-0586,hashicorp,go-getter,38e97387488f5439616be60874979433a12edb48," func (g *Getter) Mode(ctx context.Context, u *url.URL) (getter.Mode, error) {
 }
 
 func (g *Getter) Get(ctx context.Context, req *getter.Request) error {
+
+	if g.Timeout > 0 {
+		var cancel context.CancelFunc
+		ctx, cancel = context.WithTimeout(ctx, g.Timeout)
+		defer cancel()
+	}
+
 	// Parse URL
 	bucket, object, err := g.parseURL(req.URL())
 	if err != nil {
"
GO-2022-0586,hashicorp,go-getter,38e97387488f5439616be60874979433a12edb48," func (g *Getter) Get(ctx context.Context, req *getter.Request) error {
 }
 
 func (g *Getter) GetFile(ctx context.Context, req *getter.Request) error {
+
+	if g.Timeout > 0 {
+		var cancel context.CancelFunc
+		ctx, cancel = context.WithTimeout(ctx, g.Timeout)
+		defer cancel()
+	}
+
 	// Parse URL
 	bucket, object, err := g.parseURL(req.URL())
 	if err != nil {
"
GO-2022-0586,hashicorp,go-getter,38e97387488f5439616be60874979433a12edb48," import (
 
 // Getter is a Getter implementation that will download a module from
 // a S3 bucket.
-type Getter struct{}
+type Getter struct {
+
+	// Timeout sets a deadline which all S3 operations should
+	// complete within. Zero value means no timeout.
+	Timeout time.Duration
+}
 
 func (g *Getter) Mode(ctx context.Context, u *url.URL) (getter.Mode, error) {
+
+	if g.Timeout > 0 {
+		var cancel context.CancelFunc
+		ctx, cancel = context.WithTimeout(ctx, g.Timeout)
+		defer cancel()
+	}
+
 	// Parse URL
 	region, bucket, path, _, creds, err := g.parseUrl(u)
 	if err != nil {
"
GO-2022-0586,hashicorp,go-getter,38e97387488f5439616be60874979433a12edb48," func (g *Getter) Mode(ctx context.Context, u *url.URL) (getter.Mode, error) {
 		Bucket: aws.String(bucket),
 		Prefix: aws.String(path),
 	}
-	resp, err := client.ListObjects(req)
+	resp, err := client.ListObjectsWithContext(ctx, req)
 	if err != nil {
 		return 0, err
 	}
"
GO-2022-0586,hashicorp,go-getter,38e97387488f5439616be60874979433a12edb48," func (g *Getter) Mode(ctx context.Context, u *url.URL) (getter.Mode, error) {
 
 func (g *Getter) Get(ctx context.Context, req *getter.Request) error {
 
+	if g.Timeout > 0 {
+		var cancel context.CancelFunc
+		ctx, cancel = context.WithTimeout(ctx, g.Timeout)
+		defer cancel()
+	}
+
 	// Parse URL
 	region, bucket, path, _, creds, err := g.parseUrl(req.URL())
 	if err != nil {
"
GO-2022-0586,hashicorp,go-getter,38e97387488f5439616be60874979433a12edb48," func (g *Getter) Get(ctx context.Context, req *getter.Request) error {
 			s3Req.Marker = aws.String(lastMarker)
 		}
 
-		resp, err := client.ListObjects(s3Req)
+		resp, err := client.ListObjectsWithContext(ctx, s3Req)
 		if err != nil {
 			return err
 		}
"
GO-2022-0586,hashicorp,go-getter,38e97387488f5439616be60874979433a12edb48," func (g *Getter) Get(ctx context.Context, req *getter.Request) error {
 }
 
 func (g *Getter) GetFile(ctx context.Context, req *getter.Request) error {
+
+	if g.Timeout > 0 {
+		var cancel context.CancelFunc
+		ctx, cancel = context.WithTimeout(ctx, g.Timeout)
+		defer cancel()
+	}
+
 	region, bucket, path, version, creds, err := g.parseUrl(req.URL())
 	if err != nil {
 		return err
"
GO-2020-0027,google,fscrypt,3022c1603d968c22f147b4a2c49c4637dd1be91b," func NewHandle(pamh unsafe.Pointer) (*Handle, error) {
 		return nil, err
 	}
 
-	if h.PamUser, err = user.Lookup(C.GoString(pamUsername)); err != nil {
-		return nil, err
-	}
-	if h.OrigUser, err = util.EffectiveUser(); err != nil {
-		return nil, err
-	}
-	return h, nil
+	h.PamUser, err = user.Lookup(C.GoString(pamUsername))
+	return h, err
 }
 
 func (h *Handle) setData(name string, data unsafe.Pointer, cleanup C.CleanupFunc) error {
"
GO-2021-0101,apache,thrift,264a3f318ed3e9e51573f67f963c8509786bcec2," func (p *TSimpleJSONProtocol) readNumeric() (Numeric, error) {
 func (p *TSimpleJSONProtocol) safePeekContains(b []byte) bool {
 	for i := 0; i < len(b); i++ {
 		a, _ := p.reader.Peek(i + 1)
-		if len(a) == 0 || a[i] != b[i] {
+		if len(a) < (i+1) || a[i] != b[i] {
 			return false
 		}
 	}
"
GO-2020-0006,miekg,dns,43913f2f4fbd7dcff930b8a809e709591e4dd79e," func (srv *Server) serveTCP(l net.Listener) error {
 			}
 			return err
 		}
-		m, err := reader.ReadTCP(rw, rtimeout)
-		if err != nil {
-			continue
-		}
-		go srv.serve(rw.RemoteAddr(), handler, m, nil, nil, rw)
+		go func() {
+			m, err := reader.ReadTCP(rw, rtimeout)
+			if err != nil {
+				rw.Close()
+				return
+			}
+			srv.serve(rw.RemoteAddr(), handler, m, nil, nil, rw)
+		}()
 	}
 }
 
"
GO-2021-0070,opencontainers,runc,69af385de62ea68e2e608335cffbb0f4aa3db091," func GetExecUserPath(userSpec string, defaults *ExecUser, passwdPath, groupPath
 //     * ""uid:gid
 //     * ""user:gid""
 //     * ""uid:group""
+//
+// It should be noted that if you specify a numeric user or group id, they will
+// not be evaluated as usernames (only the metadata will be filled). So attempting
+// to parse a user with user.Name = ""1337"" will produce the user with a UID of
+// 1337.
 func GetExecUser(userSpec string, defaults *ExecUser, passwd, group io.Reader) (*ExecUser, error) {
 	var (
 		userArg, groupArg string
-		name              string
 	)
 
 	if defaults == nil {
"
GO-2021-0070,opencontainers,runc,69af385de62ea68e2e608335cffbb0f4aa3db091," func GetExecUser(userSpec string, defaults *ExecUser, passwd, group io.Reader) (
 	// allow for userArg to have either ""user"" syntax, or optionally ""user:group"" syntax
 	parseLine(userSpec, &userArg, &groupArg)
 
+	// Convert userArg and groupArg to be numeric, so we don't have to execute
+	// Atoi *twice* for each iteration over lines.
+	uidArg, uidErr := strconv.Atoi(userArg)
+	gidArg, gidErr := strconv.Atoi(groupArg)
+
 	users, err := ParsePasswdFilter(passwd, func(u User) bool {
 		if userArg == """" {
 			return u.Uid == user.Uid
 		}
-		return u.Name == userArg || strconv.Itoa(u.Uid) == userArg
+
+		if uidErr == nil {
+			// If the userArg is numeric, always treat it as a UID.
+			return uidArg == u.Uid
+		}
+
+		return u.Name == userArg
 	})
 	if err != nil && passwd != nil {
 		if userArg == """" {
"
GO-2021-0070,opencontainers,runc,69af385de62ea68e2e608335cffbb0f4aa3db091," func GetExecUser(userSpec string, defaults *ExecUser, passwd, group io.Reader) (
 		return nil, fmt.Errorf(""Unable to find user %v: %v"", userArg, err)
 	}
 
-	haveUser := users != nil && len(users) > 0
-	if haveUser {
-		// if we found any user entries that matched our filter, let's take the first one as ""correct""
-		name = users[0].Name
+	var matchedUserName string
+	if len(users) > 0 {
+		// First match wins, even if there's more than one matching entry.
+		matchedUserName = users[0].Name
 		user.Uid = users[0].Uid
 		user.Gid = users[0].Gid
 		user.Home = users[0].Home
 	} else if userArg != """" {
-		// we asked for a user but didn't find them...  let's check to see if we wanted a numeric user
-		user.Uid, err = strconv.Atoi(userArg)
-		if err != nil {
-			// not numeric - we have to bail
-			return nil, fmt.Errorf(""Unable to find user %v"", userArg)
+		// If we can't find a user with the given username, the only other valid
+		// option is if it's a numeric username with no associated entry in passwd.
+
+		if uidErr != nil {
+			// Not numeric.
+			return nil, fmt.Errorf(""unable to find user %s: %v"", userArg, ErrNoPasswdEntries)
 		}
+		user.Uid = uidArg
 
 		// Must be inside valid uid range.
 		if user.Uid < minId || user.Uid > maxId {
 			return nil, ErrRange
 		}
 
-		// if userArg couldn't be found in /etc/passwd but is numeric, just roll with it - this is legit
+		// Okay, so it's numeric. We can just roll with this.
 	}
 
-	if groupArg != """" || name != """" {
+	// On to the groups. If we matched a username, we need to do this because of
+	// the supplementary group IDs.
+	if groupArg != """" || matchedUserName != """" {
 		groups, err := ParseGroupFilter(group, func(g Group) bool {
-			// Explicit group format takes precedence.
-			if groupArg != """" {
-				return g.Name == groupArg || strconv.Itoa(g.Gid) == groupArg
+			// If the group argument isn't explicit, we'll just search for it.
+			if groupArg == """" {
+				// Check if user is a member of this group.
+				for _, u := range g.List {
+					if u == matchedUserName {
+						return true
+					}
+				}
+				return false
 			}
 
-			// Check if user is a member.
-			for _, u := range g.List {
-				if u == name {
-					return true
-				}
+			if gidErr == nil {
+				// If the groupArg is numeric, always treat it as a GID.
+				return gidArg == g.Gid
 			}
 
-			return false
+			return g.Name == groupArg
 		})
 		if err != nil && group != nil {
-			return nil, fmt.Errorf(""Unable to find groups for user %v: %v"", users[0].Name, err)
+			return nil, fmt.Errorf(""unable to find groups for spec %v: %v"", matchedUserName, err)
 		}
 
 		haveGroup := groups != nil && len(groups) > 0
"
GO-2021-0070,opencontainers,runc,69af385de62ea68e2e608335cffbb0f4aa3db091," func GetExecUser(userSpec string, defaults *ExecUser, passwd, group io.Reader) (
 			if haveGroup {
 				// if we found any group entries that matched our filter, let's take the first one as ""correct""
 				user.Gid = groups[0].Gid
-			} else {
-				// we asked for a group but didn't find id...  let's check to see if we wanted a numeric group
-				user.Gid, err = strconv.Atoi(groupArg)
-				if err != nil {
-					// not numeric - we have to bail
-					return nil, fmt.Errorf(""Unable to find group %v"", groupArg)
+			} else if groupArg != """" {
+				// If we can't find a group with the given name, the only other valid
+				// option is if it's a numeric group name with no associated entry in group.
+
+				if gidErr != nil {
+					// Not numeric.
+					return nil, fmt.Errorf(""unable to find group %s: %v"", groupArg, ErrNoGroupEntries)
 				}
+				user.Gid = gidArg
 
 				// Ensure gid is inside gid range.
 				if user.Gid < minId || user.Gid > maxId {
 					return nil, ErrRange
 				}
 
-				// if groupArg couldn't be found in /etc/group but is numeric, just roll with it - this is legit
+				// Okay, so it's numeric. We can just roll with this.
 			}
-		} else if haveGroup {
-			// If implicit group format, fill supplementary gids.
+		} else if len(groups) > 0 {
+			// Supplementary group ids only make sense if in the implicit form.
 			user.Sgids = make([]int, len(groups))
 			for i, group := range groups {
 				user.Sgids[i] = group.Gid
"
GO-2023-2074,gomarkdown,markdown,14b16010c2ee7ff33a940a541d993bd043a88940," func (p *Parser) AddBlock(n ast.Node) ast.Node {
 }
 
 func (p *Parser) isPrefixHeading(data []byte) bool {
-	if data[0] != '#' {
+	if len(data) > 0 && data[0] != '#' {
 		return false
 	}
 
"
GO-2023-2074,gomarkdown,markdown,14b16010c2ee7ff33a940a541d993bd043a88940," func citation(p *Parser, data []byte, offset int) (int, ast.Node) {
 		}
 
 		citeType := ast.CitationTypeInformative
+
+		if len(citation) < 2 {
+			continue
+		}
+
 		j = 1
 		switch citation[j] {
 		case '!':
"
GO-2021-0237,AndrewBurian,powermux,5e60a8a0372b35a898796c2697c40e8daabed8e9," func newRoute() *Route {
 // a route.
 func (r *Route) execute(ex *routeExecution, method, pattern string) {
 
+	if strings.Contains(pattern, ""//"") {
+		ex.handler = r.badRequest(""Invalid path"")
+		return
+	}
+
 	pathParts := pathPartsPool.Get().([]string)[0:0]
+	defer pathPartsPool.Put(pathParts)
 	pathParts = append(pathParts, """")
 	start := 1
 	for i := 1; i < len(pattern); i++ {
"
GO-2021-0237,AndrewBurian,powermux,5e60a8a0372b35a898796c2697c40e8daabed8e9," func (r *Route) execute(ex *routeExecution, method, pattern string) {
 		}
 	}
 
+	// redirect trailing slashes
+	if pattern != ""/"" && strings.HasSuffix(pattern, ""/"") {
+		target := strings.TrimSuffix(pattern, ""/"")
+		ex.handler = http.RedirectHandler(target, http.StatusPermanentRedirect)
+		ex.pattern = target
+		return
+	}
+
 	// get the trailing path param
 	if pattern != ""/"" {
 		pathParts = append(pathParts, pattern[start:])
"
GO-2021-0237,AndrewBurian,powermux,5e60a8a0372b35a898796c2697c40e8daabed8e9," func (r *Route) execute(ex *routeExecution, method, pattern string) {
 	// Fill the execution
 	r.getExecution(method, pathParts, ex)
 
-	// return path parts
-	pathPartsPool.Put(pathParts)
 }
 
 // getExecution is a recursive step in the tree traversal. It checks to see if this node matches,
"
GO-2022-0978,open-policy-agent,opa,25a597bc3f4985162e7f65f9c36599f4f8f55823," func (c *Compiler) rewriteWithModifiers() {
 			if !ok {
 				return x, nil
 			}
-			body, err := rewriteWithModifiersInBody(c, f, body)
+			body, err := rewriteWithModifiersInBody(c, c.unsafeBuiltinsMap, f, body)
 			if err != nil {
 				c.err(err)
 			}
"
GO-2022-0978,open-policy-agent,opa,25a597bc3f4985162e7f65f9c36599f4f8f55823," func rewriteDeclaredVar(g *localVarGenerator, stack *localDeclaredVars, v Var, o
 // rewriteWithModifiersInBody will rewrite the body so that with modifiers do
 // not contain terms that require evaluation as values. If this function
 // encounters an invalid with modifier target then it will raise an error.
-func rewriteWithModifiersInBody(c *Compiler, f *equalityFactory, body Body) (Body, *Error) {
+func rewriteWithModifiersInBody(c *Compiler, unsafeBuiltinsMap map[string]struct{}, f *equalityFactory, body Body) (Body, *Error) {
 	var result Body
 	for i := range body {
-		exprs, err := rewriteWithModifier(c, f, body[i])
+		exprs, err := rewriteWithModifier(c, unsafeBuiltinsMap, f, body[i])
 		if err != nil {
 			return nil, err
 		}
"
GO-2022-0978,open-policy-agent,opa,25a597bc3f4985162e7f65f9c36599f4f8f55823," func rewriteWithModifiersInBody(c *Compiler, f *equalityFactory, body Body) (Bod
 	return result, nil
 }
 
-func rewriteWithModifier(c *Compiler, f *equalityFactory, expr *Expr) ([]*Expr, *Error) {
+func rewriteWithModifier(c *Compiler, unsafeBuiltinsMap map[string]struct{}, f *equalityFactory, expr *Expr) ([]*Expr, *Error) {
 
 	var result []*Expr
 	for i := range expr.With {
-		eval, err := validateWith(c, expr, i)
+		eval, err := validateWith(c, unsafeBuiltinsMap, expr, i)
 		if err != nil {
 			return nil, err
 		}
"
GO-2022-0978,open-policy-agent,opa,25a597bc3f4985162e7f65f9c36599f4f8f55823," func rewriteWithModifier(c *Compiler, f *equalityFactory, expr *Expr) ([]*Expr,
 	return append(result, expr), nil
 }
 
-func validateWith(c *Compiler, expr *Expr, i int) (bool, *Error) {
+func validateWith(c *Compiler, unsafeBuiltinsMap map[string]struct{}, expr *Expr, i int) (bool, *Error) {
 	target, value := expr.With[i].Target, expr.With[i].Value
 
 	// Ensure that values that are built-ins are rewritten to Ref (not Var)
"
GO-2022-0978,open-policy-agent,opa,25a597bc3f4985162e7f65f9c36599f4f8f55823," func validateWith(c *Compiler, expr *Expr, i int) (bool, *Error) {
 			value.Value = Ref([]*Term{NewTerm(v)})
 		}
 	}
+	isBuiltinRefOrVar, err := isBuiltinRefOrVar(c.builtins, unsafeBuiltinsMap, target)
+	if err != nil {
+		return false, err
+	}
 
 	switch {
 	case isDataRef(target):
"
GO-2022-0978,open-policy-agent,opa,25a597bc3f4985162e7f65f9c36599f4f8f55823," func validateWith(c *Compiler, expr *Expr, i int) (bool, *Error) {
 			if child := node.Child(ref[len(ref)-1].Value); child != nil {
 				for _, v := range child.Values {
 					if len(v.(*Rule).Head.Args) > 0 {
-						if validateWithFunctionValue(c.builtins, c.RuleTree, value) {
-							return false, nil
+						if ok, err := validateWithFunctionValue(c.builtins, unsafeBuiltinsMap, c.RuleTree, value); err != nil || ok {
+							return false, err // may be nil
 						}
 					}
 				}
 			}
 		}
 	case isInputRef(target): // ok, valid
-	case isBuiltinRefOrVar(c.builtins, target):
+	case isBuiltinRefOrVar:
 
 		// NOTE(sr): first we ensure that parsed Var builtins (`count`, `concat`, etc)
 		// are rewritten to their proper Ref convention
"
GO-2022-0978,open-policy-agent,opa,25a597bc3f4985162e7f65f9c36599f4f8f55823," func validateWith(c *Compiler, expr *Expr, i int) (bool, *Error) {
 			return false, err
 		}
 
-		if validateWithFunctionValue(c.builtins, c.RuleTree, value) {
-			return false, nil
+		if ok, err := validateWithFunctionValue(c.builtins, unsafeBuiltinsMap, c.RuleTree, value); err != nil || ok {
+			return false, err // may be nil
 		}
 	default:
 		return false, NewError(TypeErr, target.Location, ""with keyword target must reference existing %v, %v, or a function"", InputRootDocument, DefaultRootDocument)
"
GO-2022-0978,open-policy-agent,opa,25a597bc3f4985162e7f65f9c36599f4f8f55823," func validateWithBuiltinTarget(bi *Builtin, target Ref, loc *location.Location)
 	return nil
 }
 
-func validateWithFunctionValue(bs map[string]*Builtin, ruleTree *TreeNode, value *Term) bool {
+func validateWithFunctionValue(bs map[string]*Builtin, unsafeMap map[string]struct{}, ruleTree *TreeNode, value *Term) (bool, *Error) {
 	if v, ok := value.Value.(Ref); ok {
 		if ruleTree.Find(v) != nil { // ref exists in rule tree
-			return true
+			return true, nil
 		}
 	}
-	return isBuiltinRefOrVar(bs, value)
+	return isBuiltinRefOrVar(bs, unsafeMap, value)
 }
 
 func isInputRef(term *Term) bool {
"
GO-2022-0978,open-policy-agent,opa,25a597bc3f4985162e7f65f9c36599f4f8f55823," func isDataRef(term *Term) bool {
 	return false
 }
 
-func isBuiltinRefOrVar(bs map[string]*Builtin, term *Term) bool {
+func isBuiltinRefOrVar(bs map[string]*Builtin, unsafeBuiltinsMap map[string]struct{}, term *Term) (bool, *Error) {
 	switch v := term.Value.(type) {
 	case Ref, Var:
+		if _, ok := unsafeBuiltinsMap[v.String()]; ok {
+			return false, NewError(CompileErr, term.Location, ""with keyword replacing built-in function: target must not be unsafe: %q"", v)
+		}
 		_, ok := bs[v.String()]
-		return ok
+		return ok, nil
 	}
-	return false
+	return false, nil
 }
 
 func isVirtual(node *TreeNode, ref Ref) bool {
"
GO-2022-0978,open-policy-agent,opa,3e8c754ed007b22393cf65e48751ad9f6457fee8," func (c *Compiler) rewriteWithModifiers() {
 			if !ok {
 				return x, nil
 			}
-			body, err := rewriteWithModifiersInBody(c, f, body)
+			body, err := rewriteWithModifiersInBody(c, c.unsafeBuiltinsMap, f, body)
 			if err != nil {
 				c.err(err)
 			}
"
GO-2022-0978,open-policy-agent,opa,3e8c754ed007b22393cf65e48751ad9f6457fee8," func rewriteDeclaredVar(g *localVarGenerator, stack *localDeclaredVars, v Var, o
 // rewriteWithModifiersInBody will rewrite the body so that with modifiers do
 // not contain terms that require evaluation as values. If this function
 // encounters an invalid with modifier target then it will raise an error.
-func rewriteWithModifiersInBody(c *Compiler, f *equalityFactory, body Body) (Body, *Error) {
+func rewriteWithModifiersInBody(c *Compiler, unsafeBuiltinsMap map[string]struct{}, f *equalityFactory, body Body) (Body, *Error) {
 	var result Body
 	for i := range body {
-		exprs, err := rewriteWithModifier(c, f, body[i])
+		exprs, err := rewriteWithModifier(c, unsafeBuiltinsMap, f, body[i])
 		if err != nil {
 			return nil, err
 		}
"
GO-2022-0978,open-policy-agent,opa,3e8c754ed007b22393cf65e48751ad9f6457fee8," func rewriteWithModifiersInBody(c *Compiler, f *equalityFactory, body Body) (Bod
 	return result, nil
 }
 
-func rewriteWithModifier(c *Compiler, f *equalityFactory, expr *Expr) ([]*Expr, *Error) {
+func rewriteWithModifier(c *Compiler, unsafeBuiltinsMap map[string]struct{}, f *equalityFactory, expr *Expr) ([]*Expr, *Error) {
 
 	var result []*Expr
 	for i := range expr.With {
-		eval, err := validateWith(c, expr, i)
+		eval, err := validateWith(c, unsafeBuiltinsMap, expr, i)
 		if err != nil {
 			return nil, err
 		}
"
GO-2022-0978,open-policy-agent,opa,3e8c754ed007b22393cf65e48751ad9f6457fee8," func rewriteWithModifier(c *Compiler, f *equalityFactory, expr *Expr) ([]*Expr,
 	return append(result, expr), nil
 }
 
-func validateWith(c *Compiler, expr *Expr, i int) (bool, *Error) {
+func validateWith(c *Compiler, unsafeBuiltinsMap map[string]struct{}, expr *Expr, i int) (bool, *Error) {
 	target, value := expr.With[i].Target, expr.With[i].Value
 
 	// Ensure that values that are built-ins are rewritten to Ref (not Var)
"
GO-2022-0978,open-policy-agent,opa,3e8c754ed007b22393cf65e48751ad9f6457fee8," func validateWith(c *Compiler, expr *Expr, i int) (bool, *Error) {
 			value.Value = Ref([]*Term{NewTerm(v)})
 		}
 	}
+	isBuiltinRefOrVar, err := isBuiltinRefOrVar(c.builtins, unsafeBuiltinsMap, target)
+	if err != nil {
+		return false, err
+	}
 
 	switch {
 	case isDataRef(target):
"
GO-2022-0978,open-policy-agent,opa,3e8c754ed007b22393cf65e48751ad9f6457fee8," func validateWith(c *Compiler, expr *Expr, i int) (bool, *Error) {
 			if child := node.Child(ref[len(ref)-1].Value); child != nil {
 				for _, v := range child.Values {
 					if len(v.(*Rule).Head.Args) > 0 {
-						if validateWithFunctionValue(c.builtins, c.RuleTree, value) {
-							return false, nil
+						if ok, err := validateWithFunctionValue(c.builtins, unsafeBuiltinsMap, c.RuleTree, value); err != nil || ok {
+							return false, err // may be nil
 						}
 					}
 				}
 			}
 		}
 	case isInputRef(target): // ok, valid
-	case isBuiltinRefOrVar(c.builtins, target):
+	case isBuiltinRefOrVar:
 
 		// NOTE(sr): first we ensure that parsed Var builtins (`count`, `concat`, etc)
 		// are rewritten to their proper Ref convention
"
GO-2022-0978,open-policy-agent,opa,3e8c754ed007b22393cf65e48751ad9f6457fee8," func validateWith(c *Compiler, expr *Expr, i int) (bool, *Error) {
 			return false, err
 		}
 
-		if validateWithFunctionValue(c.builtins, c.RuleTree, value) {
-			return false, nil
+		if ok, err := validateWithFunctionValue(c.builtins, unsafeBuiltinsMap, c.RuleTree, value); err != nil || ok {
+			return false, err // may be nil
 		}
 	default:
 		return false, NewError(TypeErr, target.Location, ""with keyword target must reference existing %v, %v, or a function"", InputRootDocument, DefaultRootDocument)
"
GO-2022-0978,open-policy-agent,opa,3e8c754ed007b22393cf65e48751ad9f6457fee8," func validateWithBuiltinTarget(bi *Builtin, target Ref, loc *location.Location)
 	return nil
 }
 
-func validateWithFunctionValue(bs map[string]*Builtin, ruleTree *TreeNode, value *Term) bool {
+func validateWithFunctionValue(bs map[string]*Builtin, unsafeMap map[string]struct{}, ruleTree *TreeNode, value *Term) (bool, *Error) {
 	if v, ok := value.Value.(Ref); ok {
 		if ruleTree.Find(v) != nil { // ref exists in rule tree
-			return true
+			return true, nil
 		}
 	}
-	return isBuiltinRefOrVar(bs, value)
+	return isBuiltinRefOrVar(bs, unsafeMap, value)
 }
 
 func isInputRef(term *Term) bool {
"
GO-2022-0978,open-policy-agent,opa,3e8c754ed007b22393cf65e48751ad9f6457fee8," func isDataRef(term *Term) bool {
 	return false
 }
 
-func isBuiltinRefOrVar(bs map[string]*Builtin, term *Term) bool {
+func isBuiltinRefOrVar(bs map[string]*Builtin, unsafeBuiltinsMap map[string]struct{}, term *Term) (bool, *Error) {
 	switch v := term.Value.(type) {
 	case Ref, Var:
+		if _, ok := unsafeBuiltinsMap[v.String()]; ok {
+			return false, NewError(CompileErr, term.Location, ""with keyword replacing built-in function: target must not be unsafe: %q"", v)
+		}
 		_, ok := bs[v.String()]
-		return ok
+		return ok, nil
 	}
-	return false
+	return false, nil
 }
 
 func isVirtual(node *TreeNode, ref Ref) bool {
"
GO-2023-1713,sjqzhang,go-fastdfs,61cbff5124c61e292994099372b11c06cdb5b80b," func (c *Server) Download(w http.ResponseWriter, r *http.Request) {
 		smallPath string
 		fi        os.FileInfo
 	)
+	// check uri is contains ..
+	if strings.Contains(r.RequestURI, "".."") {
+		c.NotPermit(w, r)
+		return
+	}
 	// redirect to upload
 	if r.RequestURI == ""/"" || r.RequestURI == """" ||
 		r.RequestURI == ""/""+Config().Group ||
"
GO-2023-1713,sjqzhang,go-fastdfs,61cbff5124c61e292994099372b11c06cdb5b80b," package server
 import ""net/http""
 
 func (c *Server) CrossOrigin(w http.ResponseWriter, r *http.Request) {
+	r.Header.Set(""Origin"", ""*"")
 	w.Header().Set(""Access-Control-Allow-Origin"", ""*"")
 	w.Header().Set(""Access-Control-Allow-Headers"", ""Authorization, Content-Type, Depth, User-Agent, X-File-Size, X-Requested-With, X-Requested-By, If-Modified-Since, X-File-Name, X-File-Type, Cache-Control, Origin"")
 	w.Header().Set(""Access-Control-Allow-Methods"", ""GET, POST, OPTIONS, PUT, DELETE"")
"
GO-2023-1713,sjqzhang,go-fastdfs,61cbff5124c61e292994099372b11c06cdb5b80b," func (c *Server) upload(w http.ResponseWriter, r *http.Request) {
 		}
 		if Config().EnableCustomPath {
 			fileInfo.Path = r.FormValue(""path"")
+			//replace . to """"
+			fileInfo.Path = strings.Replace(fileInfo.Path, ""."", """", -1)
 			fileInfo.Path = strings.Trim(fileInfo.Path, ""/"")
 		}
 		scene = r.FormValue(""scene"")
"
GO-2023-2133,nats-io,nats-server,fa5b7afcb64e7e887e49afdd032358802b5c4478," func (o *Options) processConfigFileLine(k string, v interface{}, errors *[]error
 			*errors = append(*errors, err)
 			return
 		}
-
+		o.authBlockDefined = true
 		o.Username = auth.user
 		o.Password = auth.pass
 		o.Authorization = auth.token
"
GO-2023-2133,nats-io,nats-server,fa5b7afcb64e7e887e49afdd032358802b5c4478," func (s *Server) configureAccounts(reloading bool) (map[string]struct{}, error)
 		// If we have defined a system account here check to see if its just us and the $G account.
 		// We would do this to add user/pass to the system account. If this is the case add in
 		// no-auth-user for $G.
-		// Only do this if non-operator mode.
-		if len(opts.TrustedOperators) == 0 && numAccounts == 2 && opts.NoAuthUser == _EMPTY_ {
+		// Only do this if non-operator mode and we did not have an authorization block defined.
+		if len(opts.TrustedOperators) == 0 && numAccounts == 2 && opts.NoAuthUser == _EMPTY_ && !opts.authBlockDefined {
 			// If we come here from config reload, let's not recreate the fake user name otherwise
 			// it will cause currently clients to be disconnected.
 			uname := s.sysAccOnlyNoAuthUser
"
GO-2023-1573,containerd,containerd,0c314901076a74a7b797a545d2f462285fdbb8c4," func ImportIndex(ctx context.Context, store content.Store, reader io.Reader, opt
 	return writeManifest(ctx, store, idx, ocispec.MediaTypeImageIndex)
 }
 
+const (
+	kib       = 1024
+	mib       = 1024 * kib
+	jsonLimit = 20 * mib
+)
+
 func onUntarJSON(r io.Reader, j interface{}) error {
-	b, err := io.ReadAll(r)
-	if err != nil {
-		return err
-	}
-	return json.Unmarshal(b, j)
+	return json.NewDecoder(io.LimitReader(r, jsonLimit)).Decode(j)
 }
 
 func onUntarBlob(ctx context.Context, r io.Reader, store content.Ingester, size int64, ref string) (digest.Digest, error) {
"
GO-2023-1872,openfga,openfga,087ce392595f3c319ab3028b5089118ea4063452," func New(model *openfgapb.AuthorizationModel) *TypeSystem {
 	relations := make(map[string]map[string]*openfgapb.Relation, len(model.GetTypeDefinitions()))
 
 	for _, td := range model.GetTypeDefinitions() {
-		tds[td.GetType()] = td
+		typeName := td.GetType()
+
+		tds[typeName] = td
 		tdRelations := make(map[string]*openfgapb.Relation, len(td.GetRelations()))
 
 		for relation, rewrite := range td.GetRelations() {
"
GO-2023-1872,openfga,openfga,087ce392595f3c319ab3028b5089118ea4063452," func New(model *openfgapb.AuthorizationModel) *TypeSystem {
 
 			tdRelations[relation] = r
 		}
-		relations[td.GetType()] = tdRelations
+		relations[typeName] = tdRelations
 	}
 
 	return &TypeSystem{
"
GO-2023-1872,openfga,openfga,087ce392595f3c319ab3028b5089118ea4063452," func (t *TypeSystem) relationInvolvesExclusion(objectType, relation string, visi
 //     a. For a type (e.g. user) this means checking that this type is in the *TypeSystem
 //     b. For a type#relation this means checking that this type with this relation is in the *TypeSystem
 //  4. Check that a relation is assignable if and only if it has a non-zero list of types
-func NewAndValidate(model *openfgapb.AuthorizationModel) (*TypeSystem, error) {
+func NewAndValidate(ctx context.Context, model *openfgapb.AuthorizationModel) (*TypeSystem, error) {
+	_, span := tracer.Start(ctx, ""typesystem.NewAndValidate"")
+	defer span.End()
+
 	t := New(model)
 	schemaVersion := t.GetSchemaVersion()
 
"
GO-2023-1872,openfga,openfga,087ce392595f3c319ab3028b5089118ea4063452," func NewAndValidate(model *openfgapb.AuthorizationModel) (*TypeSystem, error) {
 		return nil, err
 	}
 
-	// Validate the userset rewrites
-	for _, td := range t.typeDefinitions {
-		for relation, rewrite := range td.GetRelations() {
-			err := t.isUsersetRewriteValid(td.GetType(), relation, rewrite)
+	typedefsMap := t.typeDefinitions
+
+	typeNames := make([]string, 0, len(typedefsMap))
+	for typeName := range typedefsMap {
+		typeNames = append(typeNames, typeName)
+	}
+
+	// range over the type definitions in sorted order to produce a deterministic outcome
+	sort.Strings(typeNames)
+
+	for _, typeName := range typeNames {
+		typedef := typedefsMap[typeName]
+
+		relationMap := typedef.GetRelations()
+		relationNames := make([]string, 0, len(relationMap))
+		for relationName := range relationMap {
+			relationNames = append(relationNames, relationName)
+		}
+
+		// range over the relations in sorted order to produce a deterministic outcome
+		sort.Strings(relationNames)
+
+		for _, relationName := range relationNames {
+
+			err := t.validateRelation(typeName, relationName, relationMap)
 			if err != nil {
 				return nil, err
 			}
"
GO-2023-1872,openfga,openfga,087ce392595f3c319ab3028b5089118ea4063452," func containsDuplicateType(model *openfgapb.AuthorizationModel) bool {
 func (t *TypeSystem) validateNames() error {
 	for _, td := range t.typeDefinitions {
 		objectType := td.GetType()
+
+		if objectType == """" {
+			return fmt.Errorf(""the type name of a type definition cannot be an empty string"")
+		}
+
 		if objectType == ""self"" || objectType == ""this"" {
 			return &InvalidTypeError{ObjectType: objectType, Cause: ErrReservedKeywords}
 		}
 
 		for relation := range td.GetRelations() {
+			if relation == """" {
+				return fmt.Errorf(""type '%s' defines a relation with an empty string for a name"", objectType)
+			}
+
 			if relation == ""self"" || relation == ""this"" {
 				return &InvalidRelationError{ObjectType: objectType, Relation: relation, Cause: ErrReservedKeywords}
 			}
"
GO-2023-1534,pion,dtls,a50d26c5e4eed2ca87509494ffef2d2ebd22b1eb," func (m *MessageHelloVerifyRequest) Unmarshal(data []byte) error {
 	}
 	m.Version.Major = data[0]
 	m.Version.Minor = data[1]
-	cookieLength := data[2]
-	if len(data) < (int(cookieLength) + 3) {
+	cookieLength := int(data[2])
+	if len(data) < cookieLength+3 {
 		return errBufferTooSmall
 	}
 	m.Cookie = make([]byte, cookieLength)
"
GO-2020-0042,sassoftware,go-rpmutils,a64058cf21b8aada501bba923c9aab66fb6febf0," const (
 	S_ISSOCK = 0140000 // Socket
 )
 
+// Extract the contents of a cpio stream from r to the destination directory dest
 func Extract(rs io.Reader, dest string) error {
+	dest = filepath.Clean(filepath.FromSlash(dest))
 	linkMap := make(map[int][]string)
 
 	stream := NewCpioStream(rs)
"
GO-2020-0042,sassoftware,go-rpmutils,a64058cf21b8aada501bba923c9aab66fb6febf0," func Extract(rs io.Reader, dest string) error {
 			break
 		}
 
-		target := path.Join(dest, path.Clean(entry.Header.filename))
-		parent := path.Dir(target)
-
+		// sanitize path
+		target := path.Clean(entry.Header.filename)
+		for strings.HasPrefix(target, ""../"") {
+			target = target[3:]
+		}
+		target = filepath.Join(dest, filepath.FromSlash(target))
+		if !strings.HasPrefix(target, dest+string(filepath.Separator)) && dest != target {
+			// this shouldn't happen due to the sanitization above but always check
+			return fmt.Errorf(""invalid cpio path %q"", entry.Header.filename)
+		}
 		// Create the parent directory if it doesn't exist.
-		if _, err := os.Stat(parent); os.IsNotExist(err) {
-			if err := os.MkdirAll(parent, 0755); err != nil {
-				return err
-			}
+		parent := filepath.Dir(target)
+		if err := os.MkdirAll(parent, 0755); err != nil {
+			return err
 		}
-
 		// FIXME: Need a makedev implementation in go.
 
 		switch entry.Header.Mode() &^ 07777 {
"
GO-2021-0110,ory,fosite,0c9e0f6d654913ad57c507dd9a36631e1858a3e9," func (f *Fosite) AuthenticateClient(ctx context.Context, r *http.Request, form u
 			return nil, errors.WithStack(ErrInvalidClient.WithHint(""Unable to type assert claims from request parameter \""client_assertion\""."").WithDebugf(`Got claims of type %T but expected type ""*jwt.MapClaims"".`, token.Claims))
 		}
 
+		var jti string
 		if !claims.VerifyIssuer(clientID, true) {
 			return nil, errors.WithStack(ErrInvalidClient.WithHint(""Claim \""iss\"" from \""client_assertion\"" must match the \""client_id\"" of the OAuth 2.0 Client.""))
 		} else if f.TokenURL == """" {
 			return nil, errors.WithStack(ErrMisconfiguration.WithHint(""The authorization server's token endpoint URL has not been set.""))
 		} else if sub, ok := (*claims)[""sub""].(string); !ok || sub != clientID {
 			return nil, errors.WithStack(ErrInvalidClient.WithHint(""Claim \""sub\"" from \""client_assertion\"" must match the \""client_id\"" of the OAuth 2.0 Client.""))
-		} else if jti, ok := (*claims)[""jti""].(string); !ok || len(jti) == 0 {
+		} else if jti, ok = (*claims)[""jti""].(string); !ok || len(jti) == 0 {
 			return nil, errors.WithStack(ErrInvalidClient.WithHint(""Claim \""jti\"" from \""client_assertion\"" must be set but is not.""))
+		} else if f.Store.ClientAssertionJWTValid(context.Background(), jti) != nil {
+			return nil, errors.WithStack(ErrJTIKnown.WithHint(""Claim \""jti\"" from \""client_assertion\"" MUST only be used once.""))
+		}
+
+		// type conversion according to jwt.MapClaims.VerifyExpiresAt
+		var expiry int64
+		err = nil
+		switch exp := (*claims)[""exp""].(type) {
+		case float64:
+			expiry = int64(exp)
+		case json.Number:
+			expiry, err = exp.Int64()
+		default:
+			err = ErrInvalidClient.WithHint(""Unable to type assert the expiry time from claims. This should not happen as we validate the expiry time already earlier with token.Claims.Valid()"")
+		}
+
+		if err != nil {
+			return nil, errors.WithStack(err)
+		}
+		if err := f.Store.SetClientAssertionJWT(context.Background(), jti, time.Unix(expiry, 0)); err != nil {
+			return nil, err
 		}
 
 		if auds, ok := (*claims)[""aud""].([]interface{}); !ok {
"
GO-2022-0460,pion,dtls,e0b2ce3592e8e7d73713ac67b363a2e192a4cecf," func (f *fragmentBuffer) pop() (content []byte, epoch uint16) {
 		for _, f := range frags {
 			if f.handshakeHeader.FragmentOffset == targetOffset {
 				fragmentEnd := (f.handshakeHeader.FragmentOffset + f.handshakeHeader.FragmentLength)
-				if fragmentEnd != f.handshakeHeader.Length {
+				if fragmentEnd != f.handshakeHeader.Length && f.handshakeHeader.FragmentLength != 0 {
 					if !appendMessage(fragmentEnd) {
 						return false
 					}
"
GO-2022-0438,hashicorp,go-getter,36b68b2f68a3ed10ee7ecbb0cb9f6b1dc5da49cc," func RedactURL(u *url.URL) string {
 
 	ru := *u
 	if _, has := ru.User.Password(); has {
-		ru.User = url.UserPassword(ru.User.Username(), ""xxxxx"")
+		ru.User = url.UserPassword(ru.User.Username(), ""redacted"")
+	}
+	q := ru.Query()
+	if q.Get(""sshkey"") != """" {
+		q.Set(""sshkey"", ""redacted"")
+		ru.RawQuery = q.Encode()
 	}
 	return ru.String()
 }
"
GO-2022-1201,openshift,osin,8612686d6dda34ae9ef6b5a974e4b7accb4fea29," func (d *DefaultClient) GetUserData() interface{} {
 
 // Implement the ClientSecretMatcher interface
 func (d *DefaultClient) ClientSecretMatches(secret string) bool {
-	return d.Secret == secret
+	return subtle.ConstantTimeCompare([]byte(d.Secret), []byte(secret)) == 1
 }
 
 func (d *DefaultClient) CopyFrom(client Client) {
"
GO-2022-1201,openshift,osin,8612686d6dda34ae9ef6b5a974e4b7accb4fea29," func CheckClientSecret(client Client, secret string) bool {
 		return client.ClientSecretMatches(secret)
 	default:
 		// Fallback to the less secure method of extracting the plain text secret from the client for comparison
-		return client.GetSecret() == secret
+		return subtle.ConstantTimeCompare([]byte(client.GetSecret()), []byte(secret)) == 1
 	}
 }
 
"
GO-2023-2101,Consensys,gnark-crypto,ec6be1a037f7c496d595c541a8a8d31c47bcfa3d," func (p *G1Jac) mulWindowed(a *G1Jac, s *big.Int) *G1Jac {
 	var res G1Jac
 	var ops [3]G1Jac
 
-	res.Set(&g1Infinity)
 	ops[0].Set(a)
+	e := s
+	if s.Sign() == -1 {
+		e = bigIntPool.Get().(*big.Int)
+		defer bigIntPool.Put(e)
+		e.Neg(s)
+		ops[0].Neg(&ops[0])
+	}
+	res.Set(&g1Infinity)
 	ops[1].Double(&ops[0])
 	ops[2].Set(&ops[0]).AddAssign(&ops[1])
 
"
GO-2023-2101,Consensys,gnark-crypto,ec6be1a037f7c496d595c541a8a8d31c47bcfa3d," func (p *G2Jac) mulWindowed(a *G2Jac, s *big.Int) *G2Jac {
 	var res G2Jac
 	var ops [3]G2Jac
 
-	res.Set(&g2Infinity)
 	ops[0].Set(a)
+	e := s
+	if s.Sign() == -1 {
+		e = bigIntPool.Get().(*big.Int)
+		defer bigIntPool.Put(e)
+		e.Neg(s)
+		ops[0].Neg(&ops[0])
+	}
+	res.Set(&g2Infinity)
 	ops[1].Double(&ops[0])
 	ops[2].Set(&ops[0]).AddAssign(&ops[1])
 
"
GO-2023-2101,Consensys,gnark-crypto,ec6be1a037f7c496d595c541a8a8d31c47bcfa3d," func (z *E12) ExpGLV(x E12, k *big.Int) *E12 {
 	s1 = s1.SetBigInt(&s[0]).Bits()
 	s2 = s2.SetBigInt(&s[1]).Bits()
 
+	maxBit := s1.BitLen()
+	if s2.BitLen() > maxBit {
+		maxBit = s2.BitLen()
+	}
+	hiWordIndex := (maxBit - 1) / 64
+
 	// loop starts from len(s1)/2 due to the bounds
-	for i := len(s1) / 2; i >= 0; i-- {
+	for i := hiWordIndex; i >= 0; i-- {
 		mask := uint64(3) << 62
 		for j := 0; j < 32; j++ {
 			res.CyclotomicSquare(&res).CyclotomicSquare(&res)
"
GO-2023-2101,Consensys,gnark-crypto,ec6be1a037f7c496d595c541a8a8d31c47bcfa3d," func (z *E24) ExpGLV(x E24, k *big.Int) *E24 {
 	s1 = s1.SetBigInt(&s[0]).Bits()
 	s2 = s2.SetBigInt(&s[1]).Bits()
 
+	maxBit := s1.BitLen()
+	if s2.BitLen() > maxBit {
+		maxBit = s2.BitLen()
+	}
+	hiWordIndex := (maxBit - 1) / 64
+
 	// loop starts from len(s1)/2 due to the bounds
-	for i := len(s1)/2 + 1; i >= 0; i-- {
+	for i := hiWordIndex; i >= 0; i-- {
 		mask := uint64(3) << 62
 		for j := 0; j < 32; j++ {
 			res.CyclotomicSquare(&res).CyclotomicSquare(&res)
"
GO-2023-2101,Consensys,gnark-crypto,ec6be1a037f7c496d595c541a8a8d31c47bcfa3d," func (z *E6) ExpGLV(x E6, k *big.Int) *E6 {
 	s1 = s1.SetBigInt(&s[0]).Bits()
 	s2 = s2.SetBigInt(&s[1]).Bits()
 
+	maxBit := s1.BitLen()
+	if s2.BitLen() > maxBit {
+		maxBit = s2.BitLen()
+	}
+	hiWordIndex := (maxBit - 1) / 64
+
 	// loop starts from len(s1)/2 due to the bounds
-	for i := len(s1) / 2; i >= 0; i-- {
+	for i := hiWordIndex; i >= 0; i-- {
 		mask := uint64(3) << 62
 		for j := 0; j < 32; j++ {
 			res.CyclotomicSquare(&res).CyclotomicSquare(&res)
"
GO-2023-1611,gookit,goutil,d7b94fede71f018f129f7d21feb58c895d28dadc," func Unzip(archive, targetDir string) (err error) {
 	}
 
 	for _, file := range reader.File {
+
+		if strings.Contains(file.Name, "".."") {
+			return fmt.Errorf(""illegal file path in zip: %v"", file.Name)
+		}
+
 		fullPath := filepath.Join(targetDir, file.Name)
+
 		if file.FileInfo().IsDir() {
 			err = os.MkdirAll(fullPath, file.Mode())
 			if err != nil {
"
GO-2022-0244,satori,go.uuid,75cca531ea763666bc46e531da3b4c3b95f64557," func (g *rfc4122Generator) NewV3(ns UUID, name string) UUID {
 // NewV4 returns random generated UUID.
 func (g *rfc4122Generator) NewV4() (UUID, error) {
 	u := UUID{}
-	if _, err := g.rand.Read(u[:]); err != nil {
+	if _, err := io.ReadFull(g.rand, u[:]); err != nil {
 		return Nil, err
 	}
 	u.SetVersion(V4)
"
GO-2022-0244,satori,go.uuid,75cca531ea763666bc46e531da3b4c3b95f64557," func (g *rfc4122Generator) getClockSequence() (uint64, uint16, error) {
 	var err error
 	g.clockSequenceOnce.Do(func() {
 		buf := make([]byte, 2)
-		if _, err = g.rand.Read(buf); err != nil {
+		if _, err = io.ReadFull(g.rand, buf); err != nil {
 			return
 		}
 		g.clockSequence = binary.BigEndian.Uint16(buf)
"
GO-2022-0244,satori,go.uuid,75cca531ea763666bc46e531da3b4c3b95f64557," func (g *rfc4122Generator) getHardwareAddr() ([]byte, error) {
 
 		// Initialize hardwareAddr randomly in case
 		// of real network interfaces absence.
-		if _, err = g.rand.Read(g.hardwareAddr[:]); err != nil {
+		if _, err = io.ReadFull(g.rand, g.hardwareAddr[:]); err != nil {
 			return
 		}
 		// Set multicast bit as recommended by RFC 4122
"
GO-2021-0105,ethereum,go-ethereum,87c0ba92136a75db0ab2aba1046d4a9860375d6a," func (s *StateDB) createObject(addr common.Address) (newobj, prev *stateObject)
 		s.journal.append(resetObjectChange{prev: prev, prevdestruct: prevdestruct})
 	}
 	s.setStateObject(newobj)
-	return newobj, prev
+	if prev != nil && !prev.deleted {
+		return newobj, prev
+	}
+	return newobj, nil
 }
 
 // CreateAccount explicitly creates a state object. If a state object with the address
"
GO-2022-0248,cloudflare,cfrpki,eb9cc4db7b7b79e44f56dfaa959fccdfb2af8284," func ExtractPathCert(cert *librpki.RPKICertificate) []*PKIFile {
 }
 
 // Returns the list of files from the Manifest
-func ExtractPathManifest(mft *librpki.RPKIManifest) []*PKIFile {
+func ExtractPathManifest(mft *librpki.RPKIManifest) ([]*PKIFile, error) {
 	fileList := make([]*PKIFile, 0)
 	for _, file := range mft.Content.FileList {
 		curFile := file.Name
 		path := string(curFile)
-		// GHSA-cqh2-vc2f-q4fh: Prevent file path references to parent
+		// GHSA-8459-6rc9-8vf8: Prevent file path references to parent
 		// directories.
-		path = strings.ReplaceAll(path, ""../"", """")
+		if strings.Contains(path, ""../"") || strings.Contains(path, ""..\\"") {
+			return nil, fmt.Errorf(""Path %q contains illegal path element"", path)
+		}
 		item := PKIFile{
 			Type:         DetermineType(path),
 			Path:         path,
"
GO-2022-0248,cloudflare,cfrpki,eb9cc4db7b7b79e44f56dfaa959fccdfb2af8284," func ExtractPathManifest(mft *librpki.RPKIManifest) []*PKIFile {
 		}
 		fileList = append(fileList, &item)
 	}
-	return fileList
+	return fileList, nil
 }
 
 func (sm *SimpleManager) AddInitial(fileList []*PKIFile) {
"
GO-2023-1559,ipfs,go-unixfsnode,59050ea8bc458ae55246ae09243e6e165923e076," func NewUnixFSHAMTShard(ctx context.Context, substrate dagpb.PBNode, data data.U
 		return nil, err
 	}
 	shardCache := make(map[ipld.Link]*_UnixFSHAMTShard, substrate.FieldLinks().Length())
-	bf := bitField(data)
+	bf, err := bitField(data)
+	if err != nil {
+		return nil, err
+	}
 	return &_UnixFSHAMTShard{
 		ctx:          ctx,
 		_substrate:   substrate,
"
GO-2023-1559,ipfs,go-unixfsnode,59050ea8bc458ae55246ae09243e6e165923e076," func maxPadLength(nd data.UnixFSData) int {
 	return len(fmt.Sprintf(""%X"", nd.FieldFanout().Must().Int()-1))
 }
 
-func bitField(nd data.UnixFSData) bitfield.Bitfield {
-	bf := bitfield.NewBitfield(int(nd.FieldFanout().Must().Int()))
+const maximumHamtWidth = 1 << 10
+
+func bitField(nd data.UnixFSData) (bitfield.Bitfield, error) {
+	fanout := int(nd.FieldFanout().Must().Int())
+	if fanout > maximumHamtWidth {
+		return nil, fmt.Errorf(""hamt witdh (%d) exceed maximum allowed (%d)"", fanout, maximumHamtWidth)
+	}
+	bf, err := bitfield.NewBitfield(fanout)
+	if err != nil {
+		return nil, err
+	}
 	bf.SetBytes(nd.FieldData().Must().Bytes())
-	return bf
+	return bf, nil
 }
 
 func checkLogTwo(v int) error {
"
GO-2021-0063,ethereum,go-ethereum,bddd103a9f0af27ef533f04e06ea429cf76b6d46," func (h *serverHandler) handleMsg(p *clientPeer, wg *sync.WaitGroup) error {
 		var (
 			lastBHash common.Hash
 			root      common.Hash
+			header    *types.Header
 		)
 		reqCnt := len(req.Reqs)
 		if accept(req.ReqID, uint64(reqCnt), MaxProofsFetch) {
"
GO-2021-0063,ethereum,go-ethereum,bddd103a9f0af27ef533f04e06ea429cf76b6d46," func (h *serverHandler) handleMsg(p *clientPeer, wg *sync.WaitGroup) error {
 					// Open the account or storage trie for the request
 					statedb := h.blockchain.StateCache()
 
+					var trie state.Trie
 					switch len(request.AccKey) {
 					case 0:
 						// No account key specified, open an account trie
"
GO-2021-0063,ethereum,go-ethereum,bddd103a9f0af27ef533f04e06ea429cf76b6d46," func (h *serverHandler) handleMsg(p *clientPeer, wg *sync.WaitGroup) error {
 						return
 					}
 					// Look up the root hash belonging to the request
-					var (
-						header *types.Header
-						trie   state.Trie
-					)
 					if request.BHash != lastBHash {
 						root, lastBHash = common.Hash{}, request.BHash
 
"
GO-2020-0022,cloudflare,golz4,199f5f7878062ca17a98e079f2dbe1205e2ed898," func clen(s []byte) C.int {
 
 // Uncompress with a known output size. len(out) should be equal to
 // the length of the uncompressed out.
-func Uncompress(in, out []byte) (err error) {
-	read := int(C.LZ4_uncompress(p(in), p(out), clen(out)))
-
-	if read != len(in) {
-		err = fmt.Errorf(""uncompress read %d bytes should have read %d"",
-			read, len(in))
+func Uncompress(in, out []byte) (error) {
+	if int(C.LZ4_decompress_safe(p(in), p(out), clen(in), clen(out))) < 0 {
+		return errors.New(""Malformed compression stream"")
 	}
-	return
+
+	return nil
 }
 
 // CompressBound calculates the size of the output buffer needed by
"
GO-2023-1765,cloudflare,circl,ff8d91225f8954b4970b6d6382d2e4c78f4a4cf8," func DeriveAttributeKeysCCA(rand io.Reader, sp *SecretParams, attrs *Attributes)
 
 func EncryptCCA(rand io.Reader, public *PublicParams, policy *Policy, msg []byte) ([]byte, error) {
 	seed := make([]byte, macKeySeedSize)
-	_, err := rand.Read(seed)
+	_, err := io.ReadFull(rand, seed)
 	if err != nil {
 		return nil, err
 	}
"
GO-2023-1765,cloudflare,circl,ff8d91225f8954b4970b6d6382d2e4c78f4a4cf8," func (v RSAVerifier) Blind(random io.Reader, message []byte) ([]byte, blindsign.
 	}
 
 	salt := make([]byte, v.hash.Size())
-	_, err := random.Read(salt)
+	_, err := io.ReadFull(random, salt)
 	if err != nil {
 		return nil, nil, err
 	}
"
GO-2023-1765,cloudflare,circl,ff8d91225f8954b4970b6d6382d2e4c78f4a4cf8," func generateKeyPair(rand io.Reader) (*PublicKey, *PrivateKey, error) {
 func (pk *PublicKey) EncapsulateTo(ct []byte, ss []byte, seed []byte) {
 	if seed == nil {
 		seed = make([]byte, EncapsulationSeedSize)
-		_, _ = cryptoRand.Read(seed[:])
+		if _, err := cryptoRand.Read(seed[:]); err != nil {
+			panic(err)
+		}
 	}
 	if len(seed) != EncapsulationSeedSize {
 		panic(""seed must be of length EncapsulationSeedSize"")
"
GO-2023-1765,cloudflare,circl,ff8d91225f8954b4970b6d6382d2e4c78f4a4cf8," func GenerateKeyPair(rand io.Reader) (*PublicKey, *PrivateKey, error) {
 func (pk *PublicKey) EncapsulateTo(ct, ss []byte, seed []byte) {
 	if seed == nil {
 		seed = make([]byte, EncapsulationSeedSize)
-		cryptoRand.Read(seed[:])
+		if _, err := cryptoRand.Read(seed[:]); err != nil {
+			panic(err)
+		}
 	} else {
 		if len(seed) != EncapsulationSeedSize {
 			panic(""seed must be of length EncapsulationSeedSize"")
"
GO-2023-1765,cloudflare,circl,ff8d91225f8954b4970b6d6382d2e4c78f4a4cf8," func (*scheme) DeriveKeyPair(seed []byte) (kem.PublicKey, kem.PrivateKey) {
 
 func (sch *scheme) Encapsulate(pk kem.PublicKey) (ct []byte, ss []byte, err error) {
 	var seed [EncapsulationSeedSize]byte
-	cryptoRand.Read(seed[:])
+	if _, err := cryptoRand.Read(seed[:]); err != nil {
+		return nil, nil, err
+	}
 	return sch.EncapsulateDeterministically(pk, seed[:])
 }
 
"
GO-2023-1566,usememos,memos,b11d2130a084385eb65c3761a3c841ebe9f81ae8," func (s *Server) registerResourceRoutes(g *echo.Group) {
 		}
 
 		resourceCreate.CreatorID = userID
+		// Only allow those external links with http prefix.
+		if resourceCreate.ExternalLink != """" && !strings.HasPrefix(resourceCreate.ExternalLink, ""http"") {
+			return echo.NewHTTPError(http.StatusBadRequest, ""Invalid external link"")
+		}
 		resource, err := s.Store.CreateResource(ctx, resourceCreate)
 		if err != nil {
 			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to create resource"").SetInternal(err)
"
GO-2023-1566,usememos,memos,b11d2130a084385eb65c3761a3c841ebe9f81ae8," func (s *Server) registerResourceRoutes(g *echo.Group) {
 			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to fetch resource"").SetInternal(err)
 		}
 
-		c.Response().Writer.WriteHeader(http.StatusOK)
-		c.Response().Writer.Header().Set(""Content-Type"", resource.Type)
-		c.Response().Writer.Header().Set(echo.HeaderContentSecurityPolicy, ""default-src 'self'"")
-		if _, err := c.Response().Writer.Write(resource.Blob); err != nil {
-			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to write resource blob"").SetInternal(err)
-		}
-		return nil
+		return c.Stream(http.StatusOK, resource.Type, bytes.NewReader(resource.Blob))
 	})
 
 	g.PATCH(""/resource/:resourceId"", func(c echo.Context) error {
"
GO-2023-1566,usememos,memos,b11d2130a084385eb65c3761a3c841ebe9f81ae8," func (s *Server) registerResourcePublicRoutes(g *echo.Group) {
 		}
 		resource, err := s.Store.FindResource(ctx, resourceFind)
 		if err != nil {
-			return echo.NewHTTPError(http.StatusInternalServerError, fmt.Sprintf(""Failed to fetch resource ID: %v"", resourceID)).SetInternal(err)
+			return echo.NewHTTPError(http.StatusInternalServerError, fmt.Sprintf(""Failed to find resource by ID: %v"", resourceID)).SetInternal(err)
 		}
 
-		resourceType := strings.ToLower(resource.Type)
-		if strings.HasPrefix(resourceType, ""text"") || (strings.HasPrefix(resourceType, ""application"") && resourceType != ""application/pdf"") {
-			resourceType = echo.MIMETextPlain
-		}
 		c.Response().Writer.Header().Set(echo.HeaderCacheControl, ""max-age=31536000, immutable"")
 		c.Response().Writer.Header().Set(echo.HeaderContentSecurityPolicy, ""default-src 'self'"")
-		if strings.HasPrefix(resourceType, ""video"") || strings.HasPrefix(resourceType, ""audio"") {
+		resourceType := strings.ToLower(resource.Type)
+		if strings.HasPrefix(resourceType, ""text"") {
+			resourceType = echo.MIMETextPlainCharsetUTF8
+		} else if strings.HasPrefix(resourceType, ""video"") || strings.HasPrefix(resourceType, ""audio"") {
 			http.ServeContent(c.Response(), c.Request(), resource.Filename, time.Unix(resource.UpdatedTs, 0), bytes.NewReader(resource.Blob))
 			return nil
 		}
"
GO-2020-0038,pion,dtls,fd73a5df2ff0e1fb6ae6a51e2777d7a16cc4f4e0," func (c *Conn) handleIncomingPacket(buf []byte) (*alert, error) {
 		c.log.Trace(""<- ChangeCipherSpec"")
 		c.setRemoteEpoch(c.getRemoteEpoch() + 1)
 	case *applicationData:
+		if h.epoch == 0 {
+			return &alert{alertLevelFatal, alertUnexpectedMessage}, fmt.Errorf(""ApplicationData with epoch of 0"")
+		}
+
 		c.decrypted <- content.data
 	default:
 		return &alert{alertLevelFatal, alertUnexpectedMessage}, fmt.Errorf(""unhandled contentType %d"", content.contentType())
"
GO-2021-0087,opencontainers,runc,2fc03cc11c775b7a8b2e48d7ee447cb9bef32ad0," func mountToRootfs(m *configs.Mount, rootfs, mountLabel string, enableCgroupns b
 
 	switch m.Device {
 	case ""proc"", ""sysfs"":
+		// If the destination already exists and is not a directory, we bail
+		// out This is to avoid mounting through a symlink or similar -- which
+		// has been a ""fun"" attack scenario in the past.
+		// TODO: This won't be necessary once we switch to libpathrs and we can
+		//       stop all of these symlink-exchange attacks.
+		if fi, err := os.Lstat(dest); err != nil {
+			if !os.IsNotExist(err) {
+				return err
+			}
+		} else if fi.Mode()&os.ModeDir == 0 {
+			return fmt.Errorf(""filesystem %q must be mounted on ordinary directory"", m.Device)
+		}
 		if err := os.MkdirAll(dest, 0755); err != nil {
 			return err
 		}
"
GO-2021-0058,crewjam,saml,da4f1a0612c0a8dd0452cf8b3c7a6518f6b4d053," func NewIdpAuthnRequest(idp *IdentityProvider, r *http.Request) (*IdpAuthnReques
 // the AuthnRequest and Metadata properties. Returns a non-nil error if the
 // request is not valid.
 func (req *IdpAuthnRequest) Validate() error {
+	if err := xrv.Validate(bytes.NewReader(req.RequestBuffer)); err != nil {
+		return err
+	}
+
 	if err := xml.Unmarshal(req.RequestBuffer, &req.Request); err != nil {
 		return err
 	}
"
GO-2021-0058,crewjam,saml,da4f1a0612c0a8dd0452cf8b3c7a6518f6b4d053," func randomBytes(n int) []byte {
 }
 
 func getSPMetadata(r io.Reader) (spMetadata *saml.EntityDescriptor, err error) {
-	var bytes []byte
-
-	if bytes, err = ioutil.ReadAll(r); err != nil {
+	var data []byte
+	if data, err = ioutil.ReadAll(r); err != nil {
 		return nil, err
 	}
 
 	spMetadata = &saml.EntityDescriptor{}
+	if err := xrv.Validate(bytes.NewBuffer(data)); err != nil {
+		return nil, err
+	}
 
-	if err := xml.Unmarshal(bytes, &spMetadata); err != nil {
+	if err := xml.Unmarshal(data, &spMetadata); err != nil {
 		if err.Error() == ""expected element type <EntityDescriptor> but have <EntitiesDescriptor>"" {
 			entities := &saml.EntitiesDescriptor{}
-
-			if err := xml.Unmarshal(bytes, &entities); err != nil {
+			if err := xml.Unmarshal(data, &entities); err != nil {
 				return nil, err
 			}
 
"
GO-2021-0058,crewjam,saml,da4f1a0612c0a8dd0452cf8b3c7a6518f6b4d053," import (
 // <EntityDescriptor>.
 func ParseMetadata(data []byte) (*saml.EntityDescriptor, error) {
 	entity := &saml.EntityDescriptor{}
+
+	if err := xrv.Validate(bytes.NewBuffer(data)); err != nil {
+		return nil, err
+	}
+
 	err := xml.Unmarshal(data, entity)
 
 	// this comparison is ugly, but it is how the error is generated in encoding/xml
"
GO-2021-0058,crewjam,saml,da4f1a0612c0a8dd0452cf8b3c7a6518f6b4d053," func (sp *ServiceProvider) ParseXMLResponse(decodedResponseXML []byte, possibleR
 		Response: string(decodedResponseXML),
 	}
 
+	// ensure that the response XML is well formed before we parse it
+	if err := xrv.Validate(bytes.NewReader(decodedResponseXML)); err != nil {
+		retErr.PrivateErr = fmt.Errorf(""invalid xml: %s"", err)
+		return nil, retErr
+	}
+
 	// do some validation first before we decrypt
 	resp := Response{}
-	if err := xml.Unmarshal([]byte(decodedResponseXML), &resp); err != nil {
+	if err := xml.Unmarshal(decodedResponseXML, &resp); err != nil {
 		retErr.PrivateErr = fmt.Errorf(""cannot unmarshal response: %s"", err)
 		return nil, retErr
 	}
"
GO-2021-0058,crewjam,saml,da4f1a0612c0a8dd0452cf8b3c7a6518f6b4d053," func (sp *ServiceProvider) ParseXMLResponse(decodedResponseXML []byte, possibleR
 		}
 		retErr.Response = string(plaintextAssertion)
 
+		// TODO(ross): add test case for this
+		if err := xrv.Validate(bytes.NewReader(plaintextAssertion)); err != nil {
+			retErr.PrivateErr = fmt.Errorf(""plaintext response contains invalid XML: %s"", err)
+			return nil, retErr
+		}
+
 		doc = etree.NewDocument()
 		if err := doc.ReadFromBytes(plaintextAssertion); err != nil {
 			retErr.PrivateErr = fmt.Errorf(""cannot parse plaintext response %v"", err)
"
GO-2021-0058,crewjam,saml,da4f1a0612c0a8dd0452cf8b3c7a6518f6b4d053," func (sp *ServiceProvider) ParseXMLResponse(decodedResponseXML []byte, possibleR
 		}
 
 		assertion = &Assertion{}
+		// Note: plaintextAssertion is known to be safe to parse because
+		// plaintextAssertion is unmodified from when xrv.Validate() was called above.
 		if err := xml.Unmarshal(plaintextAssertion, assertion); err != nil {
 			retErr.PrivateErr = err
 			return nil, retErr
"
GO-2021-0058,crewjam,saml,da4f1a0612c0a8dd0452cf8b3c7a6518f6b4d053," func (sp *ServiceProvider) ValidateLogoutResponseForm(postFormData string) error
 		return fmt.Errorf(""unable to parse base64: %s"", err)
 	}
 
-	var resp LogoutResponse
+	// TODO(ross): add test case for this (SLO does not have tests right now)
+	if err := xrv.Validate(bytes.NewReader(rawResponseBuf)); err != nil {
+		return fmt.Errorf(""response contains invalid XML: %s"", err)
+	}
 
+	var resp LogoutResponse
 	if err := xml.Unmarshal(rawResponseBuf, &resp); err != nil {
 		return fmt.Errorf(""cannot unmarshal response: %s"", err)
 	}
"
GO-2021-0058,crewjam,saml,da4f1a0612c0a8dd0452cf8b3c7a6518f6b4d053," func (sp *ServiceProvider) ValidateLogoutResponseRedirect(queryParameterData str
 		return fmt.Errorf(""unable to parse base64: %s"", err)
 	}
 
-	gr := flate.NewReader(bytes.NewBuffer(rawResponseBuf))
+	gr, err := ioutil.ReadAll(flate.NewReader(bytes.NewBuffer(rawResponseBuf)))
+	if err != nil {
+		return err
+	}
+
+	if err := xrv.Validate(bytes.NewReader(gr)); err != nil {
+		return err
+	}
 
-	decoder := xml.NewDecoder(gr)
+	decoder := xml.NewDecoder(bytes.NewReader(gr))
 
 	var resp LogoutResponse
 
"
GO-2021-0058,crewjam,saml,da4f1a0612c0a8dd0452cf8b3c7a6518f6b4d053," func (sp *ServiceProvider) ValidateLogoutResponseRedirect(queryParameterData str
 	}
 
 	doc := etree.NewDocument()
-	if _, err := doc.ReadFrom(gr); err != nil {
+	if _, err := doc.ReadFrom(bytes.NewReader(gr)); err != nil {
 		return err
 	}
 
"
GO-2021-0098,git-lfs,git-lfs,fc664697ed2c2081ee9633010de0a7f9debea72a," func PipeMediaCommand(name string, args ...string) error {
 }
 
 func PipeCommand(name string, args ...string) error {
-	cmd := exec.Command(name, args...)
+	cmd := subprocess.ExecCommand(name, args...)
 	cmd.Stdin = os.Stdin
 	cmd.Stderr = os.Stderr
 	cmd.Stdout = os.Stdout
"
GO-2021-0098,git-lfs,git-lfs,fc664697ed2c2081ee9633010de0a7f9debea72a," func (a *AskPassCredentialHelper) getFromProgram(valueType credValueType, u *url
 
 	// 'cmd' will run the GIT_ASKPASS (or core.askpass) command prompting
 	// for the desired valueType (`Username` or `Password`)
-	cmd := exec.Command(a.Program, a.args(fmt.Sprintf(""%s for %q"", valueString, u))...)
+	cmd := subprocess.ExecCommand(a.Program, a.args(fmt.Sprintf(""%s for %q"", valueString, u))...)
 	cmd.Stderr = &err
 	cmd.Stdout = &value
 
"
GO-2021-0098,git-lfs,git-lfs,fc664697ed2c2081ee9633010de0a7f9debea72a," func pipeExtensions(cfg *config.Configuration, request *pipeRequest) (response p
 			arg := strings.Replace(value, ""%f"", request.fileName, -1)
 			args = append(args, arg)
 		}
-		cmd := exec.Command(name, args...)
+		cmd := subprocess.ExecCommand(name, args...)
 		ec := &extCommand{cmd: cmd, result: &pipeExtResult{name: e.Name}}
 		extcmds = append(extcmds, ec)
 	}
"
GO-2021-0098,git-lfs,git-lfs,fc664697ed2c2081ee9633010de0a7f9debea72a," func (c *sshAuthClient) Resolve(e Endpoint, method string) (sshAuthResponse, err
 	}
 
 	exe, args := sshGetLFSExeAndArgs(c.os, c.git, e, method)
-	cmd := exec.Command(exe, args...)
+	cmd := subprocess.ExecCommand(exe, args...)
 
 	// Save stdout and stderr in separate buffers
 	var outbuf, errbuf bytes.Buffer
"
GO-2022-0417,containers,buildah,e7e55c988c05dd74005184ceb64f097a0cfe645b," func setCapabilities(spec *specs.Spec, keepCaps ...string) error {
 	capMap := map[capability.CapType][]string{
 		capability.BOUNDING:    spec.Process.Capabilities.Bounding,
 		capability.EFFECTIVE:   spec.Process.Capabilities.Effective,
-		capability.INHERITABLE: spec.Process.Capabilities.Inheritable,
+		capability.INHERITABLE: []string{},
 		capability.PERMITTED:   spec.Process.Capabilities.Permitted,
 		capability.AMBIENT:     spec.Process.Capabilities.Ambient,
 	}
"
GO-2022-0417,containers,buildah,e7e55c988c05dd74005184ceb64f097a0cfe645b," func setupCapAdd(g *generate.Generator, caps ...string) error {
 		if err := g.AddProcessCapabilityEffective(cap); err != nil {
 			return errors.Wrapf(err, ""error adding %q to the effective capability set"", cap)
 		}
-		if err := g.AddProcessCapabilityInheritable(cap); err != nil {
-			return errors.Wrapf(err, ""error adding %q to the inheritable capability set"", cap)
-		}
 		if err := g.AddProcessCapabilityPermitted(cap); err != nil {
 			return errors.Wrapf(err, ""error adding %q to the permitted capability set"", cap)
 		}
"
GO-2022-0417,containers,buildah,e7e55c988c05dd74005184ceb64f097a0cfe645b," func setupCapDrop(g *generate.Generator, caps ...string) error {
 		if err := g.DropProcessCapabilityEffective(cap); err != nil {
 			return errors.Wrapf(err, ""error removing %q from the effective capability set"", cap)
 		}
-		if err := g.DropProcessCapabilityInheritable(cap); err != nil {
-			return errors.Wrapf(err, ""error removing %q from the inheritable capability set"", cap)
-		}
 		if err := g.DropProcessCapabilityPermitted(cap); err != nil {
 			return errors.Wrapf(err, ""error removing %q from the permitted capability set"", cap)
 		}
"
GO-2023-1602,russellhaering,gosaml2,f9d66040241093e8702649baff50cc70d2c683c0," func (sp *SAMLServiceProvider) ValidateEncodedLogoutRequestPOST(encodedRequest s
 	}
 
 	// Parse the raw request - parseResponse is generic
-	doc, el, err := parseResponse(raw)
+	doc, el, err := parseResponse(raw, sp.MaximumDecompressedBodySize)
 	if err != nil {
 		return nil, err
 	}
"
GO-2023-1602,russellhaering,gosaml2,f9d66040241093e8702649baff50cc70d2c683c0," func (sp *SAMLServiceProvider) validateAssertionSignatures(el *etree.Element) er
 	}
 }
 
-//ValidateEncodedResponse both decodes and validates, based on SP
-//configuration, an encoded, signed response. It will also appropriately
-//decrypt a response if the assertion was encrypted
+// ValidateEncodedResponse both decodes and validates, based on SP
+// configuration, an encoded, signed response. It will also appropriately
+// decrypt a response if the assertion was encrypted
 func (sp *SAMLServiceProvider) ValidateEncodedResponse(encodedResponse string) (*types.Response, error) {
 	raw, err := base64.StdEncoding.DecodeString(encodedResponse)
 	if err != nil {
"
GO-2023-1602,russellhaering,gosaml2,f9d66040241093e8702649baff50cc70d2c683c0," func (sp *SAMLServiceProvider) ValidateEncodedResponse(encodedResponse string) (
 	}
 
 	// Parse the raw response
-	doc, el, err := parseResponse(raw)
+	doc, el, err := parseResponse(raw, sp.MaximumDecompressedBodySize)
 	if err != nil {
 		return nil, err
 	}
"
GO-2023-1602,russellhaering,gosaml2,f9d66040241093e8702649baff50cc70d2c683c0," func DecodeUnverifiedBaseResponse(encodedResponse string) (*types.UnverifiedBase
 
 	var response *types.UnverifiedBaseResponse
 
-	err = maybeDeflate(raw, func(maybeXML []byte) error {
+	err = maybeDeflate(raw, defaultMaxDecompressedResponseSize, func(maybeXML []byte) error {
 		response = &types.UnverifiedBaseResponse{}
 		return xml.Unmarshal(maybeXML, response)
 	})
"
GO-2023-1602,russellhaering,gosaml2,f9d66040241093e8702649baff50cc70d2c683c0," func DecodeUnverifiedLogoutResponse(encodedResponse string) (*types.LogoutRespon
 
 	var response *types.LogoutResponse
 
-	err = maybeDeflate(raw, func(maybeXML []byte) error {
+	err = maybeDeflate(raw, defaultMaxDecompressedResponseSize, func(maybeXML []byte) error {
 		response = &types.LogoutResponse{}
 		return xml.Unmarshal(maybeXML, response)
 	})
"
GO-2023-1602,russellhaering,gosaml2,f9d66040241093e8702649baff50cc70d2c683c0," func (sp *SAMLServiceProvider) ValidateEncodedLogoutResponsePOST(encodedResponse
 	}
 
 	// Parse the raw response
-	doc, el, err := parseResponse(raw)
+	doc, el, err := parseResponse(raw, sp.MaximumDecompressedBodySize)
 	if err != nil {
 		return nil, err
 	}
"
GO-2022-0980,hashicorp,consul-template,d6a6f4af219c28e67d847ba0e0b2bea8f5bb9076," func (t *Template) Execute(i *ExecuteInput) (*ExecuteResult, error) {
 	// Execute the template into the writer
 	var b bytes.Buffer
 	if err := tmpl.Execute(&b, nil); err != nil {
-		return nil, errors.Wrap(err, ""execute"")
+		return nil, errors.Wrap(redactinator(&used, i.Brain, err), ""execute"")
 	}
 
 	return &ExecuteResult{
"
GO-2021-0090,tendermint,tendermint,480b995a31727593f58b361af979054d17d84340," func (voteSet *VoteSet) sumTotalFrac() (int64, int64, float64) {
 //--------------------------------------------------------------------------------
 // Commit
 
-// MakeCommit constructs a Commit from the VoteSet.
-// Panics if the vote type is not PrecommitType or if
-// there's no +2/3 votes for a single block.
+// MakeCommit constructs a Commit from the VoteSet. It only includes precommits
+// for the block, which has 2/3+ majority, and nil.
+//
+// Panics if the vote type is not PrecommitType or if there's no +2/3 votes for
+// a single block.
 func (voteSet *VoteSet) MakeCommit() *Commit {
 	if voteSet.signedMsgType != tmproto.PrecommitType {
 		panic(""Cannot MakeCommit() unless VoteSet.Type is PrecommitType"")
"
GO-2021-0090,tendermint,tendermint,480b995a31727593f58b361af979054d17d84340," func (voteSet *VoteSet) MakeCommit() *Commit {
 	// For every validator, get the precommit
 	commitSigs := make([]CommitSig, len(voteSet.votes))
 	for i, v := range voteSet.votes {
-		commitSigs[i] = v.CommitSig()
+		commitSig := v.CommitSig()
+		// if block ID exists but doesn't match, exclude sig
+		if commitSig.ForBlock() && !v.BlockID.Equals(*voteSet.maj23) {
+			commitSig = NewCommitSigAbsent()
+		}
+		commitSigs[i] = commitSig
 	}
 
 	return NewCommit(voteSet.GetHeight(), voteSet.GetRound(), *voteSet.maj23, commitSigs)
"
GO-2020-0025,cloudfoundry,archiver,09b5706aa9367972c09144a450bb4523049ee840," func extractTarArchive(tarReader *tar.Reader, dest string) error {
 }
 
 func extractTarArchiveFile(header *tar.Header, dest string, input io.Reader) error {
-	filePath := filepath.Join(dest, header.Name)
+	filePath, err := securejoin.SecureJoin(dest, header.Name)
+	if err != nil {
+		return err
+	}
 	fileInfo := header.FileInfo()
 
 	if fileInfo.IsDir() {
 		return os.MkdirAll(filePath, fileInfo.Mode())
 	}
 
-	err := os.MkdirAll(filepath.Dir(filePath), 0755)
+	err = os.MkdirAll(filepath.Dir(filePath), 0755)
 	if err != nil {
 		return err
 	}
"
GO-2020-0025,cloudfoundry,archiver,09b5706aa9367972c09144a450bb4523049ee840," func extractZip(src, dest string) error {
 }
 
 func extractZipArchiveFile(file *zip.File, dest string, input io.Reader) error {
-	filePath := filepath.Join(dest, file.Name)
+	filePath, err := securejoin.SecureJoin(dest, file.Name)
 	fileInfo := file.FileInfo()
 
 	if fileInfo.IsDir() {
-		err := os.MkdirAll(filePath, fileInfo.Mode())
+		err = os.MkdirAll(filePath, fileInfo.Mode())
 		if err != nil {
 			return err
 		}
 	} else {
-		err := os.MkdirAll(filepath.Dir(filePath), 0755)
+		err = os.MkdirAll(filepath.Dir(filePath), 0755)
 		if err != nil {
 			return err
 		}
"
GO-2021-0072,distribution,distribution,91c507a39abfce14b5c8541cf284330e22208c0f," func closeResources(handler http.Handler, closers ...io.Closer) http.Handler {
 // copyFullPayload copies the payload of an HTTP request to destWriter. If it
 // receives less content than expected, and the client disconnected during the
 // upload, it avoids sending a 400 error to keep the logs cleaner.
-func copyFullPayload(responseWriter http.ResponseWriter, r *http.Request, destWriter io.Writer, context ctxu.Context, action string, errSlice *errcode.Errors) error {
+//
+// The copy will be limited to `limit` bytes, if limit is greater than zero.
+func copyFullPayload(responseWriter http.ResponseWriter, r *http.Request, destWriter io.Writer, limit int64, context ctxu.Context, action string) error {
 	// Get a channel that tells us if the client disconnects
 	var clientClosed <-chan bool
 	if notifier, ok := responseWriter.(http.CloseNotifier); ok {
"
GO-2021-0072,distribution,distribution,91c507a39abfce14b5c8541cf284330e22208c0f," func copyFullPayload(responseWriter http.ResponseWriter, r *http.Request, destWr
 		ctxu.GetLogger(context).Warnf(""the ResponseWriter does not implement CloseNotifier (type: %T)"", responseWriter)
 	}
 
+	var body = r.Body
+	if limit > 0 {
+		body = http.MaxBytesReader(responseWriter, body, limit)
+	}
+
 	// Read in the data, if any.
-	copied, err := io.Copy(destWriter, r.Body)
+	copied, err := io.Copy(destWriter, body)
 	if clientClosed != nil && (err != nil || (r.ContentLength > 0 && copied < r.ContentLength)) {
 		// Didn't receive as much content as expected. Did the client
 		// disconnect during the request? If so, avoid returning a 400
"
GO-2021-0072,distribution,distribution,91c507a39abfce14b5c8541cf284330e22208c0f," func (bs *blobStore) Get(ctx context.Context, dgst digest.Digest) ([]byte, error
 		return nil, err
 	}
 
-	p, err := bs.driver.GetContent(ctx, bp)
+	p, err := getContent(ctx, bs.driver, bp)
 	if err != nil {
 		switch err.(type) {
 		case driver.PathNotFoundError:
"
GO-2021-0072,distribution,distribution,91c507a39abfce14b5c8541cf284330e22208c0f," func (bs *blobStore) Get(ctx context.Context, dgst digest.Digest) ([]byte, error
 		return nil, err
 	}
 
-	return p, err
+	return p, nil
 }
 
 func (bs *blobStore) Open(ctx context.Context, dgst digest.Digest) (distribution.ReadSeekCloser, error) {
"
GO-2021-0072,distribution,distribution,91c507a39abfce14b5c8541cf284330e22208c0f," func copyFullPayload(responseWriter http.ResponseWriter, r *http.Request, destWr
 
 	if err != nil {
 		ctxu.GetLogger(context).Errorf(""unknown error reading request payload: %v"", err)
-		*errSlice = append(*errSlice, errcode.ErrorCodeUnknown.WithDetail(err))
 		return err
 	}
 
"
GO-2020-0023,robbert229,jwt,ca1404ee6e83fcbafb66b09ed0d543850a15b654," func (a *Algorithm) validateSignature(encoded string) error {
 
 	b64SignedAttempt := base64.RawURLEncoding.EncodeToString([]byte(signedAttempt))
 
-	if strings.Compare(b64Signature, b64SignedAttempt) != 0 {
+	if !hmac.Equal([]byte(b64Signature), []byte(b64SignedAttempt)) {
 		return errors.New(""invalid signature"")
 	}
 
"
GO-2022-0962,helm,helm,10466e3e179cc8cad4b0bb451108d3c442c69fbc," func setIndex(list []interface{}, index int, val interface{}) (l2 []interface{},
 	if index < 0 {
 		return list, fmt.Errorf(""negative %d index not allowed"", index)
 	}
+	if index > MaxIndex {
+		return list, fmt.Errorf(""index of %d is greater than maximum supported index of %d"", index, MaxIndex)
+	}
 	if len(list) <= index {
 		newlist := make([]interface{}, index+1)
 		copy(newlist, list)
"
GO-2023-1497,sylabs,scs-library-client,68ac4cab5cda0afd8758ff5b5e2e57be6a22fcfa," type Downloader struct {
 
 // httpGetRangeRequest performs HTTP GET range request to URL specified by 'u' in range start-end.
 func (c *Client) httpGetRangeRequest(ctx context.Context, url string, start, end int64) (*http.Response, error) {
-	req, err := c.newRequestWithURL(ctx, http.MethodGet, url, nil)
+	req, err := http.NewRequestWithContext(ctx, http.MethodGet, url, nil)
 	if err != nil {
 		return nil, err
 	}
 
+	if v := c.UserAgent; v != """" {
+		req.Header.Set(""User-Agent"", v)
+	}
+
 	req.Header.Add(""Range"", fmt.Sprintf(""bytes=%d-%d"", start, end))
 
 	return c.HTTPClient.Do(req)
"
GO-2022-1114,duke-git,lancet,f133b32faa05eb93e66175d01827afa4b7094572," func UnZip(zipFile string, destPath string) error {
 	defer zipReader.Close()
 
 	for _, f := range zipReader.File {
-		path := filepath.Join(destPath, f.Name)
+		//issue#62: fix ZipSlip bug
+		path, err := safeFilepathJoin(destPath, f.Name)
+		if err != nil {
+			return err
+		}
 		if f.FileInfo().IsDir() {
 			os.MkdirAll(path, os.ModePerm)
 		} else {
"
GO-2022-1114,duke-git,lancet,f869a0a67098e92d24ddd913e188b32404fa72c9," func UnZip(zipFile string, destPath string) error {
 		path := filepath.Join(destPath, f.Name)
 
 		//issue#62: fix ZipSlip bug
-		if !strings.HasPrefix(path, destPath) {
-			return fmt.Errorf(""%s: illegal file path"", path)
+		path, err := safeFilepathJoin(destPath, f.Name)
+		if err != nil {
+			return err
 		}
 
 		if f.FileInfo().IsDir() {
"
GO-2022-1114,duke-git,lancet,f869a0a67098e92d24ddd913e188b32404fa72c9," func Zip(fpath string, destPath string) error {
 
 // UnZip unzip the file and save it to destPath
 func UnZip(zipFile string, destPath string) error {
-	destPath = filepath.Clean(destPath) + string(os.PathSeparator)
 
 	zipReader, err := zip.OpenReader(zipFile)
 	if err != nil {
"
GO-2023-1832,notaryproject,notation-go,39c8ed050a65cca3f3f308534acb612096735a64," func Verify(ctx context.Context, verifier Verifier, repo registry.Repository, ve
 		// artifactRef is not a digest reference
 		logger.Infof(""Resolved artifact tag `%s` to digest `%s` before verification"", ref.Reference, artifactDescriptor.Digest.String())
 		logger.Warn(""The resolved digest may not point to the same signed artifact, since tags are mutable"")
+	} else if ref.Reference != artifactDescriptor.Digest.String() {
+		return ocispec.Descriptor{}, nil, ErrorSignatureRetrievalFailed{Msg: fmt.Sprintf(""user input digest %s does not match the resolved digest %s"", ref.Reference, artifactDescriptor.Digest.String())}
 	}
 
 	var verificationOutcomes []*VerificationOutcome
"
GO-2023-1832,notaryproject,notation-go,eba60f5aed9c9e05dee55324423c95fe34700b4c," func Sign(ctx context.Context, signer Signer, repo registry.Repository, signOpts
 	if err != nil {
 		return ocispec.Descriptor{}, fmt.Errorf(""failed to resolve reference: %w"", err)
 	}
+	// artifactRef is a tag or a digest, if it's a digest it has to match
+	// the resolved digest
 	if artifactRef != targetDesc.Digest.String() {
-		// artifactRef is not a digest reference
+		if _, err := digest.Parse(artifactRef); err == nil {
+			// artifactRef is a digest, but does not match the resolved digest
+			return ocispec.Descriptor{}, fmt.Errorf(""user input digest %s does not match the resolved digest %s"", artifactRef, targetDesc.Digest.String())
+		}
+		// artifactRef is a tag
 		logger.Warnf(""Always sign the artifact using digest(`@sha256:...`) rather than a tag(`:%s`) because tags are mutable and a tag reference can point to a different artifact than the one signed"", artifactRef)
 		logger.Infof(""Resolved artifact tag `%s` to digest `%s` before signing"", artifactRef, targetDesc.Digest.String())
 	}
-
 	descToSign, err := addUserMetadataToDescriptor(ctx, targetDesc, signOpts.UserMetadata)
 	if err != nil {
 		return ocispec.Descriptor{}, err
"
GO-2020-0007,seccomp,libseccomp-golang,06e7a29f36a34b8cf419aeb87b979ee508e58f9e," func (f *ScmpFilter) addRuleGeneric(call ScmpSyscall, action ScmpAction, exact b
 	}
 
 	if len(conds) == 0 {
-		if err := f.addRuleWrapper(call, action, exact, nil); err != nil {
+		if err := f.addRuleWrapper(call, action, exact, 0, nil); err != nil {
 			return err
 		}
 	} else {
"
GO-2020-0007,seccomp,libseccomp-golang,06e7a29f36a34b8cf419aeb87b979ee508e58f9e," func (f *ScmpFilter) addRuleGeneric(call ScmpSyscall, action ScmpAction, exact b
 			}
 		}
 
-		for _, cond := range conds {
-			cmpStruct := C.make_struct_arg_cmp(C.uint(cond.Argument), cond.Op.toNative(), C.uint64_t(cond.Operand1), C.uint64_t(cond.Operand2))
-			defer C.free(cmpStruct)
+		argsArr := C.make_arg_cmp_array(C.uint(len(conds)))
+		if argsArr == nil {
+			return fmt.Errorf(""error allocating memory for conditions"")
+		}
+		defer C.free(argsArr)
+
+		for i, cond := range conds {
+			C.add_struct_arg_cmp(C.scmp_cast_t(argsArr), C.uint(i),
+				C.uint(cond.Argument), cond.Op.toNative(),
+				C.uint64_t(cond.Operand1), C.uint64_t(cond.Operand2))
+		}
 
-			if err := f.addRuleWrapper(call, action, exact, C.scmp_cast_t(cmpStruct)); err != nil {
-				return err
-			}
+		if err := f.addRuleWrapper(call, action, exact, C.uint(len(conds)), C.scmp_cast_t(argsArr)); err != nil {
+			return err
 		}
 	}
 
"
GO-2021-0059,tidwall,gjson,f0ee9ebde4b619767ae4ac03e8e42addb530f6bc," func squash(json string) string {
 					}
 				}
 				if depth == 0 {
+					if i >= len(json) {
+						return json
+					}
 					return json[:i+1]
 				}
 			case '{', '[', '(':
"
GO-2022-0444,theupdateframework,go-tuf,ed6788e710fc3093a7ecc2d078bf734c0f200d8d," func (c *Client) Update() (data.TargetFiles, error) {
 		return nil, err
 	}
 
-	// Get timestamp.json, extract snapshot.json file meta and save the
-	// timestamp.json locally
+	// Load trusted metadata files, if any, and verify them against the latest root
+	c.getLocalMeta()
+
+	// 5.4.1 - Download the timestamp metadata
 	timestampJSON, err := c.downloadMetaUnsafe(""timestamp.json"", defaultTimestampDownloadLimit)
 	if err != nil {
 		return nil, err
 	}
+	// 5.4.(2,3 and 4) - Verify timestamp against various attacks
+	// Returns the extracted snapshot metadata
 	snapshotMeta, err := c.decodeTimestamp(timestampJSON)
 	if err != nil {
 		return nil, err
 	}
+	// 5.4.5 - Persist the timestamp metadata
 	if err := c.local.SetMeta(""timestamp.json"", timestampJSON); err != nil {
 		return nil, err
 	}
 
-	// Get snapshot.json, then extract file metas.
-	// root.json meta should not be stored in the snapshot, if it is,
-	// the root will be checked, re-downloaded
+	// 5.5.1 - Download snapshot metadata
+	// 5.5.2 and 5.5.4 - Check against timestamp role's snapshot hash and version
 	snapshotJSON, err := c.downloadMetaFromTimestamp(""snapshot.json"", snapshotMeta)
 	if err != nil {
 		return nil, err
 	}
+	// 5.5.(3,5 and 6) - Verify snapshot against various attacks
+	// Returns the extracted metadata files
 	snapshotMetas, err := c.decodeSnapshot(snapshotJSON)
 	if err != nil {
 		return nil, err
 	}
-
-	// Save the snapshot.json
+	// 5.5.7 - Persist snapshot metadata
 	if err := c.local.SetMeta(""snapshot.json"", snapshotJSON); err != nil {
 		return nil, err
 	}
"
GO-2022-0444,theupdateframework,go-tuf,ed6788e710fc3093a7ecc2d078bf734c0f200d8d," func (c *Client) Update() (data.TargetFiles, error) {
 	var updatedTargets data.TargetFiles
 	targetsMeta := snapshotMetas[""targets.json""]
 	if !c.hasMetaFromSnapshot(""targets.json"", targetsMeta) {
+		// 5.6.1 - Download the top-level targets metadata file
+		// 5.6.2 and 5.6.4 - Check against snapshot role's targets hash and version
 		targetsJSON, err := c.downloadMetaFromSnapshot(""targets.json"", targetsMeta)
 		if err != nil {
 			return nil, err
 		}
+		// 5.6.(3 and 5) - Verify signatures and check against freeze attack
 		updatedTargets, err = c.decodeTargets(targetsJSON)
 		if err != nil {
 			return nil, err
 		}
+		// 5.6.6 - Persist targets metadata
 		if err := c.local.SetMeta(""targets.json"", targetsJSON); err != nil {
 			return nil, err
 		}
"
GO-2022-0444,theupdateframework,go-tuf,ed6788e710fc3093a7ecc2d078bf734c0f200d8d," func (c *Client) downloadMetaFromSnapshot(name string, m data.SnapshotFileMeta)
 	if err != nil {
 		return nil, err
 	}
+	// 5.6.2 and 5.6.4 - Check against snapshot role's targets hash and version
 	if err := util.SnapshotFileMetaEqual(meta, m); err != nil {
 		return nil, ErrDownloadFailed{name, err}
 	}
"
GO-2022-0444,theupdateframework,go-tuf,ed6788e710fc3093a7ecc2d078bf734c0f200d8d," func (c *Client) downloadMetaFromTimestamp(name string, m data.TimestampFileMeta
 	if err != nil {
 		return nil, err
 	}
+	// 5.5.2 and 5.5.4 - Check against timestamp role's snapshot hash and version
 	if err := util.TimestampFileMetaEqual(meta, m); err != nil {
 		return nil, ErrDownloadFailed{name, err}
 	}
"
GO-2022-0444,theupdateframework,go-tuf,ed6788e710fc3093a7ecc2d078bf734c0f200d8d," func (c *Client) decodeSnapshot(b json.RawMessage) (data.SnapshotFiles, error) {
 // returns updated targets.
 func (c *Client) decodeTargets(b json.RawMessage) (data.TargetFiles, error) {
 	targets := &data.Targets{}
+	// 5.6.(3 and 5) - Verify signatures and check against freeze attack
 	if err := c.db.Unmarshal(b, targets, ""targets"", c.targetsVer); err != nil {
 		return nil, ErrDecodeFailed{""targets.json"", err}
 	}
+	// Generate a list with the updated targets
 	updatedTargets := make(data.TargetFiles)
 	for path, meta := range targets.Targets {
 		if local, ok := c.targets[path]; ok {
"
GO-2022-0444,theupdateframework,go-tuf,ed6788e710fc3093a7ecc2d078bf734c0f200d8d," func (c *Client) decodeTargets(b json.RawMessage) (data.TargetFiles, error) {
 		}
 		updatedTargets[path] = meta
 	}
-	c.targetsVer = targets.Version
+	// c.targetsVer was already updated when we verified the snapshot metadata
 	// FIXME(TUF-0.9) temporarily support files with leading path separators.
 	// c.targets = targets.Targets
 	c.loadTargets(targets.Targets)
"
GO-2022-0444,theupdateframework,go-tuf,ed6788e710fc3093a7ecc2d078bf734c0f200d8d," func (c *Client) decodeTimestamp(b json.RawMessage) (data.TimestampFileMeta, err
 	if err := c.db.Unmarshal(b, timestamp, ""timestamp"", c.timestampVer); err != nil {
 		return data.TimestampFileMeta{}, ErrDecodeFailed{""timestamp.json"", err}
 	}
+	// 5.4.3.2 - Check for snapshot rollback attack
+	// Verify that the current snapshot meta version is less than or equal to the new one
+	if timestamp.Meta[""snapshot.json""].Version < c.snapshotVer {
+		return data.TimestampFileMeta{}, verify.ErrLowVersion{Actual: timestamp.Meta[""snapshot.json""].Version, Current: c.snapshotVer}
+	}
+	// At this point we can trust the new timestamp and the snaphost version it refers to
+	// so we can update the client's trusted versions and proceed with persisting the new timestamp
 	c.timestampVer = timestamp.Version
+	c.snapshotVer = timestamp.Meta[""snapshot.json""].Version
 	return timestamp.Meta[""snapshot.json""], nil
 }
 
"
GO-2022-0444,theupdateframework,go-tuf,ed6788e710fc3093a7ecc2d078bf734c0f200d8d," func TargetFileMetaEqual(actual data.TargetFileMeta, expected data.TargetFileMet
 }
 
 func TimestampFileMetaEqual(actual data.TimestampFileMeta, expected data.TimestampFileMeta) error {
-	// As opposed to snapshots, the length and hashes are still required in
-	// TUF-1.0. See:
-	// https://github.com/theupdateframework/specification/issues/38
-	if err := FileMetaEqual(actual.FileMeta, expected.FileMeta); err != nil {
-		return err
+	// TUF no longer considers the length and hashes to be a required
+	// member of Timestamp.
+	if expected.Length != 0 && actual.Length != expected.Length {
+		return ErrWrongLength{expected.Length, actual.Length}
 	}
-
+	// 5.5.2 - Check against timestamp role's snapshot hash
+	if len(expected.Hashes) != 0 {
+		if err := hashEqual(actual.Hashes, expected.Hashes); err != nil {
+			return err
+		}
+	}
+	// 5.5.4 - Check against timestamp role's snapshot version
 	if err := versionEqual(actual.Version, expected.Version); err != nil {
 		return err
 	}
"
GO-2020-0045,dinever,golf,3776f338be48b5bc5e8cf9faff7851fc52a3f1fe,"
 package golf
 
 import (
+	""crypto/rand""
 	""encoding/hex""
-	""math/rand""
-	""time""
 )
 
 const chars = ""abcdefghijklmnopqrstuvwxyz0123456789""
 
 func randomBytes(strlen int) []byte {
-	rand.Seed(time.Now().UTC().UnixNano())
-	result := make([]byte, strlen)
-	for i := 0; i < strlen; i++ {
-		result[i] = chars[rand.Intn(len(chars))]
+	b := make([]byte, strlen)
+	_, err := rand.Read(b)
+	if err != nil {
+		// panic on failure since this indicates a failure of the system's
+		// CSPRNG
+		panic(err)
 	}
-	return result
+	return b
 }
 
 func decodeXSRFToken(maskedToken string) ([]byte, []byte, error) {
"
GO-2020-0033,go-aah,aah,881dc9f71d1f7a4e8a9a39df9c5c081d3a2da1ec," func (e *HTTPEngine) Handle(w http.ResponseWriter, r *http.Request) {
 		defer e.a.accessLog.Log(ctx)
 	}
 
+	// Path Clean
+	r.URL.Path = path.Clean(r.URL.Path)
+
 	ctx.Req, ctx.Res = ahttp.AcquireRequest(r), ahttp.AcquireResponseWriter(w)
 
 	// Recovery handling
"
GO-2023-1923,mastercactapus,proxyprotocol,5c4a101121fc3e868026189c7a73f7f19eef90ac," func parseV2(r *bufio.Reader) (*HeaderV2, error) {
 	}
 
 	// highest 4 indicate address family
-	if (rawHdr.FamProto >> 4) > 3 {
+	switch rawHdr.FamProto >> 4 {
+	case 0: // local
+		if rawHdr.Len != 0 {
+			return nil, &InvalidHeaderErr{Read: buf[:16], error: errors.New(""invalid length"")}
+		}
+	case 1: // ipv4
+		if rawHdr.Len != 12 {
+			return nil, &InvalidHeaderErr{Read: buf[:16], error: errors.New(""invalid length"")}
+		}
+	case 2: // ipv6
+		if rawHdr.Len != 36 {
+			return nil, &InvalidHeaderErr{Read: buf[:16], error: errors.New(""invalid length"")}
+		}
+	case 3: // unix
+		if rawHdr.Len != 216 {
+			return nil, &InvalidHeaderErr{Read: buf[:16], error: errors.New(""invalid length"")}
+		}
+	default:
 		return nil, &InvalidHeaderErr{Read: buf[:16], error: errors.New(""invalid v2 address family"")}
 	}
 
"
GO-2023-1923,mastercactapus,proxyprotocol,5c4a101121fc3e868026189c7a73f7f19eef90ac," func parseV2(r *bufio.Reader) (*HeaderV2, error) {
 		return nil, &InvalidHeaderErr{Read: buf[:16], error: errors.New(""invalid v2 transport protocol"")}
 	}
 
-	if 16+int(rawHdr.Len) > len(buf) {
-		newBuf := make([]byte, 16+int(rawHdr.Len))
-		copy(newBuf, buf[:16])
-		buf = newBuf
-	} else {
-		buf = buf[:16+int(rawHdr.Len)]
-	}
+	buf = buf[:16+int(rawHdr.Len)]
 
 	n, err = io.ReadFull(r, buf[16:])
 	if err != nil {
"
GO-2023-1640,dablelv,go-huge-util,0e308b0fac8973e6fa251b0ab095cdc5c1c0956b," func Unzip(zipPath, dstDir string) error {
 }
 
 func unzipFile(file *zip.File, dstDir string) error {
-	// create the directory of file
-	filePath := path.Join(dstDir, file.Name)
+	// Prevent path traversal vulnerability.
+	// Such as if the file name is ""../../../path/to/file.txt"" which will be cleaned to ""path/to/file.txt"".
+	name := strings.TrimPrefix(filepath.Join(string(filepath.Separator), file.Name), string(filepath.Separator))
+	filePath := path.Join(dstDir, name)
+
+	// Create the directory of file.
 	if file.FileInfo().IsDir() {
 		if err := os.MkdirAll(filePath, os.ModePerm); err != nil {
 			return err
"
GO-2023-1640,dablelv,go-huge-util,0e308b0fac8973e6fa251b0ab095cdc5c1c0956b," func unzipFile(file *zip.File, dstDir string) error {
 		return err
 	}
 
-	// open the file
+	// Open the file.
 	r, err := file.Open()
 	if err != nil {
 		return err
 	}
 	defer r.Close()
 
-	// create the file
+	// Create the file.
 	w, err := os.Create(filePath)
 	if err != nil {
 		return err
 	}
 	defer w.Close()
 
-	// save the decompressed file content
+	// Save the decompressed file content.
 	_, err = io.Copy(w, r)
 	return err
 }
"
GO-2021-0057,buger,jsonparser,df3ea76ece10095374fd1c9a22a4fb85a44efc42," func searchKeys(data []byte, keys ...string) int {
 		case '[':
 			// If we want to get array element by index
 			if keyLevel == level && keys[level][0] == '[' {
-				aIdx, err := strconv.Atoi(keys[level][1 : len(keys[level])-1])
+				var keyLen = len(keys[level])
+				if keyLen < 3 || keys[level][0] != '[' || keys[level][keyLen-1] != ']' {
+					return -1
+				}
+				aIdx, err := strconv.Atoi(keys[level][1 : keyLen-1])
 				if err != nil {
 					return -1
 				}
"
GO-2023-1578,hashicorp,go-getter,78e6721a2a76266718dc92c3c03c1571dffdefdc," import (
 
 // untar is a shared helper for untarring an archive. The reader should provide
 // an uncompressed view of the tar archive.
-func untar(input io.Reader, dst, src string, dir bool, umask os.FileMode) error {
+func untar(input io.Reader, dst, src string, dir bool, umask os.FileMode, fileSizeLimit int64, filesLimit int) error {
 	tarR := tar.NewReader(input)
 	done := false
 	dirHdrs := []*tar.Header{}
 	now := time.Now()
+
+	var (
+		fileSize   int64
+		filesCount int
+	)
+
 	for {
+		if filesLimit > 0 {
+			filesCount++
+			if filesCount > filesLimit {
+				return fmt.Errorf(""tar archive contains too many files: %d > %d"", filesCount, filesLimit)
+			}
+		}
+
 		hdr, err := tarR.Next()
 		if err == io.EOF {
 			if !done {
"
GO-2023-1578,hashicorp,go-getter,78e6721a2a76266718dc92c3c03c1571dffdefdc," func untar(input io.Reader, dst, src string, dir bool, umask os.FileMode) error
 			path = filepath.Join(path, hdr.Name)
 		}
 
-		if hdr.FileInfo().IsDir() {
+		fileInfo := hdr.FileInfo()
+
+		fileSize += fileInfo.Size()
+
+		if fileSizeLimit > 0 && fileSize > fileSizeLimit {
+			return fmt.Errorf(""tar archive larger than limit: %d"", fileSizeLimit)
+		}
+
+		if fileInfo.IsDir() {
 			if !dir {
 				return fmt.Errorf(""expected a single file: %s"", src)
 			}
"
GO-2023-1578,hashicorp,go-getter,78e6721a2a76266718dc92c3c03c1571dffdefdc," func untar(input io.Reader, dst, src string, dir bool, umask os.FileMode) error
 		// Mark that we're done so future in single file mode errors
 		done = true
 
-		// Open the file for writing
-		err = copyReader(path, tarR, hdr.FileInfo().Mode(), umask)
+		// Size limit is tracked using the returned file info.
+		err = copyReader(path, tarR, hdr.FileInfo().Mode(), umask, 0)
 		if err != nil {
 			return err
 		}
"
GO-2023-1578,hashicorp,go-getter,78e6721a2a76266718dc92c3c03c1571dffdefdc," func (d *ZipDecompressor) Decompress(dst, src string, dir bool, umask os.FileMod
 		return fmt.Errorf(""expected a single file: %s"", src)
 	}
 
+	if d.FilesLimit > 0 && len(zipR.File) > d.FilesLimit {
+		return fmt.Errorf(""zip archive contains too many files: %d > %d"", len(zipR.File), d.FilesLimit)
+	}
+
+	var fileSizeTotal int64
+
 	// Go through and unarchive
 	for _, f := range zipR.File {
 		path := dst
"
GO-2023-1578,hashicorp,go-getter,78e6721a2a76266718dc92c3c03c1571dffdefdc," func (d *ZipDecompressor) Decompress(dst, src string, dir bool, umask os.FileMod
 			path = filepath.Join(path, f.Name)
 		}
 
-		if f.FileInfo().IsDir() {
+		fileInfo := f.FileInfo()
+
+		fileSizeTotal += fileInfo.Size()
+
+		if d.FileSizeLimit > 0 && fileSizeTotal > d.FileSizeLimit {
+			return fmt.Errorf(""zip archive larger than limit: %d"", d.FileSizeLimit)
+		}
+
+		if fileInfo.IsDir() {
 			if !dir {
 				return fmt.Errorf(""expected a single file: %s"", src)
 			}
"
GO-2023-1578,hashicorp,go-getter,78e6721a2a76266718dc92c3c03c1571dffdefdc," func (d *ZipDecompressor) Decompress(dst, src string, dir bool, umask os.FileMod
 			return err
 		}
 
-		err = copyReader(path, srcF, f.Mode(), umask)
+		// Size limit is tracked using the returned file info.
+		err = copyReader(path, srcF, f.Mode(), umask, 0)
 		srcF.Close()
 		if err != nil {
 			return err
"
GO-2023-1578,hashicorp,go-getter,78e6721a2a76266718dc92c3c03c1571dffdefdc," func Copy(ctx context.Context, dst io.Writer, src io.Reader) (int64, error) {
 }
 
 // copyReader copies from an io.Reader into a file, using umask to create the dst file
-func copyReader(dst string, src io.Reader, fmode, umask os.FileMode) error {
+func copyReader(dst string, src io.Reader, fmode, umask os.FileMode, fileSizeLimit int64) error {
 	dstF, err := os.OpenFile(dst, os.O_RDWR|os.O_CREATE|os.O_TRUNC, fmode)
 	if err != nil {
 		return err
 	}
 	defer dstF.Close()
 
+	if fileSizeLimit > 0 {
+		src = io.LimitReader(src, fileSizeLimit)
+	}
+
 	_, err = io.Copy(dstF, src)
 	if err != nil {
 		return err
"
GO-2021-0061,go-yaml,yaml,bb4e33bf68bf89cad44d386192cbed201f35b241," func (d *decoder) prepare(n *node, out reflect.Value) (newout reflect.Value, unm
 }
 
 func (d *decoder) unmarshal(n *node, out reflect.Value) (good bool) {
+	d.decodeCount++
+	if d.aliasDepth > 0 {
+		d.aliasCount++
+	}
+	if d.aliasCount > 100 && d.decodeCount > 1000 && float64(d.aliasCount)/float64(d.decodeCount) > 0.99 {
+		failf(""document contains excessive aliasing"")
+	}
 	switch n.kind {
 	case documentNode:
 		return d.document(n, out)
"
GO-2020-0026,openshift,source-to-image,f5cbcbc5cc6f8cc2f479a7302443bea407a700cb," func New(client dockerpkg.Client, config *api.Config, fs fs.FileSystem, override
 		config.PullAuthentication,
 		fs,
 	)
-	tarHandler := tar.New(fs)
+	tarHandler := tar.NewParanoid(fs)
 	tarHandler.SetExclusionPattern(excludePattern)
 
 	builder := &STI{
"
GO-2020-0026,openshift,source-to-image,f5cbcbc5cc6f8cc2f479a7302443bea407a700cb," func (t *stiTar) ExtractTarStreamFromTarReader(dir string, tarReader Reader, log
 				glog.Errorf(""Error reading next tar header: %v"", err)
 				return err
 			}
+
+			if t.disallowSpecialFiles {
+				switch header.Typeflag {
+				case tar.TypeReg, tar.TypeRegA, tar.TypeLink, tar.TypeSymlink, tar.TypeDir, tar.TypeGNUSparse:
+				default:
+					glog.Warningf(""Skipping special file %s, type: %v"", header.Name, header.Typeflag)
+					continue
+				}
+			}
+
+			p := header.Name
+			if t.disallowOutsidePaths {
+				p = filepath.Clean(filepath.Join(dir, p))
+				if !strings.HasPrefix(p, dir) {
+					glog.Warningf(""Skipping relative path file in tar: %s"", header.Name)
+					continue
+				}
+			}
+
 			if header.FileInfo().IsDir() {
-				dirPath := filepath.Join(dir, header.Name)
+				dirPath := filepath.Join(dir, filepath.Clean(header.Name))
 				glog.V(3).Infof(""Creating directory %s"", dirPath)
 				if err = os.MkdirAll(dirPath, 0700); err != nil {
 					glog.Errorf(""Error creating dir %q: %v"", dirPath, err)
"
GO-2020-0026,openshift,source-to-image,f5cbcbc5cc6f8cc2f479a7302443bea407a700cb," func (t *stiTar) ExtractTarStreamFromTarReader(dir string, tarReader Reader, log
 				t.Chmod(dirPath, header.FileInfo().Mode())
 			} else {
 				fileDir := filepath.Dir(header.Name)
-				dirPath := filepath.Join(dir, fileDir)
+				dirPath := filepath.Join(dir, filepath.Clean(fileDir))
 				glog.V(3).Infof(""Creating directory %s"", dirPath)
 				if err = os.MkdirAll(dirPath, 0700); err != nil {
 					glog.Errorf(""Error creating dir %q: %v"", dirPath, err)
"
GO-2020-0026,openshift,source-to-image,f5cbcbc5cc6f8cc2f479a7302443bea407a700cb," func (t *stiTar) extractLink(dir string, header *tar.Header, tarReader io.Reader
 	dest := filepath.Join(dir, header.Name)
 	source := header.Linkname
 
+	if t.disallowOutsidePaths {
+		target := filepath.Clean(filepath.Join(dest, "".."", source))
+		if !strings.HasPrefix(target, dir) {
+			glog.Warningf(""Skipping symlink that points to relative path: %s"", header.Linkname)
+			return nil
+		}
+	}
+
+	if t.disallowOverwrite {
+		if _, err := os.Stat(dest); !os.IsNotExist(err) {
+			glog.Warningf(""Refusing to overwrite existing file: %s"", dest)
+			return nil
+		}
+	}
+
 	glog.V(3).Infof(""Creating symbolic link from %q to %q"", dest, source)
 
 	// TODO: set mtime for symlink (unfortunately we can't use os.Chtimes() and probably should use syscall)
"
GO-2023-1535,pion,dtls,7a14903448b70069fd9e02adf210ca23083c56d2," func (m *MessageServerHello) Unmarshal(data []byte) error {
 	m.SessionID = append([]byte{}, data[currOffset:currOffset+n]...)
 	currOffset += len(m.SessionID)
 
+	if len(data) < currOffset+2 {
+		return errBufferTooSmall
+	}
 	m.CipherSuiteID = new(uint16)
 	*m.CipherSuiteID = binary.BigEndian.Uint16(data[currOffset:])
 	currOffset += 2
 
-	if len(data) < currOffset {
+	if len(data) <= currOffset {
 		return errBufferTooSmall
 	}
 	if compressionMethod, ok := protocol.CompressionMethods()[protocol.CompressionMethodID(data[currOffset])]; ok {
"
GO-2020-0004,nanobox-io,golang-nanoauth,063a3fb69896acf985759f0fe3851f15973993f3," func init() {
 
 // ServeHTTP is to implement the http.Handler interface. Also let clients know
 // when I have no matching route listeners
-func (self Auth) ServeHTTP(rw http.ResponseWriter, req *http.Request) {
+func (self *Auth) ServeHTTP(rw http.ResponseWriter, req *http.Request) {
 	reqPath := req.URL.Path
 	skipOnce := false
 
"
GO-2020-0004,nanobox-io,golang-nanoauth,063a3fb69896acf985759f0fe3851f15973993f3," func (self Auth) ServeHTTP(rw http.ResponseWriter, req *http.Request) {
 		skipOnce = true
 	}
 
-	if !skipOnce && check {
+	if !skipOnce {
 		auth := """"
 		if auth = req.Header.Get(self.Header); auth == """" {
 			// check form value (case sensitive) if header not set
 			auth = req.FormValue(self.Header)
 		}
 
-		if auth != self.Token {
+		if subtle.ConstantTimeCompare([]byte(auth), []byte(self.Token)) == 0 {
 			rw.WriteHeader(http.StatusUnauthorized)
 			return
 		}
"
GO-2020-0004,nanobox-io,golang-nanoauth,063a3fb69896acf985759f0fe3851f15973993f3," func (self Auth) ServeHTTP(rw http.ResponseWriter, req *http.Request) {
 
 // ListenAndServeTLS starts a TLS listener and handles serving https
 func (self *Auth) ListenAndServeTLS(addr, token string, h http.Handler, excludedPaths ...string) error {
+	if token == """" {
+		return errors.New(""nanoauth: token missing"")
+	}
 	config := &tls.Config{
 		Certificates: []tls.Certificate{*self.Certificate},
 	}
"
GO-2020-0004,nanobox-io,golang-nanoauth,063a3fb69896acf985759f0fe3851f15973993f3," func (self *Auth) ListenAndServeTLS(addr, token string, h http.Handler, excluded
 // ListenAndServe starts a normal tcp listener and handles serving http while
 // still validating the auth token.
 func (self *Auth) ListenAndServe(addr, token string, h http.Handler, excludedPaths ...string) error {
+	if token == """" {
+		return errors.New(""nanoauth: token missing"")
+	}
 	httpListener, err := net.Listen(""tcp"", addr)
 	if err != nil {
 		return err
 	}
 
-	if token == """" {
-		check = false
-	}
 	self.ExcludedPaths = excludedPaths
 	self.Token = token
 
"
GO-2020-0004,nanobox-io,golang-nanoauth,063a3fb69896acf985759f0fe3851f15973993f3," func (self *Auth) ListenAndServeTLS(addr, token string, h http.Handler, excluded
 		return err
 	}
 
-	if token == """" {
-		check = false
-	}
 	self.ExcludedPaths = excludedPaths
 	self.Token = token
 
"
GO-2021-0108,gofiber,fiber,f698b5d5066cfe594102ae252cd58a1fe57cf56f," func (ctx *Ctx) Attachment(filename ...string) {
 	if len(filename) > 0 {
 		fname := filepath.Base(filename[0])
 		ctx.Type(filepath.Ext(fname))
-		ctx.Set(HeaderContentDisposition, `attachment; filename=""`+fname+`""`)
+		ctx.Set(HeaderContentDisposition, `attachment; filename=""`+url.QueryEscape(fname)+`""`)
 		return
 	}
 	ctx.Set(HeaderContentDisposition, ""attachment"")
"
GO-2023-1595,FiloSottile,nistec,c58aa1223ccf3943513e1e661cebce95af137244," func (r *P256Point) ScalarBaseMult(scalar []byte) (*P256Point, error) {
 	}
 	scalarReversed := new(p256OrdElement)
 	p256OrdBigToLittle(scalarReversed, (*[32]byte)(scalar))
+	p256OrdReduce(scalarReversed)
 
 	r.p256BaseMult(scalarReversed)
 	return r, nil
"
GO-2023-1595,FiloSottile,nistec,c58aa1223ccf3943513e1e661cebce95af137244," func (r *P256Point) ScalarMult(q *P256Point, scalar []byte) (*P256Point, error)
 	}
 	scalarReversed := new(p256OrdElement)
 	p256OrdBigToLittle(scalarReversed, (*[32]byte)(scalar))
+	p256OrdReduce(scalarReversed)
 
 	r.Set(q).p256ScalarMult(scalarReversed)
 	return r, nil
"
GO-2023-1595,FiloSottile,nistec,c58aa1223ccf3943513e1e661cebce95af137244," func p256OrdInverse(k []byte) ([]byte, error) {
 
 	x := new(p256OrdElement)
 	p256OrdBigToLittle(x, (*[32]byte)(k))
+	p256OrdReduce(x)
 
 	// Inversion is implemented as exponentiation by n - 2, per Fermat's little theorem.
 	//
"
GO-2021-0102,cloudfoundry,gorouter,b1b5c44e050f73b399b379ca63a42a2c5780a83f," func (gcm *AesGCM) Encrypt(plainText []byte) (cipherText, nonce []byte, err erro
 }
 
 func (gcm *AesGCM) Decrypt(cipherText, nonce []byte) ([]byte, error) {
+	if len(nonce) != gcm.NonceSize() {
+		return nil, errors.New(""incorrect nonce length"")
+	}
+
 	plainText, err := gcm.Open(nil, nonce, cipherText, []byte{})
 	if err != nil {
 		return nil, err
"
GO-2022-1040,helm,helm,6ce9ba60b73013857e2e7c73d3f86ed70bc1ac9a," type Metadata struct {
 	Type string `json:""type,omitempty""`
 }
 
-// Validate checks the metadata for known issues, returning an error if metadata is not correct
+// Validate checks the metadata for known issues and sanitizes string
+// characters.
 func (md *Metadata) Validate() error {
 	if md == nil {
 		return ValidationError(""chart.metadata is required"")
 	}
+
+	md.Name = sanitizeString(md.Name)
+	md.Description = sanitizeString(md.Description)
+	md.Home = sanitizeString(md.Home)
+	md.Icon = sanitizeString(md.Icon)
+	md.Condition = sanitizeString(md.Condition)
+	md.Tags = sanitizeString(md.Tags)
+	md.AppVersion = sanitizeString(md.AppVersion)
+	md.KubeVersion = sanitizeString(md.KubeVersion)
+	for i := range md.Sources {
+		md.Sources[i] = sanitizeString(md.Sources[i])
+	}
+	for i := range md.Keywords {
+		md.Keywords[i] = sanitizeString(md.Keywords[i])
+	}
+
 	if md.APIVersion == """" {
 		return ValidationError(""chart.metadata.apiVersion is required"")
 	}
"
GO-2022-1040,helm,helm,6ce9ba60b73013857e2e7c73d3f86ed70bc1ac9a," func (md *Metadata) Validate() error {
 	if md.Version == """" {
 		return ValidationError(""chart.metadata.version is required"")
 	}
+	if !isValidSemver(md.Version) {
+		return ValidationErrorf(""chart.metadata.version %q is invalid"", md.Version)
+	}
 	if !isValidChartType(md.Type) {
 		return ValidationError(""chart.metadata.type must be application or library"")
 	}
 
+	for _, m := range md.Maintainers {
+		if err := m.Validate(); err != nil {
+			return err
+		}
+	}
+
 	// Aliases need to be validated here to make sure that the alias name does
 	// not contain any illegal characters.
 	for _, dependency := range md.Dependencies {
-		if err := validateDependency(dependency); err != nil {
+		if err := dependency.Validate(); err != nil {
 			return err
 		}
 	}
-
-	// TODO validate valid semver here?
 	return nil
 }
 
"
GO-2023-2098,Consensys,gnark,59a4087261a6c73f13e80d695c17b398c3d0934f," func (builder *builder) IsZero(i1 frontend.Variable) frontend.Variable {
 // Cmp returns 1 if i1>i2, 0 if i1=i2, -1 if i1<i2
 func (builder *builder) Cmp(i1, i2 frontend.Variable) frontend.Variable {
 
-	vars, _ := builder.toVariables(i1, i2)
-	bi1 := builder.ToBinary(vars[0], builder.cs.FieldBitLen())
-	bi2 := builder.ToBinary(vars[1], builder.cs.FieldBitLen())
+	nbBits := builder.cs.FieldBitLen()
+	// in AssertIsLessOrEq we omitted comparison against modulus for the left
+	// side as if `a+r<b` implies `a<b`, then here we compute the inequality
+	// directly.
+	bi1 := bits.ToBinary(builder, i1, bits.WithNbDigits(nbBits))
+	bi2 := bits.ToBinary(builder, i2, bits.WithNbDigits(nbBits))
 
 	res := builder.cstZero()
 
"
GO-2023-2098,Consensys,gnark,59a4087261a6c73f13e80d695c17b398c3d0934f," func (builder *builder) AssertIsLessOrEqual(v frontend.Variable, bound frontend.
 		}
 	}
 
+	nbBits := builder.cs.FieldBitLen()
+	vBits := bits.ToBinary(builder, v, bits.WithNbDigits(nbBits), bits.WithUnconstrainedOutputs())
+
 	// bound is constant
 	if bConst {
-		vv := builder.toVariable(v)
-		builder.mustBeLessOrEqCst(vv, builder.cs.ToBigInt(cb))
+		builder.MustBeLessOrEqCst(vBits, builder.cs.ToBigInt(cb), v)
 		return
 	}
 
"
GO-2023-2098,Consensys,gnark,59a4087261a6c73f13e80d695c17b398c3d0934f," func (builder *builder) mustBeLessOrEqVar(a, bound frontend.Variable) {
 
 	nbBits := builder.cs.FieldBitLen()
 
-	aBits := bits.ToBinary(builder, a, bits.WithNbDigits(nbBits), bits.WithUnconstrainedOutputs())
-	boundBits := builder.ToBinary(bound, nbBits)
+	aBits := bits.ToBinary(builder, a, bits.WithNbDigits(nbBits), bits.WithUnconstrainedOutputs(), bits.OmitModulusCheck())
+	boundBits := bits.ToBinary(builder, bound, bits.WithNbDigits(nbBits))
 
 	// constraint added
 	added := make([]int, 0, nbBits)
"
GO-2023-2098,Consensys,gnark,59a4087261a6c73f13e80d695c17b398c3d0934f," func (builder *builder) IsZero(i1 frontend.Variable) frontend.Variable {
 // Cmp returns 1 if i1>i2, 0 if i1=i2, -1 if i1<i2
 func (builder *builder) Cmp(i1, i2 frontend.Variable) frontend.Variable {
 
-	bi1 := builder.ToBinary(i1, builder.cs.FieldBitLen())
-	bi2 := builder.ToBinary(i2, builder.cs.FieldBitLen())
+	nbBits := builder.cs.FieldBitLen()
+	// in AssertIsLessOrEq we omitted comparison against modulus for the left
+	// side as if `a+r<b` implies `a<b`, then here we compute the inequality
+	// directly.
+	bi1 := bits.ToBinary(builder, i1, bits.WithNbDigits(nbBits))
+	bi2 := bits.ToBinary(builder, i2, bits.WithNbDigits(nbBits))
 
 	var res frontend.Variable
 	res = 0
"
GO-2023-2098,Consensys,gnark,59a4087261a6c73f13e80d695c17b398c3d0934f," func (builder *builder) AssertIsBoolean(i1 frontend.Variable) {
 
 // AssertIsLessOrEqual fails if  v > bound
 func (builder *builder) AssertIsLessOrEqual(v frontend.Variable, bound frontend.Variable) {
-	switch b := bound.(type) {
-	case expr.Term:
+	cv, vConst := builder.constantValue(v)
+	cb, bConst := builder.constantValue(bound)
+
+	// both inputs are constants
+	if vConst && bConst {
+		bv, bb := builder.cs.ToBigInt(cv), builder.cs.ToBigInt(cb)
+		if bv.Cmp(bb) == 1 {
+			panic(fmt.Sprintf(""AssertIsLessOrEqual: %s > %s"", bv.String(), bb.String()))
+		}
+	}
+
+	nbBits := builder.cs.FieldBitLen()
+	vBits := bits.ToBinary(builder, v, bits.WithNbDigits(nbBits), bits.WithUnconstrainedOutputs())
+
+	// bound is constant
+	if bConst {
+		builder.MustBeLessOrEqCst(vBits, builder.cs.ToBigInt(cb), v)
+		return
+	}
+
+	if b, ok := bound.(expr.Term); ok {
 		builder.mustBeLessOrEqVar(v, b)
-	default:
-		builder.mustBeLessOrEqCst(v, utils.FromInterface(b))
+	} else {
+		panic(fmt.Sprintf(""expected bound type expr.Term, got %T"", bound))
 	}
 }
 
"
GO-2023-2098,Consensys,gnark,59a4087261a6c73f13e80d695c17b398c3d0934f," func (builder *builder) mustBeLessOrEqVar(a frontend.Variable, bound expr.Term)
 
 	nbBits := builder.cs.FieldBitLen()
 
-	aBits := bits.ToBinary(builder, a, bits.WithNbDigits(nbBits), bits.WithUnconstrainedOutputs())
-	boundBits := builder.ToBinary(bound, nbBits)
+	aBits := bits.ToBinary(builder, a, bits.WithNbDigits(nbBits), bits.WithUnconstrainedOutputs(), bits.OmitModulusCheck())
+	boundBits := bits.ToBinary(builder, bound, bits.WithNbDigits(nbBits)) // enforces range check against modulus
 
 	p := make([]frontend.Variable, nbBits+1)
 	p[nbBits] = 1
"
GO-2023-2098,Consensys,gnark,59a4087261a6c73f13e80d695c17b398c3d0934f," func (circuit *recursiveHint) Define(api frontend.API) error {
 	// api.ToBinary calls another hint (bits.NBits) with linearExpression as input
 	// however, when the solver will resolve bits[...] it will need to detect w1 as a dependency
 	// in order to compute the correct linearExpression value
-	bits := api.ToBinary(linearExpression, 10)
+	bits := api.ToBinary(linearExpression, 6)
 
 	a := api.FromBinary(bits...)
 
"
GO-2023-2098,Consensys,gnark,59a4087261a6c73f13e80d695c17b398c3d0934f," type baseConversionConfig struct {
 	NbDigits             int
 	UnconstrainedOutputs bool
 	UnconstrainedInputs  bool
+
+	omitModulusCheck bool
 }
 
 // BaseConversionOption configures the behaviour of scalar decomposition.
 type BaseConversionOption func(opt *baseConversionConfig) error
 
-// WithNbDigits sets the resulting number of digits (nbDigits) to be used in the base conversion.
-// nbDigits must be > 0. If nbDigits is lower than the length of full decomposition and
-// WithUnconstrainedOutputs option is not used, then the conversion functions will generate an
-// unsatisfiable constraint. If WithNbDigits option is not set, then the full decomposition is
-// returned.
+// WithNbDigits sets the resulting number of digits (nbDigits) to be used in the
+// base conversion.
+//
+// nbDigits must be > 0. If nbDigits is lower than the length of full
+// decomposition and [WithUnconstrainedOutputs] option is not used, then the
+// conversion functions will generate an unsatisfiable constraint.
+//
+// If nbDigits is larger than the bitlength of the modulus, then the returned
+// slice has length nbDigits with excess bits being 0.
+//
+// If WithNbDigits option is not set, then the full decomposition is returned.
 func WithNbDigits(nbDigits int) BaseConversionOption {
 	return func(opt *baseConversionConfig) error {
 		if nbDigits <= 0 {
"
GO-2021-0060,russellhaering,gosaml2,42606dafba60c58c458f14f75c4c230459672ab9," func maybeDeflate(data []byte, decoder func([]byte) error) error {
 // parseResponse is a helper function that was refactored out so that the XML parsing behavior can be isolated and unit tested
 func parseResponse(xml []byte) (*etree.Document, *etree.Element, error) {
 	var doc *etree.Document
+	var rawXML []byte
 
 	err := maybeDeflate(xml, func(xml []byte) error {
 		doc = etree.NewDocument()
+		rawXML = xml
 		return doc.ReadFromBytes(xml)
 	})
 	if err != nil {
"
GO-2021-0060,russellhaering,gosaml2,42606dafba60c58c458f14f75c4c230459672ab9," func parseResponse(xml []byte) (*etree.Document, *etree.Element, error) {
 		return nil, nil, fmt.Errorf(""unable to parse response"")
 	}
 
+	// Examine the response for attempts to exploit weaknesses in Go's encoding/xml
+	err = rtvalidator.Validate(bytes.NewReader(rawXML))
+	if err != nil {
+		return nil, nil, err
+	}
+
 	return doc, el, nil
 }
 
"
GO-2022-0345,containers,buildah,a468ce0ffd347035d53ee0e26c205ef604097fb0," func RunUsingChroot(spec *specs.Spec, bundlePath, homeDir string, stdin io.Reade
 	cmd := unshare.Command(runUsingChrootCommand)
 	cmd.Stdin, cmd.Stdout, cmd.Stderr = stdin, stdout, stderr
 	cmd.Dir = ""/""
-	cmd.Env = append([]string{fmt.Sprintf(""LOGLEVEL=%d"", logrus.GetLevel())}, os.Environ()...)
+	cmd.Env = []string{fmt.Sprintf(""LOGLEVEL=%d"", logrus.GetLevel())}
 
 	logrus.Debugf(""Running %#v in %#v"", cmd.Cmd, cmd)
 	confwg.Add(1)
"
GO-2021-0052,gin-gonic,gin,5929d521715610c9dd14898ebbe1d188d5de8937," func (c *Context) ClientIP() string {
 
 	if trusted && c.engine.ForwardedByClientIP && c.engine.RemoteIPHeaders != nil {
 		for _, headerName := range c.engine.RemoteIPHeaders {
-			ip, valid := validateHeader(c.requestHeader(headerName))
+			ip, valid := c.engine.validateHeader(c.requestHeader(headerName))
 			if valid {
 				return ip
 			}
"
GO-2021-0052,gin-gonic,gin,03e5e05ae089bc989f1ca41841f05504d29e3fd9," func (c *Context) RemoteIP() (net.IP, bool) {
 		return nil, false
 	}
 
-	trustedCIDRs, _ := c.engine.prepareTrustedCIDRs()
-	c.engine.trustedCIDRs = trustedCIDRs
 	if c.engine.trustedCIDRs != nil {
 		for _, cidr := range c.engine.trustedCIDRs {
 			if cidr.Contains(remoteIP) {
"
GO-2022-1175,cortexproject,cortex,03e023d8b012887b31cc268d0d011b01e1e65506," func validateAlertmanagerConfig(cfg interface{}) error {
 			return err
 		}
 
+	case reflect.TypeOf(config.OpsGenieConfig{}):
+		if err := validateOpsGenieConfig(v.Interface().(config.OpsGenieConfig)); err != nil {
+			return err
+		}
+
 	case reflect.TypeOf(commoncfg.TLSConfig{}):
 		if err := validateReceiverTLSConfig(v.Interface().(commoncfg.TLSConfig)); err != nil {
 			return err
"
GO-2021-0097,dhowden,tag,d52dcb253c63a153632bfee5f269dd411dcd8e96," func (t Comm) String() string {
 // Description         <text string according to encoding> $00 (00)
 // Value               <text string according to encoding>
 func readTextWithDescrFrame(b []byte, hasLang bool, encoded bool) (*Comm, error) {
+	if len(b) == 0 {
+		return nil, errors.New(""error decoding tag description text: invalid encoding"")
+	}
 	enc := b[0]
 	b = b[1:]
 
 	c := &Comm{}
 	if hasLang {
 		if len(b) < 3 {
-			return nil, fmt.Errorf(""hasLang set but not enough data for language information"")
+			return nil, errors.New(""hasLang set but not enough data for language information"")
 		}
 		c.Language = string(b[:3])
 		b = b[3:]
 	}
 
 	descTextSplit := dataSplit(b, enc)
-	if len(descTextSplit) < 1 {
-		return nil, fmt.Errorf(""error decoding tag description text: invalid encoding"")
+	if len(descTextSplit) == 0 {
+		return nil, errors.New(""error decoding tag description text: invalid encoding"")
 	}
 
 	desc, err := decodeText(enc, descTextSplit[0])
"
GO-2021-0097,dhowden,tag,a92213460e4838490ce3066ef11dc823cdc1740e," func readPICFrame(b []byte) (*Picture, error) {
 // Description     <text string according to encoding> $00 (00)
 // Picture data    <binary data>
 func readAPICFrame(b []byte) (*Picture, error) {
+	if len(b) == 0 {
+		return nil, errors.New(""error decoding APIC: invalid encoding"")
+	}
 	enc := b[0]
 	mimeDataSplit := bytes.SplitN(b[1:], singleZero, 2)
+	if len(mimeDataSplit) != 2 {
+		return nil, errors.New(""error decoding APIC: invalid encoding"")
+	}
+
 	mimeType := string(mimeDataSplit[0])
 
 	b = mimeDataSplit[1]
"
GO-2021-0097,dhowden,tag,4b595ed4fac79f467594aa92f8953f90f817116e," func (m metadataMP4) readAtomData(r io.ReadSeeker, name string, size uint32, pro
 		// ""data"" + size (4 bytes each)
 		b = b[8:]
 
-		if len(b) < 3 {
-			return fmt.Errorf(""invalid encoding: expected at least %d bytes, for class, got %d"", 3, len(b))
+		if len(b) < 4 {
+			return fmt.Errorf(""invalid encoding: expected at least %d bytes, for class, got %d"", 4, len(b))
 		}
 		class := getInt(b[1:4])
 		var ok bool
"
GO-2021-0097,dhowden,tag,6b18201aa5c5535511802ddfb4e4117686b4866d," func (p Picture) String() string {
 // Description        <textstring> $00 (00)
 // Picture data       <binary data>
 func readPICFrame(b []byte) (*Picture, error) {
+	if len(b) < 5 {
+		return nil, errors.New(""invalid PIC frame"")
+	}
+
 	enc := b[0]
 	ext := string(b[1:4])
 	picType := b[4]
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (s *ImmuStore) DualProof(sourceTxHdr, targetTxHdr *TxHeader) (proof *DualPr
 	}
 	proof.LinearProof = lproof
 
+	laproof, err := s.LinearAdvanceProof(
+		sourceTxHdr.BlTxID,
+		minUint64(sourceTxHdr.ID, targetTxHdr.BlTxID),
+		targetTxHdr.BlTxID,
+	)
+	if err != nil {
+		return nil, err
+	}
+	proof.LinearAdvanceProof = laproof
+
 	return
 }
 
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func VerifyDualProof(proof *DualProof, sourceTxID, targetTxID uint64, sourceAlh,
 	}
 
 	if proof.SourceTxHeader.BlTxID > 0 {
-		verfifies := ahtree.VerifyConsistency(
+		verifies := ahtree.VerifyConsistency(
 			proof.ConsistencyProof,
 			proof.SourceTxHeader.BlTxID,
 			proof.TargetTxHeader.BlTxID,
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func VerifyDualProof(proof *DualProof, sourceTxID, targetTxID uint64, sourceAlh,
 			proof.TargetTxHeader.BlRoot,
 		)
 
-		if !verfifies {
+		if !verifies {
 			return false
 		}
 	}
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func VerifyDualProof(proof *DualProof, sourceTxID, targetTxID uint64, sourceAlh,
 	}
 
 	if sourceTxID < proof.TargetTxHeader.BlTxID {
-		return VerifyLinearProof(proof.LinearProof, proof.TargetTxHeader.BlTxID, targetTxID, proof.TargetBlTxAlh, targetAlh)
+		verifies := VerifyLinearProof(proof.LinearProof, proof.TargetTxHeader.BlTxID, targetTxID, proof.TargetBlTxAlh, targetAlh)
+		if !verifies {
+			return false
+		}
+
+		// Verify that the part of the linear proof consumed by the new merkle tree is consistent with that Merkle Tree
+		// In this case, this is the whole chain to the SourceTxID from the previous Merkle Tree.
+		// The sourceTxID consistency is already proven using proof.InclusionProof
+		if !VerifyLinearAdvanceProof(
+			proof.LinearAdvanceProof,
+			proof.SourceTxHeader.BlTxID,
+			sourceTxID,
+			sourceAlh,
+			proof.TargetTxHeader.BlRoot,
+			proof.TargetTxHeader.BlTxID,
+		) {
+			return false
+		}
+
+	} else {
+
+		verifies := VerifyLinearProof(proof.LinearProof, sourceTxID, targetTxID, sourceAlh, targetAlh)
+		if !verifies {
+			return false
+		}
+
+		// Verify that the part of the linear proof consumed by the new merkle tree is consistent with that Merkle Tree
+		// In this case, this is the whole linear chain between the old Merkle Tree and the new Merkle Tree. The last entry
+		// in the new Merkle Tree is already proven through the LastInclusionProof, the remaining part of the liner proof
+		// that goes outside of the target Merkle Tree will be validated in future DualProof validations
+		if !VerifyLinearAdvanceProof(
+			proof.LinearAdvanceProof,
+			proof.SourceTxHeader.BlTxID,
+			proof.TargetTxHeader.BlTxID,
+			proof.TargetBlTxAlh,
+			proof.TargetTxHeader.BlRoot,
+			proof.TargetTxHeader.BlTxID,
+		) {
+			return false
+		}
 	}
 
-	return VerifyLinearProof(proof.LinearProof, sourceTxID, targetTxID, sourceAlh, targetAlh)
+	return true
 }
 
 func leafFor(d [sha256.Size]byte) [sha256.Size]byte {
"
GO-2022-1117,codenotary,immudb,7267d67e28be8f0257b71d734611a051593e8a81," func (a *defaultAuditor) audit() error {
 			return noErr
 		}
 
+		dualProof := schema.DualProofFromProto(vtx.DualProof)
+		err = schema.FillMissingLinearAdvanceProof(
+			ctx, dualProof, prevState.TxId, state.TxId, a.serviceClient,
+		)
+		if err != nil {
+			a.logger.Errorf(
+				""error fetching consistency proof for previous state %d: %v"",
+				prevState.TxId, err)
+			withError = true
+			return noErr
+		}
+
 		verified = store.VerifyDualProof(
-			schema.DualProofFromProto(vtx.DualProof),
+			dualProof,
 			prevState.TxId,
 			state.TxId,
 			schema.DigestFromProto(prevState.TxHash),
"
GO-2022-1117,codenotary,immudb,7267d67e28be8f0257b71d734611a051593e8a81," func (c *immuClient) verifiedGet(ctx context.Context, kReq *schema.KeyRequest) (
 	}
 
 	if state.TxId > 0 {
-		verifies = store.VerifyDualProof(
+		err := c.verifyDualProof(
+			ctx,
 			dualProof,
 			sourceID,
 			targetID,
 			sourceAlh,
 			targetAlh,
 		)
-		if !verifies {
-			return nil, store.ErrCorruptedData
+		if err != nil {
+			return nil, err
 		}
 	}
 
"
GO-2022-1117,codenotary,immudb,7267d67e28be8f0257b71d734611a051593e8a81," func (c *immuClient) VerifiedSet(ctx context.Context, key []byte, value []byte)
 	targetAlh = tx.Header().Alh()
 
 	if state.TxId > 0 {
-		verifies = store.VerifyDualProof(
-			schema.DualProofFromProto(verifiableTx.DualProof),
+		dualProof := schema.DualProofFromProto(verifiableTx.DualProof)
+		err := c.verifyDualProof(
+			ctx,
+			dualProof,
 			sourceID,
 			targetID,
 			sourceAlh,
 			targetAlh,
 		)
-
-		if !verifies {
-			return nil, store.ErrCorruptedData
+		if err != nil {
+			return nil, err
 		}
 	}
 
"
GO-2022-1117,codenotary,immudb,7267d67e28be8f0257b71d734611a051593e8a81," func (c *immuClient) VerifiedTxByID(ctx context.Context, tx uint64) (*schema.Tx,
 	}
 
 	if state.TxId > 0 {
-		verifies := store.VerifyDualProof(
+		err := c.verifyDualProof(
+			ctx,
 			dualProof,
 			sourceID,
 			targetID,
 			sourceAlh,
 			targetAlh,
 		)
-		if !verifies {
-			return nil, store.ErrCorruptedData
+		if err != nil {
+			return nil, err
 		}
 	}
 
"
GO-2022-1117,codenotary,immudb,7267d67e28be8f0257b71d734611a051593e8a81," func (c *immuClient) VerifiedSetReferenceAt(ctx context.Context, key []byte, ref
 	targetAlh = tx.Header().Alh()
 
 	if state.TxId > 0 {
-		verifies = store.VerifyDualProof(
-			schema.DualProofFromProto(verifiableTx.DualProof),
+		dualProof := schema.DualProofFromProto(verifiableTx.DualProof)
+		err := c.verifyDualProof(
+			ctx,
+			dualProof,
 			sourceID,
 			targetID,
 			sourceAlh,
 			targetAlh,
 		)
-		if !verifies {
-			return nil, store.ErrCorruptedData
+		if err != nil {
+			return nil, err
 		}
 	}
 
"
GO-2022-1117,codenotary,immudb,7267d67e28be8f0257b71d734611a051593e8a81," func (c *immuClient) VerifiedZAddAt(ctx context.Context, set []byte, score float
 	targetAlh = tx.Header().Alh()
 
 	if state.TxId > 0 {
-		verifies = store.VerifyDualProof(
-			schema.DualProofFromProto(vtx.DualProof),
+		dualProof := schema.DualProofFromProto(vtx.DualProof)
+		err := c.verifyDualProof(
+			ctx,
+			dualProof,
 			sourceID,
 			targetID,
 			sourceAlh,
 			targetAlh,
 		)
-		if !verifies {
-			return nil, store.ErrCorruptedData
+		if err != nil {
+			return nil, err
 		}
 	}
 
"
GO-2022-1117,codenotary,immudb,7267d67e28be8f0257b71d734611a051593e8a81," func (c *immuClient) VerifyRow(ctx context.Context, row *schema.Row, table strin
 	}
 
 	if state.TxId > 0 {
-		verifies = store.VerifyDualProof(
+		err := c.verifyDualProof(
+			ctx,
 			dualProof,
 			sourceID,
 			targetID,
 			sourceAlh,
 			targetAlh,
 		)
-		if !verifies {
-			return store.ErrCorruptedData
+		if err != nil {
+			return err
 		}
 	}
 
"
GO-2022-1117,codenotary,immudb,7267d67e28be8f0257b71d734611a051593e8a81," func (c *immuClient) _streamVerifiedSet(ctx context.Context, kvs []*stream.KeyVa
 	targetAlh = tx.Header().Alh()
 
 	if state.TxId > 0 {
-		verifies = store.VerifyDualProof(
-			schema.DualProofFromProto(verifiableTx.DualProof),
+		dualProof := schema.DualProofFromProto(verifiableTx.DualProof)
+		err := c.verifyDualProof(
+			ctx,
+			dualProof,
 			sourceID,
 			targetID,
 			sourceAlh,
 			targetAlh,
 		)
-
-		if !verifies {
-			return nil, store.ErrCorruptedData
+		if err != nil {
+			return nil, err
 		}
 	}
 
"
GO-2022-1117,codenotary,immudb,7267d67e28be8f0257b71d734611a051593e8a81," func (c *immuClient) _streamVerifiedGet(ctx context.Context, req *schema.Verifia
 	}
 
 	if state.TxId > 0 {
-		verifies = store.VerifyDualProof(
+		err := c.verifyDualProof(
+			ctx,
 			dualProof,
 			sourceID,
 			targetID,
 			sourceAlh,
 			targetAlh,
 		)
-		if !verifies {
-			return nil, store.ErrCorruptedData
+		if err != nil {
+			return nil, err
 		}
 	}
 
"
GO-2023-1681,containers,podman,6ca857feb07a5fdc96fd947afef03916291673d8," func CreateTarFromSrc(source string, dest string) error {
 		return fmt.Errorf(""could not create tarball file '%s': %w"", dest, err)
 	}
 	defer file.Close()
-	return TarToFilesystem(source, file)
+	return TarChrootToFilesystem(source, file)
 }
 
 // TarToFilesystem creates a tarball from source and writes to an os.file
"
GO-2021-0099,deislabs,oras,96cd90423303f1bb42bd043cb4c36085e6e91e8e," func extractTarDirectory(root, prefix string, r io.Reader) error {
 
 		// Name check
 		name := header.Name
-		path, err := filepath.Rel(prefix, name)
+		path, err := ensureBasePath(root, prefix, name)
 		if err != nil {
 			return err
 		}
-		if strings.HasPrefix(path, ""../"") {
-			return fmt.Errorf(""%q does not have prefix %q"", name, prefix)
-		}
 		path = filepath.Join(root, path)
 
+		// Link check
+		switch header.Typeflag {
+		case tar.TypeLink, tar.TypeSymlink:
+			link := header.Linkname
+			if !filepath.IsAbs(link) {
+				link = filepath.Join(filepath.Dir(name), link)
+			}
+			if _, err := ensureBasePath(root, prefix, link); err != nil {
+				return err
+			}
+		}
+
 		// Create content
 		switch header.Typeflag {
 		case tar.TypeReg:
"
GO-2023-1547,helm,helm,293b50c65d4d56187cd4e2f390f0ada46b4c4737," func addInstallFlags(cmd *cobra.Command, f *pflag.FlagSet, client *action.Instal
 	f.BoolVar(&client.Atomic, ""atomic"", false, ""if set, the installation process deletes the installation on failure. The --wait flag will be set automatically if --atomic is used"")
 	f.BoolVar(&client.SkipCRDs, ""skip-crds"", false, ""if set, no CRDs will be installed. By default, CRDs are installed if not already present"")
 	f.BoolVar(&client.SubNotes, ""render-subchart-notes"", false, ""if set, render subchart notes along with the parent"")
+	f.BoolVar(&client.EnableDNS, ""enable-dns"", false, ""enable DNS lookups when rendering templates"")
 	addValueOptionsFlags(f, valueOpts)
 	addChartPathOptionsFlags(f, &client.ChartPathOptions)
 
"
GO-2023-1547,helm,helm,293b50c65d4d56187cd4e2f390f0ada46b4c4737," func newUpgradeCmd(cfg *action.Configuration, out io.Writer) *cobra.Command {
 					instClient.SubNotes = client.SubNotes
 					instClient.Description = client.Description
 					instClient.DependencyUpdate = client.DependencyUpdate
+					instClient.EnableDNS = client.EnableDNS
 
 					rel, err := runInstall(args, instClient, valueOpts, out)
 					if err != nil {
"
GO-2023-1547,helm,helm,293b50c65d4d56187cd4e2f390f0ada46b4c4737," func newUpgradeCmd(cfg *action.Configuration, out io.Writer) *cobra.Command {
 	f.BoolVar(&client.SubNotes, ""render-subchart-notes"", false, ""if set, render subchart notes along with the parent"")
 	f.StringVar(&client.Description, ""description"", """", ""add a custom description"")
 	f.BoolVar(&client.DependencyUpdate, ""dependency-update"", false, ""update dependencies if they are missing before installing the chart"")
+	f.BoolVar(&client.EnableDNS, ""enable-dns"", false, ""enable DNS lookups when rendering templates"")
 	addChartPathOptionsFlags(f, &client.ChartPathOptions)
 	addValueOptionsFlags(f, valueOpts)
 	bindOutputFlag(cmd, &outfmt)
"
GO-2023-1547,helm,helm,293b50c65d4d56187cd4e2f390f0ada46b4c4737," type Configuration struct {
 //
 // TODO: This function is badly in need of a refactor.
 // TODO: As part of the refactor the duplicate code in cmd/helm/template.go should be removed
-//       This code has to do with writing files to disk.
-func (cfg *Configuration) renderResources(ch *chart.Chart, values chartutil.Values, releaseName, outputDir string, subNotes, useReleaseName, includeCrds bool, pr postrender.PostRenderer, dryRun bool) ([]*release.Hook, *bytes.Buffer, string, error) {
+//
+//	This code has to do with writing files to disk.
+func (cfg *Configuration) renderResources(ch *chart.Chart, values chartutil.Values, releaseName, outputDir string, subNotes, useReleaseName, includeCrds bool, pr postrender.PostRenderer, dryRun, enableDNS bool) ([]*release.Hook, *bytes.Buffer, string, error) {
 	hs := []*release.Hook{}
 	b := bytes.NewBuffer(nil)
 
"
GO-2023-1547,helm,helm,293b50c65d4d56187cd4e2f390f0ada46b4c4737," func (cfg *Configuration) renderResources(ch *chart.Chart, values chartutil.Valu
 		if err != nil {
 			return hs, b, """", err
 		}
-		files, err2 = engine.RenderWithClient(ch, values, restConfig)
+		e := engine.New(restConfig)
+		e.EnableDNS = enableDNS
+		files, err2 = e.Render(ch, values)
 	} else {
-		files, err2 = engine.Render(ch, values)
+		var e engine.Engine
+		e.EnableDNS = enableDNS
+		files, err2 = e.Render(ch, values)
 	}
 
 	if err2 != nil {
"
GO-2023-1547,helm,helm,293b50c65d4d56187cd4e2f390f0ada46b4c4737," func (i *Install) RunWithContext(ctx context.Context, chrt *chart.Chart, vals ma
 	rel := i.createRelease(chrt, vals)
 
 	var manifestDoc *bytes.Buffer
-	rel.Hooks, manifestDoc, rel.Info.Notes, err = i.cfg.renderResources(chrt, valuesToRender, i.ReleaseName, i.OutputDir, i.SubNotes, i.UseReleaseName, i.IncludeCRDs, i.PostRenderer, i.DryRun)
+	rel.Hooks, manifestDoc, rel.Info.Notes, err = i.cfg.renderResources(chrt, valuesToRender, i.ReleaseName, i.OutputDir, i.SubNotes, i.UseReleaseName, i.IncludeCRDs, i.PostRenderer, i.DryRun, i.EnableDNS)
 	// Even for errors, attach this if available
 	if manifestDoc != nil {
 		rel.Manifest = manifestDoc.String()
"
GO-2023-1547,helm,helm,293b50c65d4d56187cd4e2f390f0ada46b4c4737," func (u *Upgrade) prepareUpgrade(name string, chart *chart.Chart, vals map[strin
 		return nil, nil, err
 	}
 
-	hooks, manifestDoc, notesTxt, err := u.cfg.renderResources(chart, valuesToRender, """", """", u.SubNotes, false, false, u.PostRenderer, u.DryRun)
+	hooks, manifestDoc, notesTxt, err := u.cfg.renderResources(chart, valuesToRender, """", """", u.SubNotes, false, false, u.PostRenderer, u.DryRun, u.EnableDNS)
 	if err != nil {
 		return nil, nil, err
 	}
"
GO-2023-1547,helm,helm,293b50c65d4d56187cd4e2f390f0ada46b4c4737," func (e Engine) initFunMap(t *template.Template, referenceTpls map[string]render
 		funcMap[""lookup""] = NewLookupFunction(e.config)
 	}
 
+	// When DNS lookups are not enabled override the sprig function and return
+	// an empty string.
+	if !e.EnableDNS {
+		funcMap[""getHostByName""] = func(name string) string {
+			return """"
+		}
+	}
+
 	t.Funcs(funcMap)
 }
 
"
GO-2021-0077,etcd-io,etcd,bf9d0d8291dc71ecbfb2690612954e1a298154b2," func (as *authStore) AuthInfoFromTLS(ctx context.Context) (ai *AuthInfo) {
 			Username: chains[0].Subject.CommonName,
 			Revision: as.Revision(),
 		}
+		md, ok := metadata.FromIncomingContext(ctx)
+		if !ok {
+			return nil
+		}
+
+		// gRPC-gateway proxy request to etcd server includes Grpcgateway-Accept
+		// header. The proxy uses etcd client server certificate. If the certificate
+		// has a CommonName we should never use this for authentication.
+		if gw := md[""grpcgateway-accept""]; len(gw) > 0 {
+			if as.lg != nil {
+				as.lg.Warn(
+					""ignoring common name in gRPC-gateway proxy request"",
+					zap.String(""common-name"", ai.Username),
+					zap.String(""user-name"", ai.Username),
+					zap.Uint64(""revision"", ai.Revision),
+				)
+			} else {
+				plog.Warningf(""ignoring common name in gRPC-gateway proxy request %s"", ai.Username)
+			}
+			return nil
+		}
 		if as.lg != nil {
 			as.lg.Debug(
 				""found command name"",
"
GO-2020-0036,go-yaml,yaml,53403b58ad1b561927d19068c655246f2db79d48," func trace(args ...interface{}) func() {
 func yaml_parser_fetch_more_tokens(parser *yaml_parser_t) bool {
 	// While we need more tokens to fetch, do it.
 	for {
-		// Check if we really need to fetch more tokens.
-		need_more_tokens := false
-
-		if parser.tokens_head == len(parser.tokens) {
-			// Queue is empty.
-			need_more_tokens = true
-		} else {
-			// Check if any potential simple key may occupy the head position.
-			for i := len(parser.simple_keys) - 1; i >= 0; i-- {
-				simple_key := &parser.simple_keys[i]
-				if simple_key.token_number < parser.tokens_parsed {
-					break
-				}
-				if valid, ok := yaml_simple_key_is_valid(parser, simple_key); !ok {
-					return false
-				} else if valid && simple_key.token_number == parser.tokens_parsed {
-					need_more_tokens = true
-					break
-				}
+		if parser.tokens_head != len(parser.tokens) {
+			// If queue is non-empty, check if any potential simple key may
+			// occupy the head position.
+			head_tok_idx, ok := parser.simple_keys_by_tok[parser.tokens_parsed]
+			if !ok {
+				break
+			} else if valid, ok := yaml_simple_key_is_valid(parser, &parser.simple_keys[head_tok_idx]); !ok {
+				return false
+			} else if !valid {
+				break
 			}
 		}
-
-		// We are finished.
-		if !need_more_tokens {
-			break
-		}
 		// Fetch the next token.
 		if !yaml_parser_fetch_next_token(parser) {
 			return false
"
GO-2020-0036,go-yaml,yaml,53403b58ad1b561927d19068c655246f2db79d48," func yaml_parser_save_simple_key(parser *yaml_parser_t) bool {
 			return false
 		}
 		parser.simple_keys[len(parser.simple_keys)-1] = simple_key
+		parser.simple_keys_by_tok[simple_key.token_number] = len(parser.simple_keys) - 1
 	}
 	return true
 }
"
GO-2020-0036,go-yaml,yaml,53403b58ad1b561927d19068c655246f2db79d48," func yaml_parser_remove_simple_key(parser *yaml_parser_t) bool {
 				""while scanning a simple key"", parser.simple_keys[i].mark,
 				""could not find expected ':'"")
 		}
+		// Remove the key from the stack.
+		parser.simple_keys[i].possible = false
+		delete(parser.simple_keys_by_tok, parser.simple_keys[i].token_number)
 	}
-	// Remove the key from the stack.
-	parser.simple_keys[i].possible = false
 	return true
 }
 
"
GO-2020-0036,go-yaml,yaml,53403b58ad1b561927d19068c655246f2db79d48," func yaml_parser_increase_flow_level(parser *yaml_parser_t) bool {
 func yaml_parser_decrease_flow_level(parser *yaml_parser_t) bool {
 	if parser.flow_level > 0 {
 		parser.flow_level--
-		parser.simple_keys = parser.simple_keys[:len(parser.simple_keys)-1]
+		last := len(parser.simple_keys) - 1
+		delete(parser.simple_keys_by_tok, parser.simple_keys[last].token_number)
+		parser.simple_keys = parser.simple_keys[:last]
 	}
 	return true
 }
"
GO-2020-0036,go-yaml,yaml,53403b58ad1b561927d19068c655246f2db79d48," func yaml_parser_fetch_stream_start(parser *yaml_parser_t) bool {
 	// Initialize the simple key stack.
 	parser.simple_keys = append(parser.simple_keys, yaml_simple_key_t{})
 
+	parser.simple_keys_by_tok = make(map[int]int)
+
 	// A simple key is allowed at the beginning of the stream.
 	parser.simple_key_allowed = true
 
"
GO-2020-0036,go-yaml,yaml,53403b58ad1b561927d19068c655246f2db79d48," func yaml_parser_fetch_value(parser *yaml_parser_t) bool {
 
 		// Remove the simple key.
 		simple_key.possible = false
+		delete(parser.simple_keys_by_tok, simple_key.token_number)
 
 		// A simple key cannot follow another simple key.
 		parser.simple_key_allowed = false
"
GO-2023-1600,kitabisa,teler-waf,6e1b0e19b8adc1bbc3513a986025d4adf88d59f8," func (t *Teler) checkCustomRules(r *http.Request) error {
 // If a match is found, it returns an error indicating a common web attack has been detected.
 // If no match is found, it returns nil.
 func (t *Teler) checkCommonWebAttack(r *http.Request) error {
-	// Decode the URL-encoded and unescape HTML entities request URI of the URL
-	uri := stringDeUnescape(r.URL.RequestURI())
+	// Decode the URL-encoded and unescape HTML entities in the
+	// request URI of the URL then remove all special characters
+	uri := removeSpecialChars(stringDeUnescape(r.URL.RequestURI()))
 
 	// Declare byte slice for request body.
 	var body string
"
GO-2023-1600,kitabisa,teler-waf,6e1b0e19b8adc1bbc3513a986025d4adf88d59f8," func (t *Teler) checkCommonWebAttack(r *http.Request) error {
 		body = buf.String()
 	}
 
-	// Decode the URL-encoded and unescape HTML entities of body
-	body = stringDeUnescape(body)
+	// Decode the URL-encoded and unescape HTML entities in the
+	// body of request then remove all special characters
+	body = removeSpecialChars(stringDeUnescape(body))
 
 	// Iterate over the filters in the CommonWebAttack data stored in the t.threat.cwa.Filters field
 	for _, filter := range t.threat.cwa.Filters {
"
GO-2021-0086,documize,community,a4384210d4d0d6b18e6fdb7e155de96d4a1cf9f3," func (*Provider) Command(ctx *provider.Context, w http.ResponseWriter, r *http.R
 
 // Render converts markdown data into HTML suitable for browser rendering.
 func (*Provider) Render(ctx *provider.Context, config, data string) string {
-	result := blackfriday.Run([]byte(data))
+	unsafe := blackfriday.Run([]byte(data))
 
-	return string(result)
+	safe := bluemonday.UGCPolicy().SanitizeBytes(unsafe)
+
+	return string(safe)
 }
 
 // Refresh just sends back data as-is.
"
GO-2023-1567,caddyserver,caddy,78b5356f2b1945a90de1ef7f2c7669d82098edbd," func (fsrv *FileServer) directoryListing(files []os.FileInfo, canGoUp bool, root
 
 		isDir := f.IsDir() || isSymlinkTargetDir(f, root, urlPath)
 
-		u := url.URL{Path: url.PathEscape(name)}
-
 		// add the slash after the escape of path to avoid escaping the slash as well
 		if isDir {
-			u.Path += ""/""
+			name += ""/""
 			dirCount++
 		} else {
 			fileCount++
"
GO-2023-1567,caddyserver,caddy,78b5356f2b1945a90de1ef7f2c7669d82098edbd," func (fsrv *FileServer) directoryListing(files []os.FileInfo, canGoUp bool, root
 			// was already set above.
 		}
 
+		u := url.URL{Path: ""./"" + name} // prepend with ""./"" to fix paths with ':' in the name
+
 		fileInfos = append(fileInfos, fileInfo{
 			IsDir:     isDir,
 			IsSymlink: fileIsSymlink,
"
GO-2023-1567,caddyserver,caddy,78b5356f2b1945a90de1ef7f2c7669d82098edbd," func StatusCodeMatches(actual, configured int) bool {
 // never be outside of root. The resulting path can be used
 // with the local file system.
 func SanitizedPathJoin(root, reqPath string) string {
-	reqPath, _ = url.PathUnescape(reqPath)
 	if root == """" {
 		root = "".""
 	}
"
GO-2023-1526,hakobe,paranoidhttp,07f671da14ce63a80f4e52432b32e8d178d75fd3," func safeAddr(ctx context.Context, resolver *net.Resolver, hostport string, opts
 
 	ip := net.ParseIP(host)
 	if ip != nil {
-		if ip.To4() != nil && c.isIPForbidden(ip) {
+		if ip.IsUnspecified() || (ip.To4() != nil && c.isIPForbidden(ip)) {
 			return """", fmt.Errorf(""bad ip is detected: %v"", ip)
 		}
 		return net.JoinHostPort(ip.String(), port), nil
"
GO-2023-2024,libp2p,go-libp2p,45d3c6fff662ddd6938982e7e9309ad5fa2ad8dd," func ConsumeEnvelope(data []byte, domain string) (envelope *Envelope, rec Record
 
 	err = e.validate(domain)
 	if err != nil {
-		return e, nil, fmt.Errorf(""failed to validate envelope: %w"", err)
+		return nil, nil, fmt.Errorf(""failed to validate envelope: %w"", err)
 	}
 
 	rec, err = e.Record()
 	if err != nil {
-		return e, nil, fmt.Errorf(""failed to unmarshal envelope payload: %w"", err)
+		return nil, nil, fmt.Errorf(""failed to unmarshal envelope payload: %w"", err)
 	}
 	return e, rec, nil
 }
"
GO-2023-2024,libp2p,go-libp2p,45d3c6fff662ddd6938982e7e9309ad5fa2ad8dd," func (ids *idService) consumeMessage(mes *pb.Identify, c network.Conn, isPush bo
 
 	// add signed addrs if we have them and the peerstore supports them
 	cab, ok := peerstore.GetCertifiedAddrBook(ids.Host.Peerstore())
-	if ok && signedPeerRecord != nil {
-		_, addErr := cab.ConsumePeerRecord(signedPeerRecord, ttl)
-		if addErr != nil {
-			log.Debugf(""error adding signed addrs to peerstore: %v"", addErr)
+	if ok && signedPeerRecord != nil && signedPeerRecord.PublicKey != nil {
+		id, err := peer.IDFromPublicKey(signedPeerRecord.PublicKey)
+		if err != nil {
+			log.Debugf(""failed to derive peer ID from peer record: %s"", err)
+		} else if id != c.RemotePeer() {
+			log.Debugf(""received signed peer record for unexpected peer ID. expected %s, got %s"", c.RemotePeer(), id)
+		} else if _, err := cab.ConsumePeerRecord(signedPeerRecord, ttl); err != nil {
+			log.Debugf(""error adding signed addrs to peerstore: %v"", err)
 		}
 	} else {
 		ids.Host.Peerstore().AddAddrs(p, lmaddrs, ttl)
"
GO-2022-0956,go-yaml,yaml,f221b8435cfb71e54062f6c6e99e9ade30b124d5," func yaml_parser_increase_flow_level(parser *yaml_parser_t) bool {
 
 	// Increase the flow level.
 	parser.flow_level++
+	if parser.flow_level > max_flow_level {
+		return yaml_parser_set_scanner_error(parser,
+			""while increasing flow level"", parser.simple_keys[len(parser.simple_keys)-1].mark,
+			fmt.Sprintf(""exceeded max depth of %d"", max_flow_level))
+	}
 	return true
 }
 
"
GO-2022-0956,go-yaml,yaml,f221b8435cfb71e54062f6c6e99e9ade30b124d5," func yaml_parser_roll_indent(parser *yaml_parser_t, column, number int, typ yaml
 		// indentation level.
 		parser.indents = append(parser.indents, parser.indent)
 		parser.indent = column
+		if len(parser.indents) > max_indents {
+			return yaml_parser_set_scanner_error(parser,
+				""while increasing indent level"", parser.simple_keys[len(parser.simple_keys)-1].mark,
+				fmt.Sprintf(""exceeded max depth of %d"", max_indents))
+		}
 
 		// Create a token and insert it into the queue.
 		token := yaml_token_t{
"
GO-2023-1772,distribution,distribution,f55a6552b006a381d9167e328808565dd2bf77dc," func (ch *catalogHandler) GetCatalog(w http.ResponseWriter, r *http.Request) {
 
 	q := r.URL.Query()
 	lastEntry := q.Get(""last"")
-	maxEntries, err := strconv.Atoi(q.Get(""n""))
-	if err != nil || maxEntries < 0 {
-		maxEntries = maximumReturnedEntries
+
+	entries := defaultReturnedEntries
+	maximumConfiguredEntries := ch.App.Config.Catalog.MaxEntries
+
+	// parse n, if n is negative abort with an error
+	if n := q.Get(""n""); n != """" {
+		parsedMax, err := strconv.Atoi(n)
+		if err != nil || parsedMax < 0 {
+			ch.Errors = append(ch.Errors, v2.ErrorCodePaginationNumberInvalid.WithDetail(map[string]string{""n"": n}))
+			return
+		}
+
+		// if a client requests more than it's allowed to receive
+		if parsedMax > maximumConfiguredEntries {
+			ch.Errors = append(ch.Errors, v2.ErrorCodePaginationNumberInvalid.WithDetail(map[string]int{""n"": parsedMax}))
+			return
+		}
+		entries = parsedMax
 	}
 
-	repos := make([]string, maxEntries)
+	// then enforce entries to be between 0 & maximumConfiguredEntries
+	// max(0, min(entries, maximumConfiguredEntries))
+	if entries < 0 || entries > maximumConfiguredEntries {
+		entries = maximumConfiguredEntries
+	}
 
-	filled, err := ch.App.registry.Repositories(ch.Context, repos, lastEntry)
-	_, pathNotFound := err.(driver.PathNotFoundError)
+	repos := make([]string, entries)
+	filled := 0
 
-	if err == io.EOF || pathNotFound {
+	// entries is guaranteed to be >= 0 and < maximumConfiguredEntries
+	if entries == 0 {
 		moreEntries = false
-	} else if err != nil {
-		ch.Errors = append(ch.Errors, errcode.ErrorCodeUnknown.WithDetail(err))
-		return
+	} else {
+		returnedRepositories, err := ch.App.registry.Repositories(ch.Context, repos, lastEntry)
+		if err != nil {
+			_, pathNotFound := err.(driver.PathNotFoundError)
+			if err != io.EOF && !pathNotFound {
+				ch.Errors = append(ch.Errors, errcode.ErrorCodeUnknown.WithDetail(err))
+				return
+			}
+			// err is either io.EOF or not PathNotFoundError
+			moreEntries = false
+		}
+		filled = returnedRepositories
 	}
 
 	w.Header().Set(""Content-Type"", ""application/json"")
 
 	// Add a link header if there are more entries to retrieve
 	if moreEntries {
-		lastEntry = repos[len(repos)-1]
-		urlStr, err := createLinkEntry(r.URL.String(), maxEntries, lastEntry)
+		lastEntry = repos[filled-1]
+		urlStr, err := createLinkEntry(r.URL.String(), entries, lastEntry)
 		if err != nil {
 			ch.Errors = append(ch.Errors, errcode.ErrorCodeUnknown.WithDetail(err))
 			return
"
GO-2021-0053,gogo,protobuf,b03c65ea87cdc3521ede29f62fe3ce239267c1bc," func (p *unmarshal) field(file *generator.FileDescriptor, msg *generator.Descrip
 			p.P(`return err`)
 			p.Out()
 			p.P(`}`)
-			p.P(`if skippy < 0 {`)
+			p.P(`if (skippy < 0) || (iNdEx + skippy) < 0 {`)
 			p.In()
 			p.P(`return ErrInvalidLength`, p.localName)
 			p.Out()
"
GO-2021-0053,gogo,protobuf,b03c65ea87cdc3521ede29f62fe3ce239267c1bc," func (p *unmarshal) Generate(file *generator.FileDescriptor) {
 			p.P(`return err`)
 			p.Out()
 			p.P(`}`)
-			p.P(`if skippy < 0 {`)
-			p.In()
-			p.P(`return ErrInvalidLength`, p.localName)
-			p.Out()
-			p.P(`}`)
-			p.P(`if (iNdEx + skippy) < 0 {`)
+			p.P(`if (skippy < 0) || (iNdEx + skippy) < 0 {`)
 			p.In()
 			p.P(`return ErrInvalidLength`, p.localName)
 			p.Out()
"
GO-2021-0053,gogo,protobuf,b03c65ea87cdc3521ede29f62fe3ce239267c1bc," func (p *unmarshal) Generate(file *generator.FileDescriptor) {
 		p.P(`return err`)
 		p.Out()
 		p.P(`}`)
-		p.P(`if skippy < 0 {`)
-		p.In()
-		p.P(`return ErrInvalidLength`, p.localName)
-		p.Out()
-		p.P(`}`)
-		p.P(`if (iNdEx + skippy) < 0 {`)
+		p.P(`if (skippy < 0) || (iNdEx + skippy) < 0 {`)
 		p.In()
 		p.P(`return ErrInvalidLength`, p.localName)
 		p.Out()
"
GO-2021-0089,buger,jsonparser,91ac96899e492584984ded0c8f9a08f10b473717," func findKeyStart(data []byte, key string) (int, error) {
 			}
 
 		case '[':
-			i = blockEnd(data[i:], data[i], ']') + i
+			end := blockEnd(data[i:], data[i], ']')
+			if end != -1 {
+				i = i + end
+			}
 		case '{':
-			i = blockEnd(data[i:], data[i], '}') + i
+			end := blockEnd(data[i:], data[i], '}')
+			if end != -1 {
+				i = i + end
+			}
 		}
 		i++
 	}
"
GO-2022-0272,kataras,iris,e213dba0d32ff66653e0ef124bc5088817264b08," func (ctx *Context) UploadFormFiles(destDirectory string, before ...func(*Contex
 			for _, files := range fhs {
 			innerLoop:
 				for _, file := range files {
-					// Fix an issue that net/http has,
-					// an attacker can push a filename
-					// which could lead to override existing system files
-					// by ../../$file.
-					// Reported by Frank through security reports.
-					file.Filename = strings.ReplaceAll(file.Filename, ""../"", """")
-					file.Filename = strings.ReplaceAll(file.Filename, ""..\\"", """")
+					// Security fix for go < 1.17.5:
+					// Reported by Kirill Efimov (snyk.io) through security reports.
+					file.Filename = filepath.Base(file.Filename)
 
 					for _, b := range before {
 						if !b(ctx, file) {
"
GO-2022-0316,open-policy-agent,opa,932e4ffc37a590ace79e9b75ca4340288c220239," func (w *writer) listWriter() entryWriter {
 // location: anything on the same line will be put into a slice.
 func groupIterable(elements []interface{}, last *ast.Location) [][]interface{} {
 	// Generated vars occur in the AST when we're rendering the result of
-	// partial evaluation in a bundle build with optimization. For those vars,
-	// there is no location, and the grouping based on source location will
-	// yield a bad result. So if there's a generated variable among elements,
-	// we'll render the elements all in one line.
-	vis := ast.NewVarVisitor()
+	// partial evaluation in a bundle build with optimization.
+	// Those variables, and wildcard variables have the ""default location"",
+	// set in `Ast()`). That is no proper file location, and the grouping
+	// based on source location will yield a bad result.
+	def := false // default location found?
 	for _, elem := range elements {
-		vis.Walk(elem)
-	}
-	for v := range vis.Vars() {
-		if v.IsGenerated() {
+		ast.WalkTerms(elem, func(t *ast.Term) bool {
+			if t.Location.File == defaultLocationFile {
+				def = true
+				return true
+			}
+			return false
+		})
+		if def { // return as-is
 			return [][]interface{}{elements}
 		}
 	}
 	sort.Slice(elements, func(i, j int) bool {
 		return locLess(elements[i], elements[j])
 	})
+
 	var lines [][]interface{}
 	var cur []interface{}
 	for i, t := range elements {
"
GO-2022-0316,open-policy-agent,opa,2bd8edab9e10e2dc9cf76ae8335ced0c224f3055," func groupIterable(elements []interface{}, last *ast.Location) [][]interface{} {
 	// Those variables, and wildcard variables have the ""default location"",
 	// set in `Ast()`). That is no proper file location, and the grouping
 	// based on source location will yield a bad result.
+	// Another case is generated variables: they do have proper file locations,
+	// but their row/col information may no longer match their AST location.
+	// So, for generated variables, we also don't trust the location, but
+	// keep them ungrouped.
 	def := false // default location found?
 	for _, elem := range elements {
 		ast.WalkTerms(elem, func(t *ast.Term) bool {
"
GO-2022-0316,open-policy-agent,opa,2bd8edab9e10e2dc9cf76ae8335ced0c224f3055," func groupIterable(elements []interface{}, last *ast.Location) [][]interface{} {
 			}
 			return false
 		})
+		ast.WalkVars(elem, func(v ast.Var) bool {
+			if v.IsGenerated() {
+				def = true
+				return true
+			}
+			return false
+		})
 		if def { // return as-is
 			return [][]interface{}{elements}
 		}
"
GO-2020-0034,artdarek,go-unzip,4975cbe0a719dc50b12da8585f1f207c82f7dfe0," func (uz Unzip) Extract() error {
 		}()
 
 		path := filepath.Join(uz.Dest, f.Name)
+		if !strings.HasPrefix(path, filepath.Clean(uz.Dest)+string(os.PathSeparator)) {
+            return fmt.Errorf(""%s: Illegal file path"", path)
+        }
 
 		if f.FileInfo().IsDir() {
 			os.MkdirAll(path, f.Mode())
"
GO-2022-0411,Masterminds,goutils,869801f20f9f1e7ecdbdb6422049d8241270d5e1," func CryptoRandomAlphaNumeric(count int) (string, error) {
 	if count == 0 {
 		return """", nil
 	}
-	RandomString, err := CryptoRandom(count, 0, 0, true, true)
-	if err != nil {
-		return """", fmt.Errorf(""Error: %s"", err)
-	}
-	match, err := regexp.MatchString(""([0-9]+)"", RandomString)
-	if err != nil {
-		panic(err)
-	}
-
-	if !match {
-		//Get the position between 0 and the length of the string-1  to insert a random number
-		position := getCryptoRandomInt(count)
-		//Insert a random number between [0-9] in the position
-		RandomString = RandomString[:position] + string('0' + getCryptoRandomInt(10)) + RandomString[position + 1:]
-		return RandomString, err
-	}
-	return RandomString, err
 
+	return CryptoRandom(count, 0, 0, true, true)
 }
 
 /*
"
GO-2022-0528,containrrr,shoutrrr,6a27056f9d7522a8b493216195cb7634bf4b5c42," func PartitionMessage(input string, limits t.MessageLimit, distance int) (items
 	maxTotal := Min(len(runes), limits.TotalChunkSize)
 	maxCount := limits.ChunkCount - 1
 
+	if len(input) == 0 {
+		// If the message is empty, return an empty array
+		omitted = 0
+		return
+	}
+
 	for i := 0; i < maxCount; i++ {
-		// If no suitable split point is found, use the chunkSize
-		chunkEnd := chunkOffset + limits.ChunkSize
-		// ... and start next chunk directly after this one
-		nextChunkStart := chunkEnd
+		// If no suitable split point is found, start next chunk at chunkSize from chunk start
+		nextChunkStart := chunkOffset + limits.ChunkSize
+		// ... and set the chunk end to the rune before the next chunk
+		chunkEnd := nextChunkStart - 1
 		if chunkEnd > maxTotal {
 			// The chunk is smaller than the limit, no need to search
 			chunkEnd = maxTotal
"
GO-2023-1557,ipfs,go-unixfs,467d139a640ecee4f2e74643dafcc58bb3b54175," func makeShard(ds ipld.DAGService, size int, key string, val *ipld.Link) (*Shard
 	if err != nil {
 		return nil, err
 	}
+	childer, err := newChilder(ds, size)
+	if err != nil {
+		return nil, err
+	}
 	maxpadding := fmt.Sprintf(""%X"", size-1)
 	s := &Shard{
 		tableSizeLg2: lg2s,
 		prefixPadStr: fmt.Sprintf(""%%0%dX"", len(maxpadding)),
 		maxpadlen:    len(maxpadding),
-		childer:      newChilder(ds, size),
+		childer:      childer,
 		tableSize:    size,
 		dserv:        ds,
 
"
GO-2023-1557,ipfs,go-unixfs,467d139a640ecee4f2e74643dafcc58bb3b54175," type childer struct {
 	children []*Shard
 }
 
-func newChilder(ds ipld.DAGService, size int) *childer {
+const maximumHamtWidth = 1 << 10 // FIXME: Spec this and decide of a correct value
+
+func newChilder(ds ipld.DAGService, size int) (*childer, error) {
+	if size > maximumHamtWidth {
+		return nil, fmt.Errorf(""hamt witdh (%d) exceed maximum allowed (%d)"", size, maximumHamtWidth)
+	}
+	bf, err := bitfield.NewBitfield(size)
+	if err != nil {
+		return nil, err
+	}
+
 	return &childer{
 		dserv:    ds,
-		bitfield: bitfield.NewBitfield(size),
-	}
+		bitfield: bf,
+	}, nil
 }
 
 func (s *childer) makeChilder(data []byte, links []*ipld.Link) *childer {
"
GO-2022-1118,codenotary,immudb,cade04756ff3f0a3b9e8d24149062744574adf5d," func NewImmuClient(options *Options) (*immuClient, error) {
 	}
 
 	stateProvider := state.NewStateProvider(serviceClient)
-	uuidProvider := state.NewUUIDProvider(serviceClient)
+	serverUUID, err := state.NewUUIDProvider(serviceClient).CurrentUUID(context.Background())
+	if err != nil {
+		return nil, logErr(l, ""Unable to get server uuid: %s"", err)
+	}
+
+	stateCache := cache.NewFileCache(c.Options.Dir)
+	if !c.Options.DisableIdentityCheck {
+		err = stateCache.ServerIdentityCheck(
+			fmt.Sprintf(""%s:%d"", c.Options.Address, c.Options.Port),
+			serverUUID,
+		)
+		if err != nil {
+			return nil, logErr(l, ""Unable to validate server identity: %s"", err)
+		}
+	}
 
-	stateService, err := state.NewStateService(cache.NewFileCache(options.Dir), l, stateProvider, uuidProvider)
+	stateService, err := state.NewStateServiceWithUUID(
+		stateCache,
+		l,
+		stateProvider,
+		serverUUID,
+	)
 	if err != nil {
 		return nil, logErr(l, ""Unable to create state service: %s"", err)
 	}
"
GO-2022-1118,codenotary,immudb,cade04756ff3f0a3b9e8d24149062744574adf5d," type Options struct {
 	StreamChunkSize     int    // Maximum size of a data chunk in bytes for streaming operations (directly affects maximum GRPC packet size)
 
 	HeartBeatFrequency time.Duration // Duration between two consecutive heartbeat calls to the server for session heartbeats
+
+	DisableIdentityCheck bool // Do not validate server's identity
 }
 
 // DefaultOptions ...
 func DefaultOptions() *Options {
 	return &Options{
-		Dir:                 ""."",
-		Address:             ""127.0.0.1"",
-		Port:                3322,
-		HealthCheckRetries:  5,
-		MTLs:                false,
-		Auth:                true,
-		MaxRecvMsgSize:      4 * 1024 * 1024, //4Mb
-		Config:              ""configs/immuclient.toml"",
-		DialOptions:         []grpc.DialOption{grpc.WithInsecure()},
-		PasswordReader:      c.DefaultPasswordReader,
-		Metrics:             true,
-		PidPath:             """",
-		LogFileName:         """",
-		ServerSigningPubKey: """",
-		StreamChunkSize:     stream.DefaultChunkSize,
-		HeartBeatFrequency:  time.Minute * 1,
+		Dir:                  ""."",
+		Address:              ""127.0.0.1"",
+		Port:                 3322,
+		HealthCheckRetries:   5,
+		MTLs:                 false,
+		Auth:                 true,
+		MaxRecvMsgSize:       4 * 1024 * 1024, //4Mb
+		Config:               ""configs/immuclient.toml"",
+		DialOptions:          []grpc.DialOption{grpc.WithInsecure()},
+		PasswordReader:       c.DefaultPasswordReader,
+		Metrics:              true,
+		PidPath:              """",
+		LogFileName:          """",
+		ServerSigningPubKey:  """",
+		StreamChunkSize:      stream.DefaultChunkSize,
+		HeartBeatFrequency:   time.Minute * 1,
+		DisableIdentityCheck: false,
 	}
 }
 
"
GO-2022-1118,codenotary,immudb,cade04756ff3f0a3b9e8d24149062744574adf5d," func (c *immuClient) OpenSession(ctx context.Context, user []byte, pass []byte,
 		}
 	}()
 
+	stateCache := cache.NewFileCache(c.Options.Dir)
+	if !c.Options.DisableIdentityCheck {
+		err = stateCache.ServerIdentityCheck(
+			fmt.Sprintf(""%s:%d"", c.Options.Address, c.Options.Port),
+			resp.GetServerUUID(),
+		)
+		if err != nil {
+			return err
+		}
+	}
+
 	stateProvider := state.NewStateProvider(serviceClient)
 
-	stateService, err := state.NewStateServiceWithUUID(cache.NewFileCache(c.Options.Dir), c.Logger, stateProvider, resp.GetServerUUID())
+	stateService, err := state.NewStateServiceWithUUID(stateCache, c.Logger, stateProvider, resp.GetServerUUID())
 	if err != nil {
 		return errors.FromError(fmt.Errorf(""unable to create state service: %v"", err))
 	}
"
GO-2022-0462,pion,dtls,d2f797183a9f044ce976e6df6f362662ca722412," func flight4Parse(ctx context.Context, c flightConn, state *State, cache *handsh
 			}
 		}
 		state.peerCertificatesVerified = verified
+	} else if state.PeerCertificates != nil {
+		// A certificate was received, but we haven't seen a CertificateVerify
+		// keep reading until we receieve one
+		return 0, nil, nil
 	}
 
 	if !state.cipherSuite.IsInitialized() {
"
GO-2022-0384,helm,helm,61d8e8c4a6f95540c15c6a65f36a6dd0a45e7a2f," func (c *ChartDownloader) ResolveChartVersion(ref, version string) (*url.URL, er
 			c.Options = append(
 				c.Options,
 				getter.WithBasicAuth(rc.Username, rc.Password),
+				getter.WithPassCredentialsAll(rc.PassCredentialsAll),
 			)
 		}
 		return u, nil
"
GO-2022-0384,helm,helm,61d8e8c4a6f95540c15c6a65f36a6dd0a45e7a2f," func (c *ChartDownloader) ResolveChartVersion(ref, version string) (*url.URL, er
 			c.Options = append(c.Options, getter.WithTLSClientConfig(r.Config.CertFile, r.Config.KeyFile, r.Config.CAFile))
 		}
 		if r.Config.Username != """" && r.Config.Password != """" {
-			c.Options = append(c.Options, getter.WithBasicAuth(r.Config.Username, r.Config.Password))
+			c.Options = append(c.Options,
+				getter.WithBasicAuth(r.Config.Username, r.Config.Password),
+				getter.WithPassCredentialsAll(r.Config.PassCredentialsAll),
+			)
 		}
 	}
 
"
GO-2022-0519,flyteorg,flyteadmin,a1ec282d02706e074bc4986fd0412e5da3b9d00a," type ResourceServer struct {
 }
 
 func (r ResourceServer) ValidateAccessToken(ctx context.Context, expectedAudience, tokenStr string) (interfaces.IdentityContext, error) {
-	raw, err := r.signatureVerifier.VerifySignature(ctx, tokenStr)
+	_, err := r.signatureVerifier.VerifySignature(ctx, tokenStr)
 	if err != nil {
 		return nil, err
 	}
 
-	claimsRaw := map[string]interface{}{}
-	if err = json.Unmarshal(raw, &claimsRaw); err != nil {
-		return nil, fmt.Errorf(""failed to unmarshal user info claim into UserInfo type. Error: %w"", err)
+	t, _, err := jwtgo.NewParser().ParseUnverified(tokenStr, jwtgo.MapClaims{})
+	if err != nil {
+		return nil, fmt.Errorf(""failed to parse token: %v"", err)
+	}
+
+	if err = t.Claims.Valid(); err != nil {
+		return nil, fmt.Errorf(""failed to validate token: %v"", err)
 	}
 
-	return verifyClaims(sets.NewString(append(r.allowedAudience, expectedAudience)...), claimsRaw)
+	return verifyClaims(sets.NewString(append(r.allowedAudience, expectedAudience)...), t.Claims.(jwtgo.MapClaims))
 }
 
 func doRequest(ctx context.Context, req *http.Request) (*http.Response, error) {
"
GO-2020-0032,goadesign,goa,70b5a199d0f813d74423993832c424e1fc73fb39," func (ctrl *Controller) FileHandler(path, filename string) Handler {
 		}
 	}
 	return func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
+		// prevent path traversal
+		if attemptsPathTraversal(req.URL.Path, path) {
+			return ErrNotFound(req.URL.Path)
+		}
 		fname := filename
 		if len(wc) > 0 {
 			if m, ok := ContextRequest(ctx).Params[wc]; ok {
"
GO-2022-1187,go-macaron,i18n,329b0c4844cc16a5a253c011b55180598e707735," func I18n(options ...Options) macaron.Handler {
 		ctx.Data[""RestLangs""] = restLangs
 
 		if opt.Redirect && isNeedRedir {
-			ctx.Redirect(opt.SubURL + ctx.Req.RequestURI[:strings.Index(ctx.Req.RequestURI, ""?"")])
+			ctx.Redirect(opt.SubURL + path.Clean(ctx.Req.RequestURI[:strings.Index(ctx.Req.RequestURI, ""?"")]))
 		}
 	}
 }
"
GO-2022-0629,kubernetes-sigs,secrets-store-csi-driver,c2cbb19e2eef16638fa0523383788a4bc22231fd," func (r *SecretProviderClassPodStatusReconciler) Reconcile(req ctrl.Request) (ct
 		return ctrl.Result{}, nil
 	}
 
-	// podObjectReference is an object reference to the pod that spc pod status
-	// is created for. The object reference is created with minimal required fields
-	// name, namespace and UID. By doing this we can skip an additional client call
-	// to fetch the pod object
-	podObjectReference, err := getPodObjectReference(spcPodStatus)
-	if err != nil {
-		logger.Errorf(""failed to get pod object reference, error: %+v"", err)
+	// Obtain the full pod metadata. An object reference is needed for sending
+	// events and the UID is helpful for validating the SPCPS TargetPath.
+	pod := &v1.Pod{}
+	if err := r.reader.Get(ctx, client.ObjectKey{Namespace: req.Namespace, Name: spcPodStatus.Status.PodName}, pod); err != nil {
+		logger.Errorf(""failed to get pod %s/%s, err: %+v"", req.Namespace, spcPodStatus.Status.PodName, err)
+		if apierrors.IsNotFound(err) {
+			return ctrl.Result{RequeueAfter: 5 * time.Second}, nil
+		}
+		return ctrl.Result{}, err
+	}
+
+	// determine which pod volume this is associated with
+	podVol := k8sutil.SPCVolume(pod, spc.Name)
+	if podVol == nil {
+		return ctrl.Result{}, fmt.Errorf(""failed to find secret provider class pod status volume for pod %s/%s"", req.Namespace, spcPodStatus.Status.PodName)
+	}
+
+	// validate TargetPath
+	if fileutil.GetPodUIDFromTargetPath(spcPodStatus.Status.TargetPath) != string(pod.UID) {
+		return ctrl.Result{}, fmt.Errorf(""secret provider class pod status targetPath did not match pod UID for pod %s/%s"", req.Namespace, spcPodStatus.Status.PodName)
+	}
+	if fileutil.GetVolumeNameFromTargetPath(spcPodStatus.Status.TargetPath) != podVol.Name {
+		return ctrl.Result{}, fmt.Errorf(""secret provider class pod status volume name did not match pod Volume for pod %s/%s"", req.Namespace, spcPodStatus.Status.PodName)
 	}
 
 	files, err := fileutil.GetMountedFiles(spcPodStatus.Status.TargetPath)
 	if err != nil {
-		r.generateEvent(podObjectReference, corev1.EventTypeWarning, secretCreationFailedReason, fmt.Sprintf(""failed to get mounted files, err: %+v"", err))
+		r.generateEvent(pod, corev1.EventTypeWarning, secretCreationFailedReason, fmt.Sprintf(""failed to get mounted files, err: %+v"", err))
 		logger.Errorf(""failed to get mounted files, err: %+v"", err)
 		return ctrl.Result{RequeueAfter: 10 * time.Second}, err
 	}
"
GO-2022-0629,kubernetes-sigs,secrets-store-csi-driver,c2cbb19e2eef16638fa0523383788a4bc22231fd," func (r *SecretProviderClassPodStatusReconciler) Reconcile(req ctrl.Request) (ct
 
 			datamap := make(map[string][]byte)
 			if datamap, err = secretutil.GetSecretData(secretObj.Data, secretType, files); err != nil {
-				r.generateEvent(podObjectReference, corev1.EventTypeWarning, secretCreationFailedReason, fmt.Sprintf(""failed to get data in spc %s/%s for secret %s, err: %+v"", req.Namespace, spcName, secretName, err))
+				r.generateEvent(pod, corev1.EventTypeWarning, secretCreationFailedReason, fmt.Sprintf(""failed to get data in spc %s/%s for secret %s, err: %+v"", req.Namespace, spcName, secretName, err))
 				log.Errorf(""failed to get data in spc %s/%s for secret %s, err: %+v"", req.Namespace, spcName, secretName, err)
 				errs = append(errs, fmt.Errorf(""failed to get data in spc %s/%s for secret %s, err: %+v"", req.Namespace, spcName, secretName, err))
 				continue
"
GO-2022-0629,kubernetes-sigs,secrets-store-csi-driver,c2cbb19e2eef16638fa0523383788a4bc22231fd," func (r *SecretProviderClassPodStatusReconciler) Reconcile(req ctrl.Request) (ct
 				Factor:   1.0,
 				Jitter:   0.1,
 			}, f); err != nil {
-				r.generateEvent(podObjectReference, corev1.EventTypeWarning, secretCreationFailedReason, err.Error())
+				r.generateEvent(pod, corev1.EventTypeWarning, secretCreationFailedReason, err.Error())
 				return ctrl.Result{RequeueAfter: 5 * time.Second}, err
 			}
 		}
"
GO-2022-0629,kubernetes-sigs,secrets-store-csi-driver,c2cbb19e2eef16638fa0523383788a4bc22231fd," func (r *Reconciler) reconcile(ctx context.Context, spcps *v1alpha1.SecretProvid
 		return fmt.Errorf(""failed to get pod %s/%s, err: %+v"", podNamespace, podName, err)
 	}
 
+	// determine which pod volume this is associated with
+	podVol := k8sutil.SPCVolume(pod, spc.Name)
+	if podVol == nil {
+		errorReason = internalerrors.PodVolumeNotFound
+		return fmt.Errorf(""could not find secret provider class pod status volume for pod %s/%s"", podNamespace, podName)
+	}
+
+	// validate TargetPath
+	if fileutil.GetPodUIDFromTargetPath(spcps.Status.TargetPath) != string(pod.UID) {
+		errorReason = internalerrors.UnexpectedTargetPath
+		return fmt.Errorf(""secret provider class pod status targetPath did not match pod UID for pod %s/%s"", podNamespace, podName)
+	}
+	if fileutil.GetVolumeNameFromTargetPath(spcps.Status.TargetPath) != podVol.Name {
+		errorReason = internalerrors.UnexpectedTargetPath
+		return fmt.Errorf(""secret provider class pod status volume name did not match pod Volume for pod %s/%s"", podNamespace, podName)
+	}
+
 	parameters := make(map[string]string)
 	if spc.Spec.Parameters != nil {
 		parameters = spc.Spec.Parameters
"
GO-2022-0629,kubernetes-sigs,secrets-store-csi-driver,c2cbb19e2eef16638fa0523383788a4bc22231fd," func (r *Reconciler) reconcile(ctx context.Context, spcps *v1alpha1.SecretProvid
 
 	// check if the volume pertaining to the current spc is using nodePublishSecretRef for
 	// accessing external secrets store
-	var nodePublishSecretRef *v1.LocalObjectReference
-	for _, vol := range pod.Spec.Volumes {
-		if vol.CSI == nil {
-			continue
-		}
-		if vol.CSI.Driver != ""secrets-store.csi.k8s.io"" {
-			continue
-		}
-		if vol.CSI.VolumeAttributes[""secretProviderClass""] != spc.Name {
-			continue
-		}
-		nodePublishSecretRef = vol.CSI.NodePublishSecretRef
-		break
-	}
+	nodePublishSecretRef := podVol.CSI.NodePublishSecretRef
 
 	var secretsJSON []byte
 	nodePublishSecretData := make(map[string]string)
"
GO-2022-0629,kubernetes-sigs,secrets-store-csi-driver,c2cbb19e2eef16638fa0523383788a4bc22231fd," func (ns *nodeServer) NodeUnpublishVolume(ctx context.Context, req *csi.NodeUnpu
 	}
 	targetPath := req.GetTargetPath()
 	volumeID := req.GetVolumeId()
-	files, err := getMountedFiles(targetPath)
+	// Assume no mounted files if GetMountedFiles fails.
+	files, _ := fileutil.GetMountedFiles(targetPath)
 
 	if isMockTargetPath(targetPath) {
 		return &csi.NodeUnpublishVolumeResponse{}, nil
 	}
 
-	podUID = getPodUIDFromTargetPath(targetPath)
+	podUID = fileutil.GetPodUIDFromTargetPath(targetPath)
 	if len(podUID) == 0 {
 		return nil, status.Error(codes.InvalidArgument, ""Cannot get podUID from Target path"")
 	}
"
GO-2021-0088,facebook,fbthrift,c461c1bd1a3e130b181aa9c854da3030cd4b5156," func Skip(self Protocol, fieldType Type, maxDepth int) (err error) {
 			}
 		}
 		return self.ReadListEnd()
+	default:
+		return fmt.Errorf(""unable to skip over unknown type id %d"", fieldType)
 	}
-	return nil
 }
"
GO-2021-0088,facebook,fbthrift,c461c1bd1a3e130b181aa9c854da3030cd4b5156," func Skip(self Protocol, fieldType Type, maxDepth int) (err error) {
 	}
 
 	switch fieldType {
-	case STOP:
-		return
 	case BOOL:
 		_, err = self.ReadBool()
 		return
"
GO-2022-1148,libp2p,go-libp2p,15d7dfbf54264ead8e6f49ca658d79c90635e2de," var muxArgTypes = newArgTypeSet(hostType, networkType, peerIDType, pstoreType)
 // using reflection.
 func MuxerConstructor(m interface{}) (MuxC, error) {
 	// Already constructed?
-	if t, ok := m.(mux.Multiplexer); ok {
-		return func(_ host.Host) (mux.Multiplexer, error) {
+	if t, ok := m.(network.Multiplexer); ok {
+		return func(_ host.Host) (network.Multiplexer, error) {
 			return t, nil
 		}, nil
 	}
"
GO-2022-1148,libp2p,go-libp2p,15d7dfbf54264ead8e6f49ca658d79c90635e2de," func makeConstructor(
 	tptType reflect.Type,
 	argTypes map[reflect.Type]constructor,
 	opts ...interface{},
-) (func(host.Host, transport.Upgrader, pnet.PSK, connmgr.ConnectionGater) (interface{}, error), error) {
+) (func(host.Host, transport.Upgrader, pnet.PSK, connmgr.ConnectionGater, network.ResourceManager) (interface{}, error), error) {
 	v := reflect.ValueOf(tpt)
 	// avoid panicing on nil/zero value.
 	if v == (reflect.Value{}) {
"
GO-2022-1148,libp2p,go-libp2p,15d7dfbf54264ead8e6f49ca658d79c90635e2de," func makeConstructor(
 		return nil, err
 	}
 
-	return func(h host.Host, u transport.Upgrader, psk pnet.PSK, cg connmgr.ConnectionGater) (interface{}, error) {
+	return func(h host.Host, u transport.Upgrader, psk pnet.PSK, cg connmgr.ConnectionGater, rcmgr network.ResourceManager) (interface{}, error) {
 		arguments := make([]reflect.Value, 0, len(argConstructors)+len(opts))
 		for i, makeArg := range argConstructors {
-			if arg := makeArg(h, u, psk, cg); arg != nil {
+			if arg := makeArg(h, u, psk, cg, rcmgr); arg != nil {
 				arguments = append(arguments, reflect.ValueOf(arg))
 			} else {
 				// ValueOf an un-typed nil yields a zero reflect
"
GO-2022-1148,libp2p,go-libp2p,15d7dfbf54264ead8e6f49ca658d79c90635e2de," func SecurityConstructor(security interface{}) (SecC, error) {
 		return nil, err
 	}
 	return func(h host.Host) (sec.SecureTransport, error) {
-		t, err := ctor(h, nil, nil, nil)
+		t, err := ctor(h, nil, nil, nil, nil)
 		if err != nil {
 			return nil, err
 		}
"
GO-2022-1148,libp2p,go-libp2p,15d7dfbf54264ead8e6f49ca658d79c90635e2de," var transportArgTypes = argTypes
 func TransportConstructor(tpt interface{}, opts ...interface{}) (TptC, error) {
 	// Already constructed?
 	if t, ok := tpt.(transport.Transport); ok {
-		return func(_ host.Host, _ transport.Upgrader, _ pnet.PSK, _ connmgr.ConnectionGater) (transport.Transport, error) {
+		return func(_ host.Host, _ transport.Upgrader, _ pnet.PSK, _ connmgr.ConnectionGater, _ network.ResourceManager) (transport.Transport, error) {
 			return t, nil
 		}, nil
 	}
"
GO-2022-1148,libp2p,go-libp2p,15d7dfbf54264ead8e6f49ca658d79c90635e2de," func TransportConstructor(tpt interface{}, opts ...interface{}) (TptC, error) {
 	if err != nil {
 		return nil, err
 	}
-	return func(h host.Host, u transport.Upgrader, psk pnet.PSK, cg connmgr.ConnectionGater) (transport.Transport, error) {
-		t, err := ctor(h, u, psk, cg)
+	return func(h host.Host, u transport.Upgrader, psk pnet.PSK, cg connmgr.ConnectionGater, rcmgr network.ResourceManager) (transport.Transport, error) {
+		t, err := ctor(h, u, psk, cg, rcmgr)
 		if err != nil {
 			return nil, err
 		}
"
GO-2022-1148,libp2p,go-libp2p,15d7dfbf54264ead8e6f49ca658d79c90635e2de," func TransportConstructor(tpt interface{}, opts ...interface{}) (TptC, error) {
 	}, nil
 }
 
-func makeTransports(h host.Host, u transport.Upgrader, cg connmgr.ConnectionGater, psk pnet.PSK, tpts []TptC) ([]transport.Transport, error) {
+func makeTransports(h host.Host, u transport.Upgrader, cg connmgr.ConnectionGater, psk pnet.PSK, rcmgr network.ResourceManager, tpts []TptC) ([]transport.Transport, error) {
 	transports := make([]transport.Transport, len(tpts))
 	for i, tC := range tpts {
-		t, err := tC(h, u, psk, cg)
+		t, err := tC(h, u, psk, cg, rcmgr)
 		if err != nil {
 			return nil, err
 		}
"
GO-2022-1148,libp2p,go-libp2p,15d7dfbf54264ead8e6f49ca658d79c90635e2de," func (c *client) DialBack(ctx context.Context, p peer.ID) (ma.Multiaddr, error)
 	if err != nil {
 		return nil, err
 	}
+
+	if err := s.Scope().SetService(ServiceName); err != nil {
+		log.Debugf(""error attaching stream to autonat service: %s"", err)
+		s.Reset()
+		return nil, err
+	}
+
+	if err := s.Scope().ReserveMemory(maxMsgSize, network.ReservationPriorityAlways); err != nil {
+		log.Debugf(""error reserving memory for autonat stream: %s"", err)
+		s.Reset()
+		return nil, err
+	}
+	defer s.Scope().ReleaseMemory(maxMsgSize)
+
 	s.SetDeadline(time.Now().Add(streamTimeout))
 	// Might as well just reset the stream. Once we get to this point, we
 	// don't care about being nice.
 	defer s.Close()
 
-	r := protoio.NewDelimitedReader(s, network.MessageSizeMax)
+	r := protoio.NewDelimitedReader(s, maxMsgSize)
 	w := protoio.NewDelimitedWriter(s)
 
 	req := newDialMessage(peer.AddrInfo{ID: c.h.ID(), Addrs: c.addrFunc()})
"
GO-2022-1148,libp2p,go-libp2p,15d7dfbf54264ead8e6f49ca658d79c90635e2de," func newAutoNATService(c *config) (*autoNATService, error) {
 }
 
 func (as *autoNATService) handleStream(s network.Stream) {
+	if err := s.Scope().SetService(ServiceName); err != nil {
+		log.Debugf(""error attaching stream to autonat service: %s"", err)
+		s.Reset()
+		return
+	}
+
+	if err := s.Scope().ReserveMemory(maxMsgSize, network.ReservationPriorityAlways); err != nil {
+		log.Debugf(""error reserving memory for autonat stream: %s"", err)
+		s.Reset()
+		return
+	}
+	defer s.Scope().ReleaseMemory(maxMsgSize)
+
 	s.SetDeadline(time.Now().Add(streamTimeout))
 	defer s.Close()
 
 	pid := s.Conn().RemotePeer()
 	log.Debugf(""New stream from %s"", pid.Pretty())
 
-	r := protoio.NewDelimitedReader(s, network.MessageSizeMax)
+	r := protoio.NewDelimitedReader(s, maxMsgSize)
 	w := protoio.NewDelimitedWriter(s)
 
 	var req pb.Message
"
GO-2022-1148,libp2p,go-libp2p,15d7dfbf54264ead8e6f49ca658d79c90635e2de," func (h *BasicHost) newStreamHandler(s network.Stream) {
 		}
 	}
 
-	s.SetProtocol(protocol.ID(protoID))
+	if err := s.SetProtocol(protocol.ID(protoID)); err != nil {
+		log.Debugf(""error setting stream protocol: %s"", err)
+		s.Reset()
+		return
+	}
+
 	log.Debugf(""protocol negotiation took %s"", took)
 
 	go handle(protoID, s)
"
GO-2022-1148,libp2p,go-libp2p,15d7dfbf54264ead8e6f49ca658d79c90635e2de," func NewRelay(h host.Host, opts ...Option) (*Relay, error) {
 		}
 	}
 
+	// get a scope for memory reservations at service level
+	err := h.Network().ResourceManager().ViewService(ServiceName,
+		func(s network.ServiceScope) error {
+			var err error
+			r.scope, err = s.BeginSpan()
+			return err
+		})
+	if err != nil {
+		return nil, err
+	}
+
 	h.SetStreamHandler(ProtoID, r.handleStream)
 
 	return r, nil
"
GO-2022-1148,libp2p,go-libp2p,15d7dfbf54264ead8e6f49ca658d79c90635e2de," func (c *Client) dialPeer(ctx context.Context, relay, dest peer.AddrInfo) (*Conn
 }
 
 func (c *Client) connectV2(s network.Stream, dest peer.AddrInfo) (*Conn, error) {
+	if err := s.Scope().ReserveMemory(maxMessageSize, network.ReservationPriorityAlways); err != nil {
+		s.Reset()
+		return nil, err
+	}
+	defer s.Scope().ReleaseMemory(maxMessageSize)
+
 	rd := util.NewDelimitedReader(s, maxMessageSize)
 	wr := util.NewDelimitedWriter(s)
 	defer rd.Close()
"
GO-2022-1148,libp2p,go-libp2p,15d7dfbf54264ead8e6f49ca658d79c90635e2de," func (c *Client) connectV2(s network.Stream, dest peer.AddrInfo) (*Conn, error)
 }
 
 func (c *Client) connectV1(s network.Stream, dest peer.AddrInfo) (*Conn, error) {
+	if err := s.Scope().ReserveMemory(maxMessageSize, network.ReservationPriorityAlways); err != nil {
+		s.Reset()
+		return nil, err
+	}
+	defer s.Scope().ReleaseMemory(maxMessageSize)
+
 	rd := util.NewDelimitedReader(s, maxMessageSize)
 	wr := util.NewDelimitedWriter(s)
 	defer rd.Close()
"
GO-2022-1148,libp2p,go-libp2p,15d7dfbf54264ead8e6f49ca658d79c90635e2de," var _ transport.Transport = (*Client)(nil)
 var _ io.Closer = (*Client)(nil)
 
 func (c *Client) Dial(ctx context.Context, a ma.Multiaddr, p peer.ID) (transport.CapableConn, error) {
+	connScope, err := c.host.Network().ResourceManager().OpenConnection(network.DirOutbound, false)
+	if err != nil {
+		return nil, err
+	}
+	if err := connScope.SetPeer(p); err != nil {
+		connScope.Done()
+		return nil, err
+	}
 	conn, err := c.dial(ctx, a, p)
 	if err != nil {
+		connScope.Done()
 		return nil, err
 	}
-
 	conn.tagHop()
-
-	return c.upgrader.Upgrade(ctx, c, conn, network.DirOutbound, p)
+	return c.upgrader.Upgrade(ctx, c, conn, network.DirOutbound, p, connScope)
 }
 
 func (c *Client) CanDial(addr ma.Multiaddr) bool {
"
GO-2022-1148,libp2p,go-libp2p,15d7dfbf54264ead8e6f49ca658d79c90635e2de," func New(h host.Host, opts ...Option) (*Relay, error) {
 		}
 	}
 
+	// get a scope for memory reservations at service level
+	err := h.Network().ResourceManager().ViewService(ServiceName,
+		func(s network.ServiceScope) error {
+			var err error
+			r.scope, err = s.BeginSpan()
+			return err
+		})
+	if err != nil {
+		return nil, err
+	}
+
 	r.constraints = newConstraints(&r.rc)
 	r.selfAddr = ma.StringCast(fmt.Sprintf(""/p2p/%s"", h.ID()))
 
"
GO-2022-1148,libp2p,go-libp2p,15d7dfbf54264ead8e6f49ca658d79c90635e2de," func New(h host.Host, opts ...Option) (*Relay, error) {
 func (r *Relay) Close() error {
 	if atomic.CompareAndSwapUint32(&r.closed, 0, 1) {
 		r.host.RemoveStreamHandler(proto.ProtoIDv2Hop)
+		r.scope.Done()
 		r.cancel()
 		r.mx.Lock()
 		for p := range r.rsvp {
"
GO-2022-1148,libp2p,go-libp2p,15d7dfbf54264ead8e6f49ca658d79c90635e2de," func (r *Relay) Close() error {
 }
 
 func (r *Relay) handleStream(s network.Stream) {
-	s.SetReadDeadline(time.Now().Add(StreamTimeout))
-
 	log.Infof(""new relay stream from: %s"", s.Conn().RemotePeer())
 
+	if err := s.Scope().SetService(ServiceName); err != nil {
+		log.Debugf(""error attaching stream to relay service: %s"", err)
+		s.Reset()
+		return
+	}
+
+	if err := s.Scope().ReserveMemory(maxMessageSize, network.ReservationPriorityAlways); err != nil {
+		log.Debugf(""error reserving memory for stream: %s"", err)
+		s.Reset()
+		return
+	}
+	defer s.Scope().ReleaseMemory(maxMessageSize)
+
 	rd := util.NewDelimitedReader(s, maxMessageSize)
 	defer rd.Close()
 
+	s.SetReadDeadline(time.Now().Add(StreamTimeout))
+
 	var msg pbv2.HopMessage
 
 	err := rd.ReadMsg(&msg)
"
GO-2022-1148,libp2p,go-libp2p,15d7dfbf54264ead8e6f49ca658d79c90635e2de," func (r *Relay) handleConnect(s network.Stream, msg *pbv2.HopMessage) {
 	src := s.Conn().RemotePeer()
 	a := s.Conn().RemoteMultiaddr()
 
+	span, err := r.scope.BeginSpan()
+	if err != nil {
+		log.Debugf(""failed to begin relay transaction: %s"", err)
+		r.handleError(s, pbv2.Status_RESOURCE_LIMIT_EXCEEDED)
+		return
+	}
+
+	fail := func(status pbv2.Status) {
+		span.Done()
+		r.handleError(s, status)
+	}
+
+	// reserve buffers for the relay
+	if err := span.ReserveMemory(2*r.rc.BufferSize, network.ReservationPriorityHigh); err != nil {
+		log.Debugf(""error reserving memory for relay: %s"", err)
+		fail(pbv2.Status_RESOURCE_LIMIT_EXCEEDED)
+		return
+	}
+
 	if isRelayAddr(a) {
 		log.Debugf(""refusing connection from %s; connection attempt over relay connection"")
-		r.handleError(s, pbv2.Status_PERMISSION_DENIED)
+		fail(pbv2.Status_PERMISSION_DENIED)
 		return
 	}
 
 	dest, err := util.PeerToPeerInfoV2(msg.GetPeer())
 	if err != nil {
-		r.handleError(s, pbv2.Status_MALFORMED_MESSAGE)
+		fail(pbv2.Status_MALFORMED_MESSAGE)
 		return
 	}
 
 	if r.acl != nil && !r.acl.AllowConnect(src, s.Conn().RemoteMultiaddr(), dest.ID) {
 		log.Debugf(""refusing connection from %s to %s; permission denied"", src, dest.ID)
-		r.handleError(s, pbv2.Status_PERMISSION_DENIED)
+		fail(pbv2.Status_PERMISSION_DENIED)
 		return
 	}
 
"
GO-2022-1148,libp2p,go-libp2p,15d7dfbf54264ead8e6f49ca658d79c90635e2de," func (r *Relay) handleConnect(s network.Stream, msg *pbv2.HopMessage) {
 	if !rsvp {
 		r.mx.Unlock()
 		log.Debugf(""refusing connection from %s to %s; no reservation"", src, dest.ID)
-		r.handleError(s, pbv2.Status_NO_RESERVATION)
+		fail(pbv2.Status_NO_RESERVATION)
 		return
 	}
 
"
GO-2022-1148,libp2p,go-libp2p,15d7dfbf54264ead8e6f49ca658d79c90635e2de," func (r *Relay) handleConnect(s network.Stream, msg *pbv2.HopMessage) {
 	if srcConns >= r.rc.MaxCircuits {
 		r.mx.Unlock()
 		log.Debugf(""refusing connection from %s to %s; too many connections from %s"", src, dest.ID, src)
-		r.handleError(s, pbv2.Status_RESOURCE_LIMIT_EXCEEDED)
+		fail(pbv2.Status_RESOURCE_LIMIT_EXCEEDED)
 		return
 	}
 
"
GO-2022-1148,libp2p,go-libp2p,15d7dfbf54264ead8e6f49ca658d79c90635e2de," func (r *Relay) handleConnect(s network.Stream, msg *pbv2.HopMessage) {
 	if destConns >= r.rc.MaxCircuits {
 		r.mx.Unlock()
 		log.Debugf(""refusing connection from %s to %s; too many connecitons to %s"", src, dest.ID, dest.ID)
-		r.handleError(s, pbv2.Status_RESOURCE_LIMIT_EXCEEDED)
+		fail(pbv2.Status_RESOURCE_LIMIT_EXCEEDED)
 		return
 	}
 
"
GO-2022-1148,libp2p,go-libp2p,15d7dfbf54264ead8e6f49ca658d79c90635e2de," func (r *Relay) handleConnect(s network.Stream, msg *pbv2.HopMessage) {
 	r.mx.Unlock()
 
 	cleanup := func() {
+		span.Done()
 		r.mx.Lock()
 		r.rmConn(src)
 		r.rmConn(dest.ID)
"
GO-2022-1148,libp2p,go-libp2p,15d7dfbf54264ead8e6f49ca658d79c90635e2de," func (r *Relay) handleConnect(s network.Stream, msg *pbv2.HopMessage) {
 		return
 	}
 
+	fail = func(status pbv2.Status) {
+		bs.Reset()
+		cleanup()
+		r.handleError(s, status)
+	}
+
+	if err := bs.Scope().SetService(ServiceName); err != nil {
+		log.Debugf(""error attaching stream to relay service: %s"", err)
+		fail(pbv2.Status_RESOURCE_LIMIT_EXCEEDED)
+		return
+	}
+
 	// handshake
+	if err := bs.Scope().ReserveMemory(maxMessageSize, network.ReservationPriorityAlways); err != nil {
+		log.Debugf(""erro reserving memory for stream: %s"", err)
+		fail(pbv2.Status_RESOURCE_LIMIT_EXCEEDED)
+		return
+	}
+	defer bs.Scope().ReleaseMemory(maxMessageSize)
+
 	rd := util.NewDelimitedReader(bs, maxMessageSize)
 	wr := util.NewDelimitedWriter(bs)
 	defer rd.Close()
"
GO-2022-1148,libp2p,go-libp2p,15d7dfbf54264ead8e6f49ca658d79c90635e2de," func (r *Relay) handleConnect(s network.Stream, msg *pbv2.HopMessage) {
 	err = wr.WriteMsg(&stopmsg)
 	if err != nil {
 		log.Debugf(""error writing stop handshake"")
-		bs.Reset()
-		cleanup()
-		r.handleError(s, pbv2.Status_CONNECTION_FAILED)
+		fail(pbv2.Status_CONNECTION_FAILED)
 		return
 	}
 
"
GO-2022-1148,libp2p,go-libp2p,15d7dfbf54264ead8e6f49ca658d79c90635e2de," func (r *Relay) handleConnect(s network.Stream, msg *pbv2.HopMessage) {
 	err = rd.ReadMsg(&stopmsg)
 	if err != nil {
 		log.Debugf(""error reading stop response: %s"", err.Error())
-		bs.Reset()
-		cleanup()
-		r.handleError(s, pbv2.Status_CONNECTION_FAILED)
+		fail(pbv2.Status_CONNECTION_FAILED)
 		return
 	}
 
 	if t := stopmsg.GetType(); t != pbv2.StopMessage_STATUS {
 		log.Debugf(""unexpected stop response; not a status message (%d)"", t)
-		bs.Reset()
-		cleanup()
-		r.handleError(s, pbv2.Status_CONNECTION_FAILED)
+		fail(pbv2.Status_CONNECTION_FAILED)
 		return
 	}
 
 	if status := stopmsg.GetStatus(); status != pbv2.Status_OK {
 		log.Debugf(""relay stop failure: %d"", status)
-		bs.Reset()
-		cleanup()
-		r.handleError(s, pbv2.Status_CONNECTION_FAILED)
+		fail(pbv2.Status_CONNECTION_FAILED)
 		return
 	}
 
"
GO-2022-1148,libp2p,go-libp2p,15d7dfbf54264ead8e6f49ca658d79c90635e2de," func (hs *Service) Close() error {
 func (hs *Service) initiateHolePunch(rp peer.ID) ([]ma.Multiaddr, time.Duration, error) {
 	hpCtx := network.WithUseTransient(hs.ctx, ""hole-punch"")
 	sCtx := network.WithNoDial(hpCtx, ""hole-punch"")
+
 	str, err := hs.host.NewStream(sCtx, rp, Protocol)
 	if err != nil {
 		return nil, 0, fmt.Errorf(""failed to open hole-punching stream: %w"", err)
 	}
 	defer str.Close()
-	str.SetDeadline(time.Now().Add(StreamTimeout))
+
+	if err := str.Scope().SetService(ServiceName); err != nil {
+		log.Debugf(""error attaching stream to holepunch service: %s"", err)
+		str.Reset()
+		return nil, 0, err
+	}
+
+	if err := str.Scope().ReserveMemory(maxMsgSize, network.ReservationPriorityAlways); err != nil {
+		log.Debugf(""error reserving memory for stream: %s, err"")
+		str.Reset()
+		return nil, 0, err
+	}
+	defer str.Scope().ReleaseMemory(maxMsgSize)
 
 	w := protoio.NewDelimitedWriter(str)
+	rd := protoio.NewDelimitedReader(str, maxMsgSize)
 
+	str.SetDeadline(time.Now().Add(StreamTimeout))
 	// send a CONNECT and start RTT measurement.
 	msg := &pb.HolePunch{
 		Type:     pb.HolePunch_CONNECT.Enum(),
"
GO-2022-1148,libp2p,go-libp2p,15d7dfbf54264ead8e6f49ca658d79c90635e2de," func (hs *Service) incomingHolePunch(s network.Stream) (rtt time.Duration, addrs
 		return 0, nil, errors.New(""rejecting hole punch request, as we don't have any public addresses"")
 	}
 
-	s.SetDeadline(time.Now().Add(StreamTimeout))
+	if err := s.Scope().ReserveMemory(maxMsgSize, network.ReservationPriorityAlways); err != nil {
+		log.Debugf(""error reserving memory for stream: %s, err"")
+		return 0, nil, err
+	}
+	defer s.Scope().ReleaseMemory(maxMsgSize)
+
 	wr := protoio.NewDelimitedWriter(s)
 	rd := protoio.NewDelimitedReader(s, maxMsgSize)
 
 	// Read Connect message
 	msg := new(pb.HolePunch)
+
+	s.SetDeadline(time.Now().Add(StreamTimeout))
+
 	if err := rd.ReadMsg(msg); err != nil {
 		return 0, nil, fmt.Errorf(""failed to read message from initator: %w"", err)
 	}
"
GO-2022-1148,libp2p,go-libp2p,15d7dfbf54264ead8e6f49ca658d79c90635e2de," func (hs *Service) handleNewStream(s network.Stream) {
 		s.Reset()
 		return
 	}
+
+	if err := s.Scope().SetService(ServiceName); err != nil {
+		log.Debugf(""error attaching stream to holepunch service: %s"", err)
+		s.Reset()
+		return
+	}
+
 	rp := s.Conn().RemotePeer()
 	rtt, addrs, err := hs.incomingHolePunch(s)
 	if err != nil {
"
GO-2022-1148,libp2p,go-libp2p,15d7dfbf54264ead8e6f49ca658d79c90635e2de," func (hs *Service) initiateHolePunch(rp peer.ID) ([]ma.Multiaddr, time.Duration,
 	}
 
 	// wait for a CONNECT message from the remote peer
-	rd := protoio.NewDelimitedReader(str, maxMsgSize)
 	msg.Reset()
 	if err := rd.ReadMsg(msg); err != nil {
 		str.Reset()
"
GO-2023-2000,libp2p,go-libp2p,0cce607219f3710addc7e18672cffd1f1d912fbb," func GenerateRSAKeyPair(bits int, src io.Reader) (PrivKey, PubKey, error) {
 	if bits < MinRsaKeyBits {
 		return nil, nil, ErrRsaKeyTooSmall
 	}
+	if bits > maxRsaKeyBits {
+		return nil, nil, ErrRsaKeyTooBig
+	}
 	priv, err := rsa.GenerateKey(src, bits)
 	if err != nil {
 		return nil, nil, err
"
GO-2023-2000,libp2p,go-libp2p,0cce607219f3710addc7e18672cffd1f1d912fbb," func UnmarshalRsaPrivateKey(b []byte) (key PrivKey, err error) {
 	if sk.N.BitLen() < MinRsaKeyBits {
 		return nil, ErrRsaKeyTooSmall
 	}
+	if sk.N.BitLen() > maxRsaKeyBits {
+		return nil, ErrRsaKeyTooBig
+	}
 	return &RsaPrivateKey{sk: *sk}, nil
 }
 
"
GO-2023-2000,libp2p,go-libp2p,0cce607219f3710addc7e18672cffd1f1d912fbb," func UnmarshalRsaPublicKey(b []byte) (key PubKey, err error) {
 	if pk.N.BitLen() < MinRsaKeyBits {
 		return nil, ErrRsaKeyTooSmall
 	}
+	if pk.N.BitLen() > maxRsaKeyBits {
+		return nil, ErrRsaKeyTooBig
+	}
 
 	return &RsaPublicKey{k: *pk}, nil
 }
"
GO-2022-1213,go-macaron,csrf,dadd1711a617000b70e5e408a76531b73187031c," func Generate(options ...Options) macaron.Handler {
 			// FIXME: actionId.
 			x.Token = GenerateToken(x.Secret, x.ID, ""POST"")
 			if opt.SetCookie {
-				ctx.SetCookie(opt.Cookie, x.Token, 0, opt.CookiePath, """", false, opt.CookieHttpOnly, time.Now().AddDate(0, 0, 1))
+				ctx.SetCookie(opt.Cookie, x.Token, 0, opt.CookiePath, """", opt.Secure, opt.CookieHttpOnly, time.Now().AddDate(0, 0, 1))
 			}
 		}
 
"
GO-2022-0755,rancher,rancher,0ddffe484adccb9e37d9432e8e625d8ebbfb0088," func New(localConfig *rest.Config, lookup ClusterLookup, dialer dialer.Factory,
 func (r *Router) ServeHTTP(rw http.ResponseWriter, req *http.Request) {
 	c, handler, err := r.serverFactory.get(req)
 	if err != nil {
-		response(rw, httperror.ServerError, err.Error())
+		e, ok := err.(*httperror.APIError)
+		if ok {
+			response(rw, e.Code, e.Message)
+		} else {
+			response(rw, httperror.ServerError, err.Error())
+		}
 		return
 	}
 
"
GO-2022-0755,rancher,rancher,0ddffe484adccb9e37d9432e8e625d8ebbfb0088," func Start(ctx context.Context, httpPort, httpsPort int, localClusterEnabled boo
 	if err != nil {
 		return err
 	}
+	websocketHandler := websocket.NewWebsocketHandler(authedHandler)
 
-	auditHandler := audit.NewAuditLogFilter(ctx, auditLogWriter, authedHandler)
+	auditHandler := audit.NewAuditLogFilter(ctx, auditLogWriter, websocketHandler)
 
 	webhookHandler := hooks.New(scaledContext)
 
"
GO-2021-0054,tidwall,gjson,bf4efcb3c18d1825b2988603dea5909140a5302b," func execModifier(json, path string) (pathOut, res string, ok bool) {
 // unwrap removes the '[]' or '{}' characters around json
 func unwrap(json string) string {
 	json = trim(json)
-	if len(json) >= 2 && json[0] == '[' || json[0] == '{' {
+	if len(json) >= 2 && (json[0] == '[' || json[0] == '{') {
 		json = json[1 : len(json)-1]
 	}
 	return json
"
GO-2023-2137,ydb-platform,ydb-go-sdk,a0d92057c4e1bbdc5e85ae8d649edb0232b8fd4c," func connect(ctx context.Context, c *Driver) error {
 		c.config = c.config.With(config.WithCredentials(
 			credentials.NewStaticCredentials(
 				c.userInfo.User, c.userInfo.Password,
-				c.config,
+				c.config.Endpoint(),
+				credentials.WithGrpcDialOptions(c.config.GrpcDialOptions()...),
 			),
 		))
 	}
"
GO-2023-2137,ydb-platform,ydb-go-sdk,a0d92057c4e1bbdc5e85ae8d649edb0232b8fd4c," func (b *Balancer) clusterDiscovery(ctx context.Context) (err error) {
 	if err = retry.Retry(ctx, func(childCtx context.Context) (err error) {
 		if err = b.clusterDiscoveryAttempt(childCtx); err != nil {
 			if xerrors.IsTransportError(err, grpcCodes.Unauthenticated) {
-				return xerrors.WithStackTrace(
-					fmt.Errorf(
-						""cluster discovery failed: %w (endpoint: %q, database: %q, credentials: %q)"",
-						err,
-						b.driverConfig.Endpoint(),
-						b.driverConfig.Database(),
-						b.driverConfig.Credentials(),
-					),
+				return credentials.UnauthenticatedError(""cluster discovery failed"", err,
+					credentials.WithEndpoint(b.driverConfig.Endpoint()),
+					credentials.WithDatabase(b.driverConfig.Database()),
+					credentials.WithCredentials(b.driverConfig.Credentials()),
 				)
 			}
 			// if got err but parent context is not done - mark error as retryable
"
GO-2023-2137,ydb-platform,ydb-go-sdk,a0d92057c4e1bbdc5e85ae8d649edb0232b8fd4c," func (b *Balancer) wrapCall(ctx context.Context, f func(ctx context.Context, cc
 
 	if err = f(ctx, cc); err != nil {
 		if conn.UseWrapping(ctx) {
+			if xerrors.IsTransportError(err, grpcCodes.Unauthenticated) {
+				err = credentials.UnauthenticatedError(""unauthenticated"", err,
+					credentials.WithAddress(cc.Endpoint().String()),
+					credentials.WithNodeID(cc.Endpoint().NodeID()),
+					credentials.WithCredentials(b.driverConfig.Credentials()),
+				)
+			}
 			return xerrors.WithStackTrace(err)
 		}
 		return err
"
GO-2023-2137,ydb-platform,ydb-go-sdk,a0d92057c4e1bbdc5e85ae8d649edb0232b8fd4c," type AccessToken struct {
 	sourceInfo string
 }
 
-func NewAccessTokenCredentials(token string, opts ...Option) *AccessToken {
-	options := optionsHolder{
+func NewAccessTokenCredentials(token string, opts ...AccessTokenCredentialsOption) *AccessToken {
+	c := &AccessToken{
+		token:      token,
 		sourceInfo: stack.Record(1),
 	}
 	for _, opt := range opts {
-		opt(&options)
-	}
-	return &AccessToken{
-		token:      token,
-		sourceInfo: options.sourceInfo,
+		opt.ApplyAccessTokenCredentialsOption(c)
 	}
+	return c
 }
 
 // Token implements Credentials.
"
GO-2023-2137,ydb-platform,ydb-go-sdk,a0d92057c4e1bbdc5e85ae8d649edb0232b8fd4c," func (c AccessToken) Token(_ context.Context) (string, error) {
 
 // Token implements Credentials.
 func (c AccessToken) String() string {
-	return fmt.Sprintf(""AccessToken(token:%q,from:%q)"", secret.Token(c.token), c.sourceInfo)
+	buffer := allocator.Buffers.Get()
+	defer allocator.Buffers.Put(buffer)
+	buffer.WriteString(""AccessToken(token:"")
+	fmt.Fprintf(buffer, ""%q"", secret.Token(c.token))
+	if c.sourceInfo != """" {
+		buffer.WriteString("",from:"")
+		fmt.Fprintf(buffer, ""%q"", c.sourceInfo)
+	}
+	buffer.WriteByte(')')
+	return buffer.String()
 }
"
GO-2023-2137,ydb-platform,ydb-go-sdk,a0d92057c4e1bbdc5e85ae8d649edb0232b8fd4c," import (
 	""context""
 	""fmt""
 
+	""github.com/ydb-platform/ydb-go-sdk/v3/internal/allocator""
 	""github.com/ydb-platform/ydb-go-sdk/v3/internal/stack""
 )
 
 var (
-	_ Credentials  = (*Anonymous)(nil)
-	_ fmt.Stringer = (*Anonymous)(nil)
+	_ Credentials                = (*Anonymous)(nil)
+	_ fmt.Stringer               = (*Anonymous)(nil)
+	_ AnonymousCredentialsOption = SourceInfoOption("""")
 )
 
+type AnonymousCredentialsOption interface {
+	ApplyAnonymousCredentialsOption(c *Anonymous)
+}
+
 // Anonymous implements Credentials interface with Anonymous access
 type Anonymous struct {
 	sourceInfo string
 }
 
-func NewAnonymousCredentials(opts ...Option) *Anonymous {
-	options := optionsHolder{
+func NewAnonymousCredentials(opts ...AnonymousCredentialsOption) *Anonymous {
+	c := &Anonymous{
 		sourceInfo: stack.Record(1),
 	}
 	for _, opt := range opts {
-		opt(&options)
-	}
-	return &Anonymous{
-		sourceInfo: options.sourceInfo,
+		opt.ApplyAnonymousCredentialsOption(c)
 	}
+	return c
 }
 
 // Token implements Credentials.
"
GO-2023-2137,ydb-platform,ydb-go-sdk,a0d92057c4e1bbdc5e85ae8d649edb0232b8fd4c," func (c Anonymous) Token(_ context.Context) (string, error) {
 
 // Token implements Credentials.
 func (c Anonymous) String() string {
-	return fmt.Sprintf(""Anonymous(from:%q)"", c.sourceInfo)
+	buffer := allocator.Buffers.Get()
+	defer allocator.Buffers.Put(buffer)
+	buffer.WriteString(""Anonymous("")
+	if c.sourceInfo != """" {
+		buffer.WriteString(""from:"")
+		fmt.Fprintf(buffer, ""%q"", c.sourceInfo)
+	}
+	buffer.WriteByte(')')
+	return buffer.String()
 }
"
GO-2023-2137,ydb-platform,ydb-go-sdk,a0d92057c4e1bbdc5e85ae8d649edb0232b8fd4c," func parseExpiresAt(raw string) (expiresAt time.Time, err error) {
 }
 
 func (c *Static) String() string {
-	return fmt.Sprintf(
-		""Static(user:%q,password:%q,token:%q,from:%q)"",
-		c.user,
-		secret.Password(c.password),
-		secret.Token(c.token),
-		c.sourceInfo,
-	)
+	buffer := allocator.Buffers.Get()
+	defer allocator.Buffers.Put(buffer)
+	buffer.WriteString(""Static(user:"")
+	fmt.Fprintf(buffer, ""%q"", c.user)
+	buffer.WriteString("",password:"")
+	fmt.Fprintf(buffer, ""%q"", secret.Password(c.password))
+	buffer.WriteString("",token:"")
+	fmt.Fprintf(buffer, ""%q"", secret.Token(c.token))
+	if c.sourceInfo != """" {
+		buffer.WriteString("",from:"")
+		fmt.Fprintf(buffer, ""%q"", c.sourceInfo)
+	}
+	buffer.WriteByte(')')
+	return buffer.String()
 }
"
GO-2023-2137,ydb-platform,ydb-go-sdk,a0d92057c4e1bbdc5e85ae8d649edb0232b8fd4c," func WithBeforeFunc(
 		},
 	}
 }
-
-func WithAfterFunc(
-	cc grpc.ClientConnInterface,
-	after func(),
-) grpc.ClientConnInterface {
-	return &middleware{
-		invoke: func(ctx context.Context, method string, args interface{}, reply interface{}, opts ...grpc.CallOption) error {
-			defer after()
-			return cc.Invoke(ctx, method, args, reply, opts...)
-		},
-		newStream: func(ctx context.Context, desc *grpc.StreamDesc, method string, opts ...grpc.CallOption) (
-			grpc.ClientStream, error,
-		) {
-			defer after()
-			return cc.NewStream(ctx, desc, method, opts...)
-		},
-	}
-}
"
GO-2021-0073,git-lfs,git-lfs,f913f5f9c7c6d1301785fdf9884a2942d59cdf19," func (c *sshAuthClient) Resolve(e Endpoint, method string) (sshAuthResponse, err
 }
 
 func sshGetLFSExeAndArgs(osEnv Env, e Endpoint, method string) (string, []string) {
-	operation := endpointOperation(e, method)
-	tracerx.Printf(""ssh: %s git-lfs-authenticate %s %s"",
-		e.SshUserAndHost, e.SshPath, operation)
-
 	exe, args := sshGetExeAndArgs(osEnv, e)
-	return exe, append(args,
-		fmt.Sprintf(""git-lfs-authenticate %s %s"", e.SshPath, operation))
+	operation := endpointOperation(e, method)
+	args = append(args, fmt.Sprintf(""git-lfs-authenticate %s %s"", e.SshPath, operation))
+	tracerx.Printf(""run_command: %s %s"", exe, strings.Join(args, "" ""))
+	return exe, args
 }
 
 // Return the executable name for ssh on this machine and the base args
"
GO-2021-0084,beego,beego,bac2b31afecc65d9a89f9e473b8006c5edc0c8d1," func (fp *FileProvider) SessionRead(sid string) (Store, error) {
 	filepder.lock.Lock()
 	defer filepder.lock.Unlock()
 
-	err := os.MkdirAll(path.Join(fp.savePath, string(sid[0]), string(sid[1])), 0777)
+	err := os.MkdirAll(path.Join(fp.savePath, string(sid[0]), string(sid[1])), 0755)
 	if err != nil {
 		SLogger.Println(err.Error())
 	}
"
GO-2021-0084,beego,beego,bac2b31afecc65d9a89f9e473b8006c5edc0c8d1," func (fp *FileProvider) SessionRegenerate(oldsid, sid string) (Store, error) {
 		return nil, fmt.Errorf(""newsid %s exist"", newSidFile)
 	}
 
-	err = os.MkdirAll(newPath, 0777)
+	err = os.MkdirAll(newPath, 0755)
 	if err != nil {
 		SLogger.Println(err.Error())
 	}
"
GO-2021-0081,containers,image,634605d06e738aec8332bcfd69162e7509ac7aaf," func (c *dockerClient) getBearerToken(ctx context.Context, challenge challenge,
 		authReq.SetBasicAuth(c.username, c.password)
 	}
 	logrus.Debugf(""%s %s"", authReq.Method, authReq.URL.String())
-	tr := tlsclientconfig.NewTransport()
-	// TODO(runcom): insecure for now to contact the external token service
-	tr.TLSClientConfig = &tls.Config{InsecureSkipVerify: true}
-	client := &http.Client{Transport: tr}
-	res, err := client.Do(authReq)
+	res, err := c.client.Do(authReq)
 	if err != nil {
 		return nil, err
 	}
"
GO-2023-1549,openshift,apiserver-library-go,30f75d79e424ca462c6de53ee8b93f91183763e6," func (s *strategy) validateProfile(fldPath *field.Path, profile string) *field.E
 		// This means that we now have to automatically allow `runtime/default`
 		// if a user specifies `docker/default` and vice versa in an SCC.
 		if s.runtimeDefaultAllowed &&
-			(p == v1.DeprecatedSeccompProfileDockerDefault ||
-				p == v1.SeccompProfileRuntimeDefault) {
+			(profile == v1.DeprecatedSeccompProfileDockerDefault ||
+				profile == v1.SeccompProfileRuntimeDefault) {
 			return nil
 		}
 	}
"
GO-2021-0104,pion,webrtc,545613dcdeb5dedb01cce94175f40bcbe045df2e," func (t *DTLSTransport) Start(remoteParameters DTLSParameters) error {
 		return ErrNoSRTPProtectionProfile
 	}
 
-	t.conn = dtlsConn
-	t.onStateChange(DTLSTransportStateConnected)
-
 	if t.api.settingEngine.disableCertificateFingerprintVerification {
 		return nil
 	}
 
 	// Check the fingerprint if a certificate was exchanged
-	remoteCerts := t.conn.ConnectionState().PeerCertificates
+	remoteCerts := dtlsConn.ConnectionState().PeerCertificates
 	if len(remoteCerts) == 0 {
 		t.onStateChange(DTLSTransportStateFailed)
 		return errNoRemoteCertificate
"
GO-2021-0104,pion,webrtc,545613dcdeb5dedb01cce94175f40bcbe045df2e," func (t *DTLSTransport) Start(remoteParameters DTLSParameters) error {
 
 	parsedRemoteCert, err := x509.ParseCertificate(t.remoteCertificate)
 	if err != nil {
+		if closeErr := dtlsConn.Close(); closeErr != nil {
+			t.log.Error(err.Error())
+		}
+
 		t.onStateChange(DTLSTransportStateFailed)
 		return err
 	}
 
 	if err = t.validateFingerPrint(parsedRemoteCert); err != nil {
+		if closeErr := dtlsConn.Close(); closeErr != nil {
+			t.log.Error(err.Error())
+		}
+
 		t.onStateChange(DTLSTransportStateFailed)
 		return err
 	}
 
+	t.conn = dtlsConn
+	t.onStateChange(DTLSTransportStateConnected)
+
 	return t.startSRTP()
 }
 
"
GO-2022-1167,helm,helm,3636f6824757ff734cb265b8770efe48c1fb3737," func runeSet(r []rune) map[rune]bool {
 	return s
 }
 
-func (t *parser) key(data map[string]interface{}) (reterr error) {
+func (t *parser) key(data map[string]interface{}, nestedNameLevel int) (reterr error) {
 	defer func() {
 		if r := recover(); r != nil {
 			reterr = fmt.Errorf(""unable to parse key: %s"", r)
"
GO-2022-1167,helm,helm,3636f6824757ff734cb265b8770efe48c1fb3737," func (t *parser) key(data map[string]interface{}) (reterr error) {
 			}
 
 			// Now we need to get the value after the ].
-			list, err = t.listItem(list, i)
+			list, err = t.listItem(list, i, nestedNameLevel)
 			set(data, kk, list)
 			return err
 		case last == '=':
"
GO-2022-1167,helm,helm,3636f6824757ff734cb265b8770efe48c1fb3737," func (t *parser) key(data map[string]interface{}) (reterr error) {
 			set(data, string(k), """")
 			return errors.Errorf(""key %q has no value (cannot end with ,)"", string(k))
 		case last == '.':
+			// Check value name is within the maximum nested name level
+			nestedNameLevel++
+			if nestedNameLevel > MaxNestedNameLevel {
+				return fmt.Errorf(""value name nested level is greater than maximum supported nested level of %d"", MaxNestedNameLevel)
+			}
+
 			// First, create or find the target map.
 			inner := map[string]interface{}{}
 			if _, ok := data[string(k)]; ok {
"
GO-2022-1167,helm,helm,3636f6824757ff734cb265b8770efe48c1fb3737," func (t *parser) key(data map[string]interface{}) (reterr error) {
 			}
 
 			// Recurse
-			e := t.key(inner)
-			if len(inner) == 0 {
+			e := t.key(inner, nestedNameLevel)
+			if e == nil && len(inner) == 0 {
 				return errors.Errorf(""key map %q has no value"", string(k))
 			}
-			set(data, string(k), inner)
+			if len(inner) != 0 {
+				set(data, string(k), inner)
+			}
 			return e
 		}
 	}
"
GO-2021-0083,hybridgroup,gobot,c1aa4f867846da4669ecf3bc3318bd96b7ee6f3f," func (a *Adaptor) newTLSConfig() *tls.Config {
 		ClientCAs: nil,
 		// InsecureSkipVerify = verify that cert contents
 		// match server. IP matches what is in cert etc.
-		InsecureSkipVerify: true,
+		InsecureSkipVerify: false,
 		// Certificates = list of certs client sends to server.
 		Certificates: certs,
 	}
"
GO-2022-0952,matrix-org,gomatrixserverlib,723fd495dde835d078b9f2074b6b62c06dea4575," func NewPowerLevelContentFromEvent(event *Event) (c PowerLevelContent, err error
 			UsersDefaultLevel  levelJSONValue            `json:""users_default""`
 			EventLevels        map[string]levelJSONValue `json:""events""`
 			StateDefaultLevel  levelJSONValue            `json:""state_default""`
-			EventDefaultLevel  levelJSONValue            `json:""event_default""`
+			EventDefaultLevel  levelJSONValue            `json:""events_default""`
 			NotificationLevels map[string]levelJSONValue `json:""notifications""`
 		}
 		if err = json.Unmarshal(event.Content(), &content); err != nil {
"
GO-2021-0412,containerd,imgcrypt,6fdd9818a4d8142107b7ecd767d839c9707700d9," func cryptManifestList(ctx context.Context, cs content.Store, desc ocispec.Descr
 	var newManifests []ocispec.Descriptor
 	modified := false
 	for _, manifest := range index.Manifests {
+		if cryptoOp == cryptoOpUnwrapOnly && !isLocalPlatform(manifest.Platform) {
+			continue
+		}
 		newManifest, m, err := cryptChildren(ctx, cs, manifest, cc, lf, cryptoOp, manifest.Platform)
 		if err != nil || cryptoOp == cryptoOpUnwrapOnly {
 			return ocispec.Descriptor{}, false, err
"
GO-2021-0412,containerd,imgcrypt,6fdd9818a4d8142107b7ecd767d839c9707700d9," func cryptManifestList(ctx context.Context, cs content.Store, desc ocispec.Descr
 		}
 		newManifests = append(newManifests, newManifest)
 	}
+	if cryptoOp == cryptoOpUnwrapOnly {
+		return ocispec.Descriptor{}, false, fmt.Errorf(""No manifest found for local platform"")
+	}
 
 	if modified {
 		// we need to update the index
"
GO-2020-0043,caddyserver,caddy,4d9ee000c8d2cbcdd8284007c1e0f2da7bc3c7c3," func (h *httpContext) InspectServerBlocks(sourceFile string, serverBlocks []cadd
 // MakeServers uses the newly-created siteConfigs to
 // create and return a list of server instances.
 func (h *httpContext) MakeServers() ([]caddy.Server, error) {
-	// make sure TLS is disabled for explicitly-HTTP sites
-	// (necessary when HTTP address shares a block containing tls)
+	// Iterate each site configuration and make sure that:
+	// 1) TLS is disabled for explicitly-HTTP sites (necessary
+	//    when an HTTP address shares a block containing tls)
+	// 2) if QUIC is enabled, TLS ClientAuth is not, because
+	//    currently, QUIC does not support ClientAuth (TODO:
+	//    revisit this when our QUIC implementation supports it)
+	// 3) if TLS ClientAuth is used, StrictHostMatching is on
 	for _, cfg := range h.siteConfigs {
 		if !cfg.TLS.Enabled {
 			continue
"
GO-2020-0043,caddyserver,caddy,4d9ee000c8d2cbcdd8284007c1e0f2da7bc3c7c3," func (h *httpContext) MakeServers() ([]caddy.Server, error) {
 			// instead of 443 because it doesn't know about TLS.
 			cfg.Addr.Port = HTTPSPort
 		}
+		if cfg.TLS.ClientAuth != tls.NoClientCert {
+			if QUIC {
+				return nil, fmt.Errorf(""cannot enable TLS client authentication with QUIC, because QUIC does not yet support it"")
+			}
+			// this must be enabled so that a client cannot connect
+			// using SNI for another site on this listener that
+			// does NOT require ClientAuth, and then send HTTP
+			// requests with the Host header of this site which DOES
+			// require client auth, thus bypassing it...
+			cfg.StrictHostMatching = true
+		}
 	}
 
 	// we must map (group) each config to a bind address
"
GO-2020-0043,caddyserver,caddy,4d9ee000c8d2cbcdd8284007c1e0f2da7bc3c7c3," func (s *Server) serveHTTP(w http.ResponseWriter, r *http.Request) (int, error)
 		r.URL = trimPathPrefix(r.URL, pathPrefix)
 	}
 
+	// enforce strict host matching, which ensures that the SNI
+	// value (if any), matches the Host header; essential for
+	// sites that rely on TLS ClientAuth sharing a port with
+	// sites that do not - if mismatched, close the connection
+	if vhost.StrictHostMatching && r.TLS != nil &&
+		strings.ToLower(r.TLS.ServerName) != strings.ToLower(hostname) {
+		r.Close = true
+		log.Printf(""[ERROR] %s - strict host matching: SNI (%s) and HTTP Host (%s) values differ"",
+			vhost.Addr, r.TLS.ServerName, hostname)
+		return http.StatusForbidden, nil
+	}
+
 	return vhost.middlewareChain.ServeHTTP(w, r)
 }
 
"
GO-2020-0043,caddyserver,caddy,4d9ee000c8d2cbcdd8284007c1e0f2da7bc3c7c3," func assertConfigsCompatible(cfg1, cfg2 *Config) error {
 	if c1.ClientAuth != c2.ClientAuth {
 		return fmt.Errorf(""client authentication policy mismatch"")
 	}
+	if c1.ClientAuth != tls.NoClientCert && c2.ClientAuth != tls.NoClientCert && c1.ClientCAs != c2.ClientCAs {
+		// Two hosts defined on the same listener are not compatible if they
+		// have ClientAuth enabled, because there's no guarantee beyond the
+		// hostname which config will be used (because SNI only has server name).
+		// To prevent clients from bypassing authentication, require that
+		// ClientAuth be configured in an unambiguous manner.
+		return fmt.Errorf(""multiple hosts requiring client authentication ambiguously configured"")
+	}
 
 	return nil
 }
"
GO-2021-0071,lxc,lxd,19c6961cc1012c8a529f20807328a9357f5034f4," func GetOwner(path string) (int, int, error) {
 }
 
 func (set *IdmapSet) doUidshiftIntoContainer(dir string, testmode bool, how string) error {
+	dir = strings.TrimRight(dir, ""/"")
+
 	convert := func(path string, fi os.FileInfo, err error) (e error) {
 		uid, gid, err := GetOwner(path)
 		if err != nil {
"
GO-2021-0071,lxc,lxd,19c6961cc1012c8a529f20807328a9357f5034f4," func (set *IdmapSet) doUidshiftIntoContainer(dir string, testmode bool, how stri
 		if testmode {
 			fmt.Printf(""I would shift %q to %d %d\n"", path, newuid, newgid)
 		} else {
-			err = os.Lchown(path, int(newuid), int(newgid))
-			if err == nil {
-				m := fi.Mode()
-				if m&os.ModeSymlink == 0 {
-					err = os.Chmod(path, m)
-					if err != nil {
-						fmt.Printf(""Error resetting mode on %q, continuing\n"", path)
-					}
-				}
+			err = ShiftOwner(dir, path, int(newuid), int(newgid))
+			if err != nil {
+				return err
 			}
 		}
 		return nil
"
GO-2022-1178,bradleyfalzon,ghinstallation,d24f14f8be70d94129d76026e8b0f4f9170c8c3e," func (t *Transport) refreshToken(ctx context.Context) error {
 	defer resp.Body.Close()
 
 	if resp.StatusCode/100 != 2 {
-		return fmt.Errorf(""request %+v received non 2xx response status %q with body %+v and TLS %+v"", resp.Request, resp.Body, resp.Request, resp.TLS)
+		return fmt.Errorf(""received non 2xx response status %q when fetching %v"", resp.Status, req.URL)
 	}
 
 	return json.NewDecoder(resp.Body).Decode(&t.token)
"
GO-2022-0435,go.googlesource.com,go,37065847d87df92b5eb246c88ba2085efcf0b331," func p256GetScalar(out *[32]byte, in []byte) {
 	n := new(big.Int).SetBytes(in)
 	var scalarBytes []byte
 
-	if n.Cmp(p256Params.N) >= 0 {
+	if n.Cmp(p256Params.N) >= 0 || len(in) > len(out) {
 		n.Mod(n, p256Params.N)
 		scalarBytes = n.Bytes()
 	} else {
"
GO-2022-0521,go.googlesource.com,go,08c46ed43d80bbb67cb904944ea3417989be4af3," Loop:
 }
 
 // Skip reads tokens until it has consumed the end element
-// matching the most recent start element already consumed.
-// It recurs if it encounters a start element, so it can be used to
-// skip nested structures.
+// matching the most recent start element already consumed,
+// skipping nested structures.
 // It returns nil if it finds an end element matching the start
 // element; otherwise it returns an error describing the problem.
 func (d *Decoder) Skip() error {
+	var depth int64
 	for {
 		tok, err := d.Token()
 		if err != nil {
"
GO-2022-0521,go.googlesource.com,go,08c46ed43d80bbb67cb904944ea3417989be4af3," func (d *Decoder) Skip() error {
 		}
 		switch tok.(type) {
 		case StartElement:
-			if err := d.Skip(); err != nil {
-				return err
-			}
+			depth++
 		case EndElement:
-			return nil
+			if depth == 0 {
+				return nil
+			}
+			depth--
 		}
 	}
 }
"
GO-2022-0220,go.googlesource.com,go,9b6e9f0c8c66355c0f0575d808b32f52c8c6d21c," func loadOptionalSyscalls() {
 	_AddDllDirectory = windowsFindfunc(k32, []byte(""AddDllDirectory\000""))
 	_AddVectoredContinueHandler = windowsFindfunc(k32, []byte(""AddVectoredContinueHandler\000""))
 	_GetQueuedCompletionStatusEx = windowsFindfunc(k32, []byte(""GetQueuedCompletionStatusEx\000""))
+	_LoadLibraryExA = windowsFindfunc(k32, []byte(""LoadLibraryExA\000""))
 	_LoadLibraryExW = windowsFindfunc(k32, []byte(""LoadLibraryExW\000""))
+	useLoadLibraryEx = (_LoadLibraryExW != nil && _LoadLibraryExA != nil && _AddDllDirectory != nil)
 
 	var advapi32dll = []byte(""advapi32.dll\000"")
-	a32 := stdcall1(_LoadLibraryA, uintptr(unsafe.Pointer(&advapi32dll[0])))
+	a32 := windowsLoadSystemLib(advapi32dll)
 	if a32 == 0 {
 		throw(""advapi32.dll not found"")
 	}
 	_RtlGenRandom = windowsFindfunc(a32, []byte(""SystemFunction036\000""))
 
 	var ntdll = []byte(""ntdll.dll\000"")
-	n32 := stdcall1(_LoadLibraryA, uintptr(unsafe.Pointer(&ntdll[0])))
+	n32 := windowsLoadSystemLib(ntdll)
 	if n32 == 0 {
 		throw(""ntdll.dll not found"")
 	}
"
GO-2022-0220,go.googlesource.com,go,9b6e9f0c8c66355c0f0575d808b32f52c8c6d21c," func loadOptionalSyscalls() {
 		}
 	}
 
+	var winmmdll = []byte(""winmm.dll\000"")
+	m32 := windowsLoadSystemLib(winmmdll)
+	if m32 == 0 {
+		throw(""winmm.dll not found"")
+	}
+	_timeBeginPeriod = windowsFindfunc(m32, []byte(""timeBeginPeriod\000""))
+	_timeEndPeriod = windowsFindfunc(m32, []byte(""timeEndPeriod\000""))
+	if _timeBeginPeriod == nil || _timeEndPeriod == nil {
+		throw(""timeBegin/EndPeriod not found"")
+	}
+
+	var ws232dll = []byte(""ws2_32.dll\000"")
+	ws232 := windowsLoadSystemLib(ws232dll)
+	if ws232 == 0 {
+		throw(""ws2_32.dll not found"")
+	}
+	_WSAGetOverlappedResult = windowsFindfunc(ws232, []byte(""WSAGetOverlappedResult\000""))
+	if _WSAGetOverlappedResult == nil {
+		throw(""WSAGetOverlappedResult not found"")
+	}
+
 	if windowsFindfunc(n32, []byte(""wine_get_version\000"")) != nil {
 		// running on Wine
 		initWine(k32)
"
GO-2022-0220,go.googlesource.com,go,9b6e9f0c8c66355c0f0575d808b32f52c8c6d21c," func compileCallback(fn eface, cleanstack bool) (code uintptr) {
 
 const _LOAD_LIBRARY_SEARCH_SYSTEM32 = 0x00000800
 
+// When available, this function will use LoadLibraryEx with the filename
+// parameter and the important SEARCH_SYSTEM32 argument. But on systems that
+// do not have that option, absoluteFilepath should contain a fallback
+// to the full path inside of system32 for use with vanilla LoadLibrary.
 //go:linkname syscall_loadsystemlibrary syscall.loadsystemlibrary
 //go:nosplit
-func syscall_loadsystemlibrary(filename *uint16) (handle, err uintptr) {
+func syscall_loadsystemlibrary(filename *uint16, absoluteFilepath *uint16) (handle, err uintptr) {
 	lockOSThread()
 	defer unlockOSThread()
 	c := &getg().m.syscall
"
GO-2022-0220,go.googlesource.com,go,9b6e9f0c8c66355c0f0575d808b32f52c8c6d21c," func syscall_loadsystemlibrary(filename *uint16) (handle, err uintptr) {
 		}{filename, 0, _LOAD_LIBRARY_SEARCH_SYSTEM32}
 		c.args = uintptr(noescape(unsafe.Pointer(&args)))
 	} else {
-		// User doesn't have KB2533623 installed. The caller
-		// wanted to only load the filename DLL from the
-		// System32 directory but that facility doesn't exist,
-		// so just load it the normal way. This is a potential
-		// security risk, but so is not installing security
-		// updates.
 		c.fn = getLoadLibrary()
 		c.n = 1
-		c.args = uintptr(noescape(unsafe.Pointer(&filename)))
+		c.args = uintptr(noescape(unsafe.Pointer(&absoluteFilepath)))
 	}
 
 	cgocall(asmstdcallAddr, unsafe.Pointer(c))
"
GO-2022-0220,go.googlesource.com,go,9b6e9f0c8c66355c0f0575d808b32f52c8c6d21c," func LoadDLL(name string) (*DLL, error) {
 	var h uintptr
 	var e Errno
 	if sysdll.IsSystemDLL[name] {
-		h, e = loadsystemlibrary(namep)
+		absoluteFilepathp, err := UTF16PtrFromString(systemDirectoryPrefix + name)
+		if err != nil {
+			return nil, err
+		}
+		h, e = loadsystemlibrary(namep, absoluteFilepathp)
 	} else {
 		h, e = loadlibrary(namep)
 	}
"
GO-2022-0220,go.googlesource.com,go,9b6e9f0c8c66355c0f0575d808b32f52c8c6d21c," func osinit() {
 
 	loadOptionalSyscalls()
 
-	useLoadLibraryEx = (_LoadLibraryExW != nil && _AddDllDirectory != nil)
-
 	disableWER()
 
 	initExceptionHandler()
"
GO-2022-0166,go.googlesource.com,go,eb876dd83cb8413335d64e50aae5d38337d1ebb4," func Sign(rand io.Reader, priv *PrivateKey, hash []byte) (r, s *big.Int, err err
 func Verify(pub *PublicKey, hash []byte, r, s *big.Int) bool {
 	// FIPS 186-3, section 4.7
 
+	if pub.P.Sign() == 0 {
+		return false
+	}
+
 	if r.Sign() < 1 || r.Cmp(pub.Q) >= 0 {
 		return false
 	}
"
GO-2021-0227,go.googlesource.com,crypto,8b5274cf687fd9316b4108863654cc57385531e8," userAuthLoop:
 				perms = candidate.perms
 			}
 		case ""gssapi-with-mic"":
+			if config.GSSAPIWithMICConfig == nil {
+				authErr = errors.New(""ssh: gssapi-with-mic auth not configured"")
+				break
+			}
 			gssapiConfig := config.GSSAPIWithMICConfig
 			userAuthRequestGSSAPI, err := parseGSSAPIPayload(userAuthReq.Payload)
 			if err != nil {
"
GO-2022-0192,go.googlesource.com,net,cf3bd585ca2a5a21b057abd8be7eea2204af89d0," func (p *parser) resetInsertionMode() {
 		case a.Table:
 			p.im = inTableIM
 		case a.Template:
+			// TODO: remove this divergence from the HTML5 spec.
+			if n.Namespace != """" {
+				continue
+			}
 			p.im = p.templateStack.top()
 		case a.Head:
 			// TODO: remove this divergence from the HTML5 spec.
"
GO-2022-0197,go.googlesource.com,net,4b62a64f59f73840b9ab79204c94fee61cd1ba2c," func (s *nodeStack) index(n *Node) int {
 // contains returns whether a is within s.
 func (s *nodeStack) contains(a atom.Atom) bool {
 	for _, n := range *s {
-		if n.DataAtom == a {
+		if n.DataAtom == a && n.Namespace == """" {
 			return true
 		}
 	}
"
GO-2022-0515,go.googlesource.com,go,695be961d57508da5a82217f7415200a11845879," func ParseFile(fset *token.FileSet, filename string, src any, mode Mode) (f *ast
 	defer func() {
 		if e := recover(); e != nil {
 			// resume same panic if it's not a bailout
-			if _, ok := e.(bailout); !ok {
+			bail, ok := e.(bailout)
+			if !ok {
 				panic(e)
+			} else if bail.msg != """" {
+				p.errors.Add(p.file.Position(bail.pos), bail.msg)
 			}
 		}
 
"
GO-2022-0515,go.googlesource.com,go,695be961d57508da5a82217f7415200a11845879," func ParseExprFrom(fset *token.FileSet, filename string, src any, mode Mode) (ex
 	defer func() {
 		if e := recover(); e != nil {
 			// resume same panic if it's not a bailout
-			if _, ok := e.(bailout); !ok {
+			bail, ok := e.(bailout)
+			if !ok {
 				panic(e)
+			} else if bail.msg != """" {
+				p.errors.Add(p.file.Position(bail.pos), bail.msg)
 			}
 		}
 		p.errors.Sort()
"
GO-2022-0515,go.googlesource.com,go,695be961d57508da5a82217f7415200a11845879," func (p *parser) parseTypeInstance(typ ast.Expr) ast.Expr {
 }
 
 func (p *parser) tryIdentOrType() ast.Expr {
+	defer decNestLev(incNestLev(p))
+
 	switch p.tok {
 	case token.IDENT:
 		typ := p.parseTypeName(nil)
"
GO-2022-0515,go.googlesource.com,go,695be961d57508da5a82217f7415200a11845879," func (p *parser) parsePrimaryExpr(x ast.Expr) ast.Expr {
 	if x == nil {
 		x = p.parseOperand()
 	}
-	for {
+	// We track the nesting here rather than at the entry for the function,
+	// since it can iteratively produce a nested output, and we want to
+	// limit how deep a structure we generate.
+	var n int
+	defer func() { p.nestLev -= n }()
+	for n = 1; ; n++ {
+		incNestLev(p)
 		switch p.tok {
 		case token.PERIOD:
 			p.next()
"
GO-2022-0515,go.googlesource.com,go,695be961d57508da5a82217f7415200a11845879," func (p *parser) parsePrimaryExpr(x ast.Expr) ast.Expr {
 }
 
 func (p *parser) parseUnaryExpr() ast.Expr {
+	defer decNestLev(incNestLev(p))
+
 	if p.trace {
 		defer un(trace(p, ""UnaryExpr""))
 	}
"
GO-2022-0515,go.googlesource.com,go,695be961d57508da5a82217f7415200a11845879," func (p *parser) parseBinaryExpr(x ast.Expr, prec1 int, check bool) ast.Expr {
 	if x == nil {
 		x = p.parseUnaryExpr()
 	}
-	for {
+	// We track the nesting here rather than at the entry for the function,
+	// since it can iteratively produce a nested output, and we want to
+	// limit how deep a structure we generate.
+	var n int
+	defer func() { p.nestLev -= n }()
+	for n = 1; ; n++ {
+		incNestLev(p)
 		op, oprec := p.tokPrec()
 		if oprec < prec1 {
 			return x
"
GO-2022-0515,go.googlesource.com,go,695be961d57508da5a82217f7415200a11845879," func (p *parser) parseIfHeader() (init ast.Stmt, cond ast.Expr) {
 }
 
 func (p *parser) parseIfStmt() *ast.IfStmt {
+	defer decNestLev(incNestLev(p))
+
 	if p.trace {
 		defer un(trace(p, ""IfStmt""))
 	}
"
GO-2022-0515,go.googlesource.com,go,695be961d57508da5a82217f7415200a11845879," func (p *parser) parseForStmt() ast.Stmt {
 }
 
 func (p *parser) parseStmt() (s ast.Stmt) {
+	defer decNestLev(incNestLev(p))
+
 	if p.trace {
 		defer un(trace(p, ""Statement""))
 	}
"
GO-2022-0247,go.googlesource.com,go,77f2750f4398990eed972186706f160631d7dae4," func (ctxt *Link) address() []*sym.Segment {
 	order = append(order, &Segtext)
 	Segtext.Rwx = 05
 	Segtext.Vaddr = va
-	for _, s := range Segtext.Sections {
+	for i, s := range Segtext.Sections {
 		va = uint64(Rnd(int64(va), int64(s.Align)))
 		s.Vaddr = va
 		va += s.Length
+
+		if ctxt.IsWasm() && i == 0 && va < wasmMinDataAddr {
+			va = wasmMinDataAddr
+		}
 	}
 
 	Segtext.Length = va - uint64(*FlagTextAddr)
"
GO-2021-0142,go.googlesource.com,go,027d7241ce050d197e7fabea3d541ffbe3487258," var overflow = errors.New(""binary: varint overflows a 64-bit integer"")
 func ReadUvarint(r io.ByteReader) (uint64, error) {
 	var x uint64
 	var s uint
-	for i := 0; ; i++ {
+	for i := 0; i < MaxVarintLen64; i++ {
 		b, err := r.ReadByte()
 		if err != nil {
 			return x, err
 		}
 		if b < 0x80 {
-			if i > 9 || i == 9 && b > 1 {
+			if i == 9 && b > 1 {
 				return x, overflow
 			}
 			return x | uint64(b)<<s, nil
"
GO-2021-0142,go.googlesource.com,go,027d7241ce050d197e7fabea3d541ffbe3487258," func ReadUvarint(r io.ByteReader) (uint64, error) {
 		x |= uint64(b&0x7f) << s
 		s += 7
 	}
+	return x, overflow
 }
 
 // ReadVarint reads an encoded signed integer from r and returns it as an int64.
"
GO-2022-0526,go.googlesource.com,go,6fa37e98ea4382bf881428ee0c150ce591500eb7," func (dec *Decoder) decOpFor(wireId typeId, rt reflect.Type, name string, inProg
 	return &op
 }
 
+var maxIgnoreNestingDepth = 10000
+
 // decIgnoreOpFor returns the decoding op for a field that has no destination.
-func (dec *Decoder) decIgnoreOpFor(wireId typeId, inProgress map[typeId]*decOp) *decOp {
+func (dec *Decoder) decIgnoreOpFor(wireId typeId, inProgress map[typeId]*decOp, depth int) *decOp {
+	if depth > maxIgnoreNestingDepth {
+		error_(errors.New(""invalid nesting depth""))
+	}
 	// If this type is already in progress, it's a recursive type (e.g. map[string]*T).
 	// Return the pointer to the op we're already building.
 	if opPtr := inProgress[wireId]; opPtr != nil {
"
GO-2022-0526,go.googlesource.com,go,6fa37e98ea4382bf881428ee0c150ce591500eb7," func (dec *Decoder) decIgnoreOpFor(wireId typeId, inProgress map[typeId]*decOp)
 			errorf(""bad data: undefined type %s"", wireId.string())
 		case wire.ArrayT != nil:
 			elemId := wire.ArrayT.Elem
-			elemOp := dec.decIgnoreOpFor(elemId, inProgress)
+			elemOp := dec.decIgnoreOpFor(elemId, inProgress, depth+1)
 			op = func(i *decInstr, state *decoderState, value reflect.Value) {
 				state.dec.ignoreArray(state, *elemOp, wire.ArrayT.Len)
 			}
"
GO-2022-0526,go.googlesource.com,go,6fa37e98ea4382bf881428ee0c150ce591500eb7," func (dec *Decoder) decIgnoreOpFor(wireId typeId, inProgress map[typeId]*decOp)
 		case wire.MapT != nil:
 			keyId := dec.wireType[wireId].MapT.Key
 			elemId := dec.wireType[wireId].MapT.Elem
-			keyOp := dec.decIgnoreOpFor(keyId, inProgress)
-			elemOp := dec.decIgnoreOpFor(elemId, inProgress)
+			keyOp := dec.decIgnoreOpFor(keyId, inProgress, depth+1)
+			elemOp := dec.decIgnoreOpFor(elemId, inProgress, depth+1)
 			op = func(i *decInstr, state *decoderState, value reflect.Value) {
 				state.dec.ignoreMap(state, *keyOp, *elemOp)
 			}
 
 		case wire.SliceT != nil:
 			elemId := wire.SliceT.Elem
-			elemOp := dec.decIgnoreOpFor(elemId, inProgress)
+			elemOp := dec.decIgnoreOpFor(elemId, inProgress, depth+1)
 			op = func(i *decInstr, state *decoderState, value reflect.Value) {
 				state.dec.ignoreSlice(state, *elemOp)
 			}
"
GO-2022-0526,go.googlesource.com,go,6fa37e98ea4382bf881428ee0c150ce591500eb7," func (dec *Decoder) compileSingle(remoteId typeId, ut *userTypeInfo) (engine *de
 func (dec *Decoder) compileIgnoreSingle(remoteId typeId) *decEngine {
 	engine := new(decEngine)
 	engine.instr = make([]decInstr, 1) // one item
-	op := dec.decIgnoreOpFor(remoteId, make(map[typeId]*decOp))
+	op := dec.decIgnoreOpFor(remoteId, make(map[typeId]*decOp), 0)
 	ovfl := overflow(dec.typeString(remoteId))
 	engine.instr[0] = decInstr{*op, 0, nil, ovfl}
 	engine.numInstr = 1
"
GO-2022-0526,go.googlesource.com,go,6fa37e98ea4382bf881428ee0c150ce591500eb7," func (dec *Decoder) compileDec(remoteId typeId, ut *userTypeInfo) (engine *decEn
 		localField, present := srt.FieldByName(wireField.Name)
 		// TODO(r): anonymous names
 		if !present || !isExported(wireField.Name) {
-			op := dec.decIgnoreOpFor(wireField.Id, make(map[typeId]*decOp))
+			op := dec.decIgnoreOpFor(wireField.Id, make(map[typeId]*decOp), 0)
 			engine.instr[fieldnum] = decInstr{*op, fieldnum, nil, ovfl}
 			continue
 		}
"
GO-2022-0190,go.googlesource.com,go,bc82d7c7db83487e05d7a88e06549d4ae2a688c3," func downloadPackage(p *load.Package) error {
 		security = web.Insecure
 	}
 
+	if err := CheckImportPath(p.ImportPath); err != nil {
+		return fmt.Errorf(""%s: invalid import path: %v"", p.ImportPath, err)
+	}
+
 	if p.Internal.Build.SrcRoot != """" {
 		// Directory exists. Look for checkout along path to src.
 		vcs, rootPath, err = vcsFromDir(p.Dir, p.Internal.Build.SrcRoot)
"
GO-2022-0189,go.googlesource.com,go,bc82d7c7db83487e05d7a88e06549d4ae2a688c3," func downloadPackage(p *load.Package) error {
 		security = web.Insecure
 	}
 
+	if err := CheckImportPath(p.ImportPath); err != nil {
+		return fmt.Errorf(""%s: invalid import path: %v"", p.ImportPath, err)
+	}
+
 	if p.Internal.Build.SrcRoot != """" {
 		// Directory exists. Look for checkout along path to src.
 		vcs, rootPath, err = vcsFromDir(p.Dir, p.Internal.Build.SrcRoot)
"
GO-2022-0535,go.googlesource.com,go,953bc8f391a63adf00bac2515dba62abe8a1e2c2," func (c *Certificate) systemVerify(opts *VerifyOptions) (chains [][]*Certificate
 	if err != nil {
 		return nil, err
 	}
+	if len(chain) < 1 {
+		return nil, errors.New(""x509: internal error: system verifier returned an empty chain"")
+	}
 
-	chains = append(chains, chain)
+	// Mitigate CVE-2020-0601, where the Windows system verifier might be
+	// tricked into using custom curve parameters for a trusted root, by
+	// double-checking all ECDSA signatures. If the system was tricked into
+	// using spoofed parameters, the signature will be invalid for the correct
+	// ones we parsed. (We don't support custom curves ourselves.)
+	for i, parent := range chain[1:] {
+		if parent.PublicKeyAlgorithm != ECDSA {
+			continue
+		}
+		if err := parent.CheckSignature(chain[i].SignatureAlgorithm,
+			chain[i].RawTBSCertificate, chain[i].Signature); err != nil {
+			return nil, err
+		}
+	}
 
-	return chains, nil
+	return [][]*Certificate{chain}, nil
 }
 
 func loadSystemRoots() (*CertPool, error) {
"
GO-2022-0536,go.googlesource.com,go,145e193131eb486077b66009beb051aba07c52a5," func (sc *http2serverConn) serve() {
 			}
 		}
 
+		// If the peer is causing us to generate a lot of control frames,
+		// but not reading them from us, assume they are trying to make us
+		// run out of memory.
+		if sc.queuedControlFrames > sc.srv.maxQueuedControlFrames() {
+			sc.vlogf(""http2: too many control frames in send queue, closing connection"")
+			return
+		}
+
 		// Start the shutdown timer after sending a GOAWAY. When sending GOAWAY
 		// with no error code (graceful shutdown), don't start the timer until
 		// all open streams have been completed.
"
GO-2022-0536,go.googlesource.com,go,145e193131eb486077b66009beb051aba07c52a5," func (sc *http2serverConn) writeFrame(wr http2FrameWriteRequest) {
 	}
 
 	if !ignoreWrite {
+		if wr.isControl() {
+			sc.queuedControlFrames++
+			// For extra safety, detect wraparounds, which should not happen,
+			// and pull the plug.
+			if sc.queuedControlFrames < 0 {
+				sc.conn.Close()
+			}
+		}
 		sc.writeSched.Push(wr)
 	}
 	sc.scheduleFrameWrite()
"
GO-2022-0536,go.googlesource.com,go,145e193131eb486077b66009beb051aba07c52a5," func (sc *http2serverConn) scheduleFrameWrite() {
 		}
 		if !sc.inGoAway || sc.goAwayCode == http2ErrCodeNo {
 			if wr, ok := sc.writeSched.Pop(); ok {
+				if wr.isControl() {
+					sc.queuedControlFrames--
+				}
 				sc.startFrameWrite(wr)
 				continue
 			}
"
GO-2022-0525,go.googlesource.com,go,e5017a93fcde94f09836200bca55324af037ee5f," func (t *transferReader) parseTransferEncoding() error {
 	if len(raw) != 1 {
 		return &unsupportedTEError{fmt.Sprintf(""too many transfer encodings: %q"", raw)}
 	}
-	if !ascii.EqualFold(textproto.TrimString(raw[0]), ""chunked"") {
+	if !ascii.EqualFold(raw[0], ""chunked"") {
 		return &unsupportedTEError{fmt.Sprintf(""unsupported transfer encoding: %q"", raw[0])}
 	}
 
"
GO-2021-0172,go.googlesource.com,go,7478ea5dba7ed02ddffd91c1d17ec8141f7cf184," func (r *Reader) readForm(maxMemory int64) (_ *Form, err error) {
 			if err != nil {
 				return nil, err
 			}
-			defer file.Close()
 			_, err = io.Copy(file, io.MultiReader(&b, p))
+			if cerr := file.Close(); err == nil {
+				err = cerr
+			}
 			if err != nil {
 				os.Remove(file.Name())
 				return nil, err
"
GO-2020-0015,go.googlesource.com,text,23ae387dee1f90d29a23c0e87ee0b46038fbed0e," func (u *utf16Decoder) Reset() {
 }
 
 func (u *utf16Decoder) Transform(dst, src []byte, atEOF bool) (nDst, nSrc int, err error) {
+	if len(src) < 2 && atEOF && u.current.bomPolicy&requireBOM != 0 {
+		return 0, 0, ErrMissingBOM
+	}
 	if len(src) == 0 {
-		if atEOF && u.current.bomPolicy&requireBOM != 0 {
-			return 0, 0, ErrMissingBOM
-		}
 		return 0, 0, nil
 	}
-	if u.current.bomPolicy&acceptBOM != 0 {
-		if len(src) < 2 {
-			return 0, 0, transform.ErrShortSrc
-		}
+	if len(src) >= 2 && u.current.bomPolicy&acceptBOM != 0 {
 		switch {
 		case src[0] == 0xfe && src[1] == 0xff:
 			u.current.endianness = BigEndian
"
GO-2020-0015,go.googlesource.com,text,23ae387dee1f90d29a23c0e87ee0b46038fbed0e," func String(t Transformer, s string) (result string, n int, err error) {
 	// Transform the remaining input, growing dst and src buffers as necessary.
 	for {
 		n := copy(src, s[pSrc:])
-		nDst, nSrc, err := t.Transform(dst[pDst:], src[:n], pSrc+n == len(s))
+		atEOF := pSrc+n == len(s)
+		nDst, nSrc, err := t.Transform(dst[pDst:], src[:n], atEOF)
 		pDst += nDst
 		pSrc += nSrc
 
"
GO-2020-0015,go.googlesource.com,text,23ae387dee1f90d29a23c0e87ee0b46038fbed0e," func String(t Transformer, s string) (result string, n int, err error) {
 				dst = grow(dst, pDst)
 			}
 		} else if err == ErrShortSrc {
+			if atEOF {
+				return string(dst[:pDst]), pSrc, err
+			}
 			if nSrc == 0 {
 				src = grow(src, 0)
 			}
"
GO-2023-1992,go.googlesource.com,crypto,c05e17bb3b2dca130fc919668a96b4bec9eb9442," func getLine(data []byte) (line, rest []byte) {
 	return data[0:i], data[j:]
 }
 
-// Decode finds the first clearsigned message in data and returns it, as well
-// as the suffix of data which remains after the message.
+// Decode finds the first clearsigned message in data and returns it, as well as
+// the suffix of data which remains after the message. Any prefix data is
+// discarded.
+//
+// If no message is found, or if the message is invalid, Decode returns nil and
+// the whole data slice. The only allowed header type is Hash, and it is not
+// verified against the signature hash.
 func Decode(data []byte) (b *Block, rest []byte) {
 	// start begins with a newline. However, at the very beginning of
 	// the byte array, we'll accept the start string without it.
"
GO-2023-1992,go.googlesource.com,crypto,c05e17bb3b2dca130fc919668a96b4bec9eb9442," func Decode(data []byte) (b *Block, rest []byte) {
 		return nil, data
 	}
 
-	// Consume the start line.
-	_, rest = getLine(rest)
+	// Consume the start line and check it does not have a suffix.
+	suffix, rest := getLine(rest)
+	if len(suffix) != 0 {
+		return nil, data
+	}
 
 	var line []byte
 	b = &Block{
"
GO-2023-1992,go.googlesource.com,crypto,c05e17bb3b2dca130fc919668a96b4bec9eb9442," func Decode(data []byte) (b *Block, rest []byte) {
 			break
 		}
 
+		// Reject headers with control or Unicode characters.
+		if i := bytes.IndexFunc(line, func(r rune) bool {
+			return r < 0x20 || r > 0x7e
+		}); i != -1 {
+			return nil, data
+		}
+
 		i := bytes.Index(line, []byte{':'})
 		if i == -1 {
 			return nil, data
 		}
 
-		key, val := line[0:i], line[i+1:]
-		key = bytes.TrimSpace(key)
-		val = bytes.TrimSpace(val)
-		b.Headers.Add(string(key), string(val))
+		key, val := string(line[0:i]), string(line[i+1:])
+		key = strings.TrimSpace(key)
+		if key != ""Hash"" {
+			return nil, data
+		}
+		val = strings.TrimSpace(val)
+		b.Headers.Add(key, val)
 	}
 
 	firstLine := true
"
GO-2021-0240,go.googlesource.com,go,74242baa4136c7a9132a8ccd9881354442788c8c," func (z *Reader) init(r io.ReaderAt, size int64) error {
 		return err
 	}
 	z.r = r
-	z.File = make([]*File, 0, end.directoryRecords)
+	// Since the number of directory records is not validated, it is not
+	// safe to preallocate z.File without first checking that the specified
+	// number of files is reasonable, since a malformed archive may
+	// indicate it contains up to 1 << 128 - 1 files. Since each file has a
+	// header which will be _at least_ 30 bytes we can safely preallocate
+	// if (data size / 30) >= end.directoryRecords.
+	if (uint64(size)-end.directorySize)/30 >= end.directoryRecords {
+		z.File = make([]*File, 0, end.directoryRecords)
+	}
 	z.Comment = end.comment
 	rs := io.NewSectionReader(r, 0, size)
 	if _, err = rs.Seek(int64(end.directoryOffset), io.SeekStart); err != nil {
"
GO-2022-0213,go.googlesource.com,go,552987fdbf4c2bc9641016fd323c3ae5d3a0d9a3," func Verify(pub *PublicKey, hash []byte, r, s *big.Int) bool {
 	}
 
 	w := new(big.Int).ModInverse(s, pub.Q)
+	if w == nil {
+		return false
+	}
 
 	n := pub.Q.BitLen()
 	if n%8 != 0 {
"
GO-2022-0520,go.googlesource.com,go,b2cc0fecc2ccd80e6d5d16542cc684f97b3a9c8a," func (h Header) Clone() Header {
 	sv := make([]string, nv) // shared backing array for headers' values
 	h2 := make(Header, len(h))
 	for k, vv := range h {
+		if vv == nil {
+			// Preserve nil values. ReverseProxy distinguishes
+			// between nil and zero-length header values.
+			h2[k] = nil
+			continue
+		}
 		n := copy(sv, vv)
 		h2[k] = sv[:n:n]
 		sv = sv[n:]
"
GO-2021-0245,go.googlesource.com,go,b7a85e0003cedb1b48a1fd3ae5b746ec6330102e," func (p *ReverseProxy) ServeHTTP(rw http.ResponseWriter, req *http.Request) {
 	if req.ContentLength == 0 {
 		outreq.Body = nil // Issue 16036: nil Body for http.Transport retries
 	}
+	if outreq.Body != nil {
+		// Reading from the request body after returning from a handler is not
+		// allowed, and the RoundTrip goroutine that reads the Body can outlive
+		// this handler. This can lead to a crash if the handler panics (see
+		// Issue 46866). Although calling Close doesn't guarantee there isn't
+		// any Read in flight after the handle returns, in practice it's safe to
+		// read after closing it.
+		defer outreq.Body.Close()
+	}
 	if outreq.Header == nil {
 		outreq.Header = make(http.Header) // Issue 33142: historical behavior was to always allocate
 	}
"
GO-2021-0223,go.googlesource.com,go,82175e699a2e2cd83d3aa34949e9b922d66d52f5," func (c *Certificate) systemVerify(opts *VerifyOptions) (chains [][]*Certificate
 	para := new(syscall.CertChainPara)
 	para.Size = uint32(unsafe.Sizeof(*para))
 
-	// If there's a DNSName set in opts, assume we're verifying
-	// a certificate from a TLS server.
-	if hasDNSName {
-		oids := []*byte{
-			&syscall.OID_PKIX_KP_SERVER_AUTH[0],
-			// Both IE and Chrome allow certificates with
-			// Server Gated Crypto as well. Some certificates
-			// in the wild require them.
-			&syscall.OID_SERVER_GATED_CRYPTO[0],
-			&syscall.OID_SGC_NETSCAPE[0],
+	keyUsages := opts.KeyUsages
+	if len(keyUsages) == 0 {
+		keyUsages = []ExtKeyUsage{ExtKeyUsageServerAuth}
+	}
+	oids := make([]*byte, 0, len(keyUsages))
+	for _, eku := range keyUsages {
+		if eku == ExtKeyUsageAny {
+			oids = nil
+			break
+		}
+		if oid, ok := windowsExtKeyUsageOIDs[eku]; ok {
+			oids = append(oids, &oid[0])
 		}
+		// Like the standard verifier, accept SGC EKUs as equivalent to ServerAuth.
+		if eku == ExtKeyUsageServerAuth {
+			oids = append(oids, &syscall.OID_SERVER_GATED_CRYPTO[0])
+			oids = append(oids, &syscall.OID_SGC_NETSCAPE[0])
+		}
+	}
+	if oids != nil {
 		para.RequestedUsage.Type = syscall.USAGE_MATCH_TYPE_OR
 		para.RequestedUsage.Usage.Length = uint32(len(oids))
 		para.RequestedUsage.Usage.UsageIdentifiers = &oids[0]
"
GO-2021-0223,go.googlesource.com,go,82175e699a2e2cd83d3aa34949e9b922d66d52f5," func (c *Certificate) systemVerify(opts *VerifyOptions) (chains [][]*Certificate
 		return nil, err
 	}
 
-	if hasDNSName {
+	if opts != nil && len(opts.DNSName) > 0 {
 		err = checkChainSSLServerPolicy(c, chainCtx, opts)
 		if err != nil {
 			return nil, err
"
GO-2022-0209,go.googlesource.com,crypto,b7391e95e576cacdcdd422573063bc057239113d,"
+// Copyright 2019 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// +build !amd64 appengine gccgo
+
+package salsa
+
+// XORKeyStream crypts bytes from in to out using the given key and counters.
+// In and out must overlap entirely or not at all. Counter
+// contains the raw salsa20 counter bytes (both nonce and block counter).
+func XORKeyStream(out, in []byte, counter *[16]byte, key *[32]byte) {
+	genericXORKeyStream(out, in, counter, key)
+}
"
GO-2020-0014,go.googlesource.com,net,d26f9f9a57f3fab6a695bec0d84433c2c50f8bbf," func inSelectIM(p *parser) bool {
 			}
 			p.addElement()
 		case a.Select:
-			p.tok.Type = EndTagToken
-			return false
+			if p.popUntil(selectScope, a.Select) {
+				p.resetInsertionMode()
+			} else {
+				// Ignore the token.
+				return true
+			}
 		case a.Input, a.Keygen, a.Textarea:
 			if p.elementInScope(selectScope, a.Select) {
 				p.parseImpliedToken(EndTagToken, a.Select, a.Select.String())
"
GO-2020-0014,go.googlesource.com,net,d26f9f9a57f3fab6a695bec0d84433c2c50f8bbf," func inSelectIM(p *parser) bool {
 		case a.Select:
 			if p.popUntil(selectScope, a.Select) {
 				p.resetInsertionMode()
+			} else {
+				// Ignore the token.
+				return true
 			}
 		case a.Template:
 			return inHeadIM(p)
"
GO-2020-0014,go.googlesource.com,net,d26f9f9a57f3fab6a695bec0d84433c2c50f8bbf," func inSelectInTableIM(p *parser) bool {
 	case StartTagToken, EndTagToken:
 		switch p.tok.DataAtom {
 		case a.Caption, a.Table, a.Tbody, a.Tfoot, a.Thead, a.Tr, a.Td, a.Th:
-			if p.tok.Type == StartTagToken || p.elementInScope(tableScope, p.tok.DataAtom) {
-				p.parseImpliedToken(EndTagToken, a.Select, a.Select.String())
-				return false
-			} else {
+			if p.tok.Type == EndTagToken && !p.elementInScope(tableScope, p.tok.DataAtom) {
 				// Ignore the token.
 				return true
 			}
+			// This is like p.popUntil(selectScope, a.Select), but it also
+			// matches <math select>, not just <select>. Matching the MathML
+			// tag is arguably incorrect (conceptually), but it mimics what
+			// Chromium does.
+			for i := len(p.oe) - 1; i >= 0; i-- {
+				if n := p.oe[i]; n.DataAtom == a.Select {
+					p.oe = p.oe[:i]
+					break
+				}
+			}
+			p.resetInsertionMode()
+			return false
 		}
 	}
 	return inSelectIM(p)
"
GO-2022-0524,go.googlesource.com,go,b2b8872c876201eac2d0707276c6999ff3eb185e," func (z *Reader) Read(p []byte) (n int, err error) {
 		return 0, z.err
 	}
 
-	n, z.err = z.decompressor.Read(p)
-	z.digest = crc32.Update(z.digest, crc32.IEEETable, p[:n])
-	z.size += uint32(n)
-	if z.err != io.EOF {
-		// In the normal case we return here.
-		return n, z.err
-	}
+	for n == 0 {
+		n, z.err = z.decompressor.Read(p)
+		z.digest = crc32.Update(z.digest, crc32.IEEETable, p[:n])
+		z.size += uint32(n)
+		if z.err != io.EOF {
+			// In the normal case we return here.
+			return n, z.err
+		}
 
-	// Finished file; check checksum and size.
-	if _, err := io.ReadFull(z.r, z.buf[:8]); err != nil {
-		z.err = noEOF(err)
-		return n, z.err
-	}
-	digest := le.Uint32(z.buf[:4])
-	size := le.Uint32(z.buf[4:8])
-	if digest != z.digest || size != z.size {
-		z.err = ErrChecksum
-		return n, z.err
-	}
-	z.digest, z.size = 0, 0
+		// Finished file; check checksum and size.
+		if _, err := io.ReadFull(z.r, z.buf[:8]); err != nil {
+			z.err = noEOF(err)
+			return n, z.err
+		}
+		digest := le.Uint32(z.buf[:4])
+		size := le.Uint32(z.buf[4:8])
+		if digest != z.digest || size != z.size {
+			z.err = ErrChecksum
+			return n, z.err
+		}
+		z.digest, z.size = 0, 0
 
-	// File is ok; check if there is another.
-	if !z.multistream {
-		return n, io.EOF
-	}
-	z.err = nil // Remove io.EOF
+		// File is ok; check if there is another.
+		if !z.multistream {
+			return n, io.EOF
+		}
+		z.err = nil // Remove io.EOF
 
-	if _, z.err = z.readHeader(); z.err != nil {
-		return n, z.err
+		if _, z.err = z.readHeader(); z.err != nil {
+			return n, z.err
+		}
 	}
 
-	// Read from next file, if necessary.
-	if n > 0 {
-		return n, nil
-	}
-	return z.Read(p)
+	return n, nil
 }
 
 // Close closes the Reader. It does not close the underlying io.Reader.
"
GO-2021-0224,go.googlesource.com,go,fa98f46741f818913a8c11b877520a548715131f," type expectContinueReader struct {
 	resp       *response
 	readCloser io.ReadCloser
 	closed     bool
-	sawEOF     bool
+	sawEOF     atomicBool
 }
 
 func (ecr *expectContinueReader) Read(p []byte) (n int, err error) {
 	if ecr.closed {
 		return 0, ErrBodyReadAfterClose
 	}
-	if !ecr.resp.wroteContinue && !ecr.resp.conn.hijacked() {
-		ecr.resp.wroteContinue = true
-		ecr.resp.conn.bufw.WriteString(""HTTP/1.1 100 Continue\r\n\r\n"")
-		ecr.resp.conn.bufw.Flush()
+	w := ecr.resp
+	if !w.wroteContinue && w.canWriteContinue.isSet() && !w.conn.hijacked() {
+		w.wroteContinue = true
+		w.writeContinueMu.Lock()
+		if w.canWriteContinue.isSet() {
+			w.conn.bufw.WriteString(""HTTP/1.1 100 Continue\r\n\r\n"")
+			w.conn.bufw.Flush()
+			w.canWriteContinue.setFalse()
+		}
+		w.writeContinueMu.Unlock()
 	}
 	n, err = ecr.readCloser.Read(p)
 	if err == io.EOF {
-		ecr.sawEOF = true
+		ecr.sawEOF.setTrue()
 	}
 	return
 }
"
GO-2021-0319,go.googlesource.com,go,7f9494c277a471f6f47f4af3036285c0b1419816," func (curve *CurveParams) IsOnCurve(x, y *big.Int) bool {
 		return specific.IsOnCurve(x, y)
 	}
 
+	if x.Sign() < 0 || x.Cmp(curve.P) >= 0 ||
+		y.Sign() < 0 || y.Cmp(curve.P) >= 0 {
+		return false
+	}
+
 	// y = x - 3x + b
 	y2 := new(big.Int).Mul(y, y)
 	y2.Mod(y2, curve.P)
"
GO-2021-0319,go.googlesource.com,go,7f9494c277a471f6f47f4af3036285c0b1419816," func p384PointFromAffine(x, y *big.Int) (p *nistec.P384Point, ok bool) {
 	if x.Sign() == 0 && y.Sign() == 0 {
 		return nistec.NewP384Point(), true
 	}
+	if x.Sign() < 0 || y.Sign() < 0 {
+		return nil, false
+	}
 	if x.BitLen() > 384 || y.BitLen() > 384 {
 		return nil, false
 	}
"
GO-2021-0319,go.googlesource.com,go,7f9494c277a471f6f47f4af3036285c0b1419816," func p521PointFromAffine(x, y *big.Int) (p *nistec.P521Point, ok bool) {
 	if x.Sign() == 0 && y.Sign() == 0 {
 		return nistec.NewP521Point(), true
 	}
+	if x.Sign() < 0 || y.Sign() < 0 {
+		return nil, false
+	}
 	if x.BitLen() > 521 || y.BitLen() > 521 {
 		return nil, false
 	}
"
GO-2022-0236,go.googlesource.com,net,89ef3d95e781148a0951956029c92a211477f7f9," func trimOWS(x string) string {
 // contains token amongst its comma-separated tokens, ASCII
 // case-insensitively.
 func headerValueContainsToken(v string, token string) bool {
-	v = trimOWS(v)
-	if comma := strings.IndexByte(v, ','); comma != -1 {
-		return tokenEqual(trimOWS(v[:comma]), token) || headerValueContainsToken(v[comma+1:], token)
+	for comma := strings.IndexByte(v, ','); comma != -1; comma = strings.IndexByte(v, ',') {
+		if tokenEqual(trimOWS(v[:comma]), token) {
+			return true
+		}
+		v = v[comma+1:]
 	}
-	return tokenEqual(v, token)
+	return tokenEqual(trimOWS(v), token)
 }
 
 // lowerASCII returns the ASCII lowercase version of b.
"
GO-2022-0193,go.googlesource.com,net,2f5d2388922f370f4355f327fcf4cfe9f5583908," func inBodyIM(p *parser) bool {
 			p.acknowledgeSelfClosingTag()
 			p.popUntil(buttonScope, a.P)
 			p.parseImpliedToken(StartTagToken, a.Form, a.Form.String())
+			if p.form == nil {
+				// NOTE: The 'isindex' element has been removed,
+				// and the 'template' element has not been designed to be
+				// collaborative with the index element.
+				//
+				// Ignore the token.
+				return true
+			}
 			if action != """" {
 				p.form.Attr = []Attribute{{Key: ""action"", Val: action}}
 			}
"
GO-2021-0159,go.googlesource.com,go,26049f6f9171d1190f3bbe05ec304845cfe6399f," func (b *body) readLocked(p []byte) (n int, err error) {
 		if b.hdr != nil {
 			if e := b.readTrailer(); e != nil {
 				err = e
+				// Something went wrong in the trailer, we must not allow any
+				// further reads of any kind to succeed from body, nor any
+				// subsequent requests on the server connection. See
+				// golang.org/issue/12027
+				b.sawEOF = false
+				b.closed = true
 			}
 			b.hdr = nil
 		} else {
"
GO-2021-0159,go.googlesource.com,go,117ddcb83d7f42d6aa72241240af99ded81118e9," func (r *Reader) upcomingHeaderNewlines() (n int) {
 // the rest are converted to lowercase.  For example, the
 // canonical key for ""accept-encoding"" is ""Accept-Encoding"".
 // MIME header keys are assumed to be ASCII only.
+// If s contains a space or invalid header field bytes, it is
+// returned without modifications.
 func CanonicalMIMEHeaderKey(s string) string {
 	// Quick check for canonical encoding.
 	upper := true
 	for i := 0; i < len(s); i++ {
 		c := s[i]
+		if !validHeaderFieldByte(c) {
+			return s
+		}
 		if upper && 'a' <= c && c <= 'z' {
 			return canonicalMIMEHeaderKey([]byte(s))
 		}
"
GO-2021-0159,go.googlesource.com,go,300d9a21583e7cf0149a778a0611e76ff7c6680f," func (t *transferWriter) shouldSendContentLength() bool {
 		return true
 	}
 	if t.ContentLength == 0 && isIdentity(t.TransferEncoding) {
+		if t.Method == ""GET"" || t.Method == ""HEAD"" {
+			return false
+		}
 		return true
 	}
 
"
GO-2021-0159,go.googlesource.com,go,300d9a21583e7cf0149a778a0611e76ff7c6680f," func readTransfer(msg interface{}, r *bufio.Reader) (err error) {
 		}
 	case *Request:
 		t.Header = rr.Header
+		t.RequestMethod = rr.Method
 		t.ProtoMajor = rr.ProtoMajor
 		t.ProtoMinor = rr.ProtoMinor
 		// Transfer semantics for Requests are exactly like those for
"
GO-2021-0159,go.googlesource.com,go,300d9a21583e7cf0149a778a0611e76ff7c6680f," func readTransfer(msg interface{}, r *bufio.Reader) (err error) {
 	}
 
 	// Transfer encoding, content length
-	t.TransferEncoding, err = fixTransferEncoding(t.RequestMethod, t.Header)
+	t.TransferEncoding, err = fixTransferEncoding(isResponse, t.RequestMethod, t.Header)
 	if err != nil {
 		return err
 	}
"
GO-2021-0159,go.googlesource.com,go,300d9a21583e7cf0149a778a0611e76ff7c6680f," func chunked(te []string) bool { return len(te) > 0 && te[0] == ""chunked"" }
 func isIdentity(te []string) bool { return len(te) == 1 && te[0] == ""identity"" }
 
 // Sanitize transfer encoding
-func fixTransferEncoding(requestMethod string, header Header) ([]string, error) {
+func fixTransferEncoding(isResponse bool, requestMethod string, header Header) ([]string, error) {
 	raw, present := header[""Transfer-Encoding""]
 	if !present {
 		return nil, nil
 	}
-
+	isRequest := !isResponse
 	delete(header, ""Transfer-Encoding"")
 
 	encodings := strings.Split(raw[0], "","")
"
GO-2021-0159,go.googlesource.com,go,300d9a21583e7cf0149a778a0611e76ff7c6680f," func fixTransferEncoding(requestMethod string, header Header) ([]string, error)
 		return nil, &badStringError{""too many transfer encodings"", strings.Join(te, "","")}
 	}
 	if len(te) > 0 {
-		// Chunked encoding trumps Content-Length. See RFC 2616
-		// Section 4.4. Currently len(te) > 0 implies chunked
-		// encoding.
-		delete(header, ""Content-Length"")
+		// RFC 7230 3.3.2 says ""A sender MUST NOT send a
+		// Content-Length header field in any message that
+		// contains a Transfer-Encoding header field.""
+		if len(header[""Content-Length""]) > 0 {
+			if isRequest {
+				return nil, errors.New(""http: invalid Content-Length with Transfer-Encoding"")
+			}
+			delete(header, ""Content-Length"")
+		}
 		return te, nil
 	}
 
"
GO-2021-0159,go.googlesource.com,go,300d9a21583e7cf0149a778a0611e76ff7c6680f," func fixTransferEncoding(requestMethod string, header Header) ([]string, error)
 // function is not a method, because ultimately it should be shared by
 // ReadResponse and ReadRequest.
 func fixLength(isResponse bool, status int, requestMethod string, header Header, te []string) (int64, error) {
-
+	contentLens := header[""Content-Length""]
+	isRequest := !isResponse
 	// Logic based on response type or status
 	if noBodyExpected(requestMethod) {
+		// For HTTP requests, as part of hardening against request
+		// smuggling (RFC 7230), don't allow a Content-Length header for
+		// methods which don't permit bodies. As an exception, allow
+		// exactly one Content-Length header if its value is ""0"".
+		if isRequest && len(contentLens) > 0 && !(len(contentLens) == 1 && contentLens[0] == ""0"") {
+			return 0, fmt.Errorf(""http: method cannot contain a Content-Length; got %q"", contentLens)
+		}
 		return 0, nil
 	}
 	if status/100 == 1 {
"
GO-2021-0159,go.googlesource.com,go,300d9a21583e7cf0149a778a0611e76ff7c6680f," func fixLength(isResponse bool, status int, requestMethod string, header Header,
 		return 0, nil
 	}
 
+	if len(contentLens) > 1 {
+		// harden against HTTP request smuggling. See RFC 7230.
+		return 0, errors.New(""http: message cannot contain multiple Content-Length headers"")
+	}
+
 	// Logic based on Transfer-Encoding
 	if chunked(te) {
 		return -1, nil
 	}
 
 	// Logic based on Content-Length
-	cl := strings.TrimSpace(header.get(""Content-Length""))
+	var cl string
+	if len(contentLens) == 1 {
+		cl = strings.TrimSpace(contentLens[0])
+	}
 	if cl != """" {
 		n, err := parseContentLength(cl)
 		if err != nil {
"
GO-2021-0159,go.googlesource.com,go,300d9a21583e7cf0149a778a0611e76ff7c6680f," func fixLength(isResponse bool, status int, requestMethod string, header Header,
 		header.Del(""Content-Length"")
 	}
 
-	if !isResponse && requestMethod == ""GET"" {
-		// RFC 2616 doesn't explicitly permit nor forbid an
+	if !isResponse {
+		// RFC 2616 neither explicitly permits nor forbids an
 		// entity-body on a GET request so we permit one if
 		// declared, but we default to 0 here (not -1 below)
 		// if there's no mention of a body.
+		// Likewise, all other request methods are assumed to have
+		// no body if neither Transfer-Encoding chunked nor a
+		// Content-Length are set.
 		return 0, nil
 	}
 
"
GO-2021-0159,go.googlesource.com,go,c2db5f4ccc61ba7df96a747e268a277b802cbb87," func (cw *chunkWriter) writeHeader(p []byte) {
 	// don't want to do an unbounded amount of reading here for
 	// DoS reasons, so we only try up to a threshold.
 	if w.req.ContentLength != 0 && !w.closeAfterReply {
-		ecr, isExpecter := w.req.Body.(*expectContinueReader)
-		if !isExpecter || ecr.resp.wroteContinue {
-			var tooBig bool
-			if reqBody, ok := w.req.Body.(*body); ok && reqBody.unreadDataSize() >= maxPostHandlerReadBytes {
+		var discard, tooBig bool
+
+		switch bdy := w.req.Body.(type) {
+		case *expectContinueReader:
+			if bdy.resp.wroteContinue {
+				discard = true
+			}
+		case *body:
+			switch {
+			case bdy.closed:
+				if !bdy.sawEOF {
+					// Body was closed in handler with non-EOF error.
+					w.closeAfterReply = true
+				}
+			case bdy.unreadDataSize() >= maxPostHandlerReadBytes:
 				tooBig = true
-			} else {
-				n, _ := io.CopyN(ioutil.Discard, w.req.Body, maxPostHandlerReadBytes+1)
-				tooBig = n >= maxPostHandlerReadBytes
+			default:
+				discard = true
 			}
-			if tooBig {
-				w.requestTooLarge()
-				delHeader(""Connection"")
-				setHeader.connection = ""close""
-			} else {
-				w.req.Body.Close()
+		default:
+			discard = true
+		}
+
+		if discard {
+			_, err := io.CopyN(ioutil.Discard, w.req.Body, maxPostHandlerReadBytes+1)
+			switch err {
+			case nil:
+				// There must be even more data left over.
+				tooBig = true
+			case ErrBodyReadAfterClose:
+				// Body was already consumed and closed.
+			case io.EOF:
+				// The remaining body was just consumed, close it.
+				err = w.req.Body.Close()
+				if err != nil {
+					w.closeAfterReply = true
+				}
+			default:
+				// Some other kind of error occured, like a read timeout, or
+				// corrupt chunked encoding. In any case, whatever remains
+				// on the wire must not be parsed as another HTTP request.
+				w.closeAfterReply = true
 			}
 		}
+
+		if tooBig {
+			w.requestTooLarge()
+			delHeader(""Connection"")
+			setHeader.connection = ""close""
+		}
 	}
 
 	code := w.status
"
GO-2021-0317,go.googlesource.com,go,ad345c265916bbf6c646865e4642eafce6d39e78," func (z *Rat) SetString(s string) (*Rat, bool) {
 		n := exp5
 		if n < 0 {
 			n = -n
+			if n < 0 {
+				// This can occur if -n overflows. -(-1 << 63) would become
+				// -1 << 63, which is still negative.
+				return nil, false
+			}
 		}
 		if n > 1e6 {
 			return nil, false // avoid excessively large exponents
"
GO-2022-0318,go.googlesource.com,go,fa4d9b8e2bc2612960c80474fca83a4c85a974eb," func (r *codeRepo) Latest() (*RevInfo, error) {
 // If statVers is a valid module version, it is used for the Version field.
 // Otherwise, the Version is derived from the passed-in info and recent tags.
 func (r *codeRepo) convert(info *codehost.RevInfo, statVers string) (*RevInfo, error) {
-	info2 := &RevInfo{
-		Name:  info.Name,
-		Short: info.Short,
-		Time:  info.Time,
-	}
-
 	// If this is a plain tag (no dir/ prefix)
 	// and the module path is unversioned,
 	// and if the underlying file tree has no go.mod,
 	// then allow using the tag with a +incompatible suffix.
+	//
+	// (If the version is +incompatible, then the go.mod file must not exist:
+	// +incompatible is not an ongoing opt-out from semantic import versioning.)
 	var canUseIncompatible func() bool
 	canUseIncompatible = func() bool {
 		var ok bool
"
GO-2022-0318,go.googlesource.com,go,fa4d9b8e2bc2612960c80474fca83a4c85a974eb," func (r *codeRepo) convert(info *codehost.RevInfo, statVers string) (*RevInfo, e
 		return ok
 	}
 
-	invalidf := func(format string, args ...any) error {
-		return &module.ModuleError{
-			Path: r.modPath,
-			Err: &module.InvalidVersionError{
-				Version: info2.Version,
-				Err:     fmt.Errorf(format, args...),
-			},
-		}
-	}
-
-	// checkGoMod verifies that the go.mod file for the module exists or does not
-	// exist as required by info2.Version and the module path represented by r.
-	checkGoMod := func() (*RevInfo, error) {
+	// checkCanonical verifies that the canonical version v is compatible with the
+	// module path represented by r, adding a ""+incompatible"" suffix if needed.
+	//
+	// If statVers is also canonical, checkCanonical also verifies that v is
+	// either statVers or statVers with the added ""+incompatible"" suffix.
+	checkCanonical := func(v string) (*RevInfo, error) {
 		// If r.codeDir is non-empty, then the go.mod file must exist: the module
 		// author  not the module consumer,  gets to decide how to carve up the repo
 		// into modules.
"
GO-2022-0318,go.googlesource.com,go,fa4d9b8e2bc2612960c80474fca83a4c85a974eb," func (r *codeRepo) convert(info *codehost.RevInfo, statVers string) (*RevInfo, e
 		// r.findDir verifies both of these conditions. Execute it now so that
 		// r.Stat will correctly return a notExistError if the go.mod location or
 		// declared module path doesn't match.
-		_, _, _, err := r.findDir(info2.Version)
+		_, _, _, err := r.findDir(v)
 		if err != nil {
 			// TODO: It would be nice to return an error like ""not a module"".
 			// Right now we return ""missing go.mod"", which is a little confusing.
 			return nil, &module.ModuleError{
 				Path: r.modPath,
 				Err: &module.InvalidVersionError{
-					Version: info2.Version,
+					Version: v,
 					Err:     notExistError{err: err},
 				},
 			}
 		}
 
-		// If the version is +incompatible, then the go.mod file must not exist:
-		// +incompatible is not an ongoing opt-out from semantic import versioning.
-		if strings.HasSuffix(info2.Version, ""+incompatible"") {
-			if !canUseIncompatible() {
+		invalidf := func(format string, args ...any) error {
+			return &module.ModuleError{
+				Path: r.modPath,
+				Err: &module.InvalidVersionError{
+					Version: v,
+					Err:     fmt.Errorf(format, args...),
+				},
+			}
+		}
+
+		// Add the +incompatible suffix if needed or requested explicitly, and
+		// verify that its presence or absence is appropriate for this version
+		// (which depends on whether it has an explicit go.mod file).
+
+		if v == strings.TrimSuffix(statVers, ""+incompatible"") {
+			v = statVers
+		}
+		base := strings.TrimSuffix(v, ""+incompatible"")
+		var errIncompatible error
+		if !module.MatchPathMajor(base, r.pathMajor) {
+			if canUseIncompatible() {
+				v = base + ""+incompatible""
+			} else {
 				if r.pathMajor != """" {
-					return nil, invalidf(""+incompatible suffix not allowed: module path includes a major version suffix, so major version must match"")
+					errIncompatible = invalidf(""module path includes a major version suffix, so major version must match"")
 				} else {
-					return nil, invalidf(""+incompatible suffix not allowed: module contains a go.mod file, so semantic import versioning is required"")
+					errIncompatible = invalidf(""module contains a go.mod file, so module path must match major version (%q)"", path.Join(r.pathPrefix, semver.Major(v)))
 				}
 			}
+		} else if strings.HasSuffix(v, ""+incompatible"") {
+			errIncompatible = invalidf(""+incompatible suffix not allowed: major version %s is compatible"", semver.Major(v))
+		}
 
-			if err := module.CheckPathMajor(strings.TrimSuffix(info2.Version, ""+incompatible""), r.pathMajor); err == nil {
-				return nil, invalidf(""+incompatible suffix not allowed: major version %s is compatible"", semver.Major(info2.Version))
+		if statVers != """" && statVers == module.CanonicalVersion(statVers) {
+			// Since the caller-requested version is canonical, it would be very
+			// confusing to resolve it to anything but itself, possibly with a
+			// ""+incompatible"" suffix. Error out explicitly.
+			if statBase := strings.TrimSuffix(statVers, ""+incompatible""); statBase != base {
+				return nil, &module.ModuleError{
+					Path: r.modPath,
+					Err: &module.InvalidVersionError{
+						Version: statVers,
+						Err:     fmt.Errorf(""resolves to version %v (%s is not a tag)"", v, statBase),
+					},
+				}
 			}
 		}
 
-		return info2, nil
+		if errIncompatible != nil {
+			return nil, errIncompatible
+		}
+
+		return &RevInfo{
+			Name:    info.Name,
+			Short:   info.Short,
+			Time:    info.Time,
+			Version: v,
+		}, nil
 	}
 
 	// Determine version.
-	//
-	// If statVers is canonical, then the original call was repo.Stat(statVers).
-	// Since the version is canonical, we must not resolve it to anything but
-	// itself, possibly with a '+incompatible' annotation: we do not need to do
-	// the work required to look for an arbitrary pseudo-version.
-	if statVers != """" && statVers == module.CanonicalVersion(statVers) {
-		info2.Version = statVers
-
-		if module.IsPseudoVersion(info2.Version) {
-			if err := r.validatePseudoVersion(info, info2.Version); err != nil {
-				return nil, err
-			}
-			return checkGoMod()
-		}
 
-		if err := module.CheckPathMajor(info2.Version, r.pathMajor); err != nil {
-			if canUseIncompatible() {
-				info2.Version += ""+incompatible""
-				return checkGoMod()
-			} else {
-				if vErr, ok := err.(*module.InvalidVersionError); ok {
-					// We're going to describe why the version is invalid in more detail,
-					// so strip out the existing invalid version wrapper.
-					err = vErr.Err
-				}
-				return nil, invalidf(""module contains a go.mod file, so major version must be compatible: %v"", err)
-			}
+	if module.IsPseudoVersion(statVers) {
+		if err := r.validatePseudoVersion(info, statVers); err != nil {
+			return nil, err
 		}
-
-		return checkGoMod()
+		return checkCanonical(statVers)
 	}
 
-	// statVers is empty or non-canonical, so we need to resolve it to a canonical
-	// version or pseudo-version.
+	// statVers is not a pseudo-version, so we need to either resolve it to a
+	// canonical version or verify that it is already a canonical tag
+	// (not a branch).
 
 	// Derive or verify a version from a code repo tag.
 	// Tag must have a prefix matching codeDir.
"
GO-2022-0318,go.googlesource.com,go,fa4d9b8e2bc2612960c80474fca83a4c85a974eb," func (r *codeRepo) convert(info *codehost.RevInfo, statVers string) (*RevInfo, e
 		if v == """" || !strings.HasPrefix(trimmed, v) {
 			return """", false // Invalid or incomplete version (just vX or vX.Y).
 		}
-		if isRetracted(v) {
-			return """", false
-		}
 		if v == trimmed {
 			tagIsCanonical = true
 		}
-
-		if err := module.CheckPathMajor(v, r.pathMajor); err != nil {
-			if canUseIncompatible() {
-				return v + ""+incompatible"", tagIsCanonical
-			}
-			return """", false
-		}
-
 		return v, tagIsCanonical
 	}
 
 	// If the VCS gave us a valid version, use that.
 	if v, tagIsCanonical := tagToVersion(info.Version); tagIsCanonical {
-		info2.Version = v
-		return checkGoMod()
+		if info, err := checkCanonical(v); err == nil {
+			return info, err
+		}
 	}
 
 	// Look through the tags on the revision for either a usable canonical version
 	// or an appropriate base for a pseudo-version.
-	var pseudoBase string
+	var (
+		highestCanonical string
+		pseudoBase       string
+	)
 	for _, pathTag := range info.Tags {
 		v, tagIsCanonical := tagToVersion(pathTag)
-		if tagIsCanonical {
-			if statVers != """" && semver.Compare(v, statVers) == 0 {
-				// The user requested a non-canonical version, but the tag for the
-				// canonical equivalent refers to the same revision. Use it.
-				info2.Version = v
-				return checkGoMod()
+		if statVers != """" && semver.Compare(v, statVers) == 0 {
+			// The tag is equivalent to the version requested by the user.
+			if tagIsCanonical {
+				// This tag is the canonical form of the requested version,
+				// not some other form with extra build metadata.
+				// Use this tag so that the resolved version will match exactly.
+				// (If it isn't actually allowed, we'll error out in checkCanonical.)
+				return checkCanonical(v)
 			} else {
-				// Save the highest canonical tag for the revision. If we don't find a
-				// better match, we'll use it as the canonical version.
+				// The user explicitly requested something equivalent to this tag. We
+				// can't use the version from the tag directly: since the tag is not
+				// canonical, it could be ambiguous. For example, tags v0.0.1+a and
+				// v0.0.1+b might both exist and refer to different revisions.
 				//
-				// NOTE: Do not replace this with semver.Max. Despite the name,
-				// semver.Max *also* canonicalizes its arguments, which uses
-				// semver.Canonical instead of module.CanonicalVersion and thereby
-				// strips our ""+incompatible"" suffix.
-				if semver.Compare(info2.Version, v) < 0 {
-					info2.Version = v
-				}
+				// The tag is otherwise valid for the module, so we can at least use it as
+				// the base of an unambiguous pseudo-version.
+				//
+				// If multiple tags match, tagToVersion will canonicalize them to the same
+				// base version.
+				pseudoBase = v
+			}
+		}
+		// Save the highest non-retracted canonical tag for the revision.
+		// If we don't find a better match, we'll use it as the canonical version.
+		if tagIsCanonical && semver.Compare(highestCanonical, v) < 0 && !isRetracted(v) {
+			if module.MatchPathMajor(v, r.pathMajor) || canUseIncompatible() {
+				highestCanonical = v
 			}
-		} else if v != """" && semver.Compare(v, statVers) == 0 {
-			// The user explicitly requested something equivalent to this tag. We
-			// can't use the version from the tag directly: since the tag is not
-			// canonical, it could be ambiguous. For example, tags v0.0.1+a and
-			// v0.0.1+b might both exist and refer to different revisions.
-			//
-			// The tag is otherwise valid for the module, so we can at least use it as
-			// the base of an unambiguous pseudo-version.
-			//
-			// If multiple tags match, tagToVersion will canonicalize them to the same
-			// base version.
-			pseudoBase = v
 		}
 	}
 
-	// If we found any canonical tag for the revision, return it.
+	// If we found a valid canonical tag for the revision, return it.
 	// Even if we found a good pseudo-version base, a canonical version is better.
-	if info2.Version != """" {
-		return checkGoMod()
+	if highestCanonical != """" {
+		return checkCanonical(highestCanonical)
 	}
 
 	// Find the highest tagged version in the revision's history, subject to
"
GO-2022-0318,go.googlesource.com,go,fa4d9b8e2bc2612960c80474fca83a4c85a974eb," func (r *codeRepo) convert(info *codehost.RevInfo, statVers string) (*RevInfo, e
 				tag, _ = r.code.RecentTag(info.Name, tagPrefix, allowedMajor(""v0""))
 			}
 		}
-		pseudoBase, _ = tagToVersion(tag) // empty if the tag is invalid
+		pseudoBase, _ = tagToVersion(tag)
 	}
 
-	info2.Version = module.PseudoVersion(r.pseudoMajor, pseudoBase, info.Time, info.Short)
-	return checkGoMod()
+	return checkCanonical(module.PseudoVersion(r.pseudoMajor, pseudoBase, info.Time, info.Short))
 }
 
 // validatePseudoVersion checks that version has a major version compatible with
"
GO-2022-0318,go.googlesource.com,go,fa4d9b8e2bc2612960c80474fca83a4c85a974eb," func (r *codeRepo) validatePseudoVersion(info *codehost.RevInfo, version string)
 		}
 	}()
 
-	if err := module.CheckPathMajor(version, r.pathMajor); err != nil {
-		return err
-	}
-
 	rev, err := module.PseudoVersionRev(version)
 	if err != nil {
 		return err
"
GO-2021-0235,go.googlesource.com,go,d95ca9138026cbe40e0857d76a81a16d03230871," func p224Invert(out, in *p224FieldElement) {
 // p224Contract converts a FieldElement to its unique, minimal form.
 //
 // On entry, in[i] < 2**29
-// On exit, in[i] < 2**28
+// On exit, out[i] < 2**28 and out < p
 func p224Contract(out, in *p224FieldElement) {
 	copy(out[:], in[:])
 
+	// First, carry the bits above 28 to the higher limb.
 	for i := 0; i < 7; i++ {
 		out[i+1] += out[i] >> 28
 		out[i] &= bottom28Bits
"
GO-2021-0235,go.googlesource.com,go,d95ca9138026cbe40e0857d76a81a16d03230871," func p224Contract(out, in *p224FieldElement) {
 	top := out[7] >> 28
 	out[7] &= bottom28Bits
 
+	// Use the reduction identity to carry the overflow.
+	//
+	//   a + top * 2 = a + top * 2 - top
 	out[0] -= top
 	out[3] += top << 12
 
-	// We may just have made out[i] negative. So we carry down. If we made
+	// We may just have made out[0] negative. So we carry down. If we made
 	// out[0] negative then we know that out[3] is sufficiently positive
 	// because we just added to it.
 	for i := 0; i < 3; i++ {
"
GO-2021-0235,go.googlesource.com,go,d95ca9138026cbe40e0857d76a81a16d03230871," func p224Contract(out, in *p224FieldElement) {
 	// There are two cases to consider for out[3]:
 	//   1) The first time that we eliminated top, we didn't push out[3] over
 	//      2**28. In this case, the partial carry chain didn't change any values
-	//      and top is zero.
+	//      and top is now zero.
 	//   2) We did push out[3] over 2**28 the first time that we eliminated top.
-	//      The first value of top was in [0..16), therefore, prior to eliminating
-	//      the first top, 0xfff1000 <= out[3] <= 0xfffffff. Therefore, after
-	//      overflowing and being reduced by the second carry chain, out[3] <=
-	//      0xf000. Thus it cannot have overflowed when we eliminated top for the
-	//      second time.
+	//      The first value of top was in [0..2], therefore, after overflowing
+	//      and being reduced by the second carry chain, out[3] <= 2<<12 - 1.
+	// In both cases, out[3] cannot have overflowed when we eliminated top for
+	// the second time.
 
 	// Again, we may just have made out[0] negative, so do the same carry down.
 	// As before, if we made out[0] negative then we know that out[3] is
"
GO-2021-0235,go.googlesource.com,go,d95ca9138026cbe40e0857d76a81a16d03230871," func p224Contract(out, in *p224FieldElement) {
 	bottom3NonZero |= bottom3NonZero >> 1
 	bottom3NonZero = uint32(int32(bottom3NonZero<<31) >> 31)
 
-	// Everything depends on the value of out[3].
-	//    If it's > 0xffff000 and top4AllOnes != 0 then the whole value is >= p
-	//    If it's = 0xffff000 and top4AllOnes != 0 and bottom3NonZero != 0,
-	//      then the whole value is >= p
+	// Assuming top4AllOnes != 0, everything depends on the value of out[3].
+	//    If it's > 0xffff000 then the whole value is > p
+	//    If it's = 0xffff000 and bottom3NonZero != 0, then the whole value is >= p
 	//    If it's < 0xffff000, then the whole value is < p
-	n := out[3] - 0xffff000
+	n := 0xffff000 - out[3]
 	out3Equal := n
 	out3Equal |= out3Equal >> 16
 	out3Equal |= out3Equal >> 8
"
GO-2021-0235,go.googlesource.com,go,d95ca9138026cbe40e0857d76a81a16d03230871," func p224Contract(out, in *p224FieldElement) {
 	out3Equal |= out3Equal >> 1
 	out3Equal = ^uint32(int32(out3Equal<<31) >> 31)
 
-	// If out[3] > 0xffff000 then n's MSB will be zero.
-	out3GT := ^uint32(int32(n) >> 31)
+	// If out[3] > 0xffff000 then n's MSB will be one.
+	out3GT := uint32(int32(n) >> 31)
 
 	mask := top4AllOnes & ((out3Equal & bottom3NonZero) | out3GT)
 	out[0] -= 1 & mask
"
GO-2021-0235,go.googlesource.com,go,d95ca9138026cbe40e0857d76a81a16d03230871," func p224Contract(out, in *p224FieldElement) {
 	out[5] -= 0xfffffff & mask
 	out[6] -= 0xfffffff & mask
 	out[7] -= 0xfffffff & mask
+
+	// Do one final carry down, in case we made out[0] negative. One of
+	// out[0..3] needs to be positive and able to absorb the -1 or the value
+	// would have been < p, and the subtraction wouldn't have happened.
+	for i := 0; i < 3; i++ {
+		mask := uint32(int32(out[i]) >> 31)
+		out[i] += (1 << 28) & mask
+		out[i+1] -= 1 & mask
+	}
 }
 
 // Group element functions.
"
GO-2022-0531,go.googlesource.com,go,fe4de36198794c447fbd9d7cc2d7199a506c76a5," func (hs *serverHandshakeStateTLS13) sendSessionTickets() error {
 	}
 	m.lifetime = uint32(maxSessionTicketLifetime / time.Second)
 
+	// ticket_age_add is a random 32-bit value. See RFC 8446, section 4.6.1
+	// The value is not stored anywhere; we never need to check the ticket age
+	// because 0-RTT is not supported.
+	ageAdd := make([]byte, 4)
+	_, err = hs.c.config.rand().Read(ageAdd)
+	if err != nil {
+		return err
+	}
+	m.ageAdd = binary.LittleEndian.Uint32(ageAdd)
+
+	// ticket_nonce, which must be unique per connection, is always left at
+	// zero because we only ever send one ticket per connection.
+
 	if _, err := c.writeRecord(recordTypeHandshake, m.marshal()); err != nil {
 		return err
 	}
"
GO-2022-0523,go.googlesource.com,go,c4c1993fd2a5b26fe45c09592af6d3388a3b2e08," func (d *Decoder) DecodeElement(v any, start *StartElement) error {
 	if val.IsNil() {
 		return errors.New(""nil pointer passed to Unmarshal"")
 	}
-	return d.unmarshal(val.Elem(), start)
+	return d.unmarshal(val.Elem(), start, 0)
 }
 
 // An UnmarshalError represents an error in the unmarshaling process.
"
GO-2022-0523,go.googlesource.com,go,c4c1993fd2a5b26fe45c09592af6d3388a3b2e08," var (
 	textUnmarshalerType = reflect.TypeOf((*encoding.TextUnmarshaler)(nil)).Elem()
 )
 
+const maxUnmarshalDepth = 10000
+
+var errExeceededMaxUnmarshalDepth = errors.New(""exceeded max depth"")
+
 // Unmarshal a single XML element into val.
-func (d *Decoder) unmarshal(val reflect.Value, start *StartElement) error {
+func (d *Decoder) unmarshal(val reflect.Value, start *StartElement, depth int) error {
+	if depth >= maxUnmarshalDepth {
+		return errExeceededMaxUnmarshalDepth
+	}
 	// Find start element if we need it.
 	if start == nil {
 		for {
"
GO-2022-0523,go.googlesource.com,go,c4c1993fd2a5b26fe45c09592af6d3388a3b2e08," func (d *Decoder) unmarshal(val reflect.Value, start *StartElement) error {
 		v.Set(reflect.Append(val, reflect.Zero(v.Type().Elem())))
 
 		// Recur to read element into slice.
-		if err := d.unmarshal(v.Index(n), start); err != nil {
+		if err := d.unmarshal(v.Index(n), start, depth+1); err != nil {
 			v.SetLen(n)
 			return err
 		}
"
GO-2022-0523,go.googlesource.com,go,c4c1993fd2a5b26fe45c09592af6d3388a3b2e08," Loop:
 		case StartElement:
 			consumed := false
 			if sv.IsValid() {
-				consumed, err = d.unmarshalPath(tinfo, sv, nil, &t)
+				// unmarshalPath can call unmarshal, so we need to pass the depth through so that
+				// we can continue to enforce the maximum recusion limit.
+				consumed, err = d.unmarshalPath(tinfo, sv, nil, &t, depth)
 				if err != nil {
 					return err
 				}
 				if !consumed && saveAny.IsValid() {
 					consumed = true
-					if err := d.unmarshal(saveAny, &t); err != nil {
+					if err := d.unmarshal(saveAny, &t, depth+1); err != nil {
 						return err
 					}
 				}
"
GO-2022-0523,go.googlesource.com,go,c4c1993fd2a5b26fe45c09592af6d3388a3b2e08," func copyValue(dst reflect.Value, src []byte) (err error) {
 // The consumed result tells whether XML elements have been consumed
 // from the Decoder until start's matching end element, or if it's
 // still untouched because start is uninteresting for sv's fields.
-func (d *Decoder) unmarshalPath(tinfo *typeInfo, sv reflect.Value, parents []string, start *StartElement) (consumed bool, err error) {
+func (d *Decoder) unmarshalPath(tinfo *typeInfo, sv reflect.Value, parents []string, start *StartElement, depth int) (consumed bool, err error) {
 	recurse := false
 Loop:
 	for i := range tinfo.fields {
"
GO-2022-0523,go.googlesource.com,go,c4c1993fd2a5b26fe45c09592af6d3388a3b2e08," Loop:
 		}
 		if len(finfo.parents) == len(parents) && finfo.name == start.Name.Local {
 			// It's a perfect match, unmarshal the field.
-			return true, d.unmarshal(finfo.value(sv, initNilPointers), start)
+			return true, d.unmarshal(finfo.value(sv, initNilPointers), start, depth+1)
 		}
 		if len(finfo.parents) > len(parents) && finfo.parents[len(parents)] == start.Name.Local {
 			// It's a prefix for the field. Break and recurse
"
GO-2022-0523,go.googlesource.com,go,c4c1993fd2a5b26fe45c09592af6d3388a3b2e08," Loop:
 		}
 		switch t := tok.(type) {
 		case StartElement:
-			consumed2, err := d.unmarshalPath(tinfo, sv, parents, &t)
+			// the recursion depth of unmarshalPath is limited to the path length specified
+			// by the struct field tag, so we don't increment the depth here.
+			consumed2, err := d.unmarshalPath(tinfo, sv, parents, &t, depth)
 			if err != nil {
 				return true, err
 			}
"
GO-2021-0242,go.googlesource.com,go,6c591f79b0b5327549bd4e94970f7a279efb4ab0," func (z *Rat) SetString(s string) (*Rat, bool) {
 		if n < 0 {
 			n = -n
 		}
+		if n > 1e6 {
+			return nil, false // avoid excessively large exponents
+		}
 		pow5 := z.b.abs.expNN(natFive, nat(nil).setWord(Word(n)), nil) // use underlying array of z.b.abs
 		if exp5 > 0 {
 			z.a.abs = z.a.abs.mul(z.a.abs, pow5)
"
GO-2021-0242,go.googlesource.com,go,6c591f79b0b5327549bd4e94970f7a279efb4ab0," func (z *Rat) SetString(s string) (*Rat, bool) {
 	}
 
 	// apply exp2 contributions
+	if exp2 < -1e7 || exp2 > 1e7 {
+		return nil, false // avoid excessively large exponents
+	}
 	if exp2 > 0 {
-		if int64(uint(exp2)) != exp2 {
-			panic(""exponent too large"")
-		}
 		z.a.abs = z.a.abs.shl(z.a.abs, uint(exp2))
 	} else if exp2 < 0 {
-		if int64(uint(-exp2)) != -exp2 {
-			panic(""exponent too large"")
-		}
 		z.b.abs = z.b.abs.shl(z.b.abs, uint(-exp2))
 	}
 
"
GO-2021-0238,go.googlesource.com,net,37e1c6afe02340126705deced573a85ab75209d7," func inHeadIM(p *parser) bool {
 			// Ignore the token.
 			return true
 		case a.Template:
+			// TODO: remove this divergence from the HTML5 spec.
+			//
+			// We don't handle all of the corner cases when mixing foreign
+			// content (i.e. <math> or <svg>) with <template>. Without this
+			// early return, we can get into an infinite loop, possibly because
+			// of the ""TODO... further divergence"" a little below.
+			//
+			// As a workaround, if we are mixing foreign content and templates,
+			// just ignore the rest of the HTML. Foreign content is rare and a
+			// relatively old HTML feature. Templates are also rare and a
+			// relatively new HTML feature. Their combination is very rare.
+			for _, e := range p.oe {
+				if e.Namespace != """" {
+					p.im = ignoreTheRemainingTokens
+					return true
+				}
+			}
+
 			p.addElement()
 			p.afe = append(p.afe, &scopeMarker)
 			p.framesetOK = false
"
GO-2021-0238,go.googlesource.com,net,37e1c6afe02340126705deced573a85ab75209d7," func inHeadIM(p *parser) bool {
 			if !p.oe.contains(a.Template) {
 				return true
 			}
-			// TODO: remove this divergence from the HTML5 spec.
+			// TODO: remove this further divergence from the HTML5 spec.
 			//
 			// See https://bugs.chromium.org/p/chromium/issues/detail?id=829668
 			p.generateImpliedEndTags()
"
GO-2022-0532,go.googlesource.com,go,960ffa98ce73ef2c2060c84c7ac28d37a83f345e," func lookExtensions(path, dir string) (string, error) {
 // The Wait method will return the exit code and release associated resources
 // once the command exits.
 func (c *Cmd) Start() error {
+	if c.Path == """" && c.Err == nil && c.lookPathErr == nil {
+		c.Err = errors.New(""exec: no command"")
+	}
 	if c.Err != nil || c.lookPathErr != nil {
 		c.closeDescriptors(c.closeAfterStart)
 		c.closeDescriptors(c.closeAfterWait)
"
GO-2022-0475,go.googlesource.com,go,062e0e5ce6df339dc26732438ad771f73dbf2292," func dynimport(obj string) {
 			if s.Version != """" {
 				targ += ""#"" + s.Version
 			}
+			checkImportSymName(s.Name)
+			checkImportSymName(targ)
 			fmt.Fprintf(stdout, ""//go:cgo_import_dynamic %s %s %q\n"", s.Name, targ, s.Library)
 		}
 		lib, _ := f.ImportedLibraries()
"
GO-2022-0475,go.googlesource.com,go,062e0e5ce6df339dc26732438ad771f73dbf2292," func dynimport(obj string) {
 			if len(s) > 0 && s[0] == '_' {
 				s = s[1:]
 			}
+			checkImportSymName(s)
 			fmt.Fprintf(stdout, ""//go:cgo_import_dynamic %s %s %q\n"", s, s, """")
 		}
 		lib, _ := f.ImportedLibraries()
"
GO-2022-0475,go.googlesource.com,go,062e0e5ce6df339dc26732438ad771f73dbf2292," func dynimport(obj string) {
 		for _, s := range sym {
 			ss := strings.Split(s, "":"")
 			name := strings.Split(ss[0], ""@"")[0]
+			checkImportSymName(name)
+			checkImportSymName(ss[0])
 			fmt.Fprintf(stdout, ""//go:cgo_import_dynamic %s %s %q\n"", name, ss[0], strings.ToLower(ss[1]))
 		}
 		return
"
GO-2022-0475,go.googlesource.com,go,062e0e5ce6df339dc26732438ad771f73dbf2292," func dynimport(obj string) {
 				// Go symbols.
 				continue
 			}
+			checkImportSymName(s.Name)
 			fmt.Fprintf(stdout, ""//go:cgo_import_dynamic %s %s %q\n"", s.Name, s.Name, s.Library)
 		}
 		lib, err := f.ImportedLibraries()
"
GO-2022-0475,go.googlesource.com,go,062e0e5ce6df339dc26732438ad771f73dbf2292," OverlayLoop:
 		noCompiler()
 	}
 
+	// Double check the //go:cgo_ldflag comments in the generated files.
+	// The compiler only permits such comments in files whose base name
+	// starts with ""_cgo_"". Make sure that the comments in those files
+	// are safe. This is a backstop against people somehow smuggling
+	// such a comment into a file generated by cgo.
+	if cfg.BuildToolchainName == ""gc"" && !cfg.BuildN {
+		var flags []string
+		for _, f := range outGo {
+			if !strings.HasPrefix(filepath.Base(f), ""_cgo_"") {
+				continue
+			}
+
+			src, err := ioutil.ReadFile(f)
+			if err != nil {
+				return nil, nil, err
+			}
+
+			const cgoLdflag = ""//go:cgo_ldflag""
+			idx := bytes.Index(src, []byte(cgoLdflag))
+			for idx >= 0 {
+				// We are looking at //go:cgo_ldflag.
+				// Find start of line.
+				start := bytes.LastIndex(src[:idx], []byte(""\n""))
+				if start == -1 {
+					start = 0
+				}
+
+				// Find end of line.
+				end := bytes.Index(src[idx:], []byte(""\n""))
+				if end == -1 {
+					end = len(src)
+				} else {
+					end += idx
+				}
+
+				// Check for first line comment in line.
+				// We don't worry about /* */ comments,
+				// which normally won't appear in files
+				// generated by cgo.
+				commentStart := bytes.Index(src[start:], []byte(""//""))
+				commentStart += start
+				// If that line comment is //go:cgo_ldflag,
+				// it's a match.
+				if bytes.HasPrefix(src[commentStart:], []byte(cgoLdflag)) {
+					// Pull out the flag, and unquote it.
+					// This is what the compiler does.
+					flag := string(src[idx+len(cgoLdflag) : end])
+					flag = strings.TrimSpace(flag)
+					flag = strings.Trim(flag, `""`)
+					flags = append(flags, flag)
+				}
+				src = src[end:]
+				idx = bytes.Index(src, []byte(cgoLdflag))
+			}
+		}
+		if err := checkLinkerFlags(""LDFLAGS"", ""go:cgo_ldflag"", flags); err != nil {
+			return nil, nil, err
+		}
+	}
+
 	return outGo, outObj, nil
 }
 
"
GO-2021-0160,go.googlesource.com,go,1e066cad1ba23f4064545355b8737e4762dd6838," func (z nat) expNNMontgomery(x, y, m nat) nat {
 	}
 	// convert to regular number
 	zz = zz.montgomery(z, one, m, k0, numWords)
+
+	// One last reduction, just in case.
+	// See golang.org/issue/13907.
+	if zz.cmp(m) >= 0 {
+		// Common case is m has high bit set; in that case,
+		// since zz is the same length as m, there can be just
+		// one multiple of m to remove. Just subtract.
+		// We think that the subtract should be sufficient in general,
+		// so do that unconditionally, but double-check,
+		// in case our beliefs are wrong.
+		// The div is not expected to be reached.
+		zz = zz.sub(zz, m)
+		if zz.cmp(m) >= 0 {
+			_, zz = nat(nil).div(nil, zz, m)
+		}
+	}
+
 	return zz.norm()
 }
 
"
GO-2021-0160,go.googlesource.com,go,4306352182bf94f86f0cfc6a8b0ed461cbf1d82c," func basicMul(z, x, y nat) {
 	}
 }
 
-// montgomery computes x*y*2^(-n*_W) mod m,
-// assuming k = -1/m mod 2^_W.
+// montgomery computes z mod m = x*y*2**(-n*_W) mod m,
+// assuming k = -1/m mod 2**_W.
 // z is used for storing the result which is returned;
 // z must not alias x, y or m.
+// See Gueron, ""Efficient Software Implementations of Modular Exponentiation"".
+// https://eprint.iacr.org/2011/239.pdf
+// In the terminology of that paper, this is an ""Almost Montgomery Multiplication"":
+// x and y are required to satisfy 0 <= z < 2**(n*_W) and then the result
+// z is guaranteed to satisfy 0 <= z < 2**(n*_W), but it may not be < m.
 func (z nat) montgomery(x, y, m nat, k Word, n int) nat {
-	var c1, c2 Word
+	// This code assumes x, y, m are all the same length, n.
+	// (required by addMulVVW and the for loop).
+	// It also assumes that x, y are already reduced mod m,
+	// or else the result will not be properly reduced.
+	if len(x) != n || len(y) != n || len(m) != n {
+		panic(""math/big: mismatched montgomery number lengths"")
+	}
+	var c1, c2, c3 Word
 	z = z.make(n)
 	z.clear()
 	for i := 0; i < n; i++ {
 		d := y[i]
-		c1 += addMulVVW(z, x, d)
+		c2 = addMulVVW(z, x, d)
 		t := z[0] * k
-		c2 = addMulVVW(z, m, t)
-
+		c3 = addMulVVW(z, m, t)
 		copy(z, z[1:])
-		z[n-1] = c1 + c2
-		if z[n-1] < c1 {
+		cx := c1 + c2
+		cy := cx + c3
+		z[n-1] = cy
+		if cx < c2 || cy < c3 {
 			c1 = 1
 		} else {
 			c1 = 0
"
GO-2021-0263,go.googlesource.com,go,61536ec03063b4951163bd09609c86d82631fa27," func NewFile(r io.ReaderAt) (*File, error) {
 			if err := binary.Read(b, bo, &hdr); err != nil {
 				return nil, err
 			}
+			if hdr.Iundefsym > uint32(len(f.Symtab.Syms)) {
+				return nil, &FormatError{offset, fmt.Sprintf(
+					""undefined symbols index in dynamic symbol table command is greater than symbol table length (%d > %d)"",
+					hdr.Iundefsym, len(f.Symtab.Syms)), nil}
+			} else if hdr.Iundefsym+hdr.Nundefsym > uint32(len(f.Symtab.Syms)) {
+				return nil, &FormatError{offset, fmt.Sprintf(
+					""number of undefined symbols after index in dynamic symbol table command is greater than symbol table length (%d > %d)"",
+					hdr.Iundefsym+hdr.Nundefsym, len(f.Symtab.Syms)), nil}
+			}
 			dat := make([]byte, hdr.Nindirectsyms*4)
 			if _, err := r.ReadAt(dat, int64(hdr.Indirectsymoff)); err != nil {
 				return nil, err
"
GO-2021-0226,go.googlesource.com,go,4f5cd0c0331943c7ec72df3b827d972584f77833," func (r *response) Header() http.Header {
 	return r.header
 }
 
-func (r *response) Write(data []byte) (int, error) {
+func (r *response) Write(p []byte) (n int, err error) {
 	if !r.wroteHeader {
 		r.WriteHeader(http.StatusOK)
 	}
-	return r.w.Write(data)
+	if !r.wroteCGIHeader {
+		r.writeCGIHeader(p)
+	}
+	return r.w.Write(p)
 }
 
 func (r *response) WriteHeader(code int) {
"
GO-2021-0234,go.googlesource.com,go,d0b79e3513a29628f3599dc8860666b6eed75372," func (d *Decoder) Token() (Token, error) {
 	if d.nextToken != nil {
 		t = d.nextToken
 		d.nextToken = nil
-	} else if t, err = d.rawToken(); err != nil {
-		switch {
-		case err == io.EOF && d.t != nil:
-			err = nil
-		case err == io.EOF && d.stk != nil && d.stk.kind != stkEOF:
-			err = d.syntaxError(""unexpected EOF"")
+	} else {
+		if t, err = d.rawToken(); t == nil && err != nil {
+			if err == io.EOF && d.stk != nil && d.stk.kind != stkEOF {
+				err = d.syntaxError(""unexpected EOF"")
+			}
+			return nil, err
 		}
-		return t, err
+		// We still have a token to process, so clear any
+		// errors (e.g. EOF) and proceed.
+		err = nil
 	}
-
 	if !d.Strict {
 		if t1, ok := d.autoClose(t); ok {
 			d.nextToken = t
"
GO-2020-0012,go.googlesource.com,crypto,bac4c82f69751a6dd76e702d54b3ceb88adab236," func parseED25519(in []byte) (out PublicKey, rest []byte, err error) {
 		return nil, nil, err
 	}
 
-	key := ed25519.PublicKey(w.KeyBytes)
+	if l := len(w.KeyBytes); l != ed25519.PublicKeySize {
+		return nil, nil, fmt.Errorf(""invalid size %d for Ed25519 public key"", l)
+	}
 
-	return (ed25519PublicKey)(key), w.Rest, nil
+	return ed25519PublicKey(w.KeyBytes), w.Rest, nil
 }
 
 func (k ed25519PublicKey) Marshal() []byte {
"
GO-2020-0012,go.googlesource.com,crypto,bac4c82f69751a6dd76e702d54b3ceb88adab236," func (k ed25519PublicKey) Verify(b []byte, sig *Signature) error {
 	if sig.Format != k.Type() {
 		return fmt.Errorf(""ssh: signature type %s for key type %s"", sig.Format, k.Type())
 	}
+	if l := len(k); l != ed25519.PublicKeySize {
+		return fmt.Errorf(""ssh: invalid size %d for Ed25519 public key"", l)
+	}
 
-	edKey := (ed25519.PublicKey)(k)
-	if ok := ed25519.Verify(edKey, b, sig.Blob); !ok {
+	if ok := ed25519.Verify(ed25519.PublicKey(k), b, sig.Blob); !ok {
 		return errors.New(""ssh: signature did not verify"")
 	}
 
"
GO-2020-0012,go.googlesource.com,crypto,bac4c82f69751a6dd76e702d54b3ceb88adab236," func parseSKEd25519(in []byte) (out PublicKey, rest []byte, err error) {
 		return nil, nil, err
 	}
 
+	if l := len(w.KeyBytes); l != ed25519.PublicKeySize {
+		return nil, nil, fmt.Errorf(""invalid size %d for Ed25519 public key"", l)
+	}
+
 	key := new(skEd25519PublicKey)
 	key.application = w.Application
 	key.PublicKey = ed25519.PublicKey(w.KeyBytes)
"
GO-2020-0012,go.googlesource.com,crypto,bac4c82f69751a6dd76e702d54b3ceb88adab236," func (k *skEd25519PublicKey) Verify(data []byte, sig *Signature) error {
 	if sig.Format != k.Type() {
 		return fmt.Errorf(""ssh: signature type %s for key type %s"", sig.Format, k.Type())
 	}
+	if l := len(k.PublicKey); l != ed25519.PublicKeySize {
+		return fmt.Errorf(""invalid size %d for Ed25519 public key"", l)
+	}
 
 	h := sha256.New()
 	h.Write([]byte(k.application))
"
GO-2020-0012,go.googlesource.com,crypto,bac4c82f69751a6dd76e702d54b3ceb88adab236," func (k *skEd25519PublicKey) Verify(data []byte, sig *Signature) error {
 
 	original := Marshal(blob)
 
-	edKey := (ed25519.PublicKey)(k.PublicKey)
-	if ok := ed25519.Verify(edKey, original, edSig.Signature); !ok {
+	if ok := ed25519.Verify(k.PublicKey, original, edSig.Signature); !ok {
 		return errors.New(""ssh: signature did not verify"")
 	}
 
"
GO-2020-0012,go.googlesource.com,crypto,bac4c82f69751a6dd76e702d54b3ceb88adab236," func NewPublicKey(key interface{}) (PublicKey, error) {
 	case *dsa.PublicKey:
 		return (*dsaPublicKey)(key), nil
 	case ed25519.PublicKey:
-		return (ed25519PublicKey)(key), nil
+		if l := len(key); l != ed25519.PublicKeySize {
+			return nil, fmt.Errorf(""ssh: invalid size %d for Ed25519 public key"", l)
+		}
+		return ed25519PublicKey(key), nil
 	default:
 		return nil, fmt.Errorf(""ssh: unsupported key type %T"", key)
 	}
"
GO-2022-0191,go.googlesource.com,go,770130659b6fb2acf271476579a3644e093dda7f," func appendToFreshChain(chain []*Certificate, cert *Certificate) []*Certificate
 	return n
 }
 
-func (c *Certificate) buildChains(cache map[int][][]*Certificate, currentChain []*Certificate, opts *VerifyOptions) (chains [][]*Certificate, err error) {
-	possibleRoots, failedRoot, rootErr := opts.Roots.findVerifiedParents(c)
-nextRoot:
-	for _, rootNum := range possibleRoots {
-		root := opts.Roots.certs[rootNum]
+// maxChainSignatureChecks is the maximum number of CheckSignatureFrom calls
+// that an invocation of buildChains will (tranistively) make. Most chains are
+// less than 15 certificates long, so this leaves space for multiple chains and
+// for failed checks due to different intermediates having the same Subject.
+const maxChainSignatureChecks = 100
 
+func (c *Certificate) buildChains(cache map[*Certificate][][]*Certificate, currentChain []*Certificate, sigChecks *int, opts *VerifyOptions) (chains [][]*Certificate, err error) {
+	var (
+		hintErr  error
+		hintCert *Certificate
+	)
+
+	considerCandidate := func(certType int, candidate *Certificate) {
 		for _, cert := range currentChain {
-			if cert.Equal(root) {
-				continue nextRoot
+			if cert.Equal(candidate) {
+				return
 			}
 		}
 
-		err = root.isValid(rootCertificate, currentChain, opts)
-		if err != nil {
-			continue
+		if sigChecks == nil {
+			sigChecks = new(int)
+		}
+		*sigChecks++
+		if *sigChecks > maxChainSignatureChecks {
+			err = errors.New(""x509: signature check attempts limit reached while verifying certificate chain"")
+			return
 		}
-		chains = append(chains, appendToFreshChain(currentChain, root))
-	}
 
-	possibleIntermediates, failedIntermediate, intermediateErr := opts.Intermediates.findVerifiedParents(c)
-nextIntermediate:
-	for _, intermediateNum := range possibleIntermediates {
-		intermediate := opts.Intermediates.certs[intermediateNum]
-		for _, cert := range currentChain {
-			if cert.Equal(intermediate) {
-				continue nextIntermediate
+		if err := c.CheckSignatureFrom(candidate); err != nil {
+			if hintErr == nil {
+				hintErr = err
+				hintCert = candidate
 			}
+			return
 		}
-		err = intermediate.isValid(intermediateCertificate, currentChain, opts)
+
+		err = candidate.isValid(certType, currentChain, opts)
 		if err != nil {
-			continue
+			return
 		}
-		var childChains [][]*Certificate
-		childChains, ok := cache[intermediateNum]
-		if !ok {
-			childChains, err = intermediate.buildChains(cache, appendToFreshChain(currentChain, intermediate), opts)
-			cache[intermediateNum] = childChains
+
+		switch certType {
+		case rootCertificate:
+			chains = append(chains, appendToFreshChain(currentChain, candidate))
+		case intermediateCertificate:
+			if cache == nil {
+				cache = make(map[*Certificate][][]*Certificate)
+			}
+			childChains, ok := cache[candidate]
+			if !ok {
+				childChains, err = candidate.buildChains(cache, appendToFreshChain(currentChain, candidate), sigChecks, opts)
+				cache[candidate] = childChains
+			}
+			chains = append(chains, childChains...)
 		}
-		chains = append(chains, childChains...)
+	}
+
+	for _, rootNum := range opts.Roots.findPotentialParents(c) {
+		considerCandidate(rootCertificate, opts.Roots.certs[rootNum])
+	}
+	for _, intermediateNum := range opts.Intermediates.findPotentialParents(c) {
+		considerCandidate(intermediateCertificate, opts.Intermediates.certs[intermediateNum])
 	}
 
 	if len(chains) > 0 {
 		err = nil
 	}
-
 	if len(chains) == 0 && err == nil {
-		hintErr := rootErr
-		hintCert := failedRoot
-		if hintErr == nil {
-			hintErr = intermediateErr
-			hintCert = failedIntermediate
-		}
 		err = UnknownAuthorityError{c, hintErr, hintCert}
 	}
 
"
GO-2022-0537,go.googlesource.com,go,055113ef364337607e3e72ed7d48df67fde6fc66," func (z *Float) GobDecode(buf []byte) error {
 		*z = Float{}
 		return nil
 	}
+	if len(buf) < 6 {
+		return errors.New(""Float.GobDecode: buffer too small"")
+	}
 
 	if buf[0] != floatGobVersion {
 		return fmt.Errorf(""Float.GobDecode: encoding version %d not supported"", buf[0])
"
GO-2022-0537,go.googlesource.com,go,055113ef364337607e3e72ed7d48df67fde6fc66," func (z *Float) GobDecode(buf []byte) error {
 	z.prec = binary.BigEndian.Uint32(buf[2:])
 
 	if z.form == finite {
+		if len(buf) < 10 {
+			return errors.New(""Float.GobDecode: buffer too small for finite form float"")
+		}
 		z.exp = int32(binary.BigEndian.Uint32(buf[6:]))
 		z.mant = z.mant.setBytes(buf[10:])
 	}
"
GO-2022-0537,go.googlesource.com,go,055113ef364337607e3e72ed7d48df67fde6fc66," func (z *Rat) GobDecode(buf []byte) error {
 		*z = Rat{}
 		return nil
 	}
+	if len(buf) < 5 {
+		return errors.New(""Rat.GobDecode: buffer too small"")
+	}
 	b := buf[0]
 	if b>>1 != ratGobVersion {
 		return fmt.Errorf(""Rat.GobDecode: encoding version %d not supported"", b>>1)
 	}
 	const j = 1 + 4
 	i := j + binary.BigEndian.Uint32(buf[j-4:j])
+	if len(buf) < int(i) {
+		return errors.New(""Rat.GobDecode: buffer too small"")
+	}
 	z.a.neg = b&1 != 0
 	z.a.abs = z.a.abs.setBytes(buf[j:i])
 	z.b.abs = z.b.abs.setBytes(buf[i:])
"
GO-2021-0067,go.googlesource.com,go,cd3b4ca9f20fd14187ed4cdfdee1a02ea87e5cd8," func toValidName(name string) string {
 	if strings.HasPrefix(p, ""/"") {
 		p = p[len(""/""):]
 	}
-	for strings.HasPrefix(name, ""../"") {
+	for strings.HasPrefix(p, ""../"") {
 		p = p[len(""../""):]
 	}
 	return p
"
GO-2022-0171,go.googlesource.com,go,7e5b2e0ec144d5f5b2923a7d5db0b9143f79a35a,"
 
 package x509
 
-import ""os/exec""
+import (
+	""bytes""
+	""encoding/pem""
+	""fmt""
+	""io/ioutil""
+	""os""
+	""os/exec""
+	""strconv""
+	""sync""
+	""syscall""
+)
 
 func (c *Certificate) systemVerify(opts *VerifyOptions) (chains [][]*Certificate, err error) {
 	return nil, nil
 }
 
+// This code is only used when compiling without cgo.
+// It is here, instead of root_nocgo_darwin.go, so that tests can check it
+// even if the tests are run with cgo enabled.
+// The linker will not include these unused functions in binaries built with cgo enabled.
+
 func execSecurityRoots() (*CertPool, error) {
 	cmd := exec.Command(""/usr/bin/security"", ""find-certificate"", ""-a"", ""-p"", ""/System/Library/Keychains/SystemRootCertificates.keychain"")
 	data, err := cmd.Output()
"
GO-2021-0069,go.googlesource.com,go,1e1fa5903b760c6714ba17e50bf850b01f49135c," func (z nat) divRecursiveStep(u, v nat, depth int, tmp *nat, temps []*nat) {
 
 	// Now u < (v<<B), compute lower bits in the same way.
 	// Choose shift = B-1 again.
-	s := B
+	s := B - 1
 	qhat := *temps[depth]
 	qhat.clear()
 	qhat.divRecursiveStep(u[s:].norm(), v[s:], depth+1, tmp, temps)
"
GO-2022-0533,go.googlesource.com,go,9cd1818a7d019c02fa4898b3e45a323e35033290," func Clean(path string) string {
 		case os.IsPathSeparator(path[r]):
 			// empty path element
 			r++
-		case path[r] == '.' && (r+1 == n || os.IsPathSeparator(path[r+1])):
+		case path[r] == '.' && r+1 == n:
 			// . element
 			r++
+		case path[r] == '.' && os.IsPathSeparator(path[r+1]):
+			// ./ element
+			r++
+
+			for r < len(path) && os.IsPathSeparator(path[r]) {
+				r++
+			}
+			if out.w == 0 && volumeNameLen(path[r:]) > 0 {
+				// When joining prefix ""."" and an absolute path on Windows,
+				// the prefix should not be removed.
+				out.append('.')
+			}
 		case path[r] == '.' && path[r+1] == '.' && (r+2 == n || os.IsPathSeparator(path[r+2])):
 			// .. element: remove to last separator
 			r += 2
"
GO-2022-0761,go.googlesource.com,go,b97df54c31d6c4cc2a28a3c83725366d52329223," func (h *Handler) ServeHTTP(rw http.ResponseWriter, req *http.Request) {
 
 	for k, v := range req.Header {
 		k = strings.Map(upperCaseAndUnderscore, k)
+		if k == ""PROXY"" {
+			// See Issue 16405
+			continue
+		}
 		joinStr := "", ""
 		if k == ""COOKIE"" {
 			joinStr = ""; ""
"
GO-2022-0761,go.googlesource.com,go,b97df54c31d6c4cc2a28a3c83725366d52329223," func ProxyFromEnvironment(req *Request) (*url.URL, error) {
 	}
 	if proxy == """" {
 		proxy = httpProxyEnv.Get()
+		if proxy != """" && os.Getenv(""REQUEST_METHOD"") != """" {
+			return nil, errors.New(""net/http: refusing to use HTTP_PROXY value in CGI environment; see golang.org/s/cgihttpproxy"")
+		}
 	}
 	if proxy == """" {
 		return nil, nil
"
GO-2021-0243,go.googlesource.com,go,a98589711da5e9d935e8d690cfca92892e86d557," func (ka rsaKeyAgreement) generateClientKeyExchange(config *Config, clientHello
 		return nil, nil, err
 	}
 
-	encrypted, err := rsa.EncryptPKCS1v15(config.rand(), cert.PublicKey.(*rsa.PublicKey), preMasterSecret)
+	rsaKey, ok := cert.PublicKey.(*rsa.PublicKey)
+	if !ok {
+		return nil, nil, errors.New(""tls: server certificate contains incorrect key type for selected ciphersuite"")
+	}
+	encrypted, err := rsa.EncryptPKCS1v15(config.rand(), rsaKey, preMasterSecret)
 	if err != nil {
 		return nil, nil, err
 	}
"
GO-2021-0113,go.googlesource.com,text,383b2e75a7a4198c42f8f87833eefb772868a56f," func Parse(s string) (t Tag, err error) {
 	if s == """" {
 		return Und, ErrSyntax
 	}
+	defer func() {
+		if recover() != nil {
+			t = Und
+			err = ErrSyntax
+			return
+		}
+	}()
 	if len(s) <= maxAltTaglen {
 		b := [maxAltTaglen]byte{}
 		for i, c := range s {
"
GO-2021-0241,go.googlesource.com,go,950fa11c4cb01a145bb07eeb167d90a1846061b3," func (p *ReverseProxy) ServeHTTP(rw http.ResponseWriter, req *http.Request) {
 	// important is ""Connection"" because we want a persistent
 	// connection, regardless of what the client sent to us.
 	for _, h := range hopHeaders {
-		hv := outreq.Header.Get(h)
-		if hv == """" {
-			continue
-		}
-		if h == ""Te"" && hv == ""trailers"" {
-			// Issue 21096: tell backend applications that
-			// care about trailer support that we support
-			// trailers. (We do, but we don't go out of
-			// our way to advertise that unless the
-			// incoming client request thought it was
-			// worth mentioning)
-			continue
-		}
 		outreq.Header.Del(h)
 	}
 
+	// Issue 21096: tell backend applications that care about trailer support
+	// that we support trailers. (We do, but we don't go out of our way to
+	// advertise that unless the incoming client request thought it was worth
+	// mentioning.) Note that we look at req.Header, not outreq.Header, since
+	// the latter has passed through removeConnectionHeaders.
+	if httpguts.HeaderValuesContainsToken(req.Header[""Te""], ""trailers"") {
+		outreq.Header.Set(""Te"", ""trailers"")
+	}
+
 	// After stripping all the hop-by-hop connection headers above, add back any
 	// necessary for protocol upgrades, such as for websockets.
 	if reqUpType != """" {
"
GO-2021-0239,go.googlesource.com,go,c89f1224a544cde464fcb86e78ebb0cc97eedba2," func LookupCNAME(host string) (cname string, err error) {
 // LookupCNAME does not return an error if host does not
 // contain DNS ""CNAME"" records, as long as host resolves to
 // address records.
-func (r *Resolver) LookupCNAME(ctx context.Context, host string) (cname string, err error) {
-	return r.lookupCNAME(ctx, host)
+//
+// The returned canonical name is validated to be a properly
+// formatted presentation-format domain name.
+func (r *Resolver) LookupCNAME(ctx context.Context, host string) (string, error) {
+	cname, err := r.lookupCNAME(ctx, host)
+	if err != nil {
+		return """", err
+	}
+	if !isDomainName(cname) {
+		return """", &DNSError{Err: ""CNAME target is invalid"", Name: host}
+	}
+	return cname, nil
 }
 
 // LookupSRV tries to resolve an SRV query of the given service,
"
GO-2021-0239,go.googlesource.com,go,c89f1224a544cde464fcb86e78ebb0cc97eedba2," func LookupSRV(service, proto, name string) (cname string, addrs []*SRV, err err
 // That is, it looks up _service._proto.name. To accommodate services
 // publishing SRV records under non-standard names, if both service
 // and proto are empty strings, LookupSRV looks up name directly.
-func (r *Resolver) LookupSRV(ctx context.Context, service, proto, name string) (cname string, addrs []*SRV, err error) {
-	return r.lookupSRV(ctx, service, proto, name)
+//
+// The returned service names are validated to be properly
+// formatted presentation-format domain names.
+func (r *Resolver) LookupSRV(ctx context.Context, service, proto, name string) (string, []*SRV, error) {
+	cname, addrs, err := r.lookupSRV(ctx, service, proto, name)
+	if err != nil {
+		return """", nil, err
+	}
+	if cname != """" && !isDomainName(cname) {
+		return """", nil, &DNSError{Err: ""SRV header name is invalid"", Name: name}
+	}
+	for _, addr := range addrs {
+		if addr == nil {
+			continue
+		}
+		if !isDomainName(addr.Target) {
+			return """", nil, &DNSError{Err: ""SRV target is invalid"", Name: name}
+		}
+	}
+	return cname, addrs, nil
 }
 
 // LookupMX returns the DNS MX records for the given domain name sorted by preference.
 //
+// The returned mail server names are validated to be properly
+// formatted presentation-format domain names.
+//
 // LookupMX uses context.Background internally; to specify the context, use
 // Resolver.LookupMX.
 func LookupMX(name string) ([]*MX, error) {
"
GO-2021-0239,go.googlesource.com,go,c89f1224a544cde464fcb86e78ebb0cc97eedba2," func LookupMX(name string) ([]*MX, error) {
 }
 
 // LookupMX returns the DNS MX records for the given domain name sorted by preference.
+//
+// The returned mail server names are validated to be properly
+// formatted presentation-format domain names.
 func (r *Resolver) LookupMX(ctx context.Context, name string) ([]*MX, error) {
-	return r.lookupMX(ctx, name)
+	records, err := r.lookupMX(ctx, name)
+	if err != nil {
+		return nil, err
+	}
+	for _, mx := range records {
+		if mx == nil {
+			continue
+		}
+		if !isDomainName(mx.Host) {
+			return nil, &DNSError{Err: ""MX target is invalid"", Name: name}
+		}
+	}
+	return records, nil
 }
 
 // LookupNS returns the DNS NS records for the given domain name.
 //
+// The returned name server names are validated to be properly
+// formatted presentation-format domain names.
+//
 // LookupNS uses context.Background internally; to specify the context, use
 // Resolver.LookupNS.
 func LookupNS(name string) ([]*NS, error) {
"
GO-2021-0239,go.googlesource.com,go,c89f1224a544cde464fcb86e78ebb0cc97eedba2," func LookupNS(name string) ([]*NS, error) {
 }
 
 // LookupNS returns the DNS NS records for the given domain name.
+//
+// The returned name server names are validated to be properly
+// formatted presentation-format domain names.
 func (r *Resolver) LookupNS(ctx context.Context, name string) ([]*NS, error) {
-	return r.lookupNS(ctx, name)
+	records, err := r.lookupNS(ctx, name)
+	if err != nil {
+		return nil, err
+	}
+	for _, ns := range records {
+		if ns == nil {
+			continue
+		}
+		if !isDomainName(ns.Host) {
+			return nil, &DNSError{Err: ""NS target is invalid"", Name: name}
+		}
+	}
+	return records, nil
 }
 
 // LookupTXT returns the DNS TXT records for the given domain name.
"
GO-2021-0239,go.googlesource.com,go,c89f1224a544cde464fcb86e78ebb0cc97eedba2," func LookupAddr(addr string) (names []string, err error) {
 
 // LookupAddr performs a reverse lookup for the given address, returning a list
 // of names mapping to that address.
-func (r *Resolver) LookupAddr(ctx context.Context, addr string) (names []string, err error) {
-	return r.lookupAddr(ctx, addr)
+//
+// The returned names are validated to be properly
+// formatted presentation-format domain names.
+func (r *Resolver) LookupAddr(ctx context.Context, addr string) ([]string, error) {
+	names, err := r.lookupAddr(ctx, addr)
+	if err != nil {
+		return nil, err
+	}
+	for _, name := range names {
+		if !isDomainName(name) {
+			return nil, &DNSError{Err: ""PTR target is invalid"", Name: addr}
+		}
+	}
+	return names, nil
 }
"
GO-2020-0013,go.googlesource.com,crypto,e4e2799dd7aab89f583e1d898300d96367750991," func NewClient(c Conn, chans <-chan NewChannel, reqs <-chan *Request) *Client {
 func NewClientConn(c net.Conn, addr string, config *ClientConfig) (Conn, <-chan NewChannel, <-chan *Request, error) {
 	fullConf := *config
 	fullConf.SetDefaults()
+	if fullConf.HostKeyCallback == nil {
+		c.Close()
+		return nil, nil, nil, errors.New(""ssh: must specify HostKeyCallback"")
+	}
+
 	conn := &connection{
 		sshConn: sshConn{conn: c},
 	}
"
GO-2021-0264,go.googlesource.com,go,b24687394b55a93449e2be4e6892ead58ea9a10f," func fileEntryLess(x, y string) bool {
 func (r *Reader) Open(name string) (fs.File, error) {
 	r.initFileList()
 
+	if !fs.ValidPath(name) {
+		return nil, &fs.PathError{Op: ""open"", Path: name, Err: fs.ErrInvalid}
+	}
 	e := r.openLookup(name)
-	if e == nil || !fs.ValidPath(name) {
+	if e == nil {
 		return nil, &fs.PathError{Op: ""open"", Path: name, Err: fs.ErrNotExist}
 	}
 	if e.isDir {
"
GO-2021-0264,go.googlesource.com,go,b24687394b55a93449e2be4e6892ead58ea9a10f," func (r *Reader) Open(name string) (fs.File, error) {
 }
 
 func split(name string) (dir, elem string, isDir bool) {
-	if name[len(name)-1] == '/' {
+	if len(name) > 0 && name[len(name)-1] == '/' {
 		isDir = true
 		name = name[:len(name)-1]
 	}
"
GO-2021-0078,go.googlesource.com,net,aaf60122140d3fcf75376d319f0554393160eb50," func inBodyIM(p *parser) bool {
 				p.acknowledgeSelfClosingTag()
 			}
 			return true
-		case a.Frame:
-			// TODO: remove this divergence from the HTML5 spec.
-			if p.oe.contains(a.Template) {
-				p.addElement()
-				return true
-			}
-		case a.Caption, a.Col, a.Colgroup, a.Head, a.Tbody, a.Td, a.Tfoot, a.Th, a.Thead, a.Tr:
+		case a.Caption, a.Col, a.Colgroup, a.Frame, a.Head, a.Tbody, a.Td, a.Tfoot, a.Th, a.Thead, a.Tr:
 			// Ignore the token.
 		default:
 			p.reconstructActiveFormattingElements()
"
GO-2021-0078,go.googlesource.com,net,aaf60122140d3fcf75376d319f0554393160eb50," func inFramesetIM(p *parser) bool {
 			p.acknowledgeSelfClosingTag()
 		case a.Noframes:
 			return inHeadIM(p)
-		case a.Template:
-			// TODO: remove this divergence from the HTML5 spec.
-			//
-			// See https://bugs.chromium.org/p/chromium/issues/detail?id=829668
-			return inTemplateIM(p)
 		}
 	case EndTagToken:
 		switch p.tok.DataAtom {
"
GO-2022-0211,go.googlesource.com,go,61bb56ad63992a3199acc55b2537c8355ef887b6," func parseHost(host string) (string, error) {
 			}
 			return host1 + host2 + host3, nil
 		}
+	} else if i := strings.LastIndex(host, "":""); i != -1 {
+		colonPort := host[i:]
+		if !validOptionalPort(colonPort) {
+			return """", fmt.Errorf(""invalid port %q after host"", colonPort)
+		}
 	}
 
 	var err error
"
