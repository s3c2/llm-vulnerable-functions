id,repo_owner,repo_name,sha,raw_patch,label_combined_unique
GO-2020-0016,ulikunitz,xz,69c6093c7b2397b923acf82cb378f55ab2652b9b," var errOverflowU64 = errors.New(""xz: uvarint overflows 64-bit unsigned integer"")
 
 // readUvarint reads a uvarint from the given byte reader.
 func readUvarint(r io.ByteReader) (x uint64, n int, err error) {
+	const maxUvarintLen = 10
+
 	var s uint
 	i := 0
 	for {
",[True]
GO-2020-0016,ulikunitz,xz,69c6093c7b2397b923acf82cb378f55ab2652b9b," func readUvarint(r io.ByteReader) (x uint64, n int, err error) {
 			return x, i, err
 		}
 		i++
+		if i > maxUvarintLen {
+			return x, i, errOverflowU64
+		}
 		if b < 0x80 {
-			if i > 10 || i == 10 && b > 1 {
+			if i == maxUvarintLen && b > 1 {
 				return x, i, errOverflowU64
 			}
 			return x | uint64(b)<<s, i, nil
",[True]
GO-2022-1008,containers,buildah,4a8bf740e862f2438279c6feee2ea59ddf0cda0b," func (b *Builder) configureUIDGID(g *generate.Generator, mountPoint string, opti
 	}
 	g.SetProcessUID(user.UID)
 	g.SetProcessGID(user.GID)
+	g.AddProcessAdditionalGid(user.GID)
 	for _, gid := range user.AdditionalGids {
 		g.AddProcessAdditionalGid(gid)
 	}
",[True]
GO-2023-2116,gofiber,fiber,8c3916dbf4ad2ed427d02c6eb63ae8b2fa8f019a," func New(config ...Config) fiber.Handler {
 			cookieToken := c.Cookies(cfg.CookieName)
 
 			if cookieToken != """" {
-				rawToken := getTokenFromStorage(c, cookieToken, cfg, sessionManager, storageManager)
+				raw := getRawFromStorage(c, cookieToken, cfg, sessionManager, storageManager)
 
-				if rawToken != nil {
-					token = string(rawToken)
+				if raw != nil {
+					token = cookieToken // Token is valid, safe to set it
 				}
 			}
 		default:
",[True]
GO-2023-2116,gofiber,fiber,8c3916dbf4ad2ed427d02c6eb63ae8b2fa8f019a," func New(config ...Config) fiber.Handler {
 			// If not using CsrfFromCookie extractor, check that the token matches the cookie
 			// This is to prevent CSRF attacks by using a Double Submit Cookie method
 			// Useful when we do not have access to the users Session
-			if !isCsrfFromCookie(cfg.Extractor) && extractedToken != c.Cookies(cfg.CookieName) {
+			if !isCsrfFromCookie(cfg.Extractor) && !compareStrings(extractedToken, c.Cookies(cfg.CookieName)) {
 				return cfg.ErrorHandler(c, ErrTokenInvalid)
 			}
 
-			rawToken := getTokenFromStorage(c, extractedToken, cfg, sessionManager, storageManager)
+			raw := getRawFromStorage(c, extractedToken, cfg, sessionManager, storageManager)
 
-			if rawToken == nil {
+			if raw == nil {
 				// If token is not in storage, expire the cookie
 				expireCSRFCookie(c, cfg)
 				// and return an error
",[True]
GO-2023-2116,gofiber,fiber,8c3916dbf4ad2ed427d02c6eb63ae8b2fa8f019a," func New(config ...Config) fiber.Handler {
 				// If token is single use, delete it from storage
 				deleteTokenFromStorage(c, extractedToken, cfg, sessionManager, storageManager)
 			} else {
-				token = string(rawToken)
+				token = extractedToken // Token is valid, safe to set it
 			}
 		}
 
",[True]
GO-2023-2116,gofiber,fiber,8c3916dbf4ad2ed427d02c6eb63ae8b2fa8f019a," func refererMatchesHost(c *fiber.Ctx) error {
 	if referer == """" {
 		return ErrNoReferer
 	}
-	if referer != c.Protocol()+""://""+c.Hostname() {
+
+	refererURL, err := url.Parse(referer)
+	if err != nil {
 		return ErrBadReferer
 	}
+
+	if refererURL.Scheme+""://""+refererURL.Host != c.Protocol()+""://""+c.Hostname() {
+		return ErrBadReferer
+	}
+
 	return nil
 }
",[False]
GO-2023-2116,gofiber,fiber,8c3916dbf4ad2ed427d02c6eb63ae8b2fa8f019a," func CsrfFromParam(param string) func(c *fiber.Ctx) (string, error) {
 	return func(c *fiber.Ctx) (string, error) {
 		token := c.Params(param)
 		if token == """" {
-			return """", errMissingParam
+			return """", ErrMissingParam
 		}
 		return token, nil
 	}
",[True]
GO-2023-2116,gofiber,fiber,8c3916dbf4ad2ed427d02c6eb63ae8b2fa8f019a," func CsrfFromForm(param string) func(c *fiber.Ctx) (string, error) {
 	return func(c *fiber.Ctx) (string, error) {
 		token := c.FormValue(param)
 		if token == """" {
-			return """", errMissingForm
+			return """", ErrMissingForm
 		}
 		return token, nil
 	}
",[True]
GO-2023-2116,gofiber,fiber,8c3916dbf4ad2ed427d02c6eb63ae8b2fa8f019a," func CsrfFromCookie(param string) func(c *fiber.Ctx) (string, error) {
 	return func(c *fiber.Ctx) (string, error) {
 		token := c.Cookies(param)
 		if token == """" {
-			return """", errMissingCookie
+			return """", ErrMissingCookie
 		}
 		return token, nil
 	}
",[True]
GO-2023-2116,gofiber,fiber,8c3916dbf4ad2ed427d02c6eb63ae8b2fa8f019a," func CsrfFromHeader(param string) func(c *fiber.Ctx) (string, error) {
 	return func(c *fiber.Ctx) (string, error) {
 		token := c.Get(param)
 		if token == """" {
-			return """", errMissingHeader
+			return """", ErrMissingHeader
 		}
 		return token, nil
 	}
",[True]
GO-2023-2116,gofiber,fiber,8c3916dbf4ad2ed427d02c6eb63ae8b2fa8f019a," func CsrfFromQuery(param string) func(c *fiber.Ctx) (string, error) {
 	return func(c *fiber.Ctx) (string, error) {
 		token := c.Query(param)
 		if token == """" {
-			return """", errMissingQuery
+			return """", ErrMissingQuery
 		}
 		return token, nil
 	}
",[True]
GO-2023-2116,gofiber,fiber,8c3916dbf4ad2ed427d02c6eb63ae8b2fa8f019a," import (
 func compareTokens(a, b []byte) bool {
 	return subtle.ConstantTimeCompare(a, b) == 1
 }
+
+func compareStrings(a, b string) bool {
+	return subtle.ConstantTimeCompare([]byte(a), []byte(b)) == 1
+}
",[False]
GO-2023-2116,gofiber,fiber,b50d91d58ecdff2a330bf07950244b6c4caf65b1," func configDefault(config ...Config) Config {
 	if cfg.ErrorHandler == nil {
 		cfg.ErrorHandler = ConfigDefault.ErrorHandler
 	}
+	if cfg.SessionKey == """" {
+		cfg.SessionKey = ConfigDefault.SessionKey
+	}
+	if cfg.HandlerContextKey == """" {
+		cfg.HandlerContextKey = ConfigDefault.HandlerContextKey
+	}
 
 	// Generate the correct extractor to get the token from the correct location
 	selectors := strings.Split(cfg.KeyLookup, "":"")
",[True]
GO-2023-2116,gofiber,fiber,b50d91d58ecdff2a330bf07950244b6c4caf65b1," func configDefault(config ...Config) Config {
 		case ""param"":
 			cfg.Extractor = CsrfFromParam(selectors[1])
 		case ""cookie"":
+			if cfg.Session == nil {
+				log.Warn(""[CSRF] Cookie extractor is not recommended without a session store"")
+			}
+			if cfg.CookieSameSite == ""None"" || cfg.CookieSameSite != ""Lax"" && cfg.CookieSameSite != ""Strict"" {
+				log.Warn(""[CSRF] Cookie extractor is only recommended for use with SameSite=Lax or SameSite=Strict"")
+			}
 			cfg.Extractor = CsrfFromCookie(selectors[1])
+			cfg.CookieName = selectors[1] // Cookie name is the same as the key
 		}
 	}
 
",[True]
GO-2023-2116,gofiber,fiber,b50d91d58ecdff2a330bf07950244b6c4caf65b1," package csrf
 
 import (
 	""errors""
+	""reflect""
 	""time""
 
 	""github.com/gofiber/fiber/v2""
 )
 
-var errTokenNotFound = errors.New(""csrf token not found"")
+var (
+	ErrTokenNotFound = errors.New(""csrf token not found"")
+	ErrTokenInvalid  = errors.New(""csrf token invalid"")
+	ErrNoReferer     = errors.New(""referer not supplied"")
+	ErrBadReferer    = errors.New(""referer invalid"")
+	dummyValue       = []byte{'+'}
+)
+
+type CSRFHandler struct {
+	config         *Config
+	sessionManager *sessionManager
+	storageManager *storageManager
+}
 
 // New creates a new middleware handler
 func New(config ...Config) fiber.Handler {
 	// Set default config
 	cfg := configDefault(config...)
 
-	// Create manager to simplify storage operations ( see manager.go )
-	manager := newManager(cfg.Storage)
+	// Create manager to simplify storage operations ( see *_manager.go )
+	var sessionManager *sessionManager
+	var storageManager *storageManager
+	if cfg.Session != nil {
+		// Register the Token struct in the session store
+		cfg.Session.RegisterType(Token{})
 
-	dummyValue := []byte{'+'}
+		sessionManager = newSessionManager(cfg.Session, cfg.SessionKey)
+	} else {
+		storageManager = newStorageManager(cfg.Storage)
+	}
 
 	// Return new handler
 	return func(c *fiber.Ctx) error {
",[True]
GO-2023-2116,gofiber,fiber,b50d91d58ecdff2a330bf07950244b6c4caf65b1," func New(config ...Config) fiber.Handler {
 			return c.Next()
 		}
 
+		// Store the CSRF handler in the context if a context key is specified
+		if cfg.HandlerContextKey != """" {
+			c.Locals(cfg.HandlerContextKey, &CSRFHandler{
+				config:         &cfg,
+				sessionManager: sessionManager,
+				storageManager: storageManager,
+			})
+		}
+
 		var token string
 
 		// Action depends on the HTTP method
 		switch c.Method() {
 		case fiber.MethodGet, fiber.MethodHead, fiber.MethodOptions, fiber.MethodTrace:
-			// Declare empty token and try to get existing CSRF from cookie
-			token = c.Cookies(cfg.CookieName)
+			cookieToken := c.Cookies(cfg.CookieName)
+
+			if cookieToken != """" {
+				rawToken := getTokenFromStorage(c, cookieToken, cfg, sessionManager, storageManager)
+
+				if rawToken != nil {
+					token = string(rawToken)
+				}
+			}
 		default:
 			// Assume that anything not defined as 'safe' by RFC7231 needs protection
 
+			// Enforce an origin check for HTTPS connections.
+			if c.Protocol() == ""https"" {
+				if err := refererMatchesHost(c); err != nil {
+					return cfg.ErrorHandler(c, err)
+				}
+			}
+
 			// Extract token from client request i.e. header, query, param, form or cookie
-			token, err := cfg.Extractor(c)
+			extractedToken, err := cfg.Extractor(c)
 			if err != nil {
 				return cfg.ErrorHandler(c, err)
 			}
 
-			// if token does not exist in Storage
-			if manager.getRaw(token) == nil {
-				// Expire cookie
-				c.Cookie(&fiber.Cookie{
-					Name:        cfg.CookieName,
-					Domain:      cfg.CookieDomain,
-					Path:        cfg.CookiePath,
-					Expires:     time.Now().Add(-1 * time.Minute),
-					Secure:      cfg.CookieSecure,
-					HTTPOnly:    cfg.CookieHTTPOnly,
-					SameSite:    cfg.CookieSameSite,
-					SessionOnly: cfg.CookieSessionOnly,
-				})
-				return cfg.ErrorHandler(c, errTokenNotFound)
+			if extractedToken == """" {
+				return cfg.ErrorHandler(c, ErrTokenNotFound)
+			}
+
+			// If not using CsrfFromCookie extractor, check that the token matches the cookie
+			// This is to prevent CSRF attacks by using a Double Submit Cookie method
+			// Useful when we do not have access to the users Session
+			if !isCsrfFromCookie(cfg.Extractor) && extractedToken != c.Cookies(cfg.CookieName) {
+				return cfg.ErrorHandler(c, ErrTokenInvalid)
+			}
+
+			rawToken := getTokenFromStorage(c, extractedToken, cfg, sessionManager, storageManager)
+
+			if rawToken == nil {
+				// If token is not in storage, expire the cookie
+				expireCSRFCookie(c, cfg)
+				// and return an error
+				return cfg.ErrorHandler(c, ErrTokenNotFound)
+			}
+			if cfg.SingleUseToken {
+				// If token is single use, delete it from storage
+				deleteTokenFromStorage(c, extractedToken, cfg, sessionManager, storageManager)
+			} else {
+				token = string(rawToken)
 			}
 		}
 
",[True]
GO-2023-2116,gofiber,fiber,b50d91d58ecdff2a330bf07950244b6c4caf65b1," func New(config ...Config) fiber.Handler {
 			token = cfg.KeyGenerator()
 		}
 
-		// Add/update token to Storage
-		manager.setRaw(token, dummyValue, cfg.Expiration)
-
-		// Create cookie to pass token to client
-		cookie := &fiber.Cookie{
-			Name:        cfg.CookieName,
-			Value:       token,
-			Domain:      cfg.CookieDomain,
-			Path:        cfg.CookiePath,
-			Expires:     time.Now().Add(cfg.Expiration),
-			Secure:      cfg.CookieSecure,
-			HTTPOnly:    cfg.CookieHTTPOnly,
-			SameSite:    cfg.CookieSameSite,
-			SessionOnly: cfg.CookieSessionOnly,
-		}
-		// Set cookie to response
-		c.Cookie(cookie)
+		// Create or extend the token in the storage
+		createOrExtendTokenInStorage(c, token, cfg, sessionManager, storageManager)
 
-		// Protect clients from caching the response by telling the browser
-		// a new header value is generated
+		// Update the CSRF cookie
+		updateCSRFCookie(c, cfg, token)
+
+		// Tell the browser that a new header value is generated
 		c.Vary(fiber.HeaderCookie)
 
-		// Store token in context if set
+		// Store the token in the context if a context key is specified
 		if cfg.ContextKey != """" {
 			c.Locals(cfg.ContextKey, token)
 		}
",[True]
GO-2023-2116,gofiber,fiber,b50d91d58ecdff2a330bf07950244b6c4caf65b1,"
+package csrf
+
+import ""crypto/subtle""
+
+func compareTokens(a, b []byte) bool {
+    return subtle.ConstantTimeCompare(a, b) == 1
+}
",[False]
GO-2023-2116,gofiber,fiber,b50d91d58ecdff2a330bf07950244b6c4caf65b1," import (
 )
 
 // go:generate msgp
-// msgp -file=""manager.go"" -o=""manager_msgp.go"" -tests=false -unexported
+// msgp -file=""storage_manager.go"" -o=""storage_manager_msgp.go"" -tests=false -unexported
 type item struct{}
 
 //msgp:ignore manager
-type manager struct {
+type storageManager struct {
 	pool    sync.Pool
 	memory  *memory.Storage
 	storage fiber.Storage
 }
 
-func newManager(storage fiber.Storage) *manager {
+func newStorageManager(storage fiber.Storage) *storageManager {
 	// Create new storage handler
-	manager := &manager{
+	storageManager := &storageManager{
 		pool: sync.Pool{
 			New: func() interface{} {
 				return new(item)
",[False]
GO-2023-2116,gofiber,fiber,b50d91d58ecdff2a330bf07950244b6c4caf65b1," func (m *manager) getRaw(key string) []byte {
 }
 
 // set data to storage or memory
-func (m *manager) setRaw(key string, raw []byte, exp time.Duration) {
+func (m *storageManager) setRaw(key string, raw []byte, exp time.Duration) {
 	if m.storage != nil {
 		_ = m.storage.Set(key, raw, exp) //nolint:errcheck // TODO: Do not ignore error
 	} else {
",[False]
GO-2023-2116,gofiber,fiber,b50d91d58ecdff2a330bf07950244b6c4caf65b1," func (m *manager) setRaw(key string, raw []byte, exp time.Duration) {
 		m.memory.Set(utils.CopyString(key), raw, exp)
 	}
 }
+
+// delete data from storage or memory
+func (m *storageManager) delRaw(key string) {
+	if m.storage != nil {
+		_ = m.storage.Delete(key) //nolint:errcheck // TODO: Do not ignore error
+	} else {
+		m.memory.Delete(key)
+	}
+}
",[False]
GO-2023-2115,gofiber,fiber,8c3916dbf4ad2ed427d02c6eb63ae8b2fa8f019a," func New(config ...Config) fiber.Handler {
 			cookieToken := c.Cookies(cfg.CookieName)
 
 			if cookieToken != """" {
-				rawToken := getTokenFromStorage(c, cookieToken, cfg, sessionManager, storageManager)
+				raw := getRawFromStorage(c, cookieToken, cfg, sessionManager, storageManager)
 
-				if rawToken != nil {
-					token = string(rawToken)
+				if raw != nil {
+					token = cookieToken // Token is valid, safe to set it
 				}
 			}
 		default:
",[True]
GO-2023-2115,gofiber,fiber,8c3916dbf4ad2ed427d02c6eb63ae8b2fa8f019a," func New(config ...Config) fiber.Handler {
 			// If not using CsrfFromCookie extractor, check that the token matches the cookie
 			// This is to prevent CSRF attacks by using a Double Submit Cookie method
 			// Useful when we do not have access to the users Session
-			if !isCsrfFromCookie(cfg.Extractor) && extractedToken != c.Cookies(cfg.CookieName) {
+			if !isCsrfFromCookie(cfg.Extractor) && !compareStrings(extractedToken, c.Cookies(cfg.CookieName)) {
 				return cfg.ErrorHandler(c, ErrTokenInvalid)
 			}
 
-			rawToken := getTokenFromStorage(c, extractedToken, cfg, sessionManager, storageManager)
+			raw := getRawFromStorage(c, extractedToken, cfg, sessionManager, storageManager)
 
-			if rawToken == nil {
+			if raw == nil {
 				// If token is not in storage, expire the cookie
 				expireCSRFCookie(c, cfg)
 				// and return an error
",[True]
GO-2023-2115,gofiber,fiber,8c3916dbf4ad2ed427d02c6eb63ae8b2fa8f019a," func New(config ...Config) fiber.Handler {
 				// If token is single use, delete it from storage
 				deleteTokenFromStorage(c, extractedToken, cfg, sessionManager, storageManager)
 			} else {
-				token = string(rawToken)
+				token = extractedToken // Token is valid, safe to set it
 			}
 		}
 
",[True]
GO-2023-2115,gofiber,fiber,8c3916dbf4ad2ed427d02c6eb63ae8b2fa8f019a," func refererMatchesHost(c *fiber.Ctx) error {
 	if referer == """" {
 		return ErrNoReferer
 	}
-	if referer != c.Protocol()+""://""+c.Hostname() {
+
+	refererURL, err := url.Parse(referer)
+	if err != nil {
 		return ErrBadReferer
 	}
+
+	if refererURL.Scheme+""://""+refererURL.Host != c.Protocol()+""://""+c.Hostname() {
+		return ErrBadReferer
+	}
+
 	return nil
 }
",[False]
GO-2023-2115,gofiber,fiber,8c3916dbf4ad2ed427d02c6eb63ae8b2fa8f019a," func CsrfFromParam(param string) func(c *fiber.Ctx) (string, error) {
 	return func(c *fiber.Ctx) (string, error) {
 		token := c.Params(param)
 		if token == """" {
-			return """", errMissingParam
+			return """", ErrMissingParam
 		}
 		return token, nil
 	}
",[True]
GO-2023-2115,gofiber,fiber,8c3916dbf4ad2ed427d02c6eb63ae8b2fa8f019a," func CsrfFromForm(param string) func(c *fiber.Ctx) (string, error) {
 	return func(c *fiber.Ctx) (string, error) {
 		token := c.FormValue(param)
 		if token == """" {
-			return """", errMissingForm
+			return """", ErrMissingForm
 		}
 		return token, nil
 	}
",[True]
GO-2023-2115,gofiber,fiber,8c3916dbf4ad2ed427d02c6eb63ae8b2fa8f019a," func CsrfFromCookie(param string) func(c *fiber.Ctx) (string, error) {
 	return func(c *fiber.Ctx) (string, error) {
 		token := c.Cookies(param)
 		if token == """" {
-			return """", errMissingCookie
+			return """", ErrMissingCookie
 		}
 		return token, nil
 	}
",[True]
GO-2023-2115,gofiber,fiber,8c3916dbf4ad2ed427d02c6eb63ae8b2fa8f019a," func CsrfFromHeader(param string) func(c *fiber.Ctx) (string, error) {
 	return func(c *fiber.Ctx) (string, error) {
 		token := c.Get(param)
 		if token == """" {
-			return """", errMissingHeader
+			return """", ErrMissingHeader
 		}
 		return token, nil
 	}
",[True]
GO-2023-2115,gofiber,fiber,8c3916dbf4ad2ed427d02c6eb63ae8b2fa8f019a," func CsrfFromQuery(param string) func(c *fiber.Ctx) (string, error) {
 	return func(c *fiber.Ctx) (string, error) {
 		token := c.Query(param)
 		if token == """" {
-			return """", errMissingQuery
+			return """", ErrMissingQuery
 		}
 		return token, nil
 	}
",[True]
GO-2023-2115,gofiber,fiber,8c3916dbf4ad2ed427d02c6eb63ae8b2fa8f019a," import (
 func compareTokens(a, b []byte) bool {
 	return subtle.ConstantTimeCompare(a, b) == 1
 }
+
+func compareStrings(a, b string) bool {
+	return subtle.ConstantTimeCompare([]byte(a), []byte(b)) == 1
+}
",[False]
GO-2023-2115,gofiber,fiber,b50d91d58ecdff2a330bf07950244b6c4caf65b1," func configDefault(config ...Config) Config {
 	if cfg.ErrorHandler == nil {
 		cfg.ErrorHandler = ConfigDefault.ErrorHandler
 	}
+	if cfg.SessionKey == """" {
+		cfg.SessionKey = ConfigDefault.SessionKey
+	}
+	if cfg.HandlerContextKey == """" {
+		cfg.HandlerContextKey = ConfigDefault.HandlerContextKey
+	}
 
 	// Generate the correct extractor to get the token from the correct location
 	selectors := strings.Split(cfg.KeyLookup, "":"")
",[True]
GO-2023-2115,gofiber,fiber,b50d91d58ecdff2a330bf07950244b6c4caf65b1," func configDefault(config ...Config) Config {
 		case ""param"":
 			cfg.Extractor = CsrfFromParam(selectors[1])
 		case ""cookie"":
+			if cfg.Session == nil {
+				log.Warn(""[CSRF] Cookie extractor is not recommended without a session store"")
+			}
+			if cfg.CookieSameSite == ""None"" || cfg.CookieSameSite != ""Lax"" && cfg.CookieSameSite != ""Strict"" {
+				log.Warn(""[CSRF] Cookie extractor is only recommended for use with SameSite=Lax or SameSite=Strict"")
+			}
 			cfg.Extractor = CsrfFromCookie(selectors[1])
+			cfg.CookieName = selectors[1] // Cookie name is the same as the key
 		}
 	}
 
",[True]
GO-2023-2115,gofiber,fiber,b50d91d58ecdff2a330bf07950244b6c4caf65b1," package csrf
 
 import (
 	""errors""
+	""reflect""
 	""time""
 
 	""github.com/gofiber/fiber/v2""
 )
 
-var errTokenNotFound = errors.New(""csrf token not found"")
+var (
+	ErrTokenNotFound = errors.New(""csrf token not found"")
+	ErrTokenInvalid  = errors.New(""csrf token invalid"")
+	ErrNoReferer     = errors.New(""referer not supplied"")
+	ErrBadReferer    = errors.New(""referer invalid"")
+	dummyValue       = []byte{'+'}
+)
+
+type CSRFHandler struct {
+	config         *Config
+	sessionManager *sessionManager
+	storageManager *storageManager
+}
 
 // New creates a new middleware handler
 func New(config ...Config) fiber.Handler {
 	// Set default config
 	cfg := configDefault(config...)
 
-	// Create manager to simplify storage operations ( see manager.go )
-	manager := newManager(cfg.Storage)
+	// Create manager to simplify storage operations ( see *_manager.go )
+	var sessionManager *sessionManager
+	var storageManager *storageManager
+	if cfg.Session != nil {
+		// Register the Token struct in the session store
+		cfg.Session.RegisterType(Token{})
 
-	dummyValue := []byte{'+'}
+		sessionManager = newSessionManager(cfg.Session, cfg.SessionKey)
+	} else {
+		storageManager = newStorageManager(cfg.Storage)
+	}
 
 	// Return new handler
 	return func(c *fiber.Ctx) error {
",[True]
GO-2023-2115,gofiber,fiber,b50d91d58ecdff2a330bf07950244b6c4caf65b1," func New(config ...Config) fiber.Handler {
 			return c.Next()
 		}
 
+		// Store the CSRF handler in the context if a context key is specified
+		if cfg.HandlerContextKey != """" {
+			c.Locals(cfg.HandlerContextKey, &CSRFHandler{
+				config:         &cfg,
+				sessionManager: sessionManager,
+				storageManager: storageManager,
+			})
+		}
+
 		var token string
 
 		// Action depends on the HTTP method
 		switch c.Method() {
 		case fiber.MethodGet, fiber.MethodHead, fiber.MethodOptions, fiber.MethodTrace:
-			// Declare empty token and try to get existing CSRF from cookie
-			token = c.Cookies(cfg.CookieName)
+			cookieToken := c.Cookies(cfg.CookieName)
+
+			if cookieToken != """" {
+				rawToken := getTokenFromStorage(c, cookieToken, cfg, sessionManager, storageManager)
+
+				if rawToken != nil {
+					token = string(rawToken)
+				}
+			}
 		default:
 			// Assume that anything not defined as 'safe' by RFC7231 needs protection
 
+			// Enforce an origin check for HTTPS connections.
+			if c.Protocol() == ""https"" {
+				if err := refererMatchesHost(c); err != nil {
+					return cfg.ErrorHandler(c, err)
+				}
+			}
+
 			// Extract token from client request i.e. header, query, param, form or cookie
-			token, err := cfg.Extractor(c)
+			extractedToken, err := cfg.Extractor(c)
 			if err != nil {
 				return cfg.ErrorHandler(c, err)
 			}
 
-			// if token does not exist in Storage
-			if manager.getRaw(token) == nil {
-				// Expire cookie
-				c.Cookie(&fiber.Cookie{
-					Name:        cfg.CookieName,
-					Domain:      cfg.CookieDomain,
-					Path:        cfg.CookiePath,
-					Expires:     time.Now().Add(-1 * time.Minute),
-					Secure:      cfg.CookieSecure,
-					HTTPOnly:    cfg.CookieHTTPOnly,
-					SameSite:    cfg.CookieSameSite,
-					SessionOnly: cfg.CookieSessionOnly,
-				})
-				return cfg.ErrorHandler(c, errTokenNotFound)
+			if extractedToken == """" {
+				return cfg.ErrorHandler(c, ErrTokenNotFound)
+			}
+
+			// If not using CsrfFromCookie extractor, check that the token matches the cookie
+			// This is to prevent CSRF attacks by using a Double Submit Cookie method
+			// Useful when we do not have access to the users Session
+			if !isCsrfFromCookie(cfg.Extractor) && extractedToken != c.Cookies(cfg.CookieName) {
+				return cfg.ErrorHandler(c, ErrTokenInvalid)
+			}
+
+			rawToken := getTokenFromStorage(c, extractedToken, cfg, sessionManager, storageManager)
+
+			if rawToken == nil {
+				// If token is not in storage, expire the cookie
+				expireCSRFCookie(c, cfg)
+				// and return an error
+				return cfg.ErrorHandler(c, ErrTokenNotFound)
+			}
+			if cfg.SingleUseToken {
+				// If token is single use, delete it from storage
+				deleteTokenFromStorage(c, extractedToken, cfg, sessionManager, storageManager)
+			} else {
+				token = string(rawToken)
 			}
 		}
 
",[True]
GO-2023-2115,gofiber,fiber,b50d91d58ecdff2a330bf07950244b6c4caf65b1," func New(config ...Config) fiber.Handler {
 			token = cfg.KeyGenerator()
 		}
 
-		// Add/update token to Storage
-		manager.setRaw(token, dummyValue, cfg.Expiration)
-
-		// Create cookie to pass token to client
-		cookie := &fiber.Cookie{
-			Name:        cfg.CookieName,
-			Value:       token,
-			Domain:      cfg.CookieDomain,
-			Path:        cfg.CookiePath,
-			Expires:     time.Now().Add(cfg.Expiration),
-			Secure:      cfg.CookieSecure,
-			HTTPOnly:    cfg.CookieHTTPOnly,
-			SameSite:    cfg.CookieSameSite,
-			SessionOnly: cfg.CookieSessionOnly,
-		}
-		// Set cookie to response
-		c.Cookie(cookie)
+		// Create or extend the token in the storage
+		createOrExtendTokenInStorage(c, token, cfg, sessionManager, storageManager)
 
-		// Protect clients from caching the response by telling the browser
-		// a new header value is generated
+		// Update the CSRF cookie
+		updateCSRFCookie(c, cfg, token)
+
+		// Tell the browser that a new header value is generated
 		c.Vary(fiber.HeaderCookie)
 
-		// Store token in context if set
+		// Store the token in the context if a context key is specified
 		if cfg.ContextKey != """" {
 			c.Locals(cfg.ContextKey, token)
 		}
",[True]
GO-2023-2115,gofiber,fiber,b50d91d58ecdff2a330bf07950244b6c4caf65b1,"
+package csrf
+
+import ""crypto/subtle""
+
+func compareTokens(a, b []byte) bool {
+    return subtle.ConstantTimeCompare(a, b) == 1
+}
",[False]
GO-2023-2115,gofiber,fiber,b50d91d58ecdff2a330bf07950244b6c4caf65b1," import (
 )
 
 // go:generate msgp
-// msgp -file=""manager.go"" -o=""manager_msgp.go"" -tests=false -unexported
+// msgp -file=""storage_manager.go"" -o=""storage_manager_msgp.go"" -tests=false -unexported
 type item struct{}
 
 //msgp:ignore manager
-type manager struct {
+type storageManager struct {
 	pool    sync.Pool
 	memory  *memory.Storage
 	storage fiber.Storage
 }
 
-func newManager(storage fiber.Storage) *manager {
+func newStorageManager(storage fiber.Storage) *storageManager {
 	// Create new storage handler
-	manager := &manager{
+	storageManager := &storageManager{
 		pool: sync.Pool{
 			New: func() interface{} {
 				return new(item)
",[False]
GO-2023-2115,gofiber,fiber,b50d91d58ecdff2a330bf07950244b6c4caf65b1," func (m *manager) getRaw(key string) []byte {
 }
 
 // set data to storage or memory
-func (m *manager) setRaw(key string, raw []byte, exp time.Duration) {
+func (m *storageManager) setRaw(key string, raw []byte, exp time.Duration) {
 	if m.storage != nil {
 		_ = m.storage.Set(key, raw, exp) //nolint:errcheck // TODO: Do not ignore error
 	} else {
",[False]
GO-2023-2115,gofiber,fiber,b50d91d58ecdff2a330bf07950244b6c4caf65b1," func (m *manager) setRaw(key string, raw []byte, exp time.Duration) {
 		m.memory.Set(utils.CopyString(key), raw, exp)
 	}
 }
+
+// delete data from storage or memory
+func (m *storageManager) delRaw(key string) {
+	if m.storage != nil {
+		_ = m.storage.Delete(key) //nolint:errcheck // TODO: Do not ignore error
+	} else {
+		m.memory.Delete(key)
+	}
+}
",[False]
GO-2022-0253,cloudflare,cfrpki,648658b1b176a747b52645989cfddc73a81eacad," func (s *state) MainRRDP(pSpan opentracing.Span) {
 				sentry.CaptureException(err)
 			})
 
-			if s.RRDPFailover {
+			// GHSA-g9wh-3vrx-r7hg: Do not process responses that are too large
+			if s.RRDPFailover && err.Error() != ""http: request body too large"" {
 				log.Errorf(""Error when processing %v (for %v): %v. Will add to rsync."", path, rsync, err)
 				rSpan.LogKV(""event"", ""rrdp failure"", ""type"", ""failover to rsync"", ""message"", err)
 			} else {
",[False]
GO-2022-0253,cloudflare,cfrpki,648658b1b176a747b52645989cfddc73a81eacad," func (f *HTTPFetcher) GetXML(url string) (string, error) {
 		return """", NewRRDPErrorFetch(req, errors.New(fmt.Sprintf(""status is %d"", res.StatusCode)))
 	}
 
-	data, err := ioutil.ReadAll(res.Body)
+	// GHSA-g9wh-3vrx-r7hg: Do not process responses that are excessively large
+	r := http.MaxBytesReader(nil, res.Body, ResponseLimit)
+	data, err := ioutil.ReadAll(r)
+
 	if err != nil {
 		return """", err
 	}
",[True]
GO-2020-0019,gorilla,websocket,5b740c29263eb386f33f265561c8262522f19d37," func newConn(conn net.Conn, isServer bool, readBufferSize, writeBufferSize int,
 	return c
 }
 
+// setReadRemaining tracks the number of bytes remaining on the connection. If n
+// overflows, an ErrReadLimit is returned.
+func (c *Conn) setReadRemaining(n int64) error {
+	if n < 0 {
+		return ErrReadLimit
+	}
+
+	c.readRemaining = n
+	return nil
+}
+
 // Subprotocol returns the negotiated protocol for the connection.
 func (c *Conn) Subprotocol() string {
 	return c.subprotocol
",[False]
GO-2020-0019,gorilla,websocket,5b740c29263eb386f33f265561c8262522f19d37," func (c *Conn) advanceFrame() (int, error) {
 	final := p[0]&finalBit != 0
 	frameType := int(p[0] & 0xf)
 	mask := p[1]&maskBit != 0
-	c.readRemaining = int64(p[1] & 0x7f)
+	c.setReadRemaining(int64(p[1] & 0x7f))
 
 	c.readDecompress = false
 	if c.newDecompressionReader != nil && (p[0]&rsv1Bit) != 0 {
",[True]
GO-2020-0019,gorilla,websocket,5b740c29263eb386f33f265561c8262522f19d37," func (c *Conn) advanceFrame() (int, error) {
 		return noFrame, c.handleProtocolError(""unknown opcode "" + strconv.Itoa(frameType))
 	}
 
-	// 3. Read and parse frame length.
+	// 3. Read and parse frame length as per
+	// https://tools.ietf.org/html/rfc6455#section-5.2
+	//
+	// The length of the ""Payload data"", in bytes: if 0-125, that is the payload
+	// length.
+	// - If 126, the following 2 bytes interpreted as a 16-bit unsigned
+	// integer are the payload length.
+	// - If 127, the following 8 bytes interpreted as
+	// a 64-bit unsigned integer (the most significant bit MUST be 0) are the
+	// payload length. Multibyte length quantities are expressed in network byte
+	// order.
 
 	switch c.readRemaining {
 	case 126:
",[True]
GO-2020-0019,gorilla,websocket,5b740c29263eb386f33f265561c8262522f19d37," func (c *Conn) advanceFrame() (int, error) {
 		if err != nil {
 			return noFrame, err
 		}
-		c.readRemaining = int64(binary.BigEndian.Uint16(p))
+
+		if err := c.setReadRemaining(int64(binary.BigEndian.Uint16(p))); err != nil {
+			return noFrame, err
+		}
 	case 127:
 		p, err := c.read(8)
 		if err != nil {
 			return noFrame, err
 		}
-		c.readRemaining = int64(binary.BigEndian.Uint64(p))
+
+		if err := c.setReadRemaining(int64(binary.BigEndian.Uint64(p))); err != nil {
+			return noFrame, err
+		}
 	}
 
 	// 4. Handle frame masking.
",[True]
GO-2020-0019,gorilla,websocket,5b740c29263eb386f33f265561c8262522f19d37," func (c *Conn) advanceFrame() (int, error) {
 	if frameType == continuationFrame || frameType == TextMessage || frameType == BinaryMessage {
 
 		c.readLength += c.readRemaining
+		// Don't allow readLength to overflow in the presence of a large readRemaining
+		// counter.
+		if c.readLength < 0 {
+			return noFrame, ErrReadLimit
+		}
+
 		if c.readLimit > 0 && c.readLength > c.readLimit {
 			c.WriteControl(CloseMessage, FormatCloseMessage(CloseMessageTooBig, """"), time.Now().Add(writeWait))
 			return noFrame, ErrReadLimit
",[True]
GO-2020-0019,gorilla,websocket,5b740c29263eb386f33f265561c8262522f19d37," func (c *Conn) advanceFrame() (int, error) {
 	var payload []byte
 	if c.readRemaining > 0 {
 		payload, err = c.read(int(c.readRemaining))
-		c.readRemaining = 0
+		c.setReadRemaining(0)
 		if err != nil {
 			return noFrame, err
 		}
",[True]
GO-2020-0019,gorilla,websocket,5b740c29263eb386f33f265561c8262522f19d37," func (c *Conn) NextReader() (messageType int, r io.Reader, err error) {
 			c.readErr = hideTempErr(err)
 			break
 		}
+
 		if frameType == TextMessage || frameType == BinaryMessage {
 			c.messageReader = &messageReader{c}
 			c.reader = c.messageReader
",[False]
GO-2020-0019,gorilla,websocket,5b740c29263eb386f33f265561c8262522f19d37," func (r *messageReader) Read(b []byte) (int, error) {
 			if c.isServer {
 				c.readMaskPos = maskBytes(c.readMaskKey, c.readMaskPos, b[:n])
 			}
-			c.readRemaining -= int64(n)
+			rem := c.readRemaining
+			rem -= int64(n)
+			c.setReadRemaining(rem)
 			if c.readRemaining > 0 && c.readErr == io.EOF {
 				c.readErr = errUnexpectedEOF
 			}
",[True]
GO-2022-1002,pandatix,go-cvss,d9d478ff0c13b8b09ace030db9262f3c2fe031f4," package gocvss20
 import (
 	""math""
 	""strings""
+	""sync""
+	""unsafe""
 )
 
+var order = [][]string{
+	{""AV"", ""AC"", ""Au"", ""C"", ""I"", ""A""}, // Base metrics
+	{""E"", ""RL"", ""RC""},                 // Temporal metrics
+	{""CDP"", ""TD"", ""CR"", ""IR"", ""AR""},   // Environmental metrics
+}
+
 // ParseVector parses a CVSS v2.0 vector.
 func ParseVector(vector string) (*CVSS20, error) {
 	// Split parts
-	pts := strings.Split(vector, ""/"")
-	if len(pts) != 6 && len(pts) != 9 && len(pts) != 14 {
+	pts, l := split(vector)
+	if l != 6 && l != 9 && l != 14 {
 		return nil, ErrTooShortVector
 	}
+	pts = pts[:l]
 
 	// Work on each CVSS part
 	cvss20 := &CVSS20{
-		Base: Base{},
-		Temporal: Temporal{
-			Exploitability:   ""ND"",
-			RemediationLevel: ""ND"",
-			ReportConfidence: ""ND"",
+		base: base{},
+		temporal: temporal{
+			exploitability:   ""ND"",
+			remediationLevel: ""ND"",
+			reportConfidence: ""ND"",
 		},
-		Environmental: Environmental{
-			CollateralDamagePotential:  ""ND"",
-			TargetDistribution:         ""ND"",
-			ConfidentialityRequirement: ""ND"",
-			IntegrityRequirement:       ""ND"",
-			AvailabilityRequirement:    ""ND"",
+		environmental: environmental{
+			collateralDamagePotential:  ""ND"",
+			targetDistribution:         ""ND"",
+			confidentialityRequirement: ""ND"",
+			integrityRequirement:       ""ND"",
+			availabilityRequirement:    ""ND"",
 		},
 	}
 
-	// Parse metrics in order
-	slcs := [][]string{
-		{""AV"", ""AC"", ""Au"", ""C"", ""I"", ""A""}, // Base metrics
-		{""E"", ""RL"", ""RC""},                 // Temporal metrics
-		{""CDP"", ""TD"", ""CR"", ""IR"", ""AR""},   // Environmental metrics
-	}
 	slci := 0
-	currSlc := slcs[slci]
 	i := 0
 	for _, pt := range pts {
 		abv, v, _ := strings.Cut(pt, "":"")
-		if abv != currSlc[i] {
+		if slci == 4 {
+			return nil, &ErrDefinedN{Abv: abv}
+		}
+		if abv != order[slci][i] {
 			return nil, ErrInvalidMetricOrder
 		}
+
 		if err := cvss20.Set(abv, v); err != nil {
 			return nil, err
 		}
+
 		// Go to next element in slice, or next slice if fully consumed
 		i++
-		if i == len(currSlc) {
+		if i == len(order[slci]) {
 			slci++
-			currSlc = slcs[slci]
 			i = 0
 		}
 	}
",[True]
GO-2022-1002,pandatix,go-cvss,d9d478ff0c13b8b09ace030db9262f3c2fe031f4," func (cvss20 CVSS20) Vector() string {
 // Attributes values must not be manipulated directly. Use Get
 // and Set methods.
 type CVSS20 struct {
-	Base
-	Temporal
-	Environmental
+	base
+	temporal
+	environmental
 }
 
-// Base is the group of metrics defined with such name by the
+// base is the group of metrics defined with such name by the
 // first.org CVSS v2.0 rev2 specification.
 // Mandatory.
-type Base struct {
+type base struct {
 	// AV -> [L,A,N]
-	AccessVector string
+	accessVector string
 	// AC -> [H,M,L]
-	AccessComplexity string
+	accessComplexity string
 	// Au -> [M,S,N]
-	Authentication string
+	authentication string
 	// C -> [N,P,C]
-	ConfidentialityImpact string
+	confidentialityImpact string
 	// I -> [N,P,C]
-	IntegrityImpact string
+	integrityImpact string
 	// A -> [N,P,C]
-	AvailabilityImpact string
+	availabilityImpact string
 }
 
-// Temporal is the group of metrics defined with such name by the
+// temporal is the group of metrics defined with such name by the
 // first.org CVSS v2.0 rev2 specification.
 // Not mandatory.
-type Temporal struct {
+type temporal struct {
 	// E -> [U,POC,F,F,H,ND]
-	Exploitability string
+	exploitability string
 	// RL -> [OF,TF,W,U,ND]
-	RemediationLevel string
+	remediationLevel string
 	// RC -> [UC,UR,C,ND]
-	ReportConfidence string
+	reportConfidence string
 }
 
-// Environmental is the group of metrics defined with such name by the
+// environmental is the group of metrics defined with such name by the
 // first.org CVSS v2.0 rev2 specification.
 // Not mandatory.
-type Environmental struct {
+type environmental struct {
 	// CDP -> [N,L,LM,MH,H,ND]
-	CollateralDamagePotential string
+	collateralDamagePotential string
 	// TD -> [N,L,M,H,ND]
-	TargetDistribution string
+	targetDistribution string
 	// CR,IR,AR -> [L,M,H,ND]
-	ConfidentialityRequirement string
-	IntegrityRequirement       string
-	AvailabilityRequirement    string
+	confidentialityRequirement string
+	integrityRequirement       string
+	availabilityRequirement    string
 }
 
 func (cvss20 CVSS20) Get(abv string) (string, error) {
 	switch abv {
 	case ""AV"":
-		return cvss20.AccessVector, nil
+		return cvss20.accessVector, nil
 	case ""AC"":
-		return cvss20.AccessComplexity, nil
+		return cvss20.accessComplexity, nil
 	case ""Au"":
-		return cvss20.Authentication, nil
+		return cvss20.authentication, nil
 	case ""C"":
-		return cvss20.ConfidentialityImpact, nil
+		return cvss20.confidentialityImpact, nil
 	case ""I"":
-		return cvss20.IntegrityImpact, nil
+		return cvss20.integrityImpact, nil
 	case ""A"":
-		return cvss20.AvailabilityImpact, nil
+		return cvss20.availabilityImpact, nil
 	case ""E"":
-		return cvss20.Exploitability, nil
+		return cvss20.exploitability, nil
 	case ""RL"":
-		return cvss20.RemediationLevel, nil
+		return cvss20.remediationLevel, nil
 	case ""RC"":
-		return cvss20.ReportConfidence, nil
+		return cvss20.reportConfidence, nil
 	case ""CDP"":
-		return cvss20.CollateralDamagePotential, nil
+		return cvss20.collateralDamagePotential, nil
 	case ""TD"":
-		return cvss20.TargetDistribution, nil
+		return cvss20.targetDistribution, nil
 	case ""CR"":
-		return cvss20.ConfidentialityRequirement, nil
+		return cvss20.confidentialityRequirement, nil
 	case ""IR"":
-		return cvss20.IntegrityRequirement, nil
+		return cvss20.integrityRequirement, nil
 	case ""AR"":
-		return cvss20.AvailabilityRequirement, nil
+		return cvss20.availabilityRequirement, nil
 	default:
 		return """", &ErrInvalidMetric{Abv: abv}
 	}
",[False]
GO-2022-1002,pandatix,go-cvss,d9d478ff0c13b8b09ace030db9262f3c2fe031f4," func (cvss20 *CVSS20) Set(abv string, value string) error {
 		if err := validate(value, []string{""L"", ""A"", ""N""}); err != nil {
 			return err
 		}
-		cvss20.AccessVector = value
+		cvss20.accessVector = value
 	case ""AC"":
 		if err := validate(value, []string{""H"", ""M"", ""L""}); err != nil {
 			return err
 		}
-		cvss20.AccessComplexity = value
+		cvss20.accessComplexity = value
 	case ""Au"":
 		if err := validate(value, []string{""M"", ""S"", ""N""}); err != nil {
 			return err
 		}
-		cvss20.Authentication = value
+		cvss20.authentication = value
 	case ""C"":
 		if err := validate(value, []string{""N"", ""P"", ""C""}); err != nil {
 			return err
 		}
-		cvss20.ConfidentialityImpact = value
+		cvss20.confidentialityImpact = value
 	case ""I"":
 		if err := validate(value, []string{""N"", ""P"", ""C""}); err != nil {
 			return err
 		}
-		cvss20.IntegrityImpact = value
+		cvss20.integrityImpact = value
 	case ""A"":
 		if err := validate(value, []string{""N"", ""P"", ""C""}); err != nil {
 			return err
 		}
-		cvss20.AvailabilityImpact = value
+		cvss20.availabilityImpact = value
 	// Temporal
 	case ""E"":
 		if err := validate(value, []string{""U"", ""POC"", ""F"", ""H"", ""ND""}); err != nil {
 			return err
 		}
-		cvss20.Exploitability = value
+		cvss20.exploitability = value
 	case ""RL"":
 		if err := validate(value, []string{""OF"", ""TF"", ""W"", ""U"", ""ND""}); err != nil {
 			return err
 		}
-		cvss20.RemediationLevel = value
+		cvss20.remediationLevel = value
 	case ""RC"":
 		if err := validate(value, []string{""UC"", ""UR"", ""C"", ""ND""}); err != nil {
 			return err
 		}
-		cvss20.ReportConfidence = value
+		cvss20.reportConfidence = value
 	// Environmental
 	case ""CDP"":
 		if err := validate(value, []string{""N"", ""L"", ""LM"", ""MH"", ""H"", ""ND""}); err != nil {
 			return err
 		}
-		cvss20.CollateralDamagePotential = value
+		cvss20.collateralDamagePotential = value
 	case ""TD"":
 		if err := validate(value, []string{""N"", ""L"", ""M"", ""H"", ""ND""}); err != nil {
 			return err
 		}
-		cvss20.TargetDistribution = value
+		cvss20.targetDistribution = value
 	case ""CR"":
 		if err := validate(value, []string{""L"", ""M"", ""H"", ""ND""}); err != nil {
 			return err
 		}
-		cvss20.ConfidentialityRequirement = value
+		cvss20.confidentialityRequirement = value
 	case ""IR"":
 		if err := validate(value, []string{""L"", ""M"", ""H"", ""ND""}); err != nil {
 			return err
 		}
-		cvss20.IntegrityRequirement = value
+		cvss20.integrityRequirement = value
 	case ""AR"":
 		if err := validate(value, []string{""L"", ""M"", ""H"", ""ND""}); err != nil {
 			return err
 		}
-		cvss20.AvailabilityRequirement = value
+		cvss20.availabilityRequirement = value
 	default:
 		return &ErrInvalidMetric{Abv: abv}
 	}
",[False]
GO-2023-1597,kitabisa,teler-waf,d1d49cfddfa3ec2adad962870f14b85cd1aaf739," func (t *Teler) checkCustomRules(r *http.Request) error {
 	// Converts map of headers to RAW string
 	headers := headersToRawString(r.Header)
 
-	// Decode the URL-encoded request URI of the URL
-	uri := toURLDecode(r.URL.RequestURI())
+	// Decode the URL-encoded and unescape HTML entities request URI of the URL
+	uri := stringDeUnescape(r.URL.RequestURI())
 
 	// Declare byte slice for request body.
 	var body string
",[True]
GO-2023-1597,kitabisa,teler-waf,d1d49cfddfa3ec2adad962870f14b85cd1aaf739," func (t *Teler) checkCustomRules(r *http.Request) error {
 		body = buf.String()
 	}
 
-	// Decode the URL-encoded of body
-	body = toURLDecode(body)
+	// Decode the URL-encoded and unescape HTML entities of body
+	body = stringDeUnescape(body)
 
 	// Iterate over the Customs field of the Teler struct, which is a slice of custom rules
 	for _, rule := range t.opt.Customs {
",[True]
GO-2023-1597,kitabisa,teler-waf,d1d49cfddfa3ec2adad962870f14b85cd1aaf739," func (t *Teler) checkCustomRules(r *http.Request) error {
 // If a match is found, it returns an error indicating a common web attack has been detected.
 // If no match is found, it returns nil.
 func (t *Teler) checkCommonWebAttack(r *http.Request) error {
-	// Decode the URL-encoded request URI of the URL
-	uri := toURLDecode(r.URL.RequestURI())
+	// Decode the URL-encoded and unescape HTML entities request URI of the URL
+	uri := stringDeUnescape(r.URL.RequestURI())
 
 	// Declare byte slice for request body.
 	var body string
",[False]
GO-2023-1597,kitabisa,teler-waf,d1d49cfddfa3ec2adad962870f14b85cd1aaf739," func (t *Teler) checkCommonWebAttack(r *http.Request) error {
 		body = buf.String()
 	}
 
-	// Decode the URL-encoded of body
-	body = toURLDecode(body)
+	// Decode the URL-encoded and unescape HTML entities of body
+	body = stringDeUnescape(body)
 
 	// Iterate over the filters in the CommonWebAttack data stored in the t.threat.cwa.Filters field
 	for _, filter := range t.threat.cwa.Filters {
",[False]
GO-2022-0534,runatlantis,atlantis,48870911974adddaa4c99c8089e79b7d787fa820," func (d *DefaultGitlabRequestParserValidator) ParseAndValidate(r *http.Request,
 
 	// Validate secret if specified.
 	headerSecret := r.Header.Get(secretHeader)
-	secretStr := string(secret)
-	if len(secret) != 0 && headerSecret != secretStr {
+	if len(secret) != 0 && subtle.ConstantTimeCompare(secret, []byte(headerSecret)) != 1 {
 		return nil, fmt.Errorf(""header %s=%s did not match expected secret"", secretHeader, headerSecret)
 	}
 
",[True]
GO-2021-0079,Bytom,bytom,1ac3c8ac4f2b1e1df9675228290bda6b9586ba42," func (net *Network) checkTopicRegister(data *topicRegister) (*pong, error) {
 	if hash != pongpkt.data.(*pong).TopicHash {
 		return nil, errors.New(""topic hash mismatch"")
 	}
-	if data.Idx < 0 || int(data.Idx) >= len(data.Topics) {
+	if int(data.Idx) < 0 || int(data.Idx) >= len(data.Topics) {
 		return nil, errors.New(""topic index out of range"")
 	}
 	return pongpkt.data.(*pong), nil
",[True]
GO-2022-0701,kubernetes,kubernetes,37f730f68c7f06e060f90714439bfb0dbb2df5e7," func BeforeCreate(strategy RESTCreateStrategy, ctx api.Context, obj runtime.Obje
 	if errs := strategy.Validate(ctx, obj); len(errs) > 0 {
 		return errors.NewInvalid(kind, objectMeta.Name, errs)
 	}
+
+	// Custom validation (including name validation) passed
+	// Now run common validation on object meta
+	// Do this *after* custom validation so that specific error messages are shown whenever possible
+	if errs := validation.ValidateObjectMeta(objectMeta, strategy.NamespaceScoped(), validation.ValidatePathSegmentName); len(errs) > 0 {
+		return errors.NewInvalid(kind, objectMeta.Name, errs)
+	}
+
 	return nil
 }
 
",[True]
GO-2022-0701,kubernetes,kubernetes,37f730f68c7f06e060f90714439bfb0dbb2df5e7,"
+/*
+Copyright 2015 The Kubernetes Authors All rights reserved.
+
+Licensed under the Apache License, Version 2.0 (the ""License"");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an ""AS IS"" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+package validation
+
+import (
+	""fmt""
+	""strings""
+)
+
+// NameMayNotBe specifies strings that cannot be used as names specified as path segments (like the REST API or etcd store)
+var NameMayNotBe = []string{""."", ""..""}
+
+// NameMayNotContain specifies substrings that cannot be used in names specified as path segments (like the REST API or etcd store)
+var NameMayNotContain = []string{""/"", ""%""}
+
+// ValidatePathSegmentName validates the name can be used as a path segment
+func ValidatePathSegmentName(name string, prefix bool) (bool, string) {
+	// Only check for exact matches if this is the full name (not a prefix)
+	if prefix == false {
+		for _, illegalName := range NameMayNotBe {
+			if name == illegalName {
+				return false, fmt.Sprintf(`name may not be %q`, illegalName)
+			}
+		}
+	}
+
+	for _, illegalContent := range NameMayNotContain {
+		if strings.Contains(name, illegalContent) {
+			return false, fmt.Sprintf(`name may not contain %q`, illegalContent)
+		}
+	}
+
+	return true, """"
+}
",[False]
GO-2022-0701,kubernetes,kubernetes,37f730f68c7f06e060f90714439bfb0dbb2df5e7," func NewREST(s storage.Interface) (*REST, *StatusREST, *FinalizeREST) {
 			return prefix
 		},
 		KeyFunc: func(ctx api.Context, name string) (string, error) {
-			return path.Join(prefix, name), nil
+			return etcdgeneric.NoNamespaceKeyFunc(ctx, prefix, name)
 		},
 		ObjectNameFunc: func(obj runtime.Object) (string, error) {
 			return obj.(*api.Namespace).Name, nil
",[True]
GO-2022-0701,kubernetes,kubernetes,37f730f68c7f06e060f90714439bfb0dbb2df5e7," func NewREST(s storage.Interface, useCacher bool, connection client.ConnectionIn
 			return prefix
 		},
 		KeyFunc: func(ctx api.Context, name string) (string, error) {
-			return prefix + ""/"" + name, nil
+			return etcdgeneric.NoNamespaceKeyFunc(ctx, prefix, name)
 		},
 		ObjectNameFunc: func(obj runtime.Object) (string, error) {
 			return obj.(*api.Node).Name, nil
",[True]
GO-2022-0701,kubernetes,kubernetes,37f730f68c7f06e060f90714439bfb0dbb2df5e7," func NewREST(s storage.Interface) (*REST, *StatusREST) {
 			return prefix
 		},
 		KeyFunc: func(ctx api.Context, name string) (string, error) {
-			return path.Join(prefix, name), nil
+			return etcdgeneric.NoNamespaceKeyFunc(ctx, prefix, name)
 		},
 		ObjectNameFunc: func(obj runtime.Object) (string, error) {
 			return obj.(*api.PersistentVolume).Name, nil
",[True]
GO-2022-0701,kubernetes,kubernetes,37f730f68c7f06e060f90714439bfb0dbb2df5e7," func NamespaceKeyFunc(prefix string, obj runtime.Object) (string, error) {
 	if err != nil {
 		return """", err
 	}
+	name := meta.Name()
+	if ok, msg := validation.ValidatePathSegmentName(name, false); !ok {
+		return """", fmt.Errorf(""invalid name: %v"", msg)
+	}
 	return prefix + ""/"" + meta.Namespace() + ""/"" + meta.Name(), nil
 }
 
",[True]
GO-2022-0701,kubernetes,kubernetes,37f730f68c7f06e060f90714439bfb0dbb2df5e7," func NoNamespaceKeyFunc(prefix string, obj runtime.Object) (string, error) {
 	if err != nil {
 		return """", err
 	}
+	name := meta.Name()
+	if ok, msg := validation.ValidatePathSegmentName(name, false); !ok {
+		return """", fmt.Errorf(""invalid name: %v"", msg)
+	}
 	return prefix + ""/"" + meta.Name(), nil
 }
",[True]
GO-2021-0085,opencontainers,runc,cad42f6e0932db0ce08c3a3d9e89e6063ec283e4," func setprocattr(attr, value string) error {
 	}
 	defer f.Close()
 
+	if err := utils.EnsureProcHandle(f); err != nil {
+		return err
+	}
+
 	_, err = fmt.Fprintf(f, ""%s"", value)
 	return err
 }
",[False]
GO-2021-0085,opencontainers,runc,cad42f6e0932db0ce08c3a3d9e89e6063ec283e4," func setprocattr(attr, value string) error {
 // changeOnExec reimplements aa_change_onexec from libapparmor in Go
 func changeOnExec(name string) error {
 	value := ""exec "" + name
-	if err := setprocattr(""exec"", value); err != nil {
+	if err := setProcAttr(""exec"", value); err != nil {
 		return fmt.Errorf(""apparmor failed to apply profile: %s"", err)
 	}
 	return nil
",[False]
GO-2021-0085,opencontainers,runc,cad42f6e0932db0ce08c3a3d9e89e6063ec283e4," func InitLabels(options []string) (plabel string, mlabel string, Err error) {
 				return """", mountLabel, nil
 			}
 			if i := strings.Index(opt, "":""); i == -1 {
-				return """", """", fmt.Errorf(""Bad label option %q, valid options 'disable' or \n'user, role, level, type' followed by ':' and a value"", opt)
+				return """", """", fmt.Errorf(""Bad label option %q, valid options 'disable' or \n'user, role, level, type, filetype' followed by ':' and a value"", opt)
 			}
 			con := strings.SplitN(opt, "":"", 2)
 			if !validOptions[con[0]] {
-				return """", """", fmt.Errorf(""Bad label option %q, valid options 'disable, user, role, level, type'"", con[0])
+				return """", """", fmt.Errorf(""Bad label option %q, valid options 'disable, user, role, level, type, filetype'"", con[0])
 
 			}
+			if con[0] == ""filetype"" {
+				mcon[""type""] = con[1]
+			}
 			pcon[con[0]] = con[1]
 			if con[0] == ""level"" || con[0] == ""user"" {
 				mcon[con[0]] = con[1]
",[False]
GO-2021-0085,opencontainers,runc,cad42f6e0932db0ce08c3a3d9e89e6063ec283e4," func readCon(fpath string) (string, error) {
 	}
 	defer in.Close()
 
+	if ok, err := isProcHandle(in); err != nil {
+		return """", err
+	} else if !ok {
+		return """", fmt.Errorf(""%s not on procfs"", fpath)
+	}
+
 	var retval string
 	if _, err := fmt.Fscanf(in, ""%s"", &retval); err != nil {
 		return """", err
",[True]
GO-2021-0085,opencontainers,runc,cad42f6e0932db0ce08c3a3d9e89e6063ec283e4," func writeCon(fpath string, val string) error {
 	}
 	defer out.Close()
 
+	if ok, err := isProcHandle(out); err != nil {
+		return err
+	} else if !ok {
+		return fmt.Errorf(""%s not on procfs"", fpath)
+	}
+
 	if val != """" {
 		_, err = out.Write([]byte(val))
 	} else {
",[True]
GO-2021-0085,opencontainers,runc,cad42f6e0932db0ce08c3a3d9e89e6063ec283e4," func SetExecLabel(label string) error {
 	return writeCon(fmt.Sprintf(""/proc/self/task/%d/attr/exec"", syscall.Gettid()), label)
 }
 
+/*
+SetTaskLabel sets the SELinux label for the current thread, or an error.
+This requires the dyntransition permission.
+*/
+func SetTaskLabel(label string) error {
+	return writeCon(fmt.Sprintf(""/proc/self/task/%d/attr/current"", syscall.Gettid()), label)
+}
+
 // SetSocketLabel takes a process label and tells the kernel to assign the
 // label to the next socket that gets created
 func SetSocketLabel(label string) error {
",[False]
GO-2021-0085,opencontainers,runc,cad42f6e0932db0ce08c3a3d9e89e6063ec283e4," func SocketLabel() (string, error) {
 	return readCon(fmt.Sprintf(""/proc/self/task/%d/attr/sockcreate"", syscall.Gettid()))
 }
 
+// PeerLabel retrieves the label of the client on the other side of a socket
+func PeerLabel(fd uintptr) (string, error) {
+	return unix.GetsockoptString(int(fd), syscall.SOL_SOCKET, syscall.SO_PEERSEC)
+}
+
 // SetKeyLabel takes a process label and tells the kernel to assign the
 // label to the next kernel keyring that gets created
 func SetKeyLabel(label string) error {
",[False]
GO-2021-0085,opencontainers,runc,cad42f6e0932db0ce08c3a3d9e89e6063ec283e4," func SetExecLabel(label string) error {
 	return nil
 }
 
+/*
+SetTaskLabel sets the SELinux label for the current thread, or an error.
+This requires the dyntransition permission.
+*/
+func SetTaskLabel(label string) error {
+        return nil
+}
+
 /*
 SetSocketLabel sets the SELinux label that the kernel will use for any programs
 that are executed by the current process thread, or an error.
",[False]
GO-2021-0085,opencontainers,runc,cad42f6e0932db0ce08c3a3d9e89e6063ec283e4," func SocketLabel() (string, error) {
 	return """", nil
 }
 
+// PeerLabel retrieves the label of the client on the other side of a socket
+func PeerLabel(fd uintptr) (string, error) {
+	return """", nil
+}
+
 // SetKeyLabel takes a process label and tells the kernel to assign the
 // label to the next kernel keyring that gets created
 func SetKeyLabel(label string) error {
",[False]
GO-2021-0085,opencontainers,selinux,03b517dc4fd57245b1cf506e8ba7b817b6d309da," func readCon(fpath string) (string, error) {
 	}
 	defer in.Close()
 
+	if ok, err := isProcHandle(in); err != nil {
+		return """", err
+	} else if !ok {
+		return """", fmt.Errorf(""%s not on procfs"", fpath)
+	}
+
 	var retval string
 	if _, err := fmt.Fscanf(in, ""%s"", &retval); err != nil {
 		return """", err
",[True]
GO-2021-0085,opencontainers,selinux,03b517dc4fd57245b1cf506e8ba7b817b6d309da," func writeCon(fpath string, val string) error {
 	}
 	defer out.Close()
 
+	if ok, err := isProcHandle(out); err != nil {
+		return err
+	} else if !ok {
+		return fmt.Errorf(""%s not on procfs"", fpath)
+	}
+
 	if val != """" {
 		_, err = out.Write([]byte(val))
 	} else {
",[True]
GO-2021-0075,ethereum,go-ethereum,a5237a27eaf81946a3edb4fafe13ed6359d119e4," func (pm *ProtocolManager) handleMsg(p *peer) error {
 
 			// Advance to the next header of the query
 			switch {
-			case query.Origin.Hash != (common.Hash{}) && query.Reverse:
+			case hashMode && query.Reverse:
 				// Hash based traversal towards the genesis block
 				for i := 0; i < int(query.Skip)+1; i++ {
 					if header := pm.blockchain.GetHeader(query.Origin.Hash, number); header != nil {
",[True]
GO-2021-0075,ethereum,go-ethereum,a5237a27eaf81946a3edb4fafe13ed6359d119e4," func (pm *ProtocolManager) handleMsg(p *peer) error {
 						break
 					}
 				}
-			case query.Origin.Hash != (common.Hash{}) && !query.Reverse:
+			case hashMode && !query.Reverse:
 				// Hash based traversal towards the leaf block
-				if header := pm.blockchain.GetHeaderByNumber(origin.Number.Uint64() + query.Skip + 1); header != nil {
-					if pm.blockchain.GetBlockHashesFromHash(header.Hash(), query.Skip+1)[query.Skip] == query.Origin.Hash {
-						query.Origin.Hash = header.Hash()
+				var (
+					current = origin.Number.Uint64()
+					next    = current + query.Skip + 1
+				)
+				if next <= current {
+					infos, _ := json.MarshalIndent(p.Peer.Info(), """", ""  "")
+					p.Log().Warn(""GetBlockHeaders skip overflow attack"", ""current"", current, ""skip"", query.Skip, ""next"", next, ""attacker"", infos)
+					unknown = true
+				} else {
+					if header := pm.blockchain.GetHeaderByNumber(next); header != nil {
+						if pm.blockchain.GetBlockHashesFromHash(header.Hash(), query.Skip+1)[query.Skip] == query.Origin.Hash {
+							query.Origin.Hash = header.Hash()
+						} else {
+							unknown = true
+						}
 					} else {
 						unknown = true
 					}
-				} else {
-					unknown = true
 				}
 			case query.Reverse:
 				// Number based traversal towards the genesis block
",[True]
GO-2021-0265,tidwall,gjson,77a57fda87dca6d0d7d4627d512a630f89a91c96," func parseObject(c *parseContext, i int, path string) (int, bool) {
 		}
 		if rp.wild {
 			if kesc {
-				pmatch = match.Match(unescape(key), rp.part)
+				pmatch = matchLimit(unescape(key), rp.part)
 			} else {
-				pmatch = match.Match(key, rp.part)
+				pmatch = matchLimit(key, rp.part)
 			}
 		} else {
 			if kesc {
",[True]
GO-2021-0265,tidwall,gjson,77a57fda87dca6d0d7d4627d512a630f89a91c96," func queryMatches(rp *arrayPathResult, value Result) bool {
 		case "">="":
 			return value.Str >= rpv
 		case ""%"":
-			return match.Match(value.Str, rpv)
+			return matchLimit(value.Str, rpv)
 		case ""!%"":
-			return !match.Match(value.Str, rpv)
+			return !matchLimit(value.Str, rpv)
 		}
 	case Number:
 		rpvn, _ := strconv.ParseFloat(rpv, 64)
",[True]
GO-2021-0107,ecnepsnai,web,5a78f8d5c41ce60dcf9f61aaf47a7a8dc3e0002f," var upgrader = websocket.Upgrader{
 
 func (s *Server) socketHandler(endpointHandle SocketHandle, options HandleOptions) httprouter.Handle {
 	return func(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
+		var userData interface{}
+
+		if options.AuthenticateMethod != nil {
+			userData = options.AuthenticateMethod(r)
+			if isUserdataNil(userData) {
+				if options.UnauthorizedMethod == nil {
+					s.log.Warn(""Rejected authenticated request"")
+					w.Header().Set(""Content-Type"", ""application/json"")
+					w.WriteHeader(http.StatusUnauthorized)
+					json.NewEncoder(w).Encode(Error{401, ""Unauthorized""})
+					return
+				}
+
+				options.UnauthorizedMethod(w, r)
+				return
+			}
+		}
+
 		conn, err := upgrader.Upgrade(w, r, nil)
 		if err != nil {
 			s.log.Error(""Error upgrading client for websocket connection: %s"", err.Error())
 			return
 		}
 		endpointHandle(Request{
-			Params: ps,
-			log:    s.log,
+			Params:   ps,
+			UserData: userData,
+			log:      s.log,
 		}, WSConn{
 			c: conn,
 		})
",[True]
GO-2021-0100,containers,storage,306fcabc964470e4b3b87a43a8f6b7d698209ee1," func DecompressStream(archive io.Reader) (io.ReadCloser, error) {
 		readBufWrapper := p.NewReadCloserWrapper(buf, bz2Reader)
 		return readBufWrapper, nil
 	case Xz:
-		xzReader, chdone, err := xzDecompress(buf)
+		xzReader, err := xz.NewReader(buf)
 		if err != nil {
 			return nil, err
 		}
 		readBufWrapper := p.NewReadCloserWrapper(buf, xzReader)
-		return ioutils.NewReadCloserWrapper(readBufWrapper, func() error {
-			<-chdone
-			return readBufWrapper.Close()
-		}), nil
+		return readBufWrapper, nil
 	case Zstd:
 		return zstdReader(buf)
 	default:
",[False]
GO-2021-0100,containers,storage,306fcabc964470e4b3b87a43a8f6b7d698209ee1,"
+// Copyright 2014-2021 Ulrich Kunitz. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package hash
+
+// Roller provides an interface for rolling hashes. The hash value will become
+// valid after hash has been called Len times.
+type Roller interface {
+	Len() int
+	RollByte(x byte) uint64
+}
+
+// Hashes computes all hash values for the array p. Note that the state of the
+// roller is changed.
+func Hashes(r Roller, p []byte) []uint64 {
+	n := r.Len()
+	if len(p) < n {
+		return nil
+	}
+	h := make([]uint64, len(p)-n+1)
+	for i := 0; i < n-1; i++ {
+		r.RollByte(p[i])
+	}
+	for i := range h {
+		h[i] = r.RollByte(p[i+n-1])
+	}
+	return h
+}
",[False]
GO-2021-0100,containers,storage,306fcabc964470e4b3b87a43a8f6b7d698209ee1,"
+// Copyright 2014-2021 Ulrich Kunitz. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package lzma
+
+/* Naming conventions follows the CodeReviewComments in the Go Wiki. */
+
+// ntz32Const is used by the functions NTZ and NLZ.
+const ntz32Const = 0x04d7651f
+
+// ntz32Table is a helper table for de Bruijn algorithm by Danny Dubé.
+// See Henry S. Warren, Jr. ""Hacker's Delight"" section 5-1 figure 5-26.
+var ntz32Table = [32]int8{
+	0, 1, 2, 24, 3, 19, 6, 25,
+	22, 4, 20, 10, 16, 7, 12, 26,
+	31, 23, 18, 5, 21, 9, 15, 11,
+	30, 17, 8, 14, 29, 13, 28, 27,
+}
+
+/*
+// ntz32 computes the number of trailing zeros for an unsigned 32-bit integer.
+func ntz32(x uint32) int {
+	if x == 0 {
+		return 32
+	}
+	x = (x & -x) * ntz32Const
+	return int(ntz32Table[x>>27])
+}
+*/
+
+// nlz32 computes the number of leading zeros for an unsigned 32-bit integer.
+func nlz32(x uint32) int {
+	// Smear left most bit to the right
+	x |= x >> 1
+	x |= x >> 2
+	x |= x >> 4
+	x |= x >> 8
+	x |= x >> 16
+	// Use ntz mechanism to calculate nlz.
+	x++
+	if x == 0 {
+		return 0
+	}
+	x *= ntz32Const
+	return 32 - int(ntz32Table[x>>27])
+}
",[False]
GO-2021-0100,containers,storage,306fcabc964470e4b3b87a43a8f6b7d698209ee1,"
+// Copyright 2014-2021 Ulrich Kunitz. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package lzma
+
+import (
+	""errors""
+	""io""
+)
+
+// ErrLimit indicates that the limit of the LimitedByteWriter has been
+// reached.
+var ErrLimit = errors.New(""limit reached"")
+
+// LimitedByteWriter provides a byte writer that can be written until a
+// limit is reached. The field N provides the number of remaining
+// bytes.
+type LimitedByteWriter struct {
+	BW io.ByteWriter
+	N  int64
+}
+
+// WriteByte writes a single byte to the limited byte writer. It returns
+// ErrLimit if the limit has been reached. If the byte is successfully
+// written the field N of the LimitedByteWriter will be decremented by
+// one.
+func (l *LimitedByteWriter) WriteByte(c byte) error {
+	if l.N <= 0 {
+		return ErrLimit
+	}
+	if err := l.BW.WriteByte(c); err != nil {
+		return err
+	}
+	l.N--
+	return nil
+}
",[False]
GO-2021-0100,containers,storage,306fcabc964470e4b3b87a43a8f6b7d698209ee1," func DetectCompression(source []byte) Compression {
 	return Uncompressed
 }
 
-func xzDecompress(archive io.Reader) (io.ReadCloser, <-chan struct{}, error) {
-	args := []string{""xz"", ""-d"", ""-c"", ""-q""}
-
-	return cmdStream(exec.Command(args[0], args[1:]...), archive)
-}
-
 // DecompressStream decompresses the archive and returns a ReaderCloser with the decompressed archive.
 func DecompressStream(archive io.Reader) (io.ReadCloser, error) {
 	p := pools.BufioReader32KPool
",[False]
GO-2021-0100,containers,storage,306fcabc964470e4b3b87a43a8f6b7d698209ee1," func remapIDs(readIDMappings, writeIDMappings *idtools.IDMappings, chownOpts *id
 	return nil
 }
 
-// cmdStream executes a command, and returns its stdout as a stream.
-// If the command fails to run or doesn't complete successfully, an error
-// will be returned, including anything written on stderr.
-func cmdStream(cmd *exec.Cmd, input io.Reader) (io.ReadCloser, <-chan struct{}, error) {
-	chdone := make(chan struct{})
-	cmd.Stdin = input
-	pipeR, pipeW := io.Pipe()
-	cmd.Stdout = pipeW
-	var errBuf bytes.Buffer
-	cmd.Stderr = &errBuf
-
-	// Run the command and return the pipe
-	if err := cmd.Start(); err != nil {
-		return nil, nil, err
-	}
-
-	// Copy stdout to the returned pipe
-	go func() {
-		if err := cmd.Wait(); err != nil {
-			pipeW.CloseWithError(fmt.Errorf(""%s: %s"", err, errBuf.String()))
-		} else {
-			pipeW.Close()
-		}
-		close(chdone)
-	}()
-
-	return pipeR, chdone, nil
-}
-
 // NewTempArchive reads the content of src into a temporary file, and returns the contents
 // of that file as an archive. The archive can only be read once - as soon as reading completes,
 // the file will be deleted.
",[True]
GO-2023-2052,gofiber,fiber,b8c9ede6efa231116c4bd8bb9d5e03eac1cb76dc," func (c *Ctx) IsProxyTrusted() bool {
 	return false
 }
 
-var localHosts = [...]string{""127.0.0.1"", ""0.0.0.0"", ""::1""}
+var localHosts = [...]string{""127.0.0.1"", ""::1""}
 
 // IsLocalHost will return true if address is a localhost address.
 func (*Ctx) isLocalHost(address string) bool {
 	for _, h := range localHosts {
-		if strings.Contains(address, h) {
+		if address == h {
 			return true
 		}
 	}
",[True]
GO-2023-2052,gofiber,fiber,b8c9ede6efa231116c4bd8bb9d5e03eac1cb76dc," func (*Ctx) isLocalHost(address string) bool {
 
 // IsFromLocal will return true if request came from local.
 func (c *Ctx) IsFromLocal() bool {
-	ips := c.IPs()
-	if len(ips) == 0 {
-		ips = append(ips, c.IP())
-	}
-	return c.isLocalHost(ips[0])
+	return c.isLocalHost(c.fasthttp.RemoteIP().String())
 }
",[False]
GO-2022-0463,beego,beego,64cf44d725c8cc35d782327d333df9cbeb1bf2dd," func (t *Tree) match(treePattern string, pattern string, wildcardValues []string
 	if runObject == nil && len(t.fixrouters) > 0 {
 		// Filter the .json .xml .html extension
 		for _, str := range allowSuffixExt {
-			if strings.HasSuffix(seg, str) && strings.HasSuffix(treePattern, seg) {
+			// pattern == """" avoid cases: /aaa.html/aaa.html could access /aaa/:bbb
+			if strings.HasSuffix(seg, str) && pattern == """" {
 				for _, subTree := range t.fixrouters {
-					// strings.HasSuffix(treePattern, seg) avoid cases: /aaa.html/bbb could access /aaa/bbb
 					if subTree.prefix == seg[:len(seg)-len(str)] {
 						runObject = subTree.match(treePattern, pattern, wildcardValues, ctx)
 						if runObject != nil {
",[True]
GO-2022-0252,cloudflare,cfrpki,2882307febd66801de97b2a2ce4d93fe58132005," func (ipn *IPNet) GetAfi() uint8 {
 }
 
 func (ipn *IPNet) GetRange() (net.IP, net.IP, bool) {
-	min, max := GetRangeIP(ipn.IPNet)
+	err, min, max := GetRangeIP(ipn.IPNet)
+	if err != nil {
+		return nil, nil, false
+	}
 	return min, max, false
 }
 
",[True]
GO-2022-0252,cloudflare,cfrpki,2882307febd66801de97b2a2ce4d93fe58132005," func ValidateIPCertificateList(list []IPCertificateInformation, parent *RPKICert
 			valids = append(valids, ip)
 			continue
 		}
+		if min == nil && max == nil {
+			invalids = append(invalids, ip)
+		}
 		valid, checkParent := parent.IsIPRangeInCertificate(min, max)
 		if valid {
 			valids = append(valids, ip)
",[True]
GO-2022-0252,cloudflare,cfrpki,2882307febd66801de97b2a2ce4d93fe58132005," func EncodeROAEntries(asn int, entries []*ROAEntry) (*ROA, error) {
 	return roa, nil
 }
 
-func GetRangeIP(ipnet *net.IPNet) (net.IP, net.IP) {
+func GetRangeIP(ipnet *net.IPNet) (error, net.IP, net.IP) {
 	ip := ipnet.IP
 	mask := ipnet.Mask
 
 	beginIP := make([]byte, len(ip))
 	endIP := make([]byte, len(ip))
 	for i := range []byte(ip) {
+		// GHSA-w6ww-fmfx-2x22: Prevent oob read
+		if i >= len(mask) {
+			return errors.New(""Invalid IP address mask""), nil, nil
+		}
 		beginIP[i] = ip[i] & mask[i]
 		endIP[i] = ip[i] | ^mask[i]
 	}
-	return net.IP(beginIP), net.IP(endIP)
+	return nil, net.IP(beginIP), net.IP(endIP)
 }
 
 // https://tools.ietf.org/html/rfc6480#section-2.3
",[True]
GO-2022-0252,cloudflare,cfrpki,2882307febd66801de97b2a2ce4d93fe58132005," func ValidateIPRoaCertificateList(entries []*ROAEntry, cert *RPKICertificate) ([
 	invalids := make([]*ROAEntry, 0)
 	checkParents := make([]*ROAEntry, 0)
 	for _, entry := range entries {
-		min, max := GetRangeIP(entry.IPNet)
+		err, min, max := GetRangeIP(entry.IPNet)
+		if err != nil {
+			invalids = append(invalids, entry)
+		}
 		valid, checkParent := cert.IsIPRangeInCertificate(min, max)
 		if valid {
 			valids = append(valids, entry)
",[True]
GO-2020-0021,gogs,gogs,83283bca4cb4e0f4ec48a28af680f0d88db3d2c8," func GetIssues(uid, rid, pid, mid int64, page int, isClosed bool, labelIds, sort
 
 	if len(labelIds) > 0 {
 		for _, label := range strings.Split(labelIds, "","") {
-			sess.And(""label_ids like '%$"" + label + ""|%'"")
+			// Prevent SQL inject.
+			if com.StrTo(label).MustInt() > 0 {
+				sess.And(""label_ids like '%$"" + label + ""|%'"")
+			}
 		}
 	}
 
",[True]
GO-2020-0021,gogs,gogs,83283bca4cb4e0f4ec48a28af680f0d88db3d2c8," func SearchRepositoryByName(opt SearchOption) (repos []*Repository, err error) {
 	if opt.Uid > 0 {
 		sess.Where(""owner_id=?"", opt.Uid)
 	}
+	if !opt.Private {
+		sess.And(""is_private=false"")
+	}
 	sess.And(""lower_name like '%"" + opt.Keyword + ""%'"").Find(&repos)
 	return repos, err
 }
",[True]
GO-2020-0021,gogs,gogs,83283bca4cb4e0f4ec48a28af680f0d88db3d2c8," func GetUserByEmail(email string) (*User, error) {
 
 // SearchUserByName returns given number of users whose name contains keyword.
 func SearchUserByName(opt SearchOption) (us []*User, err error) {
-	// Prevent SQL inject.
-	opt.Keyword = strings.TrimSpace(opt.Keyword)
-	if len(opt.Keyword) == 0 {
-		return us, nil
-	}
-
-	opt.Keyword = strings.Split(opt.Keyword, "" "")[0]
+	opt.Keyword = FilterSQLInject(opt.Keyword)
 	if len(opt.Keyword) == 0 {
 		return us, nil
 	}
",[True]
GO-2020-0021,gogs,gogs,83283bca4cb4e0f4ec48a28af680f0d88db3d2c8," func SearchRepos(ctx *middleware.Context) {
 		opt.Limit = 10
 	}
 
+	// Check visibility.
+	if ctx.IsSigned && opt.Uid > 0 {
+		if ctx.User.Id == opt.Uid {
+			opt.Private = true
+		} else {
+			u, err := models.GetUserById(opt.Uid)
+			if err != nil {
+				ctx.JSON(500, map[string]interface{}{
+					""ok"":    false,
+					""error"": err.Error(),
+				})
+				return
+			}
+			if u.IsOrganization() && u.IsOrgOwner(ctx.User.Id) {
+				opt.Private = true
+			}
+			// FIXME: how about collaborators?
+		}
+	}
+
 	repos, err := models.SearchRepositoryByName(opt)
 	if err != nil {
 		ctx.JSON(500, map[string]interface{}{
",[False]
GO-2020-0028,miekg,dns,501e858f679edecd4a38a86317ce50271014a80d," func setTA(h RR_Header, c chan lex, o, f string) (RR, *ParseError, string) {
 		return nil, &ParseError{f, ""bad TA DigestType"", l}, """"
 	}
 	rr.DigestType = uint8(i)
-	s, e, c1 := endingToString(c, ""bad TA Digest"", f)
-	if e != nil {
-		return nil, e.(*ParseError), c1
+	s, err, c1 := endingToString(c, ""bad TA Digest"", f)
+	if err != nil {
+		return nil, err, c1
 	}
 	rr.Digest = s
 	return rr, nil, c1
",[True]
GO-2020-0035,yi-ge,unzip,2adbaa4891b9690853ef10216189189f5ad7dc73," func (uz Unzip) Extract() error {
 		}()
 
 		path := filepath.Join(uz.Dest, f.Name)
+		if !strings.HasPrefix(path, filepath.Clean(uz.Dest)+string(os.PathSeparator)) {
+            return fmt.Errorf(""%s: illegal file path"", path)
+        }
 
 		if f.FileInfo().IsDir() {
 			os.MkdirAll(path, f.Mode())
",[True]
GO-2022-0370,mellium,xmpp,0d92aa486da69b71f2f4a30e62aa722c711b98ac," func NewClient(ctx context.Context, origin, location string, addr jid.JID, rwc i
 	d := Dialer{
 		Origin: origin,
 	}
-	cfg, err := d.config(location)
+	cfg, err := d.config(addr.Domain().String(), location)
 	if err != nil {
 		return nil, err
 	}
",[False]
GO-2022-0370,mellium,xmpp,0d92aa486da69b71f2f4a30e62aa722c711b98ac," func (d *Dialer) Dial(ctx context.Context, addr jid.JID) (net.Conn, error) {
 		if !d.InsecureNoTLS && strings.HasPrefix(u, ""ws:"") {
 			continue
 		}
-		cfg, err = d.config(u)
+		cfg, err = d.config(addr.Domain().String(), u)
 		if err != nil {
 			continue
 		}
",[False]
GO-2022-0370,mellium,xmpp,0d92aa486da69b71f2f4a30e62aa722c711b98ac," func (d *Dialer) config(addr string) (cfg *websocket.Config, err error) {
 	cfg.TlsConfig = d.TLSConfig
 	if cfg.TlsConfig == nil {
 		cfg.TlsConfig = &tls.Config{
-			ServerName: cfg.Location.Host,
+			ServerName: remoteAddr,
 			MinVersion: tls.VersionTLS12,
 		}
 	}
",[True]
GO-2020-0017,dgrijalva,jwt-go,ec0a89a131e3e8567adcb21254a5cd20a70ea4ab,"
+package jwt
+
+import (
+	""encoding/json""
+	""reflect""
+)
+
+// ClaimStrings is used for parsing claim properties that
+// can be either a string or array of strings
+type ClaimStrings []string
+
+// UnmarshalJSON implements the json package's Unmarshaler interface
+func (c *ClaimStrings) UnmarshalJSON(data []byte) error {
+	var value interface{}
+	err := json.Unmarshal(data, &value)
+	if err != nil {
+		return err
+	}
+	switch v := value.(type) {
+	case string:
+		*c = ClaimStrings{v}
+	case []interface{}:
+		result := make(ClaimStrings, 0, len(v))
+		for i, vv := range v {
+			if x, ok := vv.(string); ok {
+				result = append(result, x)
+			} else {
+				return &json.UnsupportedTypeError{Type: reflect.TypeOf(v[i])}
+			}
+		}
+		*c = result
+	case nil:
+	default:
+		return &json.UnsupportedTypeError{Type: reflect.TypeOf(v)}
+	}
+	return nil
+}
",[False]
GO-2020-0017,dgrijalva,jwt-go,ec0a89a131e3e8567adcb21254a5cd20a70ea4ab," func (c *StandardClaims) VerifyNotBefore(cmp int64, req bool) bool {
 
 // ----- helpers
 
-func verifyAud(aud string, cmp string, required bool) bool {
-	if aud == """" {
+func verifyAud(aud ClaimStrings, cmp string, required bool) bool {
+	if len(aud) == 0 {
 		return !required
 	}
-	if subtle.ConstantTimeCompare([]byte(aud), []byte(cmp)) != 0 {
-		return true
+	for _, audStr := range aud {
+		if subtle.ConstantTimeCompare([]byte(audStr), []byte(cmp)) != 0 {
+			return true
+		}
 	}
 	return false
 }
",[False]
GO-2020-0017,dgrijalva,jwt-go,ec0a89a131e3e8567adcb21254a5cd20a70ea4ab," type MapClaims map[string]interface{}
 // Compares the aud claim against cmp.
 // If required is false, this method will return true if the value matches or is unset
 func (m MapClaims) VerifyAudience(cmp string, req bool) bool {
-	aud, _ := m[""aud""].(string)
-	return verifyAud(aud, cmp, req)
+	aud, ok := m[""aud""]
+	if !ok {
+		return !req
+	}
+
+	switch v := aud.(type) {
+	case string:
+		return verifyAud(ClaimStrings{v}, cmp, req)
+	case []string:
+		return verifyAud(ClaimStrings(v), cmp, req)
+	default:
+		return false
+	}
 }
 
 // Compares the exp claim against cmp.
",[True]
GO-2022-0400,ntbosscher,gobase,a8d40bce9c429d324122d18c446924dab809e812," func (c Config) getAccessTokenCookieName() string {
 	return strs.Coalesce(c.AccessTokenCookieName, ""token"")
 }
 
+const defaultLoginEndpoint = ""/api/auth/login""
+const defaultRefreshEndpoint = ""/api/auth/refresh""
+const defaultLogoutEndpoint = ""/api/auth/logout""
+const defaultRegisterEndpoint = ""/api/auth/register""
+
 func Setup(router *res.Router, config Config) *AuthRouter {
 	loginPath := strs.Coalesce(config.LoginPath, defaultLoginEndpoint)
 	router.Post(loginPath, loginHandler(&config))
",[True]
GO-2022-0400,ntbosscher,gobase,a8d40bce9c429d324122d18c446924dab809e812," func Setup(router *res.Router, config Config) *AuthRouter {
 		oauth.Setup(router, config.OAuth, sessionSetter)
 	}
 
-	server := middleware(config)
+	server := newServer(config)
 
-	router.Use(func(h http.Handler) http.Handler {
-		server.next = h
-		return server
+	router.Use(func(handler http.Handler) http.Handler {
+		return cloneServer(server, handler)
 	})
 
 	return &AuthRouter{
",[True]
GO-2022-0400,ntbosscher,gobase,a8d40bce9c429d324122d18c446924dab809e812," func middleware(config Config) *server {
 }
 
 type server struct {
-	next                     http.Handler
+	next http.Handler
 	perRequestFilter         PerRequestFilter
 	ignoreRoutesWithPrefixes []string
 	ignoreRoutes             []string
 	authHandler              func(request *res.Request) (res.Responder, context.Context)
 }
 
-const defaultLoginEndpoint = ""/api/auth/login""
-const defaultRefreshEndpoint = ""/api/auth/refresh""
-const defaultLogoutEndpoint = ""/api/auth/logout""
-const defaultRegisterEndpoint = ""/api/auth/register""
-
 func (s *server) ServeHTTP(w http.ResponseWriter, r *http.Request) {
 
 	ignoredRoute := false
",[False]
GO-2022-1184,sajari,docconv,b19021ade3d0b71c89d35cb00eb9e589a121faa5," func ConvertPDFImages(path string) (BodyResult, error) {
 // PdfHasImage verify if `path` (PDF) has images
 func PDFHasImage(path string) bool {
 	cmd := ""pdffonts -l 5 %s | tail -n +3 | cut -d' ' -f1 | sort | uniq""
-	out, err := exec.Command(""bash"", ""-c"", fmt.Sprintf(cmd, path)).Output()
+	out, err := exec.Command(""bash"", ""-c"", fmt.Sprintf(cmd, shellEscape(path))).CombinedOutput()
+
 	if err != nil {
 		log.Println(err)
 		return false
",[True]
GO-2022-0643,elastic,beats,aeca65779d573976981587ca1d1461399e1b59dd," func pgsqlFieldsParser(s *pgsqlStream, buf []byte) error {
 		off += 4
 
 		// read format (int16)
+		if len(buf) < off+2 {
+			return errFieldBufferShort
+		}
 		format := common.BytesNtohs(buf[off : off+2])
 		off += 2
 		fieldsFormat = append(fieldsFormat, byte(format))
",[True]
GO-2022-1165,helm,helm,638ebffbc2e445156f3978f02fd83d9af1e56f5b," func LoadIndexFile(path string) (*IndexFile, error) {
 // MustAdd adds a file to the index
 // This can leave the index in an unsorted state
 func (i IndexFile) MustAdd(md *chart.Metadata, filename, baseURL, digest string) error {
+	if i.Entries == nil {
+		return errors.New(""entries not initialized"")
+	}
+
 	if md.APIVersion == """" {
 		md.APIVersion = chart.APIVersionV1
 	}
",[True]
GO-2022-1165,helm,helm,638ebffbc2e445156f3978f02fd83d9af1e56f5b," func loadIndex(data []byte, source string) (*IndexFile, error) {
 
 	for name, cvs := range i.Entries {
 		for idx := len(cvs) - 1; idx >= 0; idx-- {
+			if cvs[idx] == nil {
+				log.Printf(""skipping loading invalid entry for chart %q from %s: empty entry"", name, source)
+				continue
+			}
 			if cvs[idx].APIVersion == """" {
 				cvs[idx].APIVersion = chart.APIVersionV1
 			}
",[True]
GO-2022-1165,helm,helm,638ebffbc2e445156f3978f02fd83d9af1e56f5b," func (r *File) Remove(name string) bool {
 	cp := []*Entry{}
 	found := false
 	for _, rf := range r.Repositories {
+		if rf == nil {
+			continue
+		}
 		if rf.Name == name {
 			found = true
 			continue
",[True]
GO-2022-1052,tendermint,tendermint,a2a6852ab99e4a0f9e79f0ea8c1726e262e25c76," func (cs *State) tryAddVote(vote *types.Vote, peerID p2p.ID) (bool, error) {
 					vote.Type)
 				return added, err
 			}
-			var timestamp time.Time
-			if voteErr.VoteA.Height == cs.state.InitialHeight {
-				timestamp = cs.state.LastBlockTime // genesis time
-			} else {
-				timestamp = sm.MedianTime(cs.LastCommit.MakeCommit(), cs.LastValidators)
-			}
-			// form duplicate vote evidence from the conflicting votes and send it across to the
-			// evidence pool
-			ev := types.NewDuplicateVoteEvidence(voteErr.VoteA, voteErr.VoteB, timestamp, cs.Validators)
-			evidenceErr := cs.evpool.AddEvidenceFromConsensus(ev)
-			if evidenceErr != nil {
-				cs.Logger.Error(""Failed to add evidence to the evidence pool"", ""err"", evidenceErr)
-			} else {
-				cs.Logger.Debug(""Added evidence to the evidence pool"", ""ev"", ev)
-			}
+			// report conflicting votes to the evidence pool
+			cs.evpool.ReportConflictingVotes(voteErr.VoteA, voteErr.VoteB)
+			cs.Logger.Info(""Found and sent conflicting votes to the evidence pool"",
+				""VoteA"", voteErr.VoteA,
+				""VoteB"", voteErr.VoteB,
+			)
 			return added, err
 		} else if err == types.ErrVoteNonDeterministicSignature {
 			cs.Logger.Debug(""Vote has non-deterministic signature"", ""err"", err)
",[True]
GO-2022-1052,tendermint,tendermint,a2a6852ab99e4a0f9e79f0ea8c1726e262e25c76," func NewPool(evidenceDB dbm.DB, stateDB sm.Store, blockStore BlockStore) (*Pool,
 		logger:          log.NewNopLogger(),
 		evidenceStore:   evidenceDB,
 		evidenceList:    clist.New(),
-		consensusBuffer: make([]types.Evidence, 0),
+		consensusBuffer: make([]duplicateVoteSet, 0),
 	}
 
 	// if pending evidence already in db, in event of prior failure, then check for expiration,
",[False]
GO-2022-1052,tendermint,tendermint,a2a6852ab99e4a0f9e79f0ea8c1726e262e25c76," func (evpool *Pool) PendingEvidence(maxBytes int64) ([]types.Evidence, int64) {
 	return evidence, size
 }
 
-// Update pulls the latest state to be used for expiration and evidence params and then prunes all expired evidence
+// Update takes both the new state and the evidence committed at that height and performs
+// the following operations:
+// 1. Take any conflicting votes from consensus and use the state's LastBlockTime to form
+//    DuplicateVoteEvidence and add it to the pool.
+// 2. Update the pool's state which contains evidence params relating to expiry.
+// 3. Moves pending evidence that has now been committed into the committed pool.
+// 4. Removes any expired evidence based on both height and time.
 func (evpool *Pool) Update(state sm.State, ev types.EvidenceList) {
 	// sanity check
 	if state.LastBlockHeight <= evpool.state.LastBlockHeight {
 		panic(fmt.Sprintf(
-			""Failed EvidencePool.Update new state height is less than or equal to previous state height: %d <= %d"",
+			""failed EvidencePool.Update new state height is less than or equal to previous state height: %d <= %d"",
 			state.LastBlockHeight,
 			evpool.state.LastBlockHeight,
 		))
 	}
-	evpool.logger.Info(""Updating evidence pool"", ""last_block_height"", state.LastBlockHeight,
+	evpool.logger.Debug(""Updating evidence pool"", ""last_block_height"", state.LastBlockHeight,
 		""last_block_time"", state.LastBlockTime)
 
-	evpool.logger.Info(
-		""updating evidence pool"",
-		""last_block_height"", state.LastBlockHeight,
-		""last_block_time"", state.LastBlockTime,
-	)
-
-	evpool.mtx.Lock()
-	// flush awaiting evidence from consensus into pool
-	evpool.flushConsensusBuffer()
+	// flush conflicting vote pairs from the buffer, producing DuplicateVoteEvidence and
+	// adding it to the pool
+	evpool.processConsensusBuffer(state)
 	// update state
-	evpool.state = state
-	evpool.mtx.Unlock()
+	evpool.updateState(state)
 
 	// move committed evidence out from the pending pool and into the committed pool
 	evpool.markEvidenceAsCommitted(ev)
",[True]
GO-2022-1052,tendermint,tendermint,a2a6852ab99e4a0f9e79f0ea8c1726e262e25c76," func (evpool *Pool) AddEvidence(ev types.Evidence) error {
 
 	// We have already verified this piece of evidence - no need to do it again
 	if evpool.isPending(ev) {
-		evpool.logger.Info(""Evidence already pending, ignoring this one"", ""ev"", ev)
+		evpool.logger.Debug(""Evidence already pending, ignoring this one"", ""ev"", ev)
 		return nil
 	}
 
",[False]
GO-2022-1052,tendermint,tendermint,a2a6852ab99e4a0f9e79f0ea8c1726e262e25c76," func (evpool *Pool) CheckEvidence(evList types.EvidenceList) error {
 
 			err := evpool.verify(ev)
 			if err != nil {
-				return &types.ErrInvalidEvidence{Evidence: ev, Reason: err}
+				return err
 			}
 
 			if err := evpool.addPendingEvidence(ev); err != nil {
",[True]
GO-2022-1052,tendermint,tendermint,a2a6852ab99e4a0f9e79f0ea8c1726e262e25c76," func (evpool *Pool) removePendingEvidence(evidence types.Evidence) {
 		evpool.logger.Error(""Unable to delete pending evidence"", ""err"", err)
 	} else {
 		atomic.AddUint32(&evpool.evidenceSize, ^uint32(0))
-		evpool.logger.Info(""Deleted pending evidence"", ""evidence"", evidence)
+		evpool.logger.Debug(""Deleted pending evidence"", ""evidence"", evidence)
 	}
 }
 
",[False]
GO-2022-0346,quay,claircore,691f2023a1720a0579e688b69a2f4bfe1f4b7821," func (ps *Scanner) Scan(ctx context.Context, layer *claircore.Layer) ([]*clairco
 			continue
 		}
 		// Build the path on the filesystem.
-		tgt := filepath.Join(root, filepath.Clean(h.Name))
+		tgt := relPath(root, h.Name)
 		// Since tar, as a format, doesn't impose ordering requirements, make
 		// sure to create all parent directories of the current entry.
 		d := filepath.Dir(tgt)
",[True]
GO-2022-0346,quay,claircore,691f2023a1720a0579e688b69a2f4bfe1f4b7821," func (ps *Scanner) Scan(ctx context.Context, layer *claircore.Layer) ([]*clairco
 			stats.Reg++
 		case tar.TypeSymlink:
 			// Normalize the link target into the root.
-			ln := filepath.Join(root, filepath.Clean(h.Linkname))
+			ln := relPath(root, h.Linkname)
 			err = os.Symlink(ln, tgt)
 			stats.Symlink++
 		case tar.TypeLink:
 			// Normalize the link target into the root.
-			ln := filepath.Join(root, filepath.Clean(h.Linkname))
+			ln := relPath(root, h.Linkname)
 			_, exists := os.Lstat(ln)
 			switch {
 			case errors.Is(exists, nil):
",[True]
GO-2022-0346,quay,claircore,691f2023a1720a0579e688b69a2f4bfe1f4b7821," func checkMagic(ctx context.Context, r io.Reader) bool {
 
 	return false
 }
+
+// RelPath takes a member and forcibly interprets it as a path underneath root.
+//
+// This should be used anytime a path for a new file on disk is needed when
+// unpacking a tar.
+func relPath(root, member string) string {
+	return filepath.Join(root, filepath.Join(""/"", member))
+}
",[False]
GO-2020-0050,russellhaering,goxmldsig,f6188febf0c29d7ffe26a0436212b19cb9615e64," func (ctx *ValidationContext) findSignature(el *etree.Element) (*types.Signature
 	var sig *types.Signature
 
 	// Traverse the tree looking for a Signature element
-	err := etreeutils.NSFindIterate(el, Namespace, SignatureTag, func(ctx etreeutils.NSContext, el *etree.Element) error {
-
+	err := etreeutils.NSFindIterate(root, Namespace, SignatureTag, func(ctx etreeutils.NSContext, signatureEl *etree.Element) error {
+		err := validateShape(signatureEl)
+		if err != nil {
+			return err
+		}
 		found := false
-		err := etreeutils.NSFindChildrenIterateCtx(ctx, el, Namespace, SignedInfoTag,
+		err = etreeutils.NSFindChildrenIterateCtx(ctx, signatureEl, Namespace, SignedInfoTag,
 			func(ctx etreeutils.NSContext, signedInfo *etree.Element) error {
 				detachedSignedInfo, err := etreeutils.NSDetatch(ctx, signedInfo)
 				if err != nil {
",[True]
GO-2020-0050,russellhaering,goxmldsig,f6188febf0c29d7ffe26a0436212b19cb9615e64," func (ctx *ValidationContext) findSignature(el *etree.Element) (*types.Signature
 					return fmt.Errorf(""invalid CanonicalizationMethod on Signature: %s"", c14NAlgorithm)
 				}
 
-				el.RemoveChild(signedInfo)
-				el.AddChild(canonicalSignedInfo)
+				signatureEl.RemoveChild(signedInfo)
+				signatureEl.AddChild(canonicalSignedInfo)
 
 				found = true
 
",[True]
GO-2020-0050,russellhaering,goxmldsig,f6188febf0c29d7ffe26a0436212b19cb9615e64," func (ctx *ValidationContext) findSignature(el *etree.Element) (*types.Signature
 
 		// Unmarshal the signature into a structured Signature type
 		_sig := &types.Signature{}
-		err = etreeutils.NSUnmarshalElement(ctx, el, _sig)
+		err = etreeutils.NSUnmarshalElement(ctx, signatureEl, _sig)
 		if err != nil {
 			return err
 		}
",[True]
GO-2022-1166,helm,helm,bafafa8bb1b571b61d7a9528da8d40c307dade3d," func ValidateAgainstSchema(chrt *chart.Chart, values map[string]interface{}) err
 }
 
 // ValidateAgainstSingleSchema checks that values does not violate the structure laid out in this schema
-func ValidateAgainstSingleSchema(values Values, schemaJSON []byte) error {
+func ValidateAgainstSingleSchema(values Values, schemaJSON []byte) (reterr error) {
+	defer func() {
+		if r := recover(); r != nil {
+			reterr = fmt.Errorf(""unable to validate schema: %s"", r)
+		}
+	}()
+
 	valuesData, err := yaml.Marshal(values)
 	if err != nil {
 		return err
",[True]
GO-2022-0587,open-policy-agent,opa,e9d3828db670cbe11129885f37f08cbf04935264," func (p *Parser) parseSome() *Expr {
 	if term := p.parseTermInfixCall(); term != nil {
 		if call, ok := term.Value.(Call); ok {
 			switch call[0].String() {
-			case Member.Name, MemberWithKey.Name: // OK
+			case Member.Name:
+				if len(call) != 3 {
+					p.illegal(""illegal domain"")
+					return nil
+				}
+			case MemberWithKey.Name:
+				if len(call) != 4 {
+					p.illegal(""illegal domain"")
+					return nil
+				}
 			default:
 				p.illegal(""expected `x in xs` or `x, y in xs` expression"")
 				return nil
",[True]
GO-2022-0587,open-policy-agent,opa,e9d3828db670cbe11129885f37f08cbf04935264," func (p *Parser) parseEvery() *Expr {
 	}
 	switch call[0].String() {
 	case Member.Name: // x in xs
+		if len(call) != 3 {
+			p.illegal(""illegal domain"")
+			return nil
+		}
 		qb.Value = call[1]
 		qb.Domain = call[2]
 	case MemberWithKey.Name: // k, v in xs
+		if len(call) != 4 {
+			p.illegal(""illegal domain"")
+			return nil
+		}
 		qb.Key = call[1]
 		qb.Value = call[2]
 		qb.Domain = call[3]
",[True]
GO-2021-0064,kubernetes,kubernetes,e99df0e5a75eb6e86123b56d53e9b7ca0fd00419," func (r *requestInfo) toCurl() string {
 	headers := """"
 	for key, values := range r.RequestHeaders {
 		for _, value := range values {
+			value = maskValue(key, value)
 			headers += fmt.Sprintf(` -H %q`, fmt.Sprintf(""%s: %s"", key, value))
 		}
 	}
",[True]
GO-2023-1874,corazawaf,coraza,a5239ba3ce839e14d9b4f9486e1b4a403dcade8c," func (mbp *multipartBodyProcessor) ProcessRequest(reader io.Reader, v plugintype
 	storagePath := options.StoragePath
 	mediaType, params, err := mime.ParseMediaType(mimeType)
 	if err != nil {
-		log.Fatalf(""failed to parse media type: %s"", err.Error())
+		return err
 	}
 	if !strings.HasPrefix(mediaType, ""multipart/"") {
 		return errors.New(""not a multipart body"")
",[True]
GO-2021-0076,evanphx,json-patch,4c9aadca8f89e349c999f04e28199e96e81aba03," func (d *partialArray) add(key string, val *lazyNode) error {
 		}
 		idx = len(ary) - idx
 	}
-
+	if idx < 0 || idx >= len(ary) || idx > len(cur) {
+		return fmt.Errorf(""Unable to access invalid index: %d"", idx)
+	}
 	copy(ary[0:idx], cur[0:idx])
 	ary[idx] = val
 	copy(ary[idx+1:], cur[idx:])
",[True]
GO-2020-0005,etcd-io,etcd,f4b650b51dc4a53a8700700dc12e1242ac56ba07," func (d *decoder) decode(rec *walpb.Record) error {
 	return d.decodeRecord(rec)
 }
 
+// raft max message size is set to 1 MB in etcd server
+// assume projects set reasonable message size limit,
+// thus entry size should never exceed 10 MB
+const maxWALEntrySizeLimit = int64(10 * 1024 * 1024)
+
 func (d *decoder) decodeRecord(rec *walpb.Record) error {
 	if len(d.brs) == 0 {
 		return io.EOF
",[True]
GO-2020-0005,etcd-io,etcd,f4b650b51dc4a53a8700700dc12e1242ac56ba07," func (d *decoder) decodeRecord(rec *walpb.Record) error {
 	}
 
 	recBytes, padBytes := decodeFrameSize(l)
+	if recBytes >= maxWALEntrySizeLimit-padBytes {
+		return ErrMaxWALEntrySizeLimitExceeded
+	}
 
 	data := make([]byte, recBytes+padBytes)
 	if _, err = io.ReadFull(d.brs[0], data); err != nil {
",[True]
GO-2020-0005,etcd-io,etcd,f4b650b51dc4a53a8700700dc12e1242ac56ba07," func (w *WAL) ReadAll() (metadata []byte, state raftpb.HardState, ents []raftpb.
 		switch rec.Type {
 		case entryType:
 			e := mustUnmarshalEntry(rec.Data)
+			// 0 <= e.Index-w.start.Index - 1 < len(ents)
 			if e.Index > w.start.Index {
-				ents = append(ents[:e.Index-w.start.Index-1], e)
+				// prevent ""panic: runtime error: slice bounds out of range [:13038096702221461992] with capacity 0""
+				up := e.Index - w.start.Index - 1
+				if up > uint64(len(ents)) {
+					// return error before append call causes runtime panic
+					return nil, state, nil, ErrSliceOutOfRange
+				}
+				ents = append(ents[:up], e)
 			}
 			w.enti = e.Index
 
",[True]
GO-2020-0037,tendermint,tendermint,03085c2da23b179c4a51f59a03cb40aa4e85a613," func makeHTTPClient(remoteAddr string) (string, *http.Client) {
 	protocol, address, dialer := makeHTTPDialer(remoteAddr)
 	return protocol + ""://"" + address, &http.Client{
 		Transport: &http.Transport{
-			Dial: dialer,
+			// Set to true to prevent GZIP-bomb DoS attacks
+			DisableCompression: true,
+			Dial:               dialer,
 		},
 	}
 }
",[True]
GO-2022-1129,crewjam,saml,aee3fb1edeeaf1088fcb458727e0fd863d277f8b," import (
 	""regexp""
 	""time""
 
-	xrv ""github.com/mattermost/xml-roundtrip-validator""
-
 	""github.com/beevik/etree""
+	xrv ""github.com/mattermost/xml-roundtrip-validator""
 	dsig ""github.com/russellhaering/goxmldsig""
 	""github.com/russellhaering/goxmldsig/etreeutils""
 
",[False]
GO-2022-1129,crewjam,saml,aee3fb1edeeaf1088fcb458727e0fd863d277f8b," func (sp *ServiceProvider) validateSignature(el *etree.Element) error {
 
 	ctx, err := etreeutils.NSBuildParentContext(el)
 	if err != nil {
-		return err
+		return fmt.Errorf(""cannot validate signature on %s: %v"", el.Tag, err)
 	}
 	ctx, err = ctx.SubContext(el)
 	if err != nil {
-		return err
+		return fmt.Errorf(""cannot validate signature on %s: %v"", el.Tag, err)
 	}
 	el, err = etreeutils.NSDetatch(ctx, el)
 	if err != nil {
-		return err
+		return fmt.Errorf(""cannot validate signature on %s: %v"", el.Tag, err)
 	}
 
 	if sp.SignatureVerifier != nil {
 		return sp.SignatureVerifier.VerifySignature(validationContext, el)
 	}
 
-	_, err = validationContext.Validate(el)
-	return err
+	if _, err := validationContext.Validate(el); err != nil {
+		return fmt.Errorf(""cannot validate signature on %s: %v"", el.Tag, err)
+	}
+
+	return nil
 }
 
 // SignLogoutRequest adds the `Signature` element to the `LogoutRequest`.
",[True]
GO-2022-1129,crewjam,saml,aee3fb1edeeaf1088fcb458727e0fd863d277f8b," func (sp *ServiceProvider) ValidateLogoutResponseRequest(req *http.Request) erro
 
 // ValidateLogoutResponseForm returns a nil error if the logout response is valid.
 func (sp *ServiceProvider) ValidateLogoutResponseForm(postFormData string) error {
+	retErr := &InvalidResponseError{
+		Now: TimeNow(),
+	}
+
 	rawResponseBuf, err := base64.StdEncoding.DecodeString(postFormData)
 	if err != nil {
-		return fmt.Errorf(""unable to parse base64: %s"", err)
+		retErr.PrivateErr = fmt.Errorf(""unable to parse base64: %s"", err)
+		return retErr
 	}
+	retErr.Response = string(rawResponseBuf)
 
 	// TODO(ross): add test case for this (SLO does not have tests right now)
 	if err := xrv.Validate(bytes.NewReader(rawResponseBuf)); err != nil {
 		return fmt.Errorf(""response contains invalid XML: %s"", err)
 	}
 
-	var resp LogoutResponse
-	if err := xml.Unmarshal(rawResponseBuf, &resp); err != nil {
-		return fmt.Errorf(""cannot unmarshal response: %s"", err)
+	doc := etree.NewDocument()
+	if err := doc.ReadFromBytes(rawResponseBuf); err != nil {
+		retErr.PrivateErr = err
+		return retErr
 	}
 
-	if err := sp.validateLogoutResponse(&resp); err != nil {
-		return err
+	if err := sp.validateSignature(doc.Root()); err != nil {
+		retErr.PrivateErr = err
+		return retErr
 	}
 
-	doc := etree.NewDocument()
-	if err := doc.ReadFromBytes(rawResponseBuf); err != nil {
+	var resp LogoutResponse
+	if err := unmarshalElement(doc.Root(), &resp); err != nil {
+		retErr.PrivateErr = err
+		return retErr
+	}
+	if err := sp.validateLogoutResponse(&resp); err != nil {
 		return err
 	}
-
-	responseEl := doc.Root()
-	return sp.validateSigned(responseEl)
+	return nil
 }
 
 // ValidateLogoutResponseRedirect returns a nil error if the logout response is valid.
",[False]
GO-2022-1129,crewjam,saml,aee3fb1edeeaf1088fcb458727e0fd863d277f8b," func (sp *ServiceProvider) ValidateLogoutResponseForm(postFormData string) error
 // URL Binding appears to be gzip / flate encoded
 // See https://www.oasis-open.org/committees/download.php/20645/sstc-saml-tech-overview-2%200-draft-10.pdf  6.6
 func (sp *ServiceProvider) ValidateLogoutResponseRedirect(queryParameterData string) error {
+	retErr := &InvalidResponseError{
+		Now: TimeNow(),
+	}
+
 	rawResponseBuf, err := base64.StdEncoding.DecodeString(queryParameterData)
 	if err != nil {
-		return fmt.Errorf(""unable to parse base64: %s"", err)
+		retErr.PrivateErr = fmt.Errorf(""unable to parse base64: %s"", err)
+		return retErr
 	}
+	retErr.Response = string(rawResponseBuf)
 
 	gr, err := ioutil.ReadAll(flate.NewReader(bytes.NewBuffer(rawResponseBuf)))
 	if err != nil {
-		return err
+		retErr.PrivateErr = err
+		return retErr
 	}
 
 	if err := xrv.Validate(bytes.NewReader(gr)); err != nil {
 		return err
 	}
 
-	decoder := xml.NewDecoder(bytes.NewReader(gr))
-
-	var resp LogoutResponse
-
-	err = decoder.Decode(&resp)
-	if err != nil {
-		return fmt.Errorf(""unable to flate decode: %s"", err)
+	doc := etree.NewDocument()
+	if err := doc.ReadFromBytes(rawResponseBuf); err != nil {
+		retErr.PrivateErr = err
+		return retErr
 	}
 
-	if err := sp.validateLogoutResponse(&resp); err != nil {
-		return err
+	if err := sp.validateSignature(doc.Root()); err != nil {
+		retErr.PrivateErr = err
+		return retErr
 	}
 
-	doc := etree.NewDocument()
-	if _, err := doc.ReadFrom(bytes.NewReader(gr)); err != nil {
+	var resp LogoutResponse
+	if err := unmarshalElement(doc.Root(), &resp); err != nil {
+		retErr.PrivateErr = err
+		return retErr
+	}
+	if err := sp.validateLogoutResponse(&resp); err != nil {
 		return err
 	}
-
-	responseEl := doc.Root()
-	return sp.validateSigned(responseEl)
+	return nil
 }
 
 // validateLogoutResponse validates the LogoutResponse fields. Returns a nil error if the LogoutResponse is valid.
",[False]
GO-2022-0379,distribution,distribution,b59a6f827947f9e0e67df0cfb571046de4733586," func init() {
 	}
 
 	imageIndexFunc := func(b []byte) (distribution.Manifest, distribution.Descriptor, error) {
+		if err := validateIndex(b); err != nil {
+			return nil, distribution.Descriptor{}, err
+		}
 		m := new(DeserializedManifestList)
 		err := m.UnmarshalJSON(b)
 		if err != nil {
",[False]
GO-2022-0379,distribution,distribution,b59a6f827947f9e0e67df0cfb571046de4733586," func (m DeserializedManifestList) Payload() (string, []byte, error) {
 
 	return mediaType, m.canonical, nil
 }
+
+// unknownDocument represents a manifest, manifest list, or index that has not
+// yet been validated
+type unknownDocument struct {
+	Config interface{} `json:""config,omitempty""`
+	Layers interface{} `json:""layers,omitempty""`
+}
+
+// validateIndex returns an error if the byte slice is invalid JSON or if it
+// contains fields that belong to a manifest
+func validateIndex(b []byte) error {
+	var doc unknownDocument
+	if err := json.Unmarshal(b, &doc); err != nil {
+		return err
+	}
+	if doc.Config != nil || doc.Layers != nil {
+		return errors.New(""index: expected index but found manifest"")
+	}
+	return nil
+}
",[False]
GO-2022-0379,distribution,distribution,b59a6f827947f9e0e67df0cfb571046de4733586," var (
 
 func init() {
 	ocischemaFunc := func(b []byte) (distribution.Manifest, distribution.Descriptor, error) {
+		if err := validateManifest(b); err != nil {
+			return nil, distribution.Descriptor{}, err
+		}
 		m := new(DeserializedManifest)
 		err := m.UnmarshalJSON(b)
 		if err != nil {
",[False]
GO-2022-0379,distribution,distribution,b59a6f827947f9e0e67df0cfb571046de4733586," func (m *DeserializedManifest) MarshalJSON() ([]byte, error) {
 func (m DeserializedManifest) Payload() (string, []byte, error) {
 	return v1.MediaTypeImageManifest, m.canonical, nil
 }
+
+// unknownDocument represents a manifest, manifest list, or index that has not
+// yet been validated
+type unknownDocument struct {
+	Manifests interface{} `json:""manifests,omitempty""`
+}
+
+// validateManifest returns an error if the byte slice is invalid JSON or if it
+// contains fields that belong to a index
+func validateManifest(b []byte) error {
+	var doc unknownDocument
+	if err := json.Unmarshal(b, &doc); err != nil {
+		return err
+	}
+	if doc.Manifests != nil {
+		return errors.New(""ocimanifest: expected manifest but found index"")
+	}
+	return nil
+}
",[False]
GO-2021-0066,kubernetes,kubernetes,11793434dac97a49bfed0150b56ac63e5dc34634," func ReadDockercfgFile(searchPaths []string) (cfg DockerConfig, err error) {
 			continue
 		}
 		cfg, err := readDockerConfigFileFromBytes(contents)
-		if err == nil {
-			klog.V(4).Infof(""found .dockercfg at %s"", absDockerConfigFileLocation)
-			return cfg, nil
+		if err != nil {
+			klog.V(4).Infof(""couldn't get the config from %q contents: %v"", absDockerConfigFileLocation, err)
+			continue
 		}
+
+		klog.V(4).Infof(""found .dockercfg at %s"", absDockerConfigFileLocation)
+		return cfg, nil
+
 	}
 	return nil, fmt.Errorf(""couldn't find valid .dockercfg after checking in %v"", searchPaths)
 }
",[False]
GO-2021-0066,kubernetes,kubernetes,11793434dac97a49bfed0150b56ac63e5dc34634," func ReadDockerConfigFileFromURL(url string, client *http.Client, header *http.H
 
 func readDockerConfigFileFromBytes(contents []byte) (cfg DockerConfig, err error) {
 	if err = json.Unmarshal(contents, &cfg); err != nil {
-		klog.Errorf(""while trying to parse blob %q: %v"", contents, err)
-		return nil, err
+		return nil, errors.New(""error occurred while trying to unmarshal json"")
 	}
 	return
 }
",[True]
GO-2021-0066,kubernetes,kubernetes,11793434dac97a49bfed0150b56ac63e5dc34634," func readDockerConfigFileFromBytes(contents []byte) (cfg DockerConfig, err error
 func readDockerConfigJSONFileFromBytes(contents []byte) (cfg DockerConfig, err error) {
 	var cfgJSON DockerConfigJSON
 	if err = json.Unmarshal(contents, &cfgJSON); err != nil {
-		klog.Errorf(""while trying to parse blob %q: %v"", contents, err)
-		return nil, err
+		return nil, errors.New(""error occurred while trying to unmarshal json"")
 	}
 	cfg = cfgJSON.Auths
 	return
",[True]
GO-2022-0945,square,go-jose,2c5656adca9909843c4ff50acf1d2cf8f32da7e6," func (ctx *genericEncrypter) EncryptWithAuthData(plaintext, aad []byte) (*JsonWe
 	return obj, nil
 }
 
-// Decrypt and validate the object and return the plaintext.
+// Decrypt and validate the object and return the plaintext. Note that this
+// function does not support multi-recipient, if you desire multi-recipient
+// decryption use DecryptMulti instead.
 func (obj JsonWebEncryption) Decrypt(decryptionKey interface{}) ([]byte, error) {
 	headers := obj.mergedHeaders(nil)
 
+	if len(obj.recipients) > 1 {
+		return nil, errors.New(""square/go-jose: too many recipients in payload; expecting only one"")
+	}
+
 	if len(headers.Crit) > 0 {
 		return nil, fmt.Errorf(""square/go-jose: unsupported crit header"")
 	}
",[False]
GO-2022-0945,square,go-jose,789a4c4bd4c118f7564954f441b29c153ccd6a96," func (ctx *cbcAEAD) Overhead() int {
 // Seal encrypts and authenticates the plaintext.
 func (ctx *cbcAEAD) Seal(dst, nonce, plaintext, data []byte) []byte {
 	// Output buffer -- must take care not to mangle plaintext input.
-	ciphertext := make([]byte, len(plaintext)+ctx.Overhead())[:len(plaintext)]
+	ciphertext := make([]byte, uint64(len(plaintext))+uint64(ctx.Overhead()))[:len(plaintext)]
 	copy(ciphertext, plaintext)
 	ciphertext = padBuffer(ciphertext, ctx.blockCipher.BlockSize())
 
",[True]
GO-2022-0945,square,go-jose,789a4c4bd4c118f7564954f441b29c153ccd6a96," func (ctx *cbcAEAD) Seal(dst, nonce, plaintext, data []byte) []byte {
 	cbc.CryptBlocks(ciphertext, ciphertext)
 	authtag := ctx.computeAuthTag(data, nonce, ciphertext)
 
-	ret, out := resize(dst, len(dst)+len(ciphertext)+len(authtag))
+	ret, out := resize(dst, uint64(len(dst))+uint64(len(ciphertext))+uint64(len(authtag)))
 	copy(out, ciphertext)
 	copy(out[len(ciphertext):], authtag)
 
",[True]
GO-2022-0945,square,go-jose,789a4c4bd4c118f7564954f441b29c153ccd6a96," func (ctx *cbcAEAD) Open(dst, nonce, ciphertext, data []byte) ([]byte, error) {
 		return nil, err
 	}
 
-	ret, out := resize(dst, len(dst)+len(plaintext))
+	ret, out := resize(dst, uint64(len(dst))+uint64(len(plaintext)))
 	copy(out, plaintext)
 
 	return ret, nil
",[False]
GO-2022-0945,square,go-jose,789a4c4bd4c118f7564954f441b29c153ccd6a96," func (ctx *cbcAEAD) Open(dst, nonce, ciphertext, data []byte) ([]byte, error) {
 
 // Compute an authentication tag
 func (ctx *cbcAEAD) computeAuthTag(aad, nonce, ciphertext []byte) []byte {
-	buffer := make([]byte, len(aad)+len(nonce)+len(ciphertext)+8)
+	buffer := make([]byte, uint64(len(aad))+uint64(len(nonce))+uint64(len(ciphertext))+8)
 	n := 0
 	n += copy(buffer, aad)
 	n += copy(buffer[n:], nonce)
 	n += copy(buffer[n:], ciphertext)
-	binary.BigEndian.PutUint64(buffer[n:], uint64(len(aad)*8))
+	binary.BigEndian.PutUint64(buffer[n:], uint64(len(aad))*8)
 
 	// According to documentation, Write() on hash.Hash never fails.
 	hmac := hmac.New(ctx.hash, ctx.integrityKey)
",[True]
GO-2022-0945,square,go-jose,789a4c4bd4c118f7564954f441b29c153ccd6a96," func (ctx *cbcAEAD) computeAuthTag(aad, nonce, ciphertext []byte) []byte {
 // resize ensures the the given slice has a capacity of at least n bytes.
 // If the capacity of the slice is less than n, a new slice is allocated
 // and the existing data will be copied.
-func resize(in []byte, n int) (head, tail []byte) {
-	if cap(in) >= n {
+func resize(in []byte, n uint64) (head, tail []byte) {
+	if uint64(cap(in)) >= n {
 		head = in[:n]
 	} else {
 		head = make([]byte, n)
",[True]
GO-2022-0945,square,go-jose,789a4c4bd4c118f7564954f441b29c153ccd6a96," func resize(in []byte, n int) (head, tail []byte) {
 // Apply padding
 func padBuffer(buffer []byte, blockSize int) []byte {
 	missing := blockSize - (len(buffer) % blockSize)
-	ret, out := resize(buffer, len(buffer)+missing)
+	ret, out := resize(buffer, uint64(len(buffer))+uint64(missing))
 	padding := bytes.Repeat([]byte{byte(missing)}, missing)
 	copy(out, padding)
 	return ret
",[True]
GO-2022-0945,square,go-jose,789a4c4bd4c118f7564954f441b29c153ccd6a96," type concatKDF struct {
 
 // NewConcatKDF builds a KDF reader based on the given inputs.
 func NewConcatKDF(hash crypto.Hash, z, algID, ptyUInfo, ptyVInfo, supPubInfo, supPrivInfo []byte) io.Reader {
-	buffer := make([]byte, len(algID)+len(ptyUInfo)+len(ptyVInfo)+len(supPubInfo)+len(supPrivInfo))
+	buffer := make([]byte, uint64(len(algID))+uint64(len(ptyUInfo))+uint64(len(ptyVInfo))+uint64(len(supPubInfo))+uint64(len(supPrivInfo)))
 	n := 0
 	n += copy(buffer, algID)
 	n += copy(buffer[n:], ptyUInfo)
",[True]
GO-2022-0945,square,go-jose,789a4c4bd4c118f7564954f441b29c153ccd6a96," import (
 
 // DeriveECDHES derives a shared encryption key using ECDH/ConcatKDF as described in JWE/JWA.
 // It is an error to call this function with a private/public key that are not on the same
-// curve. Callers must ensure that the keys are valid before calling this function.
+// curve. Callers must ensure that the keys are valid before calling this function. Output
+// size may be at most 1<<16 bytes (64 KiB).
 func DeriveECDHES(alg string, apuData, apvData []byte, priv *ecdsa.PrivateKey, pub *ecdsa.PublicKey, size int) []byte {
+	if size > 1<<16 {
+		panic(""ECDH-ES output size too large, must be less than 1<<16"")
+	}
+
 	// algId, partyUInfo, partyVInfo inputs must be prefixed with the length
 	algID := lengthPrefixed([]byte(alg))
 	ptyUInfo := lengthPrefixed(apuData)
",[True]
GO-2022-0945,square,go-jose,c7581939a3656bb65e89d64da0a52364a33d2507," func (ctx ecDecrypterSigner) decryptKey(headers rawHeader, recipient *recipientI
 		return nil, errors.New(""square/go-jose: invalid epk header"")
 	}
 
+	if !ctx.privateKey.Curve.IsOnCurve(publicKey.X, publicKey.Y) {
+		return nil, errors.New(""square/go-jose: invalid public key in epk header"")
+	}
+
 	apuData := headers.Apu.bytes()
 	apvData := headers.Apv.bytes()
 
",[True]
GO-2022-0945,square,go-jose,c7581939a3656bb65e89d64da0a52364a33d2507," func DeriveECDHES(alg string, apuData, apvData []byte, priv *ecdsa.PrivateKey, p
 	supPubInfo := make([]byte, 4)
 	binary.BigEndian.PutUint32(supPubInfo, uint32(size)*8)
 
+	if !priv.PublicKey.Curve.IsOnCurve(pub.X, pub.Y) {
+		panic(""public key not on same curve as private key"")
+	}
+
 	z, _ := priv.PublicKey.Curve.ScalarMult(pub.X, pub.Y, priv.D.Bytes())
 	reader := NewConcatKDF(crypto.SHA256, z.Bytes(), algID, ptyUInfo, ptyVInfo, supPubInfo, []byte{})
 
",[True]
GO-2022-0945,square,go-jose,c7581939a3656bb65e89d64da0a52364a33d2507," func (key rawJsonWebKey) ecPublicKey() (*ecdsa.PublicKey, error) {
 	}
 
 	if key.X == nil || key.Y == nil {
-		return nil, fmt.Errorf(""square/go-jose: invalid EC key, missing x/y values"")
+		return nil, errors.New(""square/go-jose: invalid EC key, missing x/y values"")
+	}
+
+	x := key.X.bigInt()
+	y := key.Y.bigInt()
+
+	if !curve.IsOnCurve(x, y) {
+		return nil, errors.New(""square/go-jose: invalid EC key, X/Y are not on declared curve"")
 	}
 
 	return &ecdsa.PublicKey{
 		Curve: curve,
-		X:     key.X.bigInt(),
-		Y:     key.Y.bigInt(),
+		X:     x,
+		Y:     y,
 	}, nil
 }
 
",[True]
GO-2020-0009,square,go-jose,789a4c4bd4c118f7564954f441b29c153ccd6a96," func (ctx *cbcAEAD) Overhead() int {
 // Seal encrypts and authenticates the plaintext.
 func (ctx *cbcAEAD) Seal(dst, nonce, plaintext, data []byte) []byte {
 	// Output buffer -- must take care not to mangle plaintext input.
-	ciphertext := make([]byte, len(plaintext)+ctx.Overhead())[:len(plaintext)]
+	ciphertext := make([]byte, uint64(len(plaintext))+uint64(ctx.Overhead()))[:len(plaintext)]
 	copy(ciphertext, plaintext)
 	ciphertext = padBuffer(ciphertext, ctx.blockCipher.BlockSize())
 
",[False]
GO-2020-0009,square,go-jose,789a4c4bd4c118f7564954f441b29c153ccd6a96," func (ctx *cbcAEAD) Seal(dst, nonce, plaintext, data []byte) []byte {
 	cbc.CryptBlocks(ciphertext, ciphertext)
 	authtag := ctx.computeAuthTag(data, nonce, ciphertext)
 
-	ret, out := resize(dst, len(dst)+len(ciphertext)+len(authtag))
+	ret, out := resize(dst, uint64(len(dst))+uint64(len(ciphertext))+uint64(len(authtag)))
 	copy(out, ciphertext)
 	copy(out[len(ciphertext):], authtag)
 
",[False]
GO-2020-0009,square,go-jose,789a4c4bd4c118f7564954f441b29c153ccd6a96," func (ctx *cbcAEAD) Open(dst, nonce, ciphertext, data []byte) ([]byte, error) {
 		return nil, err
 	}
 
-	ret, out := resize(dst, len(dst)+len(plaintext))
+	ret, out := resize(dst, uint64(len(dst))+uint64(len(plaintext)))
 	copy(out, plaintext)
 
 	return ret, nil
",[False]
GO-2020-0009,square,go-jose,789a4c4bd4c118f7564954f441b29c153ccd6a96," func (ctx *cbcAEAD) Open(dst, nonce, ciphertext, data []byte) ([]byte, error) {
 
 // Compute an authentication tag
 func (ctx *cbcAEAD) computeAuthTag(aad, nonce, ciphertext []byte) []byte {
-	buffer := make([]byte, len(aad)+len(nonce)+len(ciphertext)+8)
+	buffer := make([]byte, uint64(len(aad))+uint64(len(nonce))+uint64(len(ciphertext))+8)
 	n := 0
 	n += copy(buffer, aad)
 	n += copy(buffer[n:], nonce)
 	n += copy(buffer[n:], ciphertext)
-	binary.BigEndian.PutUint64(buffer[n:], uint64(len(aad)*8))
+	binary.BigEndian.PutUint64(buffer[n:], uint64(len(aad))*8)
 
 	// According to documentation, Write() on hash.Hash never fails.
 	hmac := hmac.New(ctx.hash, ctx.integrityKey)
",[True]
GO-2020-0009,square,go-jose,789a4c4bd4c118f7564954f441b29c153ccd6a96," func (ctx *cbcAEAD) computeAuthTag(aad, nonce, ciphertext []byte) []byte {
 // resize ensures the the given slice has a capacity of at least n bytes.
 // If the capacity of the slice is less than n, a new slice is allocated
 // and the existing data will be copied.
-func resize(in []byte, n int) (head, tail []byte) {
-	if cap(in) >= n {
+func resize(in []byte, n uint64) (head, tail []byte) {
+	if uint64(cap(in)) >= n {
 		head = in[:n]
 	} else {
 		head = make([]byte, n)
",[False]
GO-2020-0009,square,go-jose,789a4c4bd4c118f7564954f441b29c153ccd6a96," func resize(in []byte, n int) (head, tail []byte) {
 // Apply padding
 func padBuffer(buffer []byte, blockSize int) []byte {
 	missing := blockSize - (len(buffer) % blockSize)
-	ret, out := resize(buffer, len(buffer)+missing)
+	ret, out := resize(buffer, uint64(len(buffer))+uint64(missing))
 	padding := bytes.Repeat([]byte{byte(missing)}, missing)
 	copy(out, padding)
 	return ret
",[False]
GO-2020-0009,square,go-jose,789a4c4bd4c118f7564954f441b29c153ccd6a96," type concatKDF struct {
 
 // NewConcatKDF builds a KDF reader based on the given inputs.
 func NewConcatKDF(hash crypto.Hash, z, algID, ptyUInfo, ptyVInfo, supPubInfo, supPrivInfo []byte) io.Reader {
-	buffer := make([]byte, len(algID)+len(ptyUInfo)+len(ptyVInfo)+len(supPubInfo)+len(supPrivInfo))
+	buffer := make([]byte, uint64(len(algID))+uint64(len(ptyUInfo))+uint64(len(ptyVInfo))+uint64(len(supPubInfo))+uint64(len(supPrivInfo)))
 	n := 0
 	n += copy(buffer, algID)
 	n += copy(buffer[n:], ptyUInfo)
",[False]
GO-2020-0009,square,go-jose,789a4c4bd4c118f7564954f441b29c153ccd6a96," import (
 
 // DeriveECDHES derives a shared encryption key using ECDH/ConcatKDF as described in JWE/JWA.
 // It is an error to call this function with a private/public key that are not on the same
-// curve. Callers must ensure that the keys are valid before calling this function.
+// curve. Callers must ensure that the keys are valid before calling this function. Output
+// size may be at most 1<<16 bytes (64 KiB).
 func DeriveECDHES(alg string, apuData, apvData []byte, priv *ecdsa.PrivateKey, pub *ecdsa.PublicKey, size int) []byte {
+	if size > 1<<16 {
+		panic(""ECDH-ES output size too large, must be less than 1<<16"")
+	}
+
 	// algId, partyUInfo, partyVInfo inputs must be prefixed with the length
 	algID := lengthPrefixed([]byte(alg))
 	ptyUInfo := lengthPrefixed(apuData)
",[False]
GO-2020-0010,square,go-jose,c7581939a3656bb65e89d64da0a52364a33d2507," func (ctx ecDecrypterSigner) decryptKey(headers rawHeader, recipient *recipientI
 		return nil, errors.New(""square/go-jose: invalid epk header"")
 	}
 
+	if !ctx.privateKey.Curve.IsOnCurve(publicKey.X, publicKey.Y) {
+		return nil, errors.New(""square/go-jose: invalid public key in epk header"")
+	}
+
 	apuData := headers.Apu.bytes()
 	apvData := headers.Apv.bytes()
 
",[True]
GO-2020-0010,square,go-jose,c7581939a3656bb65e89d64da0a52364a33d2507," func DeriveECDHES(alg string, apuData, apvData []byte, priv *ecdsa.PrivateKey, p
 	supPubInfo := make([]byte, 4)
 	binary.BigEndian.PutUint32(supPubInfo, uint32(size)*8)
 
+	if !priv.PublicKey.Curve.IsOnCurve(pub.X, pub.Y) {
+		panic(""public key not on same curve as private key"")
+	}
+
 	z, _ := priv.PublicKey.Curve.ScalarMult(pub.X, pub.Y, priv.D.Bytes())
 	reader := NewConcatKDF(crypto.SHA256, z.Bytes(), algID, ptyUInfo, ptyVInfo, supPubInfo, []byte{})
 
",[True]
GO-2020-0010,square,go-jose,c7581939a3656bb65e89d64da0a52364a33d2507," func (key rawJsonWebKey) ecPublicKey() (*ecdsa.PublicKey, error) {
 	}
 
 	if key.X == nil || key.Y == nil {
-		return nil, fmt.Errorf(""square/go-jose: invalid EC key, missing x/y values"")
+		return nil, errors.New(""square/go-jose: invalid EC key, missing x/y values"")
+	}
+
+	x := key.X.bigInt()
+	y := key.Y.bigInt()
+
+	if !curve.IsOnCurve(x, y) {
+		return nil, errors.New(""square/go-jose: invalid EC key, X/Y are not on declared curve"")
 	}
 
 	return &ecdsa.PublicKey{
 		Curve: curve,
-		X:     key.X.bigInt(),
-		Y:     key.Y.bigInt(),
+		X:     x,
+		Y:     y,
 	}, nil
 }
 
",[True]
GO-2023-1664,crewjam,saml,8e9236867d176ad6338c870a84e2039aef8a5021," func NewIdpAuthnRequest(idp *IdentityProvider, r *http.Request) (*IdpAuthnReques
 		if err != nil {
 			return nil, fmt.Errorf(""cannot decode request: %s"", err)
 		}
-		req.RequestBuffer, err = ioutil.ReadAll(flate.NewReader(bytes.NewReader(compressedRequest)))
+		req.RequestBuffer, err = ioutil.ReadAll(newSaferFlateReader(bytes.NewReader(compressedRequest)))
 		if err != nil {
 			return nil, fmt.Errorf(""cannot decompress request: %s"", err)
 		}
",[True]
GO-2023-1664,crewjam,saml,8e9236867d176ad6338c870a84e2039aef8a5021," func (sp *ServiceProvider) ValidateLogoutResponseRedirect(queryParameterData str
 	}
 	retErr.Response = string(rawResponseBuf)
 
-	gr, err := ioutil.ReadAll(flate.NewReader(bytes.NewBuffer(rawResponseBuf)))
+	gr, err := ioutil.ReadAll(newSaferFlateReader(bytes.NewBuffer(rawResponseBuf)))
 	if err != nil {
 		retErr.PrivateErr = err
 		return retErr
",[True]
GO-2022-0572,beego,beego,d5df5e470d0a8ed291930ae802fd7e6b95226519," func (t *Tree) match(treePattern string, pattern string, wildcardValues []string
 	if runObject == nil && len(t.fixrouters) > 0 {
 		// Filter the .json .xml .html extension
 		for _, str := range allowSuffixExt {
-			if strings.HasSuffix(seg, str) {
+			if strings.HasSuffix(seg, str) && strings.HasSuffix(treePattern, seg){
 				for _, subTree := range t.fixrouters {
+					// strings.HasSuffix(treePattern, seg) avoid cases: /aaa.html/bbb could access /aaa/bbb
 					if subTree.prefix == seg[:len(seg)-len(str)] {
 						runObject = subTree.match(treePattern, pattern, wildcardValues, ctx)
 						if runObject != nil {
",[False]
GO-2023-2119,Consensys,gnark,3421eaa7d544286abf3de8c46282b8d4da6d5da0," func (s *instance) batchOpening() error {
 		s.zeta,
 		s.hFunc,
 		s.pk.Kzg,
+		s.proof.ZShiftedOpening.ClaimedValue.Marshal(),
 	)
 
 	return err
",[False]
GO-2023-2119,Consensys,gnark,3421eaa7d544286abf3de8c46282b8d4da6d5da0," func Verify(proof *Proof, vk *VerifyingKey, publicWitness fr.Vector) error {
 		&proof.BatchedProof,
 		zeta,
 		hFunc,
+		zu.Marshal(),
 	)
 	if err != nil {
 		return err
",[True]
GO-2022-0762,microcosm-cc,bluemonday,524f142fe46e945b7dcd291d7805c4b7dcf75bee," func (p *Policy) sanitize(r io.Reader) *bytes.Buffer {
 
 		case html.StartTagToken:
 
-			mostRecentlyStartedToken = strings.ToLower(token.Data)
+			mostRecentlyStartedToken = normaliseElementName(token.Data)
 
 			aps, ok := p.elsAndAttrs[token.Data]
 			if !ok {
",[True]
GO-2022-0762,microcosm-cc,bluemonday,524f142fe46e945b7dcd291d7805c4b7dcf75bee," func (p *Policy) sanitize(r io.Reader) *bytes.Buffer {
 
 		case html.EndTagToken:
 
-			if mostRecentlyStartedToken == strings.ToLower(token.Data) {
+			if mostRecentlyStartedToken == normaliseElementName(token.Data) {
 				mostRecentlyStartedToken = """"
 			}
 
",[True]
GO-2022-0762,microcosm-cc,bluemonday,524f142fe46e945b7dcd291d7805c4b7dcf75bee," func (p *Policy) sanitize(r io.Reader) *bytes.Buffer {
 
 			if !skipElementContent {
 				switch mostRecentlyStartedToken {
-				case ""script"":
+				case `script`:
 					// not encouraged, but if a policy allows JavaScript we
 					// should not HTML escape it as that would break the output
 					buff.WriteString(token.Data)
-				case ""style"":
+				case `style`:
 					// not encouraged, but if a policy allows CSS styles we
 					// should not HTML escape it as that would break the output
 					buff.WriteString(token.Data)
",[True]
GO-2022-0762,microcosm-cc,bluemonday,524f142fe46e945b7dcd291d7805c4b7dcf75bee," func (p *Policy) matchRegex(elementName string) (map[string]attrPolicy, bool) {
 	}
 	return aps, matched
 }
+
+
+// normaliseElementName takes a HTML element like <script> which is user input
+// and returns a lower case version of it that is immune to UTF-8 to ASCII
+// conversion tricks (like the use of upper case cyrillic i scrİpt which a
+// strings.ToLower would convert to script). Instead this func will preserve
+// all non-ASCII as their escaped equivalent, i.e. \u0130 which reveals the
+// characters when lower cased
+func normaliseElementName(str string) string {
+	// that useful QuoteToASCII put quote marks at the start and end
+	// so those are trimmed off
+	return strings.TrimSuffix(
+		strings.TrimPrefix(
+			strings.ToLower(
+				strconv.QuoteToASCII(str),
+			),
+			`""`),
+		`""`,
+	)
+}
\ No newline at end of file
",[False]
GO-2022-0355,valyala,fasthttp,6b5bc7bb304975147b4af68df54ac214ed2554c1," func normalizePath(dst, src []byte) []byte {
 		b = b[:nn+1]
 	}
 
+	if filepath.Separator == '\\' {
+		// remove \.\ parts
+		b = dst
+		for {
+			n := bytes.Index(b, strBackSlashDotBackSlash)
+			if n < 0 {
+				break
+			}
+			nn := n + len(strSlashDotSlash) - 1
+			copy(b[n:], b[nn:])
+			b = b[:len(b)-nn+n]
+		}
+
+		// remove /foo/..\ parts
+		for {
+			n := bytes.Index(b, strSlashDotDotBackSlash)
+			if n < 0 {
+				break
+			}
+			nn := bytes.LastIndexByte(b[:n], '/')
+			if nn < 0 {
+				nn = 0
+			}
+			n += len(strSlashDotDotBackSlash) - 1
+			copy(b[nn:], b[n:])
+			b = b[:len(b)-n+nn]
+		}
+
+		// remove /foo\..\ parts
+		for {
+			n := bytes.Index(b, strBackSlashDotDotBackSlash)
+			if n < 0 {
+				break
+			}
+			nn := bytes.LastIndexByte(b[:n], '/')
+			if nn < 0 {
+				nn = 0
+			}
+			n += len(strBackSlashDotDotBackSlash) - 1
+			copy(b[nn:], b[n:])
+			b = b[:len(b)-n+nn]
+		}
+
+		// remove trailing \foo\..
+		n := bytes.LastIndex(b, strBackSlashDotDot)
+		if n >= 0 && n+len(strSlashDotDot) == len(b) {
+			nn := bytes.LastIndexByte(b[:n], '/')
+			if nn < 0 {
+				return append(dst[:0], strSlash...)
+			}
+			b = b[:nn+1]
+		}
+	}
+
 	return b
 }
 
",[False]
GO-2022-0957,tidwall,match,c2f534168b739a7ec1821a33839fb2f029f26bbc," func deepMatch(str, pattern string) bool {
 }
 
 func deepMatchRune(str, pattern string) bool {
+	if pattern == ""*"" {
+		return true
+	}
+	for len(pattern) > 1 && pattern[0] == '*' && pattern[1] == '*' {
+		pattern = pattern[1:]
+	}
+
 	var sr, pr rune
 	var srsz, prsz int
 
",[False]
GO-2022-0274,opencontainers,runc,f50369af4b571e358f20b139eea52d612eb55eed," func encodeIDMapping(idMap []configs.IDMap) ([]byte, error) {
 	return data.Bytes(), nil
 }
 
+// netlinkError is an error wrapper type for use by custom netlink message
+// types. Panics with errors are wrapped in netlinkError so that the recover
+// in bootstrapData can distinguish intentional panics.
+type netlinkError struct{ error }
+
 // bootstrapData encodes the necessary data in netlink binary format
 // as a io.Reader.
 // Consumer can write the data to a bootstrap program
 // such as one that uses nsenter package to bootstrap the container's
 // init process correctly, i.e. with correct namespaces, uid/gid
 // mapping etc.
-func (c *linuxContainer) bootstrapData(cloneFlags uintptr, nsMaps map[configs.NamespaceType]string, it initType) (io.Reader, error) {
+func (c *linuxContainer) bootstrapData(cloneFlags uintptr, nsMaps map[configs.NamespaceType]string, it initType) (_ io.Reader, Err error) {
 	// create the netlink message
 	r := nl.NewNetlinkRequest(int(InitMsg), 0)
 
+	// Our custom messages cannot bubble up an error using returns, instead
+	// they will panic with the specific error type, netlinkError. In that
+	// case, recover from the panic and return that as an error.
+	defer func() {
+		if r := recover(); r != nil {
+			if e, ok := r.(netlinkError); ok {
+				Err = e.error
+			} else {
+				panic(r)
+			}
+		}
+	}()
+
 	// write cloneFlags
 	r.AddData(&Int32msg{
 		Type:  CloneFlagsAttr,
",[False]
GO-2022-0274,opencontainers,runc,f50369af4b571e358f20b139eea52d612eb55eed," type Bytemsg struct {
 
 func (msg *Bytemsg) Serialize() []byte {
 	l := msg.Len()
+	if l > math.MaxUint16 {
+		// We cannot return nil nor an error here, so we panic with
+		// a specific type instead, which is handled via recover in
+		// bootstrapData.
+		panic(netlinkError{fmt.Errorf(""netlink: cannot serialize bytemsg of length %d (larger than UINT16_MAX)"", l)})
+	}
 	buf := make([]byte, (l+unix.NLA_ALIGNTO-1) & ^(unix.NLA_ALIGNTO-1))
 	native := nl.NativeEndian()
 	native.PutUint16(buf[0:2], uint16(l))
",[True]
GO-2022-0274,opencontainers,runc,dde509df4e28cec33b3c99c6cda3d4fd5beafc77," func (c *linuxContainer) bootstrapData(cloneFlags uintptr, nsMaps map[configs.Na
 		var mounts []byte
 		for _, m := range c.config.Mounts {
 			if m.IsBind() {
+				if strings.IndexByte(m.Source, 0) >= 0 {
+					return nil, fmt.Errorf(""mount source string contains null byte: %q"", m.Source)
+				}
 				mounts = append(mounts, []byte(m.Source)...)
 			}
 			mounts = append(mounts, byte(0))
",[False]
GO-2022-0274,opencontainers,runc,dde509df4e28cec33b3c99c6cda3d4fd5beafc77," func createLibcontainerMount(cwd string, m specs.Mount) (*configs.Mount, error)
 			mnt.Source = filepath.Join(cwd, m.Source)
 		}
 	}
+
+	// None of the mount arguments can contain a null byte. Normally such
+	// strings would either cause some other failure or would just be truncated
+	// when we hit the null byte, but because we serialise these strings as
+	// netlink messages (which don't have special null-byte handling) we need
+	// to block this as early as possible.
+	if strings.IndexByte(mnt.Source, 0) >= 0 ||
+		strings.IndexByte(mnt.Destination, 0) >= 0 ||
+		strings.IndexByte(mnt.Device, 0) >= 0 {
+		return nil, errors.New(""mount field contains null byte"")
+	}
+
 	return mnt, nil
 }
 
",[False]
GO-2021-0106,whyrusleeping,tar-utils,20a61371de5b51380bbdb0c7935b30b0625ac227," func (te *Extractor) Sanitize(toggle bool) {
 
 // outputPath returns the path at which to place tarPath
 func (te *Extractor) outputPath(tarPath string) (outPath string, err error) {
-	elems := strings.Split(tarPath, ""/"")    // break into elems
+	elems := strings.Split(tarPath, ""/"") // break into elems
+	for _, e := range elems {
+		if e == "".."" {
+			return """", fmt.Errorf(""%s : path contains '..'"", tarPath)
+		}
+	}
 	elems = elems[1:]                       // remove original root
 	outPath = strings.Join(elems, ""/"")      // join elems
 	outPath = gopath.Join(te.Path, outPath) // rebase on to extraction target root
",[True]
GO-2022-0574,open-policy-agent,opa,064f6168a8dfebdeb2ea147f7882bb9f5d2b7f67," func rewriteDeclaredVarsInTerm(g *localVarGenerator, stack *localDeclaredVars, t
 			return true, errs
 		}
 		return false, errs
+	case Call:
+		ref := v[0]
+		WalkVars(ref, func(v Var) bool {
+			if gv, ok := stack.Declared(v); ok && !gv.Equal(v) {
+				// We will rewrite the ref of a function call, which is never ok since we don't have first-class functions.
+				errs = append(errs, NewError(CompileErr, term.Location, ""called function %s shadowed"", ref))
+				return true
+			}
+			return false
+		})
+		return false, errs
 	case *object:
 		cpy, _ := v.Map(func(k, v *Term) (*Term, *Term, error) {
 			kcpy := k.Copy()
",[True]
GO-2020-0008,miekg,dns,8ebf2e419df7857ac8919baa05248789a8ffbf33," var (
 	ErrTime          error = &Error{err: ""bad time""}      // ErrTime indicates a timing error in TSIG authentication.
 )
 
-// Id by default, returns a 16 bits random number to be used as a
-// message id. The random provided should be good enough. This being a
-// variable the function can be reassigned to a custom function.
-// For instance, to make it return a static value:
+// Id by default returns a 16-bit random number to be used as a message id. The
+// number is drawn from a cryptographically secure random number generator.
+// This being a variable the function can be reassigned to a custom function.
+// For instance, to make it return a static value for testing:
 //
 //	dns.Id = func() uint16 { return 3 }
 var Id = id
 
-var (
-	idLock sync.Mutex
-	idRand *rand.Rand
-)
-
 // id returns a 16 bits random number to be used as a
 // message id. The random provided should be good enough.
 func id() uint16 {
-	idLock.Lock()
-
-	if idRand == nil {
-		// This (partially) works around
-		// https://github.com/golang/go/issues/11833 by only
-		// seeding idRand upon the first call to id.
-
-		var seed int64
-		var buf [8]byte
-
-		if _, err := crand.Read(buf[:]); err == nil {
-			seed = int64(binary.LittleEndian.Uint64(buf[:]))
-		} else {
-			seed = rand.Int63()
-		}
-
-		idRand = rand.New(rand.NewSource(seed))
+	var output uint16
+	err := binary.Read(rand.Reader, binary.BigEndian, &output)
+	if err != nil {
+		panic(""dns: reading random id failed: "" + err.Error())
 	}
-
-	// The call to idRand.Uint32 must be within the
-	// mutex lock because *rand.Rand is not safe for
-	// concurrent use.
-	//
-	// There is no added performance overhead to calling
-	// idRand.Uint32 inside a mutex lock over just
-	// calling rand.Uint32 as the global math/rand rng
-	// is internally protected by a sync.Mutex.
-	id := uint16(idRand.Uint32())
-
-	idLock.Unlock()
-	return id
+	return output
 }
 
 // MsgHdr is a a manually-unpacked version of (id, bits).
",[True]
GO-2022-1045,sylabs,sif,07fb86029a12e3210f6131e065570124605daeaa," func verifyAndDecode(data []byte, kr openpgp.KeyRing) (*openpgp.Entity, []byte,
 	}
 
 	// Check signature.
-	e, err := openpgp.CheckDetachedSignature(kr, bytes.NewReader(b.Bytes), b.ArmoredSignature.Body, nil)
+	e, err := openpgp.CheckDetachedSignatureAndHash(
+		kr,
+		bytes.NewReader(b.Bytes),
+		b.ArmoredSignature.Body,
+		supportedPGPAlgorithms,
+		nil,
+	)
 	return e, b.Plaintext, rest, err
 }
 
",[True]
GO-2022-1045,sylabs,sif,07fb86029a12e3210f6131e065570124605daeaa," type digest struct {
 // newDigest returns a new digest. If h is not supported, errHashUnsupported is returned. If digest
 // is malformed, errDigestMalformed is returned.
 func newDigest(h crypto.Hash, value []byte) (digest, error) {
-	if _, ok := supportedAlgorithms[h]; !ok {
+	if _, ok := supportedDigestAlgorithms[h]; !ok {
 		return digest{}, errHashUnsupported
 	}
 
",[True]
GO-2022-1045,sylabs,sif,07fb86029a12e3210f6131e065570124605daeaa," func (d digest) matches(r io.Reader) (bool, error) {
 
 // MarshalJSON marshals d into string of format ""alg:value"".
 func (d digest) MarshalJSON() ([]byte, error) {
-	n, ok := supportedAlgorithms[d.hash]
+	n, ok := supportedDigestAlgorithms[d.hash]
 	if !ok {
 		return nil, errHashUnsupported
 	}
",[True]
GO-2022-1045,sylabs,sif,07fb86029a12e3210f6131e065570124605daeaa," func (d *digest) UnmarshalJSON(data []byte) error {
 		return fmt.Errorf(""%w: %v"", errDigestMalformed, err)
 	}
 
-	for h, n := range supportedAlgorithms {
+	for h, n := range supportedDigestAlgorithms {
 		if n == name {
 			digest, err := newDigest(h, v)
 			if err != nil {
",[False]
GO-2022-1130,prometheus,exporter-toolkit,5b1eab34484ddd353986bce736cd119d863e4ff5," func (u *webHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
 			hashedPassword = ""$2y$10$QOauhQNbBCuQDKes6eFzPeMqBSjb7Mr5DUmpZ/VcEd00UAV/LDeSi""
 		}
 
-		cacheKey := hex.EncodeToString(append(append([]byte(user), []byte(hashedPassword)...), []byte(pass)...))
+		cacheKey := strings.Join(
+			[]string{
+				hex.EncodeToString([]byte(user)),
+				hex.EncodeToString([]byte(hashedPassword)),
+				hex.EncodeToString([]byte(pass)),
+			}, "":"")
 		authOk, ok := u.cache.get(cacheKey)
 
 		if !ok {
",[True]
GO-2022-1130,prometheus,exporter-toolkit,5b1eab34484ddd353986bce736cd119d863e4ff5," func (u *webHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
 			err := bcrypt.CompareHashAndPassword([]byte(hashedPassword), []byte(pass))
 			u.bcryptMtx.Unlock()
 
-			authOk = err == nil
+			authOk = validUser && err == nil
 			u.cache.set(cacheKey, authOk)
 		}
 
",[True]
GO-2023-1717,vitessio,vitess,adf10196760ad0b3991a7aa7a8580a544e6ddf88," func (ki *KeyspaceInfo) SetKeyspaceName(name string) {
 	ki.keyspace = name
 }
 
+var invalidKeyspaceNameChars = ""/""
+
+// ValidateKeyspaceName checks if the provided name is a valid name for a
+// keyspace.
+//
+// As of v16.0.1, ""all invalid characters"" is just the forward slash (""/"").
+func ValidateKeyspaceName(name string) error {
+	if strings.ContainsAny(name, invalidKeyspaceNameChars) {
+		return vterrors.Errorf(vtrpcpb.Code_INVALID_ARGUMENT, ""keyspace name %s contains invalid characters; may not contain any of the following: %+v"", name, strings.Split(invalidKeyspaceNameChars, """"))
+	}
+
+	return nil
+}
+
 // GetServedFrom returns a Keyspace_ServedFrom record if it exists.
 func (ki *KeyspaceInfo) GetServedFrom(tabletType topodatapb.TabletType) *topodatapb.Keyspace_ServedFrom {
 	for _, ksf := range ki.ServedFroms {
",[False]
GO-2023-1717,vitessio,vitess,adf10196760ad0b3991a7aa7a8580a544e6ddf88," func (ki *KeyspaceInfo) ComputeCellServedFrom(cell string) []*topodatapb.SrvKeys
 // CreateKeyspace wraps the underlying Conn.Create
 // and dispatches the event.
 func (ts *Server) CreateKeyspace(ctx context.Context, keyspace string, value *topodatapb.Keyspace) error {
+	if err := ValidateKeyspaceName(keyspace); err != nil {
+		return vterrors.Wrapf(err, ""CreateKeyspace: %s"", err)
+	}
+
 	data, err := proto.Marshal(value)
 	if err != nil {
 		return err
",[True]
GO-2023-1717,vitessio,vitess,adf10196760ad0b3991a7aa7a8580a544e6ddf88," func (ts *Server) CreateKeyspace(ctx context.Context, keyspace string, value *to
 
 // GetKeyspace reads the given keyspace and returns it
 func (ts *Server) GetKeyspace(ctx context.Context, keyspace string) (*KeyspaceInfo, error) {
+	if err := ValidateKeyspaceName(keyspace); err != nil {
+		return nil, vterrors.Wrapf(err, ""GetKeyspace: %s"", err)
+	}
+
 	keyspacePath := path.Join(KeyspacesPath, keyspace, KeyspaceFile)
 	data, version, err := ts.globalCell.Get(ctx, keyspacePath)
 	if err != nil {
",[True]
GO-2023-1717,vitessio,vitess,adf10196760ad0b3991a7aa7a8580a544e6ddf88," var ErrKeyspaceNotFound = errors.New(""keyspace not found"")
 
 // ReadKeyspace reads the vitess keyspace record.
 func ReadKeyspace(keyspaceName string) (*topo.KeyspaceInfo, error) {
+	if err := topo.ValidateKeyspaceName(keyspaceName); err != nil {
+		return nil, err
+	}
+
 	query := `
 		select
 			keyspace_type,
",[True]
GO-2023-1574,containerd,containerd,133f6bb6cd827ce35a5fb279c1ead12b9d21460a," func setCapabilities(s *Spec) {
 	}
 }
 
+// ensureAdditionalGids ensures that the primary GID is also included in the additional GID list.
+func ensureAdditionalGids(s *Spec) {
+	setProcess(s)
+	for _, f := range s.Process.User.AdditionalGids {
+		if f == s.Process.User.GID {
+			return
+		}
+	}
+	s.Process.User.AdditionalGids = append([]uint32{s.Process.User.GID}, s.Process.User.AdditionalGids...)
+}
+
 // WithDefaultSpec returns a SpecOpts that will populate the spec with default
 // values.
 //
",[False]
GO-2023-1574,containerd,containerd,133f6bb6cd827ce35a5fb279c1ead12b9d21460a," func WithNamespacedCgroup() SpecOpts {
 //	user, uid, user:group, uid:gid, uid:group, user:gid
 func WithUser(userstr string) SpecOpts {
 	return func(ctx context.Context, client Client, c *containers.Container, s *Spec) error {
+		defer ensureAdditionalGids(s)
 		setProcess(s)
+		s.Process.User.AdditionalGids = nil
 
 		// For LCOW it's a bit harder to confirm that the user actually exists on the host as a rootfs isn't
 		// mounted on the host and shared into the guest, but rather the rootfs is constructed entirely in the
",[True]
GO-2023-1574,containerd,containerd,133f6bb6cd827ce35a5fb279c1ead12b9d21460a," func WithUser(userstr string) SpecOpts {
 // WithUIDGID allows the UID and GID for the Process to be set
 func WithUIDGID(uid, gid uint32) SpecOpts {
 	return func(_ context.Context, _ Client, _ *containers.Container, s *Spec) error {
+		defer ensureAdditionalGids(s)
 		setProcess(s)
+		s.Process.User.AdditionalGids = nil
 		s.Process.User.UID = uid
 		s.Process.User.GID = gid
 		return nil
",[True]
GO-2023-1574,containerd,containerd,133f6bb6cd827ce35a5fb279c1ead12b9d21460a," func WithUIDGID(uid, gid uint32) SpecOpts {
 // additionally sets the gid to 0, and does not return an error.
 func WithUserID(uid uint32) SpecOpts {
 	return func(ctx context.Context, client Client, c *containers.Container, s *Spec) (err error) {
+		defer ensureAdditionalGids(s)
 		setProcess(s)
-		if c.Snapshotter == """" && c.SnapshotKey == """" {
-			if !isRootfsAbs(s.Root.Path) {
-				return errors.New(""rootfs absolute path is required"")
-			}
-			user, err := UserFromPath(s.Root.Path, func(u user.User) bool {
+		s.Process.User.AdditionalGids = nil
+		setUser := func(root string) error {
+			user, err := UserFromPath(root, func(u user.User) bool {
 				return u.Uid == int(uid)
 			})
 			if err != nil {
",[True]
GO-2023-1574,containerd,containerd,133f6bb6cd827ce35a5fb279c1ead12b9d21460a," func WithUserID(uid uint32) SpecOpts {
 			}
 			s.Process.User.UID, s.Process.User.GID = uint32(user.Uid), uint32(user.Gid)
 			return nil
-
+		}
+		if c.Snapshotter == """" && c.SnapshotKey == """" {
+			if !isRootfsAbs(s.Root.Path) {
+				return errors.New(""rootfs absolute path is required"")
+			}
+			return setUser(s.Root.Path)
 		}
 		if c.Snapshotter == """" {
 			return errors.New(""no snapshotter set for container"")
",[True]
GO-2023-1574,containerd,containerd,133f6bb6cd827ce35a5fb279c1ead12b9d21460a," func WithUserID(uid uint32) SpecOpts {
 		}
 
 		mounts = tryReadonlyMounts(mounts)
-		return mount.WithTempMount(ctx, mounts, func(root string) error {
-			user, err := UserFromPath(root, func(u user.User) bool {
-				return u.Uid == int(uid)
-			})
-			if err != nil {
-				if os.IsNotExist(err) || err == ErrNoUsersFound {
-					s.Process.User.UID, s.Process.User.GID = uid, 0
-					return nil
-				}
-				return err
-			}
-			s.Process.User.UID, s.Process.User.GID = uint32(user.Uid), uint32(user.Gid)
-			return nil
-		})
+		return mount.WithTempMount(ctx, mounts, setUser)
 	}
 }
 
",[True]
GO-2023-1574,containerd,containerd,133f6bb6cd827ce35a5fb279c1ead12b9d21460a," func WithUserID(uid uint32) SpecOpts {
 // the container.
 func WithUsername(username string) SpecOpts {
 	return func(ctx context.Context, client Client, c *containers.Container, s *Spec) (err error) {
+		defer ensureAdditionalGids(s)
 		setProcess(s)
+		s.Process.User.AdditionalGids = nil
 		if s.Linux != nil {
-			if c.Snapshotter == """" && c.SnapshotKey == """" {
-				if !isRootfsAbs(s.Root.Path) {
-					return errors.New(""rootfs absolute path is required"")
-				}
-				user, err := UserFromPath(s.Root.Path, func(u user.User) bool {
+			setUser := func(root string) error {
+				user, err := UserFromPath(root, func(u user.User) bool {
 					return u.Name == username
 				})
 				if err != nil {
",[True]
GO-2023-1574,containerd,containerd,133f6bb6cd827ce35a5fb279c1ead12b9d21460a," func WithUsername(username string) SpecOpts {
 				s.Process.User.UID, s.Process.User.GID = uint32(user.Uid), uint32(user.Gid)
 				return nil
 			}
+			if c.Snapshotter == """" && c.SnapshotKey == """" {
+				if !isRootfsAbs(s.Root.Path) {
+					return errors.New(""rootfs absolute path is required"")
+				}
+				return setUser(s.Root.Path)
+			}
 			if c.Snapshotter == """" {
 				return errors.New(""no snapshotter set for container"")
 			}
",[True]
GO-2023-1574,containerd,containerd,133f6bb6cd827ce35a5fb279c1ead12b9d21460a," func WithUsername(username string) SpecOpts {
 			}
 
 			mounts = tryReadonlyMounts(mounts)
-			return mount.WithTempMount(ctx, mounts, func(root string) error {
-				user, err := UserFromPath(root, func(u user.User) bool {
-					return u.Name == username
-				})
-				if err != nil {
-					return err
-				}
-				s.Process.User.UID, s.Process.User.GID = uint32(user.Uid), uint32(user.Gid)
-				return nil
-			})
+			return mount.WithTempMount(ctx, mounts, setUser)
 		} else if s.Windows != nil {
 			s.Process.User.Username = username
 		} else {
",[True]
GO-2023-1574,containerd,containerd,133f6bb6cd827ce35a5fb279c1ead12b9d21460a," func WithAdditionalGIDs(userstr string) SpecOpts {
 			return nil
 		}
 		setProcess(s)
+		s.Process.User.AdditionalGids = nil
 		setAdditionalGids := func(root string) error {
+			defer ensureAdditionalGids(s)
 			var username string
 			uid, err := strconv.Atoi(userstr)
 			if err == nil {
",[True]
GO-2023-1574,containerd,containerd,133f6bb6cd827ce35a5fb279c1ead12b9d21460a," func WithAdditionalGIDs(userstr string) SpecOpts {
 	}
 }
 
+// WithAppendAdditionalGroups append additional groups within the container.
+// The passed in groups can be either a gid or a groupname.
+func WithAppendAdditionalGroups(groups ...string) SpecOpts {
+	return func(ctx context.Context, client Client, c *containers.Container, s *Spec) (err error) {
+		// For LCOW or on Darwin additional GID's are not supported
+		if s.Windows != nil || runtime.GOOS == ""darwin"" {
+			return nil
+		}
+		setProcess(s)
+		setAdditionalGids := func(root string) error {
+			defer ensureAdditionalGids(s)
+			gpath, err := fs.RootPath(root, ""/etc/group"")
+			if err != nil {
+				return err
+			}
+			ugroups, err := user.ParseGroupFile(gpath)
+			if err != nil {
+				return err
+			}
+			groupMap := make(map[string]user.Group)
+			for _, group := range ugroups {
+				groupMap[group.Name] = group
+			}
+			var gids []uint32
+			for _, group := range groups {
+				gid, err := strconv.ParseUint(group, 10, 32)
+				if err == nil {
+					gids = append(gids, uint32(gid))
+				} else {
+					g, ok := groupMap[group]
+					if !ok {
+						return fmt.Errorf(""unable to find group %s"", group)
+					}
+					gids = append(gids, uint32(g.Gid))
+				}
+			}
+			s.Process.User.AdditionalGids = append(s.Process.User.AdditionalGids, gids...)
+			return nil
+		}
+		if c.Snapshotter == """" && c.SnapshotKey == """" {
+			if !filepath.IsAbs(s.Root.Path) {
+				return errors.New(""rootfs absolute path is required"")
+			}
+			return setAdditionalGids(s.Root.Path)
+		}
+		if c.Snapshotter == """" {
+			return errors.New(""no snapshotter set for container"")
+		}
+		if c.SnapshotKey == """" {
+			return errors.New(""rootfs snapshot not created for container"")
+		}
+		snapshotter := client.SnapshotService(c.Snapshotter)
+		mounts, err := snapshotter.Mounts(ctx, c.SnapshotKey)
+		if err != nil {
+			return err
+		}
+
+		mounts = tryReadonlyMounts(mounts)
+		return mount.WithTempMount(ctx, mounts, setAdditionalGids)
+	}
+}
+
 // WithCapabilities sets Linux capabilities on the process
 func WithCapabilities(caps []string) SpecOpts {
 	return func(_ context.Context, _ Client, _ *containers.Container, s *Spec) error {
",[False]
GO-2023-1574,containerd,containerd,133f6bb6cd827ce35a5fb279c1ead12b9d21460a," func (c *criService) containerSpecOpts(config *runtime.ContainerConfig, imageCon
 		// Because it is still useful to get additional gids for uid 0.
 		userstr = strconv.FormatInt(securityContext.GetRunAsUser().GetValue(), 10)
 	}
-	specOpts = append(specOpts, customopts.WithAdditionalGIDs(userstr))
+	specOpts = append(specOpts, customopts.WithAdditionalGIDs(userstr),
+		customopts.WithSupplementalGroups(securityContext.GetSupplementalGroups()))
 
 	asp := securityContext.GetApparmor()
 	if asp == nil {
",[True]
GO-2021-0103,holiman,uint256,6785da6e3eea403260a5760029e722aa4ff1716d," func (z *Int) AddOverflow(x, y *Int) bool {
 	return carry != 0
 }
 
-// AddMod sets z to the sum ( x+y ) mod m, and returns z
+// AddMod sets z to the sum ( x+y ) mod m, and returns z.
+// If m == 0, z is set to 0 (OBS: differs from the big.Int)
 func (z *Int) AddMod(x, y, m *Int) *Int {
+	if m.IsZero() {
+		return z.Clear()
+	}
 	if z == m { // z is an alias for m  // TODO: Understand why needed and add tests for all ""division"" methods.
 		m = m.Clone()
 	}
",[False]
GO-2021-0103,holiman,uint256,6785da6e3eea403260a5760029e722aa4ff1716d," func (z *Int) SMod(x, y *Int) *Int {
 }
 
 // MulMod calculates the modulo-m multiplication of x and y and
-// returns z
+// returns z.
+// If m == 0, z is set to 0 (OBS: differs from the big.Int)
 func (z *Int) MulMod(x, y, m *Int) *Int {
+	if x.IsZero() || y.IsZero() || m.IsZero() {
+		return z.Clear()
+	}
 	p := umul(x, y)
 	var (
 		pl Int
",[False]
GO-2020-0041,unknwon,cae,07971c00a1bfd9dc171c3ad0bfab5b67c2287e11," func Copy(dest, src string) error {
 	}
 	return os.Chmod(dest, si.Mode())
 }
+
+// Clean cleans up given path and returns a relative path that goes straight down.
+func Clean(p string) string {
+	return strings.Trim(path.Clean(""/""+p), ""/"")
+}
",[False]
GO-2020-0041,unknwon,cae,07971c00a1bfd9dc171c3ad0bfab5b67c2287e11," func (tz *TzArchive) syncFiles() {
 	for i, f := range tz.File {
 		tz.files[i] = &File{}
 		tz.files[i].Header = f
-		tz.files[i].Name = strings.Replace(f.Name, ""\\"", ""/"", -1)
+		tz.files[i].Name = cae.Clean(strings.ReplaceAll(f.Name, ""\\"", ""/""))
 		if f.FileInfo().IsDir() && !strings.HasSuffix(tz.files[i].Name, ""/"") {
 			tz.files[i].Name += ""/""
 		}
",[True]
GO-2020-0041,unknwon,cae,07971c00a1bfd9dc171c3ad0bfab5b67c2287e11," var defaultExtractFunc = func(fullName string, fi os.FileInfo) error {
 // specified destination.
 // It accepts a function as a middleware for custom operations.
 func (tz *TzArchive) ExtractToFunc(destPath string, fn cae.HookFunc, entries ...string) (err error) {
-	destPath = strings.Replace(destPath, ""\\"", ""/"", -1)
+	destPath = strings.ReplaceAll(destPath, ""\\"", ""/"")
 	isHasEntry := len(entries) > 0
 	if Verbose {
 		fmt.Println(""Extracting "" + tz.FileName + ""..."")
",[True]
GO-2020-0041,unknwon,cae,07971c00a1bfd9dc171c3ad0bfab5b67c2287e11," func (tz *TzArchive) ExtractToFunc(destPath string, fn cae.HookFunc, entries ...
 			return err
 		}
 
-		h.Name = strings.Replace(h.Name, ""\\"", ""/"", -1)
+		h.Name = cae.Clean(strings.ReplaceAll(h.Name, ""\\"", ""/""))
 
 		// Directory.
 		if h.Typeflag == tar.TypeDir {
",[True]
GO-2020-0041,unknwon,cae,07971c00a1bfd9dc171c3ad0bfab5b67c2287e11," func (z *ZipArchive) Open(name string, flag int, perm os.FileMode) error {
 		if err != nil {
 			return err
 		}
-		z.files[i].Name = strings.Replace(f.Name, ""\\"", ""/"", -1)
+		z.files[i].Name = cae.Clean(strings.ReplaceAll(f.Name, ""\\"", ""/""))
 		if f.FileInfo().IsDir() && !strings.HasSuffix(z.files[i].Name, ""/"") {
 			z.files[i].Name += ""/""
 		}
",[True]
GO-2020-0041,unknwon,cae,07971c00a1bfd9dc171c3ad0bfab5b67c2287e11," func (z *ZipArchive) ExtractToFunc(destPath string, fn cae.HookFunc, entries ...
 	}
 	os.MkdirAll(destPath, os.ModePerm)
 	for _, f := range z.File {
-		f.Name = strings.Replace(f.Name, ""\\"", ""/"", -1)
+		f.Name = cae.Clean(strings.ReplaceAll(f.Name, ""\\"", ""/""))
 
 		// Directory.
 		if strings.HasSuffix(f.Name, ""/"") {
",[True]
GO-2021-0228,unknwon,cae,07971c00a1bfd9dc171c3ad0bfab5b67c2287e11," func Copy(dest, src string) error {
 	}
 	return os.Chmod(dest, si.Mode())
 }
+
+// Clean cleans up given path and returns a relative path that goes straight down.
+func Clean(p string) string {
+	return strings.Trim(path.Clean(""/""+p), ""/"")
+}
",[False]
GO-2021-0228,unknwon,cae,07971c00a1bfd9dc171c3ad0bfab5b67c2287e11," func (tz *TzArchive) syncFiles() {
 	for i, f := range tz.File {
 		tz.files[i] = &File{}
 		tz.files[i].Header = f
-		tz.files[i].Name = strings.Replace(f.Name, ""\\"", ""/"", -1)
+		tz.files[i].Name = cae.Clean(strings.ReplaceAll(f.Name, ""\\"", ""/""))
 		if f.FileInfo().IsDir() && !strings.HasSuffix(tz.files[i].Name, ""/"") {
 			tz.files[i].Name += ""/""
 		}
",[True]
GO-2021-0228,unknwon,cae,07971c00a1bfd9dc171c3ad0bfab5b67c2287e11," var defaultExtractFunc = func(fullName string, fi os.FileInfo) error {
 // specified destination.
 // It accepts a function as a middleware for custom operations.
 func (tz *TzArchive) ExtractToFunc(destPath string, fn cae.HookFunc, entries ...string) (err error) {
-	destPath = strings.Replace(destPath, ""\\"", ""/"", -1)
+	destPath = strings.ReplaceAll(destPath, ""\\"", ""/"")
 	isHasEntry := len(entries) > 0
 	if Verbose {
 		fmt.Println(""Extracting "" + tz.FileName + ""..."")
",[True]
GO-2021-0228,unknwon,cae,07971c00a1bfd9dc171c3ad0bfab5b67c2287e11," func (tz *TzArchive) ExtractToFunc(destPath string, fn cae.HookFunc, entries ...
 			return err
 		}
 
-		h.Name = strings.Replace(h.Name, ""\\"", ""/"", -1)
+		h.Name = cae.Clean(strings.ReplaceAll(h.Name, ""\\"", ""/""))
 
 		// Directory.
 		if h.Typeflag == tar.TypeDir {
",[True]
GO-2021-0228,unknwon,cae,07971c00a1bfd9dc171c3ad0bfab5b67c2287e11," func (z *ZipArchive) Open(name string, flag int, perm os.FileMode) error {
 		if err != nil {
 			return err
 		}
-		z.files[i].Name = strings.Replace(f.Name, ""\\"", ""/"", -1)
+		z.files[i].Name = cae.Clean(strings.ReplaceAll(f.Name, ""\\"", ""/""))
 		if f.FileInfo().IsDir() && !strings.HasSuffix(z.files[i].Name, ""/"") {
 			z.files[i].Name += ""/""
 		}
",[True]
GO-2021-0228,unknwon,cae,07971c00a1bfd9dc171c3ad0bfab5b67c2287e11," func (z *ZipArchive) ExtractToFunc(destPath string, fn cae.HookFunc, entries ...
 	}
 	os.MkdirAll(destPath, os.ModePerm)
 	for _, f := range z.File {
-		f.Name = strings.Replace(f.Name, ""\\"", ""/"", -1)
+		f.Name = cae.Clean(strings.ReplaceAll(f.Name, ""\\"", ""/""))
 
 		// Directory.
 		if strings.HasSuffix(f.Name, ""/"") {
",[True]
GO-2022-0246,cloudflare,cfrpki,a8db4e009ef217484598ba1fd1c595b54e0f6422," func (entry *ROAEntry) Validate() error {
 	if entry.MaxLength < s {
 		return errors.New(fmt.Sprintf(""Max length (%v) is smaller than prefix length (%v)"", entry.MaxLength, s))
 	}
+
+	if entry.MaxLength < 0 {
+		return fmt.Errorf(""max length (%d) is less than 0"", entry.MaxLength)
+	}
+
+	if entry.IPNet.IP.To4() != nil && entry.MaxLength > 32 { // If IPv4
+		return fmt.Errorf(""max length (%d) too small for IPv4 prefix"", entry.MaxLength)
+	} else if entry.MaxLength > 128 { // If IPv6
+		return fmt.Errorf(""max length (%d) too small for IPv6 prefix"", entry.MaxLength)
+	}
+
 	return nil
 }
 
",[True]
GO-2021-0065,kubernetes,kubernetes,4441f1d9c3e94d9a3d93b4f184a591cab02a5245," func (rt *debuggingRoundTripper) RoundTrip(req *http.Request) (*http.Response, e
 		klog.Infof(""Request Headers:"")
 		for key, values := range reqInfo.RequestHeaders {
 			for _, value := range values {
+				value = maskValue(key, value)
 				klog.Infof(""    %s: %s"", key, value)
 			}
 		}
",[True]
GO-2023-2077,SagerNet,sing,5b05b5c147d9650e8accb4441e216c72a61f4859," func HandleConnection0(ctx context.Context, conn net.Conn, version byte, authent
 			if err != nil {
 				return err
 			}
+			if response.Status != socks5.UsernamePasswordStatusSuccess {
+				return E.New(""socks5: authentication failed, username="", usernamePasswordAuthRequest.Username, "", password="", usernamePasswordAuthRequest.Password)
+			}
 		}
 		request, err := socks5.ReadRequest(conn)
 		if err != nil {
",[True]
GO-2020-0020,gorilla,handlers,90663712d74cb411cbef281bc1e08c19d1a76145," func (ch *cors) ServeHTTP(w http.ResponseWriter, r *http.Request) {
 		w.Header().Set(corsVaryHeader, corsOriginHeader)
 	}
 
-	w.Header().Set(corsAllowOriginHeader, origin)
+	returnOrigin := origin
+	for _, o := range ch.allowedOrigins {
+		// A configuration of * is different than explicitly setting an allowed
+		// origin. Returning arbitrary origin headers an an access control allow
+		// origin header is unsafe and is not required by any use case.
+		if o == corsOriginMatchAll {
+			returnOrigin = ""*""
+			break
+		}
+	}
+	w.Header().Set(corsAllowOriginHeader, returnOrigin)
 
 	if r.Method == corsOptionMethod {
 		return
",[True]
GO-2021-0094,hashicorp,go-slug,28cafc59c8da6126a3ae94dfa84181df4073454f," func Unpack(r io.Reader, dst string) error {
 		}
 		path = filepath.Join(dst, path)
 
+		// Check for paths outside our directory, they are forbidden
+		target := filepath.Clean(path)
+		if !strings.HasPrefix(target, dst) {
+			return fmt.Errorf(""Invalid filename, traversal with \""..\"" outside of current directory"")
+		}
+
+		// Ensure the destination is not through any symlinks. This prevents
+		// any files from being deployed through symlinks defined in the slug.
+		// There are malicious cases where this could be used to escape the
+		// slug's boundaries (zipslip), and any legitimate use is questionable
+		// and likely indicates a hand-crafted tar file, which we are not in
+		// the business of supporting here.
+		//
+		// The strategy is to Lstat each path  component from dst up to the
+		// immediate parent directory of the file name in the tarball, checking
+		// the mode on each to ensure we wouldn't be passing through any
+		// symlinks.
+		currentPath := dst // Start at the root of the unpacked tarball.
+		components := strings.Split(header.Name, ""/"")
+
+		for i := 0; i < len(components)-1; i++ {
+			currentPath = filepath.Join(currentPath, components[i])
+			fi, err := os.Lstat(currentPath)
+			if os.IsNotExist(err) {
+				// Parent directory structure is incomplete. Technically this
+				// means from here upward cannot be a symlink, so we cancel the
+				// remaining path tests.
+				break
+			}
+			if err != nil {
+				return fmt.Errorf(""Failed to evaluate path %q: %v"", header.Name, err)
+			}
+			if fi.Mode()&os.ModeSymlink != 0 {
+				return fmt.Errorf(""Cannot extract %q through symlink"",
+					header.Name)
+			}
+		}
+
 		// Make the directories to the path.
 		dir := filepath.Dir(path)
 		if err := os.MkdirAll(dir, 0755); err != nil {
",[True]
GO-2023-1494,elgs,gosqljson,2740b331546cb88eb61771df4c07d389e9f0363a," func QueryDbToArray(db *sql.DB, toLower bool, sqlStatement string, sqlParams ...
 			fmt.Println(err)
 		}
 	}()
+
+	SqlSafe(&sqlStatement)
+
 	var results [][]string
 	if strings.HasPrefix(strings.ToUpper(sqlStatement), ""SELECT"") {
 		rows, err := db.Query(sqlStatement, sqlParams...)
",[True]
GO-2023-1494,elgs,gosqljson,2740b331546cb88eb61771df4c07d389e9f0363a," func QueryDbToMap(db *sql.DB, toLower bool, sqlStatement string, sqlParams ...in
 		}
 	}()
 
+	SqlSafe(&sqlStatement)
+
 	var results []map[string]string
 	if strings.HasPrefix(strings.ToUpper(sqlStatement), ""SELECT "") {
 		rows, err := db.Query(sqlStatement, sqlParams...)
",[True]
GO-2023-1494,elgs,gosqljson,2740b331546cb88eb61771df4c07d389e9f0363a," func ExecDb(db *sql.DB, sqlStatement string, sqlParams ...interface{}) (int64, e
 		}
 	}()
 
+	SqlSafe(&sqlStatement)
+
 	sqlUpper := strings.ToUpper(sqlStatement)
 	if strings.HasPrefix(sqlUpper, ""UPDATE "") ||
 		strings.HasPrefix(sqlUpper, ""INSERT "") ||
",[True]
GO-2023-1494,elgs,gosqljson,2740b331546cb88eb61771df4c07d389e9f0363a," func ExecDb(db *sql.DB, sqlStatement string, sqlParams ...interface{}) (int64, e
 	}
 	return 0, errors.New(fmt.Sprint(""Invalid SQL:"", sqlStatement))
 }
+
+func SqlSafe(s *string) {
+	*s = strings.Replace(*s, ""'"", ""''"", -1)
+	*s = strings.Replace(*s, ""--"", """", -1)
+}
",[False]
GO-2021-0109,ory,fosite,03dd55813f5521985f7dd64277b7ba0cf1441319," func (f *Fosite) writeJsonError(rw http.ResponseWriter, err error) {
 	}
 
 	rw.WriteHeader(rfcerr.Code)
-	rw.Write(js)
+	// ignoring the error because the connection is broken when it happens
+	_, _ = rw.Write(js)
 }
",[False]
GO-2021-0109,ory,fosite,03dd55813f5521985f7dd64277b7ba0cf1441319," func (f *Fosite) WriteAccessResponse(rw http.ResponseWriter, requester AccessReq
 	rw.Header().Set(""Content-Type"", ""application/json;charset=UTF-8"")
 
 	rw.WriteHeader(http.StatusOK)
-	rw.Write(js)
+	_, _ = rw.Write(js)
 }
",[False]
GO-2021-0109,ory,fosite,03dd55813f5521985f7dd64277b7ba0cf1441319," func (f *Fosite) WriteAuthorizeError(rw http.ResponseWriter, ar AuthorizeRequest
 		}
 
 		rw.WriteHeader(rfcerr.Code)
-		rw.Write(js)
+		_, _ = rw.Write(js)
 		return
 	}
 
",[False]
GO-2021-0109,ory,fosite,03dd55813f5521985f7dd64277b7ba0cf1441319," func (i *IDTokenHandleHelper) GetAccessTokenHash(ctx context.Context, requester
 
 	buffer := bytes.NewBufferString(token)
 	hash := sha256.New()
-	hash.Write(buffer.Bytes())
+	// sha256.digest.Write() always returns nil for err, the panic should never happen
+	_, err := hash.Write(buffer.Bytes())
+	if err != nil {
+		panic(err)
+	}
 	hashBuf := bytes.NewBuffer(hash.Sum([]byte{}))
 	len := hashBuf.Len()
 
",[False]
GO-2021-0109,ory,fosite,03dd55813f5521985f7dd64277b7ba0cf1441319," func (f *Fosite) WriteRevocationResponse(rw http.ResponseWriter, err error) {
 		}
 
 		rw.WriteHeader(ErrInvalidRequest.Code)
-		rw.Write(js)
+		_, _ = rw.Write(js)
 	} else if errors.Is(err, ErrInvalidClient) {
 		rw.Header().Set(""Content-Type"", ""application/json;charset=UTF-8"")
 
",[False]
GO-2021-0109,ory,fosite,03dd55813f5521985f7dd64277b7ba0cf1441319," func (f *Fosite) WriteRevocationResponse(rw http.ResponseWriter, err error) {
 		}
 
 		rw.WriteHeader(ErrInvalidClient.Code)
-		rw.Write(js)
+		_, _ = rw.Write(js)
 	} else {
 		// 200 OK
 		rw.WriteHeader(http.StatusOK)
",[False]
GO-2021-0109,ory,fosite,03dd55813f5521985f7dd64277b7ba0cf1441319," func (c *HMACStrategy) Signature(token string) string {
 
 func generateHMAC(data []byte, key *[32]byte) []byte {
 	h := hmac.New(sha512.New512_256, key[:])
-	h.Write(data)
+	// sha512.digest.Write() always returns nil for err, the panic should never happen
+	_, err := h.Write(data)
+	if err != nil {
+		panic(err)
+	}
 	return h.Sum(nil)
 }
",[False]
GO-2021-0112,mongodb,mongo-go-driver,2aca31d5986a9e1c65a92264736de9fdc3b9b4ca," func (vw *valueWriter) invalidTransitionError(destination mode, name string, mod
 func (vw *valueWriter) writeElementHeader(t bsontype.Type, destination mode, callerName string, addmodes ...mode) error {
 	switch vw.stack[vw.frame].mode {
 	case mElement:
-		vw.buf = bsoncore.AppendHeader(vw.buf, t, vw.stack[vw.frame].key)
+		key := vw.stack[vw.frame].key
+		if !isValidCString(key) {
+			return errors.New(""BSON element key cannot contain null bytes"")
+		}
+
+		vw.buf = bsoncore.AppendHeader(vw.buf, t, key)
 	case mValue:
 		// TODO: Do this with a cache of the first 1000 or so array keys.
 		vw.buf = bsoncore.AppendHeader(vw.buf, t, strconv.Itoa(vw.stack[vw.frame].arrkey))
",[True]
GO-2021-0112,mongodb,mongo-go-driver,2aca31d5986a9e1c65a92264736de9fdc3b9b4ca," func (vw *valueWriter) WriteObjectID(oid primitive.ObjectID) error {
 }
 
 func (vw *valueWriter) WriteRegex(pattern string, options string) error {
+	if !isValidCString(pattern) || !isValidCString(options) {
+		return errors.New(""BSON regex values cannot contain null bytes"")
+	}
 	if err := vw.writeElementHeader(bsontype.Regex, mode(0), ""WriteRegex""); err != nil {
 		return err
 	}
",[False]
GO-2021-0112,mongodb,mongo-go-driver,2aca31d5986a9e1c65a92264736de9fdc3b9b4ca," func (vw *valueWriter) writeLength() error {
 	vw.buf[start+3] = byte(length >> 24)
 	return nil
 }
+
+func isValidCString(cs string) bool {
+	return !strings.ContainsRune(cs, '\x00')
+}
",[False]
GO-2021-0112,mongodb,mongo-go-driver,2aca31d5986a9e1c65a92264736de9fdc3b9b4ca," func AppendKey(dst []byte, key string) []byte { return append(dst, key+nullTermi
 // AppendHeader will append Type t and key to dst and return the extended
 // buffer.
 func AppendHeader(dst []byte, t bsontype.Type, key string) []byte {
+	if !isValidCString(key) {
+		panic(invalidKeyPanicMsg)
+	}
+
 	dst = AppendType(dst, t)
 	dst = append(dst, key...)
 	return append(dst, 0x00)
",[True]
GO-2021-0112,mongodb,mongo-go-driver,2aca31d5986a9e1c65a92264736de9fdc3b9b4ca," func AppendNullElement(dst []byte, key string) []byte { return AppendHeader(dst,
 
 // AppendRegex will append pattern and options to dst and return the extended buffer.
 func AppendRegex(dst []byte, pattern, options string) []byte {
+	if !isValidCString(pattern) || !isValidCString(options) {
+		panic(invalidRegexPanicMsg)
+	}
+
 	return append(dst, pattern+nullTerminator+options+nullTerminator...)
 }
 
",[True]
GO-2021-0112,mongodb,mongo-go-driver,2aca31d5986a9e1c65a92264736de9fdc3b9b4ca," func appendBinarySubtype2(dst []byte, subtype byte, b []byte) []byte {
 	dst = appendLength(dst, int32(len(b)))
 	return append(dst, b...)
 }
+
+func isValidCString(cs string) bool {
+	return !strings.ContainsRune(cs, '\x00')
+}
",[False]
GO-2022-0706,elastic,apm-agent-go,dd3e8c593580e7b80a98b57e1cc6e017e56747b4," func (c *Context) build() *model.Context {
 	default:
 		return nil
 	}
+	if len(c.sanitizedFieldNames) != 0 {
+		if c.model.Request != nil {
+			sanitizeRequest(c.model.Request, c.sanitizedFieldNames)
+		}
+		if c.model.Response != nil {
+			sanitizeResponse(c.model.Response, c.sanitizedFieldNames)
+		}
+
+	}
 	return &c.model
 }
 
",[False]
GO-2022-0706,elastic,apm-agent-go,dd3e8c593580e7b80a98b57e1cc6e017e56747b4," func (t *Tracer) newError() *Error {
 	if e.recording {
 		e.Timestamp = time.Now()
 		e.Context.captureHeaders = instrumentationConfig.captureHeaders
+		e.Context.sanitizedFieldNames = instrumentationConfig.sanitizedFieldNames
 		e.stackTraceLimit = instrumentationConfig.stackTraceLimit
 	}
 
",[False]
GO-2022-0706,elastic,apm-agent-go,dd3e8c593580e7b80a98b57e1cc6e017e56747b4," func (t *Tracer) StartTransactionOptions(name, transactionType string, opts Tran
 	tx.stackTraceLimit = instrumentationConfig.stackTraceLimit
 	tx.Context.captureHeaders = instrumentationConfig.captureHeaders
 	tx.propagateLegacyHeader = instrumentationConfig.propagateLegacyHeader
-	tx.sanitizedFieldNames = instrumentationConfig.sanitizedFieldNames
+	tx.Context.sanitizedFieldNames = instrumentationConfig.sanitizedFieldNames
 	tx.breakdownMetricsEnabled = t.breakdownMetrics.enabled
 
 	var root bool
",[False]
GO-2022-0706,elastic,apm-agent-go,dd3e8c593580e7b80a98b57e1cc6e017e56747b4," func (w *modelWriter) buildModelTransaction(out *model.Transaction, tx *Transact
 	if sampled {
 		out.Context = td.Context.build()
 	}
-
-	if len(td.sanitizedFieldNames) != 0 && out.Context != nil {
-		if out.Context.Request != nil {
-			sanitizeRequest(out.Context.Request, td.sanitizedFieldNames)
-		}
-		if out.Context.Response != nil {
-			sanitizeResponse(out.Context.Response, td.sanitizedFieldNames)
-		}
-	}
 }
 
 func (w *modelWriter) buildModelSpan(out *model.Span, span *Span, sd *SpanData) {
",[True]
GO-2021-0051,labstack,echo,4422e3b66b9fd498ed1ae1d0242d660d0ed3faaa," func (common) static(prefix, root string, get func(string, HandlerFunc, ...Middl
 			return err
 		}
 
-		name := filepath.Join(root, path.Clean(""/""+p)) // ""/""+ for security
+		name := filepath.Join(root, filepath.Clean(""/""+p)) // ""/""+ for security
 		fi, err := os.Stat(name)
 		if err != nil {
 			// The access path does not exist
",[True]
GO-2021-0051,labstack,echo,4422e3b66b9fd498ed1ae1d0242d660d0ed3faaa," func StaticWithConfig(config StaticConfig) echo.MiddlewareFunc {
 			if err != nil {
 				return
 			}
-			name := filepath.Join(config.Root, path.Clean(""/""+p)) // ""/""+ for security
+			name := filepath.Join(config.Root, filepath.Clean(""/""+p)) // ""/""+ for security
 
 			if config.IgnoreBase {
 				routePath := path.Base(strings.TrimRight(c.Path(), ""/*""))
",[False]
GO-2022-0422,ipld,go-codec-dagpb,a17ace35cc760a2698645c09868f9050fa219f57," func DecodeBytes(na ipld.NodeAssembler, src []byte) error {
 			haveData = true
 
 		case 2:
-			bytesLen, n := protowire.ConsumeVarint(remaining)
+			chunk, n := protowire.ConsumeBytes(remaining)
 			if n < 0 {
 				return protowire.ParseError(n)
 			}
",[True]
GO-2022-0422,ipld,go-codec-dagpb,a17ace35cc760a2698645c09868f9050fa219f57," func DecodeBytes(na ipld.NodeAssembler, src []byte) error {
 			if err != nil {
 				return err
 			}
-			if err := unmarshalLink(remaining[:bytesLen], curLink); err != nil {
+			if err := unmarshalLink(chunk, curLink); err != nil {
 				return err
 			}
-			remaining = remaining[bytesLen:]
 			if err := curLink.Finish(); err != nil {
 				return err
 			}
",[True]
GO-2020-0048,antchfx,xmlquery,5648b2f39e8d5d3fc903c45a4f1274829df71821," func LoadURL(url string) (*Node, error) {
 		return nil, err
 	}
 	defer resp.Body.Close()
-	return Parse(resp.Body)
+	// Checking the HTTP Content-Type value from the response headers.(#39)
+	v := strings.ToLower(resp.Header.Get(""Content-Type""))
+	if v == ""text/xml"" || v == ""application/xml"" {
+		return Parse(resp.Body)
+	}
+	return nil, fmt.Errorf(""invalid XML document(%s)"", v)
 }
 
 // Parse returns the parse tree for the XML from the given Reader.
",[True]
GO-2020-0039,go-macaron,macaron,addc7461c3a90a040e79aa75bfd245107a210245," func staticHandler(ctx *Context, log *log.Logger, opt StaticOptions) bool {
 	// Try to serve index file
 	if fi.IsDir() {
 		// Redirect if missing trailing slash.
-		if !strings.HasSuffix(ctx.Req.URL.Path, ""/"") {
-			http.Redirect(ctx.Resp, ctx.Req.Request, ctx.Req.URL.Path+""/"", http.StatusFound)
+		redirPath := path.Clean(ctx.Req.URL.Path)
+		if !strings.HasSuffix(redirPath, ""/"") {
+			http.Redirect(ctx.Resp, ctx.Req.Request, redirPath+""/"", http.StatusFound)
 			return true
 		}
 
",[True]
GO-2023-2048,cyphar,filepath-securejoin,c121231e1276e11049547bee5ce68d5a2cfe2d9b," func IsNotExist(err error) bool {
 // components in the returned string are not modified (in other words are not
 // replaced with symlinks on the filesystem) after this function has returned.
 // Such a symlink race is necessarily out-of-scope of SecureJoin.
+//
+// Volume names in unsafePath are always discarded, regardless if they are
+// provided via direct input or when evaluating symlinks. Therefore:
+//
+// ""C:\Temp"" + ""D:\path\to\file.txt"" results in ""C:\Temp\path\to\file.txt""
 func SecureJoinVFS(root, unsafePath string, vfs VFS) (string, error) {
 	// Use the os.* VFS implementation if none was specified.
 	if vfs == nil {
 		vfs = osVFS{}
 	}
 
+	unsafePath = filepath.FromSlash(unsafePath)
 	var path bytes.Buffer
 	n := 0
 	for unsafePath != """" {
 		if n > 255 {
-			return """", &os.PathError{Op: ""SecureJoin"", Path: root + ""/"" + unsafePath, Err: syscall.ELOOP}
+			return """", &os.PathError{Op: ""SecureJoin"", Path: root + string(filepath.Separator) + unsafePath, Err: syscall.ELOOP}
+		}
+
+		if v := filepath.VolumeName(unsafePath); v != """" {
+			unsafePath = unsafePath[len(v):]
 		}
 
 		// Next path component, p.
",[True]
GO-2022-0251,cloudflare,cfrpki,76f0f7a98da001fa04e5bc0407c6702f91096bfa," func readObject(ber []byte, offset int) (asn1Object, int, error) {
 	*/
 	// read length
 	var length int
+	// GHSA-5mxh-2qfv-4g7j: Prevent a BER w/ NUL contents from being processed
+	if len(ber) <= offset {
+		return nil, 0, errors.New(""ber2der: invalid BER tag length"")
+	}
 	l := ber[offset]
 	offset++
 	indefinite := false
",[True]
GO-2023-1515,rancher,wrangler,341018c8fef3e12867c7cb2649bd2cecac75f287," func (g *Git) LsRemote(branch string, commit string) (string, error) {
 	}
 
 	output := &bytes.Buffer{}
-	if err := g.gitCmd(output, ""ls-remote"", g.URL, formatRefForBranch(branch)); err != nil {
+	if err := g.gitCmd(output, ""ls-remote"", ""--"", g.URL, formatRefForBranch(branch)); err != nil {
 		return """", err
 	}
 
",[False]
GO-2023-1515,rancher,wrangler,341018c8fef3e12867c7cb2649bd2cecac75f287," func (g *Git) Head(branch string) (string, error) {
 // Clone runs git clone with depth 1
 func (g *Git) Clone(branch string) error {
 	if branch == """" {
-		return g.git(""clone"", ""--depth=1"", ""-n"", g.URL, g.Directory)
+		return g.git(""clone"", ""--depth=1"", ""-n"", ""--"", g.URL, g.Directory)
 	}
-	return g.git(""clone"", ""--depth=1"", ""-n"", ""--branch"", branch, g.URL, g.Directory)
+	return g.git(""clone"", ""--depth=1"", ""-n"", ""--branch=""+branch, ""--"", g.URL, g.Directory)
 }
 
 // Update updates git repo if remote sha has changed
",[True]
GO-2023-1515,rancher,wrangler,341018c8fef3e12867c7cb2649bd2cecac75f287," func (g *Git) currentCommit() (string, error) {
 }
 
 func (g *Git) gitCmd(output io.Writer, args ...string) error {
-	kv := fmt.Sprintf(""credential.helper=%s"", ""/bin/sh -c 'echo password=$GIT_PASSWORD'"")
+	kv := fmt.Sprintf(""credential.helper=%s"", `/bin/sh -c 'echo ""password=$GIT_PASSWORD""'`)
 	cmd := exec.Command(""git"", append([]string{""-c"", kv}, args...)...)
 	cmd.Env = append(os.Environ(), fmt.Sprintf(""GIT_PASSWORD=%s"", g.password))
 	stderrBuf := &bytes.Buffer{}
",[True]
GO-2022-0586,hashicorp,go-getter,38e97387488f5439616be60874979433a12edb48," func (c *Client) Get(ctx context.Context, req *Request) (*GetResult, error) {
 		return nil, err
 	}
 
+	// Pass along the configured Getter client in the context for usage with the X-Terraform-Get feature.
+	ctx = NewContextWithClient(ctx, c)
+
 	// Store this locally since there are cases we swap this
 	if req.GetMode == ModeInvalid {
 		req.GetMode = ModeAny
 	}
 
+	// Client setting takes precedence for all requests
+	if c.DisableSymlinks {
+		req.DisableSymlinks = true
+	}
+
 	// If there is a subdir component, then we download the root separately
 	// and then copy over the proper subdir.
 	req.Src, req.subDir = SourceDirSubdir(req.Src)
+
 	if req.subDir != """" {
+		// Check if the subdirectory is attempting to traverse upwards, outside of
+		// the cloned repository path.
+		req.subDir = filepath.Clean(req.subDir)
+		if containsDotDot(req.subDir) {
+			return nil, fmt.Errorf(""subdirectory component contain path traversal out of the repository"")
+		}
+
+		// Prevent absolute paths, remove a leading path separator from the subdirectory
+		if req.subDir[0] == os.PathSeparator {
+			req.subDir = req.subDir[1:]
+		}
+
 		td, tdcloser, err := safetemp.Dir("""", ""getter"")
 		if err != nil {
 			return nil, err
",[False]
GO-2022-0586,hashicorp,go-getter,38e97387488f5439616be60874979433a12edb48," func (c *Client) get(ctx context.Context, req *Request, g Getter) (*GetResult, *
 	// Determine if we have an archive type
 	archiveV := q.Get(""archive"")
 	if archiveV != """" {
-		// Delete the paramter since it is a magic parameter we don't
+		// Delete the parameter since it is a magic parameter we don't
 		// want to pass on to the Getter
 		q.Del(""archive"")
 		req.u.RawQuery = q.Encode()
",[False]
GO-2022-0586,hashicorp,go-getter,38e97387488f5439616be60874979433a12edb48," func (c *Client) get(ctx context.Context, req *Request, g Getter) (*GetResult, *
 				filename = v
 			}
 
+			if containsDotDot(filename) {
+				return nil, &getError{true, fmt.Errorf(""filename query parameter contain path traversal"")}
+			}
+
 			req.Dst = filepath.Join(req.Dst, filename)
 		}
 	}
",[False]
GO-2022-0586,hashicorp,go-getter,38e97387488f5439616be60874979433a12edb48," func (c *Client) get(ctx context.Context, req *Request, g Getter) (*GetResult, *
 			return nil, &getError{true, err}
 		}
 
-		err = copyDir(ctx, req.realDst, subDir, false, req.umask())
+		err = copyDir(ctx, req.realDst, subDir, false, req.DisableSymlinks, req.umask())
 		if err != nil {
 			return nil, &getError{false, err}
 		}
",[False]
GO-2022-0586,hashicorp,go-getter,38e97387488f5439616be60874979433a12edb48," import (
 func main() {
 	modeRaw := flag.String(""mode"", ""any"", ""get mode (any, file, dir)"")
 	progress := flag.Bool(""progress"", false, ""display terminal progress"")
+	noSymlinks := flag.Bool(""disable-symlinks"", false, ""prevent copying or writing files through symlinks"")
 	flag.Parse()
 	args := flag.Args()
 	if len(args) < 2 {
",[False]
GO-2022-0586,hashicorp,go-getter,38e97387488f5439616be60874979433a12edb48," func main() {
 	if *progress {
 		req.ProgressListener = defaultProgressBar
 	}
-
 	wg := sync.WaitGroup{}
 	wg.Add(1)
 
 	client := getter.DefaultClient
 
+	// Disable symlinks for all client requests
+	if *noSymlinks {
+		client.DisableSymlinks = true
+	}
+
 	getters := getter.Getters
 	getters = append(getters, new(gcs.Getter))
 	getters = append(getters, new(s3.Getter))
",[False]
GO-2022-0586,hashicorp,go-getter,38e97387488f5439616be60874979433a12edb48," import (
 // should already exist.
 //
 // If ignoreDot is set to true, then dot-prefixed files/folders are ignored.
-func copyDir(ctx context.Context, dst string, src string, ignoreDot bool, umask os.FileMode) error {
+func copyDir(ctx context.Context, dst string, src string, ignoreDot bool, disableSymlinks bool, umask os.FileMode) error {
 	src, err := filepath.EvalSymlinks(src)
 	if err != nil {
 		return err
",[False]
GO-2022-0586,hashicorp,go-getter,38e97387488f5439616be60874979433a12edb48," func copyDir(ctx context.Context, dst string, src string, ignoreDot bool, umask
 			}
 		}
 
+		if disableSymlinks {
+			if info.Mode()&os.ModeSymlink == os.ModeSymlink {
+				return ErrSymlinkCopy
+			}
+		}
+
 		// The ""path"" has the src prefixed to it. We need to join our
 		// destination with the path without the src on it.
 		dstPath := filepath.Join(dst, path[len(src):])
",[False]
GO-2022-0586,hashicorp,go-getter,38e97387488f5439616be60874979433a12edb48," func copyDir(ctx context.Context, dst string, src string, ignoreDot bool, umask
 		}
 
 		// If we have a file, copy the contents.
-		_, err = copyFile(ctx, dstPath, path, info.Mode(), umask)
+		_, err = copyFile(ctx, dstPath, path, disableSymlinks, info.Mode(), umask)
 		return err
 	}
 
",[False]
GO-2022-0586,hashicorp,go-getter,38e97387488f5439616be60874979433a12edb48," import (
 
 // Getter is a Getter implementation that will download a module from
 // a GCS bucket.
-type Getter struct{}
+type Getter struct {
+
+	// Timeout sets a deadline which all GCS operations should
+	// complete within. Zero value means no timeout.
+	Timeout time.Duration
+}
 
 func (g *Getter) Mode(ctx context.Context, u *url.URL) (getter.Mode, error) {
 
+	if g.Timeout > 0 {
+		var cancel context.CancelFunc
+		ctx, cancel = context.WithTimeout(ctx, g.Timeout)
+		defer cancel()
+	}
+
 	// Parse URL
 	bucket, object, err := g.parseURL(u)
 	if err != nil {
",[True]
GO-2022-0586,hashicorp,go-getter,38e97387488f5439616be60874979433a12edb48," func (g *Getter) Mode(ctx context.Context, u *url.URL) (getter.Mode, error) {
 }
 
 func (g *Getter) Get(ctx context.Context, req *getter.Request) error {
+
+	if g.Timeout > 0 {
+		var cancel context.CancelFunc
+		ctx, cancel = context.WithTimeout(ctx, g.Timeout)
+		defer cancel()
+	}
+
 	// Parse URL
 	bucket, object, err := g.parseURL(req.URL())
 	if err != nil {
",[True]
GO-2022-0586,hashicorp,go-getter,38e97387488f5439616be60874979433a12edb48," func (g *Getter) Get(ctx context.Context, req *getter.Request) error {
 }
 
 func (g *Getter) GetFile(ctx context.Context, req *getter.Request) error {
+
+	if g.Timeout > 0 {
+		var cancel context.CancelFunc
+		ctx, cancel = context.WithTimeout(ctx, g.Timeout)
+		defer cancel()
+	}
+
 	// Parse URL
 	bucket, object, err := g.parseURL(req.URL())
 	if err != nil {
",[True]
GO-2022-0586,hashicorp,go-getter,38e97387488f5439616be60874979433a12edb48," func init() {
 	// The order of the Getters in the list may affect the result
 	// depending if the Request.Src is detected as valid by multiple getters
 	Getters = []Getter{
-		&GitGetter{[]Detector{
-			new(GitHubDetector),
-			new(GitDetector),
-			new(BitBucketDetector),
-			new(GitLabDetector),
-		},
+		&GitGetter{
+			Detectors: []Detector{
+				new(GitHubDetector),
+				new(GitDetector),
+				new(BitBucketDetector),
+				new(GitLabDetector),
+			},
 		},
 		new(HgGetter),
 		new(SmbClientGetter),
",[False]
GO-2022-0586,hashicorp,go-getter,38e97387488f5439616be60874979433a12edb48," func copyReader(dst string, src io.Reader, fmode, umask os.FileMode) error {
 }
 
 // copyFile copies a file in chunks from src path to dst path, using umask to create the dst file
-func copyFile(ctx context.Context, dst, src string, fmode, umask os.FileMode) (int64, error) {
+func copyFile(ctx context.Context, dst, src string, disableSymlinks bool, fmode, umask os.FileMode) (int64, error) {
+
+	if disableSymlinks {
+		fileInfo, err := os.Lstat(src)
+		if err != nil {
+			return 0, fmt.Errorf(""failed to check copy file source for symlinks: %w"", err)
+		}
+
+		if fileInfo.Mode()&os.ModeSymlink == os.ModeSymlink {
+			return 0, ErrSymlinkCopy
+		}
+	}
+
 	srcF, err := os.Open(src)
 	if err != nil {
 		return 0, err
",[False]
GO-2022-0586,hashicorp,go-getter,38e97387488f5439616be60874979433a12edb48," func (g *GitGetter) Get(ctx context.Context, req *Request) error {
 		req.u.RawQuery = q.Encode()
 	}
 
+	if g.Timeout > 0 {
+		var cancel context.CancelFunc
+		ctx, cancel = context.WithTimeout(ctx, g.Timeout)
+		defer cancel()
+	}
+
 	var sshKeyFile string
 	if sshKey != """" {
 		// Check that the git version is sufficiently new.
-		if err := checkGitVersion(""2.3""); err != nil {
+		if err := checkGitVersion(ctx, ""2.3""); err != nil {
 			return fmt.Errorf(""Error using ssh key: %v"", err)
 		}
 
",[False]
GO-2022-0586,hashicorp,go-getter,38e97387488f5439616be60874979433a12edb48," func (g *GitGetter) Get(ctx context.Context, req *Request) error {
 
 	// Next: check out the proper tag/branch if it is specified, and checkout
 	if ref != """" {
-		if err := g.checkout(req.Dst, ref); err != nil {
+		if err := g.checkout(ctx, req.Dst, ref); err != nil {
 			return err
 		}
 	}
",[False]
GO-2022-0586,hashicorp,go-getter,38e97387488f5439616be60874979433a12edb48," func (g *GitGetter) GetFile(ctx context.Context, req *Request) error {
 	return fg.GetFile(ctx, req)
 }
 
-func (g *GitGetter) checkout(dst string, ref string) error {
-	cmd := exec.Command(""git"", ""checkout"", ref)
+func (g *GitGetter) checkout(ctx context.Context, dst string, ref string) error {
+	cmd := exec.CommandContext(ctx, ""git"", ""checkout"", ref)
 	cmd.Dir = dst
 	return getRunCommand(cmd)
 }
",[False]
GO-2022-0586,hashicorp,go-getter,38e97387488f5439616be60874979433a12edb48," func (g *GitGetter) update(ctx context.Context, dst, sshKeyFile, ref string, dep
 		// Not a branch, switch to default branch. This will also catch
 		// non-existent branches, in which case we want to switch to default
 		// and then checkout the proper branch later.
-		ref = findDefaultBranch(dst)
+		ref = findDefaultBranch(ctx, dst)
 	}
 
 	// We have to be on a branch to pull
-	if err := g.checkout(dst, ref); err != nil {
+	if err := g.checkout(ctx, dst, ref); err != nil {
 		return err
 	}
 
 	if depth > 0 {
-		cmd = exec.Command(""git"", ""pull"", ""--depth"", strconv.Itoa(depth), ""--ff-only"")
+		cmd = exec.CommandContext(ctx, ""git"", ""pull"", ""--depth"", strconv.Itoa(depth), ""--ff-only"")
 	} else {
-		cmd = exec.Command(""git"", ""pull"", ""--ff-only"")
+		cmd = exec.CommandContext(ctx, ""git"", ""pull"", ""--ff-only"")
 	}
 
 	cmd.Dir = dst
",[False]
GO-2022-0586,hashicorp,go-getter,38e97387488f5439616be60874979433a12edb48," func (g *GitGetter) fetchSubmodules(ctx context.Context, dst, sshKeyFile string,
 // findDefaultBranch checks the repo's origin remote for its default branch
 // (generally ""master""). ""master"" is returned if an origin default branch
 // can't be determined.
-func findDefaultBranch(dst string) string {
+func findDefaultBranch(ctx context.Context, dst string) string {
 	var stdoutbuf bytes.Buffer
-	cmd := exec.Command(""git"", ""branch"", ""-r"", ""--points-at"", ""refs/remotes/origin/HEAD"")
+	cmd := exec.CommandContext(ctx, ""git"", ""branch"", ""-r"", ""--points-at"", ""refs/remotes/origin/HEAD"")
 	cmd.Dir = dst
 	cmd.Stdout = &stdoutbuf
 	err := cmd.Run()
",[False]
GO-2022-0586,hashicorp,go-getter,38e97387488f5439616be60874979433a12edb48," func setupGitEnv(cmd *exec.Cmd, sshKeyFile string) {
 // checkGitVersion is used to check the version of git installed on the system
 // against a known minimum version. Returns an error if the installed version
 // is older than the given minimum.
-func checkGitVersion(min string) error {
+func checkGitVersion(ctx context.Context, min string) error {
 	want, err := version.NewVersion(min)
 	if err != nil {
 		return err
 	}
 
-	out, err := exec.Command(""git"", ""version"").Output()
+	out, err := exec.CommandContext(ctx, ""git"", ""version"").Output()
 	if err != nil {
 		return err
 	}
",[False]
GO-2022-0586,hashicorp,go-getter,38e97387488f5439616be60874979433a12edb48," func (g *HgGetter) Get(ctx context.Context, req *Request) error {
 	if err != nil && !os.IsNotExist(err) {
 		return err
 	}
+
+	if g.Timeout > 0 {
+		var cancel context.CancelFunc
+		ctx, cancel = context.WithTimeout(ctx, g.Timeout)
+		defer cancel()
+	}
+
 	if err != nil {
-		if err := g.clone(req.Dst, newURL); err != nil {
+		if err := g.clone(ctx, req.Dst, newURL); err != nil {
 			return err
 		}
 	}
 
-	if err := g.pull(req.Dst, newURL); err != nil {
+	if err := g.pull(ctx, req.Dst, newURL); err != nil {
 		return err
 	}
 
",[False]
GO-2022-0586,hashicorp,go-getter,38e97387488f5439616be60874979433a12edb48," func (g *HgGetter) pull(dst string, u *url.URL) error {
 func (g *HgGetter) update(ctx context.Context, dst string, u *url.URL, rev string) error {
 	args := []string{""update""}
 	if rev != """" {
-		args = append(args, rev)
+		args = append(args, ""--"", rev)
 	}
 
 	cmd := exec.CommandContext(ctx, ""hg"", args...)
",[False]
GO-2022-0586,hashicorp,go-getter,38e97387488f5439616be60874979433a12edb48," func (g *HttpGetter) Get(ctx context.Context, req *Request) error {
 		}
 	}
 
+	// If the HTTP client is nil, check if there is one available in the context,
+	// otherwise create one using cleanhttp's default transport.
 	if g.Client == nil {
-		g.Client = httpClient
+		if client := httpClientFromContext(ctx); client != nil {
+			g.Client = client
+		} else {
+			g.Client = httpClient
+		}
 	}
 
+	// Pass along the configured HTTP client in the context for usage with the X-Terraform-Get feature.
+	ctx = context.WithValue(ctx, httpClientValue, g.Client)
+
 	// Add terraform-get to the parameter.
 	q := req.u.Query()
 	q.Add(""terraform-get"", ""1"")
 	req.u.RawQuery = q.Encode()
 
+	readCtx := ctx
+	if g.ReadTimeout > 0 {
+		var cancel context.CancelFunc
+		readCtx, cancel = context.WithTimeout(ctx, g.ReadTimeout)
+		defer cancel()
+	}
+
 	// Get the URL
-	httpReq, err := http.NewRequestWithContext(ctx, ""GET"", req.u.String(), nil)
+	httpReq, err := http.NewRequestWithContext(readCtx, ""GET"", req.u.String(), nil)
 	if err != nil {
 		return err
 	}
",[False]
GO-2022-0586,hashicorp,go-getter,38e97387488f5439616be60874979433a12edb48," func (g *HttpGetter) Get(ctx context.Context, req *Request) error {
 	if err != nil {
 		return err
 	}
-
 	defer resp.Body.Close()
+
+	body := resp.Body
+	if maxBytes := httpMaxBytesFromContext(ctx); maxBytes > 0 {
+		body = newLimitedWrappedReaderCloser(body, maxBytes)
+	}
+
 	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
 		return fmt.Errorf(""bad response code: %d"", resp.StatusCode)
 	}
 
+	if disabled := xTerraformGetDisabled(ctx); disabled {
+		return nil
+	}
+
+	// Get client with configured Getters from the context
+	// If the client is nil, we know we're using the HttpGetter directly. In this case,
+	// we don't know exactly which protocols are configured, but we can make a good guess.
+	//
+	// This prevents all default getters from being allowed when only using the
+	// HttpGetter directly. To enable protocol switching, a client ""wrapper"" must
+	// be used.
+	var getterClient *Client
+	if v := ClientFromContext(ctx); v != nil {
+		getterClient = v
+	} else {
+		getterClient = &Client{
+			Getters: []Getter{g},
+		}
+	}
+
 	// Extract the source URL
 	var source string
 	if v := resp.Header.Get(""X-Terraform-Get""); v != """" {
 		source = v
 	} else {
-		source, err = g.parseMeta(resp.Body)
+		source, err = g.parseMeta(readCtx, body)
 		if err != nil {
 			return err
 		}
 	}
+
 	if source == """" {
 		return fmt.Errorf(""no source URL was returned"")
 	}
 
-	// If there is a subdir component, then we download the root separately
-	// into a temporary directory, then copy over the proper subdir.
-	source, subDir := SourceDirSubdir(source)
-	req = &Request{
-		GetMode: ModeDir,
-		Src:     source,
-		Dst:     req.Dst,
-	}
-	if subDir == """" {
-		_, err = DefaultClient.Get(ctx, req)
-		return err
-	}
-	// We have a subdir, time to jump some hoops
-	return g.getSubdir(ctx, req, source, subDir)
+	return g.getXTerraformSource(ctx, req, source, getterClient)
 }
 
 // GetFile fetches the file from src and stores it at dst.
",[False]
GO-2022-0586,hashicorp,go-getter,38e97387488f5439616be60874979433a12edb48," func (g *HttpGetter) Get(ctx context.Context, req *Request) error {
 // falsely identified as being replaced, or corrupted with extra bytes
 // appended.
 func (g *HttpGetter) GetFile(ctx context.Context, req *Request) error {
+	// Optionally enforce a maxiumum HTTP response body size.
+	if g.MaxBytes > 0 {
+		ctx = context.WithValue(ctx, httpMaxBytesValue, g.MaxBytes)
+	}
+
 	if g.Netrc {
 		// Add auth from netrc if we can
 		if err := addAuthFromNetrc(req.u); err != nil {
",[False]
GO-2022-0586,hashicorp,go-getter,38e97387488f5439616be60874979433a12edb48," func (g *HttpGetter) GetFile(ctx context.Context, req *Request) error {
 	}
 
 	var currentFileSize int64
+	var httpReq *http.Request
+
+	if g.DoNotCheckHeadFirst == false {
+		headCtx := ctx
 
-	// We first make a HEAD request so we can check
-	// if the server supports range queries. If the server/URL doesn't
-	// support HEAD requests, we just fall back to GET.
-	httpReq, err := http.NewRequestWithContext(ctx, ""HEAD"", req.u.String(), nil)
+		if g.HeadFirstTimeout > 0 {
+			var cancel context.CancelFunc
+
+			headCtx, cancel = context.WithTimeout(ctx, g.HeadFirstTimeout)
+			defer cancel()
+		}
+
+		// We first make a HEAD request so we can check
+		// if the server supports range queries. If the server/URL doesn't
+		// support HEAD requests, we just fall back to GET.
+		httpReq, err = http.NewRequestWithContext(headCtx, ""HEAD"", req.u.String(), nil)
+		if err != nil {
+			return err
+		}
+		if g.Header != nil {
+			httpReq.Header = g.Header.Clone()
+		}
+		headResp, err := g.Client.Do(httpReq)
+		if err == nil {
+			headResp.Body.Close()
+			if headResp.StatusCode == 200 {
+				// If the HEAD request succeeded, then attempt to set the range
+				// query if we can.
+				if headResp.Header.Get(""Accept-Ranges"") == ""bytes"" && headResp.ContentLength >= 0 {
+					if fi, err := f.Stat(); err == nil {
+						if _, err = f.Seek(0, io.SeekEnd); err == nil {
+							currentFileSize = fi.Size()
+							httpReq.Header.Set(""Range"", fmt.Sprintf(""bytes=%d-"", currentFileSize))
+							if currentFileSize >= headResp.ContentLength {
+								// file already present
+								return nil
+							}
+						}
+					}
+				}
+			}
+		}
+	}
+
+	readCtx := ctx
+	if g.ReadTimeout > 0 {
+		var cancel context.CancelFunc
+		readCtx, cancel = context.WithTimeout(ctx, g.ReadTimeout)
+		defer cancel()
+	}
+
+	httpReq, err = http.NewRequestWithContext(readCtx, ""GET"", req.u.String(), nil)
 	if err != nil {
 		return err
 	}
 	if g.Header != nil {
 		httpReq.Header = g.Header.Clone()
 	}
-	headResp, err := g.Client.Do(httpReq)
-	if err == nil {
-		headResp.Body.Close()
-		if headResp.StatusCode == 200 {
-			// If the HEAD request succeeded, then attempt to set the range
-			// query if we can.
-			if headResp.Header.Get(""Accept-Ranges"") == ""bytes"" && headResp.ContentLength >= 0 {
-				if fi, err := f.Stat(); err == nil {
-					if _, err = f.Seek(0, io.SeekEnd); err == nil {
-						currentFileSize = fi.Size()
-						httpReq.Header.Set(""Range"", fmt.Sprintf(""bytes=%d-"", currentFileSize))
-						if currentFileSize >= headResp.ContentLength {
-							// file already present
-							return nil
-						}
-					}
-				}
-			}
-		}
+	if currentFileSize > 0 {
+		httpReq.Header.Set(""Range"", fmt.Sprintf(""bytes=%d-"", currentFileSize))
 	}
-	httpReq.Method = ""GET""
 
 	resp, err := g.Client.Do(httpReq)
 	if err != nil {
",[False]
GO-2022-0586,hashicorp,go-getter,38e97387488f5439616be60874979433a12edb48," func (g *HttpGetter) GetFile(ctx context.Context, req *Request) error {
 
 	body := resp.Body
 
+	if maxBytes := httpMaxBytesFromContext(readCtx); maxBytes > 0 {
+		body = newLimitedWrappedReaderCloser(body, maxBytes)
+	}
+
 	if req.ProgressListener != nil {
 		// track download
 		fn := filepath.Base(req.u.EscapedPath())
",[False]
GO-2022-0586,hashicorp,go-getter,38e97387488f5439616be60874979433a12edb48," func (g *HttpGetter) getSubdir(ctx context.Context, req *Request, source, subDir
 	}
 	defer tdcloser.Close()
 
-	// Download that into the given directory
-	if _, err := Get(ctx, td, source); err != nil {
+	tdReq := &Request{
+		Src:             source,
+		Dst:             td,
+		GetMode:         ModeDir,
+		DisableSymlinks: req.DisableSymlinks,
+	}
+	if _, err := client.Get(ctx, tdReq); err != nil {
 		return err
 	}
 
",[False]
GO-2022-0586,hashicorp,go-getter,38e97387488f5439616be60874979433a12edb48," import (
 
 // Getter is a Getter implementation that will download a module from
 // a S3 bucket.
-type Getter struct{}
+type Getter struct {
+
+	// Timeout sets a deadline which all S3 operations should
+	// complete within. Zero value means no timeout.
+	Timeout time.Duration
+}
 
 func (g *Getter) Mode(ctx context.Context, u *url.URL) (getter.Mode, error) {
+
+	if g.Timeout > 0 {
+		var cancel context.CancelFunc
+		ctx, cancel = context.WithTimeout(ctx, g.Timeout)
+		defer cancel()
+	}
+
 	// Parse URL
 	region, bucket, path, _, creds, err := g.parseUrl(u)
 	if err != nil {
",[True]
GO-2022-0586,hashicorp,go-getter,38e97387488f5439616be60874979433a12edb48," func (g *Getter) Mode(ctx context.Context, u *url.URL) (getter.Mode, error) {
 		Bucket: aws.String(bucket),
 		Prefix: aws.String(path),
 	}
-	resp, err := client.ListObjects(req)
+	resp, err := client.ListObjectsWithContext(ctx, req)
 	if err != nil {
 		return 0, err
 	}
",[True]
GO-2022-0586,hashicorp,go-getter,38e97387488f5439616be60874979433a12edb48," func (g *Getter) Mode(ctx context.Context, u *url.URL) (getter.Mode, error) {
 
 func (g *Getter) Get(ctx context.Context, req *getter.Request) error {
 
+	if g.Timeout > 0 {
+		var cancel context.CancelFunc
+		ctx, cancel = context.WithTimeout(ctx, g.Timeout)
+		defer cancel()
+	}
+
 	// Parse URL
 	region, bucket, path, _, creds, err := g.parseUrl(req.URL())
 	if err != nil {
",[True]
GO-2022-0586,hashicorp,go-getter,38e97387488f5439616be60874979433a12edb48," func (g *Getter) Get(ctx context.Context, req *getter.Request) error {
 			s3Req.Marker = aws.String(lastMarker)
 		}
 
-		resp, err := client.ListObjects(s3Req)
+		resp, err := client.ListObjectsWithContext(ctx, s3Req)
 		if err != nil {
 			return err
 		}
",[True]
GO-2022-0586,hashicorp,go-getter,38e97387488f5439616be60874979433a12edb48," func (g *Getter) Get(ctx context.Context, req *getter.Request) error {
 }
 
 func (g *Getter) GetFile(ctx context.Context, req *getter.Request) error {
+
+	if g.Timeout > 0 {
+		var cancel context.CancelFunc
+		ctx, cancel = context.WithTimeout(ctx, g.Timeout)
+		defer cancel()
+	}
+
 	region, bucket, path, version, creds, err := g.parseUrl(req.URL())
 	if err != nil {
 		return err
",[True]
GO-2022-0586,hashicorp,go-getter,38e97387488f5439616be60874979433a12edb48," func (g *Getter) getObject(ctx context.Context, client *s3.S3, req *getter.Reque
 		s3req.VersionId = aws.String(version)
 	}
 
-	resp, err := client.GetObject(s3req)
+	resp, err := client.GetObjectWithContext(ctx, s3req)
 	if err != nil {
 		return err
 	}
",[False]
GO-2022-0586,hashicorp,go-getter,38e97387488f5439616be60874979433a12edb48," func SourceDirSubdir(src string) (string, string) {
 //
 // The returned path is the full absolute path.
 func SubdirGlob(dst, subDir string) (string, error) {
-	matches, err := filepath.Glob(filepath.Join(dst, subDir))
+	pattern := filepath.Join(dst, subDir)
+
+	matches, err := filepath.Glob(pattern)
 	if err != nil {
 		return """", err
 	}
",[False]
GO-2022-0586,hashicorp,go-getter,a2ebce998f8d4105bd4b78d6c99a12803ad97a45," func (c *Client) Get() error {
 	dst := c.Dst
 	src, subDir := SourceDirSubdir(src)
 	if subDir != """" {
+		// Check if the subdirectory is attempting to traverse updwards, outside of
+		// the cloned repository path.
+		subDir := filepath.Clean(subDir)
+		if containsDotDot(subDir) {
+			return fmt.Errorf(""subdirectory component contain path traversal out of the repository"")
+		}
+		// Prevent absolute paths, remove a leading path separator from the subdirectory
+		if subDir[0] == os.PathSeparator {
+			subDir = subDir[1:]
+		}
+
 		td, tdcloser, err := safetemp.Dir("""", ""getter"")
 		if err != nil {
 			return err
",[False]
GO-2022-0586,hashicorp,go-getter,a2ebce998f8d4105bd4b78d6c99a12803ad97a45," func (c *Client) Get() error {
 				filename = v
 			}
 
+			if containsDotDot(filename) {
+				return fmt.Errorf(""filename query parameter contain path traversal"")
+			}
+
 			dst = filepath.Join(dst, filename)
 		}
 	}
",[False]
GO-2022-0586,hashicorp,go-getter,a2ebce998f8d4105bd4b78d6c99a12803ad97a45," func (c *Client) Get() error {
 			return err
 		}
 
-		return copyDir(c.Ctx, realDst, subDir, false, c.umask())
+		return copyDir(c.Ctx, realDst, subDir, false, c.DisableSymlinks, c.umask())
 	}
 
 	return nil
",[False]
GO-2022-0586,hashicorp,go-getter,a2ebce998f8d4105bd4b78d6c99a12803ad97a45," func mode(mode, umask os.FileMode) os.FileMode {
 // should already exist.
 //
 // If ignoreDot is set to true, then dot-prefixed files/folders are ignored.
-func copyDir(ctx context.Context, dst string, src string, ignoreDot bool, umask os.FileMode) error {
-	src, err := filepath.EvalSymlinks(src)
+func copyDir(ctx context.Context, dst string, src string, ignoreDot bool, disableSymlinks bool, umask os.FileMode) error {
+	// We can safely evaluate the symlinks here, even if disabled, because they
+	// will be checked before actual use in walkFn and copyFile
+	var err error
+	src, err = filepath.EvalSymlinks(src)
 	if err != nil {
 		return err
 	}
",[False]
GO-2022-0586,hashicorp,go-getter,a2ebce998f8d4105bd4b78d6c99a12803ad97a45," func copyDir(ctx context.Context, dst string, src string, ignoreDot bool, umask
 		if err != nil {
 			return err
 		}
+
+		if disableSymlinks {
+			fileInfo, err := os.Lstat(path)
+			if err != nil {
+				return fmt.Errorf(""failed to check copy file source for symlinks: %w"", err)
+			}
+			if fileInfo.Mode()&os.ModeSymlink == os.ModeSymlink {
+				return ErrSymlinkCopy
+			}
+			// if info.Mode()&os.ModeSymlink == os.ModeSymlink {
+			// 	return ErrSymlinkCopy
+			// }
+		}
+
 		if path == src {
 			return nil
 		}
",[False]
GO-2022-0586,hashicorp,go-getter,a2ebce998f8d4105bd4b78d6c99a12803ad97a45," func copyDir(ctx context.Context, dst string, src string, ignoreDot bool, umask
 		}
 
 		// If we have a file, copy the contents.
-		_, err = copyFile(ctx, dstPath, path, info.Mode(), umask)
+		_, err = copyFile(ctx, dstPath, path, disableSymlinks, info.Mode(), umask)
 		return err
 	}
 
",[False]
GO-2022-0586,hashicorp,go-getter,a2ebce998f8d4105bd4b78d6c99a12803ad97a45," func copyReader(dst string, src io.Reader, fmode, umask os.FileMode) error {
 }
 
 // copyFile copies a file in chunks from src path to dst path, using umask to create the dst file
-func copyFile(ctx context.Context, dst, src string, fmode, umask os.FileMode) (int64, error) {
+func copyFile(ctx context.Context, dst, src string, disableSymlinks bool, fmode, umask os.FileMode) (int64, error) {
+	if disableSymlinks {
+		fileInfo, err := os.Lstat(src)
+		if err != nil {
+			return 0, fmt.Errorf(""failed to check copy file source for symlinks: %w"", err)
+		}
+		if fileInfo.Mode()&os.ModeSymlink == os.ModeSymlink {
+			return 0, ErrSymlinkCopy
+		}
+	}
+
 	srcF, err := os.Open(src)
 	if err != nil {
 		return 0, err
",[False]
GO-2022-0586,hashicorp,go-getter,a2ebce998f8d4105bd4b78d6c99a12803ad97a45," func (g *FileGetter) GetFile(dst string, u *url.URL) error {
 		return os.Symlink(path, dst)
 	}
 
+	var disableSymlinks bool
+
+	if g.client != nil && g.client.DisableSymlinks {
+		disableSymlinks = true
+	}
+
 	// Copy
-	_, err = copyFile(ctx, dst, path, fi.Mode(), g.client.umask())
+	_, err = copyFile(ctx, dst, path, disableSymlinks, fi.Mode(), g.client.umask())
 	return err
 }
",[False]
GO-2022-0586,hashicorp,go-getter,a2ebce998f8d4105bd4b78d6c99a12803ad97a45," func (g *FileGetter) GetFile(dst string, u *url.URL) error {
 		}
 	}
 
+	var disableSymlinks bool
+
+	if g.client != nil && g.client.DisableSymlinks {
+		disableSymlinks = true
+	}
+
 	// Copy
-	_, err = copyFile(ctx, dst, path, 0666, g.client.umask())
+	_, err = copyFile(ctx, dst, path, disableSymlinks, 0666, g.client.umask())
 	return err
 }
 
",[False]
GO-2022-0586,hashicorp,go-getter,a2ebce998f8d4105bd4b78d6c99a12803ad97a45," import (
 // a GCS bucket.
 type GCSGetter struct {
 	getter
+
+	// Timeout sets a deadline which all GCS operations should
+	// complete within. Zero value means no timeout.
+	Timeout time.Duration
 }
 
 func (g *GCSGetter) ClientMode(u *url.URL) (ClientMode, error) {
 	ctx := g.Context()
 
+	if g.Timeout > 0 {
+		var cancel context.CancelFunc
+		ctx, cancel = context.WithTimeout(ctx, g.Timeout)
+		defer cancel()
+	}
+
 	// Parse URL
 	bucket, object, _, err := g.parseURL(u)
 	if err != nil {
",[False]
GO-2022-0586,hashicorp,go-getter,a2ebce998f8d4105bd4b78d6c99a12803ad97a45," func (g *GCSGetter) ClientMode(u *url.URL) (ClientMode, error) {
 func (g *GCSGetter) Get(dst string, u *url.URL) error {
 	ctx := g.Context()
 
+	if g.Timeout > 0 {
+		var cancel context.CancelFunc
+		ctx, cancel = context.WithTimeout(ctx, g.Timeout)
+		defer cancel()
+	}
+
 	// Parse URL
 	bucket, object, _, err := g.parseURL(u)
 	if err != nil {
",[False]
GO-2022-0586,hashicorp,go-getter,a2ebce998f8d4105bd4b78d6c99a12803ad97a45," func (g *GCSGetter) Get(dst string, u *url.URL) error {
 func (g *GCSGetter) GetFile(dst string, u *url.URL) error {
 	ctx := g.Context()
 
+	if g.Timeout > 0 {
+		var cancel context.CancelFunc
+		ctx, cancel = context.WithTimeout(ctx, g.Timeout)
+		defer cancel()
+	}
+
 	// Parse URL
 	bucket, object, fragment, err := g.parseURL(u)
 	if err != nil {
",[False]
GO-2022-0586,hashicorp,go-getter,a2ebce998f8d4105bd4b78d6c99a12803ad97a45," func (g *GitGetter) ClientMode(_ *url.URL) (ClientMode, error) {
 
 func (g *GitGetter) Get(dst string, u *url.URL) error {
 	ctx := g.Context()
+
+	if g.Timeout > 0 {
+		var cancel context.CancelFunc
+		ctx, cancel = context.WithTimeout(ctx, g.Timeout)
+		defer cancel()
+	}
+
 	if _, err := exec.LookPath(""git""); err != nil {
 		return fmt.Errorf(""git must be available and on the PATH"")
 	}
",[False]
GO-2022-0586,hashicorp,go-getter,a2ebce998f8d4105bd4b78d6c99a12803ad97a45," func (g *GitGetter) Get(dst string, u *url.URL) error {
 	var sshKeyFile string
 	if sshKey != """" {
 		// Check that the git version is sufficiently new.
-		if err := checkGitVersion(""2.3""); err != nil {
+		if err := checkGitVersion(ctx, ""2.3""); err != nil {
 			return fmt.Errorf(""Error using ssh key: %v"", err)
 		}
 
",[False]
GO-2022-0586,hashicorp,go-getter,a2ebce998f8d4105bd4b78d6c99a12803ad97a45," func (g *GitGetter) Get(dst string, u *url.URL) error {
 
 	// Next: check out the proper tag/branch if it is specified, and checkout
 	if ref != """" {
-		if err := g.checkout(dst, ref); err != nil {
+		if err := g.checkout(ctx, dst, ref); err != nil {
 			return err
 		}
 	}
",[False]
GO-2022-0586,hashicorp,go-getter,a2ebce998f8d4105bd4b78d6c99a12803ad97a45," func (g *GitGetter) GetFile(dst string, u *url.URL) error {
 	return fg.GetFile(dst, u)
 }
 
-func (g *GitGetter) checkout(dst string, ref string) error {
-	cmd := exec.Command(""git"", ""checkout"", ref)
+func (g *GitGetter) checkout(ctx context.Context, dst string, ref string) error {
+	cmd := exec.CommandContext(ctx, ""git"", ""checkout"", ref)
 	cmd.Dir = dst
 	return getRunCommand(cmd)
 }
",[False]
GO-2022-0586,hashicorp,go-getter,a2ebce998f8d4105bd4b78d6c99a12803ad97a45," func (g *GitGetter) clone(ctx context.Context, dst, sshKeyFile string, u *url.UR
 
 	originalRef := ref // we handle an unspecified ref differently than explicitly selecting the default branch below
 	if ref == """" {
-		ref = findRemoteDefaultBranch(u)
+		ref = findRemoteDefaultBranch(ctx, u)
 	}
 	if depth > 0 {
 		args = append(args, ""--depth"", strconv.Itoa(depth))
",[False]
GO-2022-0586,hashicorp,go-getter,a2ebce998f8d4105bd4b78d6c99a12803ad97a45," func (g *GitGetter) clone(ctx context.Context, dst, sshKeyFile string, u *url.UR
 		// If we didn't add --depth and --branch above then we will now be
 		// on the remote repository's default branch, rather than the selected
 		// ref, so we'll need to fix that before we return.
-		return g.checkout(dst, originalRef)
+		return g.checkout(ctx, dst, originalRef)
 	}
 	return nil
 }
",[False]
GO-2022-0586,hashicorp,go-getter,a2ebce998f8d4105bd4b78d6c99a12803ad97a45," func (g *GitGetter) update(ctx context.Context, dst, sshKeyFile, ref string, dep
 		// Not a branch, switch to default branch. This will also catch
 		// non-existent branches, in which case we want to switch to default
 		// and then checkout the proper branch later.
-		ref = findDefaultBranch(dst)
+		ref = findDefaultBranch(ctx, dst)
 	}
 
 	// We have to be on a branch to pull
-	if err := g.checkout(dst, ref); err != nil {
+	if err := g.checkout(ctx, dst, ref); err != nil {
 		return err
 	}
 
 	if depth > 0 {
-		cmd = exec.Command(""git"", ""pull"", ""--depth"", strconv.Itoa(depth), ""--ff-only"")
+		cmd = exec.CommandContext(ctx, ""git"", ""pull"", ""--depth"", strconv.Itoa(depth), ""--ff-only"")
 	} else {
-		cmd = exec.Command(""git"", ""pull"", ""--ff-only"")
+		cmd = exec.CommandContext(ctx, ""git"", ""pull"", ""--ff-only"")
 	}
 
 	cmd.Dir = dst
",[False]
GO-2022-0586,hashicorp,go-getter,a2ebce998f8d4105bd4b78d6c99a12803ad97a45," func (g *GitGetter) fetchSubmodules(ctx context.Context, dst, sshKeyFile string,
 // findDefaultBranch checks the repo's origin remote for its default branch
 // (generally ""master""). ""master"" is returned if an origin default branch
 // can't be determined.
-func findDefaultBranch(dst string) string {
+func findDefaultBranch(ctx context.Context, dst string) string {
 	var stdoutbuf bytes.Buffer
-	cmd := exec.Command(""git"", ""branch"", ""-r"", ""--points-at"", ""refs/remotes/origin/HEAD"")
+	cmd := exec.CommandContext(ctx, ""git"", ""branch"", ""-r"", ""--points-at"", ""refs/remotes/origin/HEAD"")
 	cmd.Dir = dst
 	cmd.Stdout = &stdoutbuf
 	err := cmd.Run()
",[False]
GO-2022-0586,hashicorp,go-getter,a2ebce998f8d4105bd4b78d6c99a12803ad97a45," func findDefaultBranch(dst string) string {
 
 // findRemoteDefaultBranch checks the remote repo's HEAD symref to return the remote repo's
 // default branch. ""master"" is returned if no HEAD symref exists.
-func findRemoteDefaultBranch(u *url.URL) string {
+func findRemoteDefaultBranch(ctx context.Context, u *url.URL) string {
 	var stdoutbuf bytes.Buffer
-	cmd := exec.Command(""git"", ""ls-remote"", ""--symref"", u.String(), ""HEAD"")
+	cmd := exec.CommandContext(ctx, ""git"", ""ls-remote"", ""--symref"", u.String(), ""HEAD"")
 	cmd.Stdout = &stdoutbuf
 	err := cmd.Run()
 	matches := lsRemoteSymRefRegexp.FindStringSubmatch(stdoutbuf.String())
",[False]
GO-2022-0586,hashicorp,go-getter,a2ebce998f8d4105bd4b78d6c99a12803ad97a45," func setupGitEnv(cmd *exec.Cmd, sshKeyFile string) {
 // checkGitVersion is used to check the version of git installed on the system
 // against a known minimum version. Returns an error if the installed version
 // is older than the given minimum.
-func checkGitVersion(min string) error {
+func checkGitVersion(ctx context.Context, min string) error {
 	want, err := version.NewVersion(min)
 	if err != nil {
 		return err
 	}
 
-	out, err := exec.Command(""git"", ""version"").Output()
+	out, err := exec.CommandContext(ctx, ""git"", ""version"").Output()
 	if err != nil {
 		return err
 	}
",[False]
GO-2022-0586,hashicorp,go-getter,a2ebce998f8d4105bd4b78d6c99a12803ad97a45," func (g *HgGetter) ClientMode(_ *url.URL) (ClientMode, error) {
 
 func (g *HgGetter) Get(dst string, u *url.URL) error {
 	ctx := g.Context()
+
+	if g.Timeout > 0 {
+		var cancel context.CancelFunc
+		ctx, cancel = context.WithTimeout(ctx, g.Timeout)
+		defer cancel()
+	}
+
 	if _, err := exec.LookPath(""hg""); err != nil {
 		return fmt.Errorf(""hg must be available and on the PATH"")
 	}
",[False]
GO-2022-0586,hashicorp,go-getter,a2ebce998f8d4105bd4b78d6c99a12803ad97a45," func (g *HgGetter) Get(dst string, u *url.URL) error {
 		return err
 	}
 	if err != nil {
-		if err := g.clone(dst, newURL); err != nil {
+		if err := g.clone(ctx, dst, newURL); err != nil {
 			return err
 		}
 	}
 
-	if err := g.pull(dst, newURL); err != nil {
+	if err := g.pull(ctx, dst, newURL); err != nil {
 		return err
 	}
 
",[False]
GO-2022-0586,hashicorp,go-getter,a2ebce998f8d4105bd4b78d6c99a12803ad97a45," func (g *HgGetter) pull(dst string, u *url.URL) error {
 func (g *HgGetter) update(ctx context.Context, dst string, u *url.URL, rev string) error {
 	args := []string{""update""}
 	if rev != """" {
-		args = append(args, rev)
+		args = append(args, ""--"", rev)
 	}
 
 	cmd := exec.CommandContext(ctx, ""hg"", args...)
",[False]
GO-2022-0586,hashicorp,go-getter,a2ebce998f8d4105bd4b78d6c99a12803ad97a45," func (g *HttpGetter) Get(dst string, u *url.URL) error {
 		}
 	}
 
+	// If the HTTP client is nil, check if there is one available in the context,
+	// otherwise create one using cleanhttp's default transport.
 	if g.Client == nil {
-		g.Client = httpClient
-		if g.client != nil && g.client.Insecure {
-			insecureTransport := cleanhttp.DefaultTransport()
-			insecureTransport.TLSClientConfig = &tls.Config{InsecureSkipVerify: true}
-			g.Client.Transport = insecureTransport
+		if client := httpClientFromContext(ctx); client != nil {
+			g.Client = client
+		} else {
+			client := httpClient
+			if g.client != nil && g.client.Insecure {
+				insecureTransport := cleanhttp.DefaultTransport()
+				insecureTransport.TLSClientConfig = &tls.Config{InsecureSkipVerify: true}
+				client.Transport = insecureTransport
+			}
+			g.Client = client
 		}
 	}
 
+	// Pass along the configured HTTP client in the context for usage with the X-Terraform-Get feature.
+	ctx = context.WithValue(ctx, httpClientValue, g.Client)
+
 	// Add terraform-get to the parameter.
 	q := u.Query()
 	q.Add(""terraform-get"", ""1"")
 	u.RawQuery = q.Encode()
 
+	readCtx := ctx
+
+	if g.ReadTimeout > 0 {
+		var cancel context.CancelFunc
+		readCtx, cancel = context.WithTimeout(ctx, g.ReadTimeout)
+		defer cancel()
+	}
+
 	// Get the URL
-	req, err := http.NewRequestWithContext(ctx, ""GET"", u.String(), nil)
+	req, err := http.NewRequestWithContext(readCtx, ""GET"", u.String(), nil)
 	if err != nil {
 		return err
 	}
",[False]
GO-2022-0586,hashicorp,go-getter,a2ebce998f8d4105bd4b78d6c99a12803ad97a45," func (g *HttpGetter) Get(dst string, u *url.URL) error {
 	if err != nil {
 		return err
 	}
-
 	defer resp.Body.Close()
+
+	body := resp.Body
+
+	if maxBytes := httpMaxBytesFromContext(ctx); maxBytes > 0 {
+		body = newLimitedWrappedReaderCloser(body, maxBytes)
+	}
+
 	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
 		return fmt.Errorf(""bad response code: %d"", resp.StatusCode)
 	}
 
-	// Extract the source URL
+	if disabled := xTerraformGetDisabled(ctx); disabled {
+		return nil
+	}
+
+	// Extract the source URL,
 	var source string
 	if v := resp.Header.Get(""X-Terraform-Get""); v != """" {
 		source = v
 	} else {
-		source, err = g.parseMeta(resp.Body)
+		source, err = g.parseMeta(readCtx, body)
 		if err != nil {
 			return err
 		}
",[False]
GO-2022-0586,hashicorp,go-getter,a2ebce998f8d4105bd4b78d6c99a12803ad97a45," func (g *HttpGetter) Get(dst string, u *url.URL) error {
 	source, subDir := SourceDirSubdir(source)
 	if subDir == """" {
 		var opts []ClientOption
+
+		// Check if the protocol was switched to one which was not configured.
+		//
+		// Otherwise, all default getters are allowed.
+		if g.client != nil && g.client.Getters != nil {
+			protocol := strings.Split(source, "":"")[0]
+			_, allowed := g.client.Getters[protocol]
+			if !allowed {
+				return fmt.Errorf(""no getter available for X-Terraform-Get source protocol: %q"", protocol)
+			}
+		}
+
+		// Add any getter client options.
 		if g.client != nil {
 			opts = g.client.Options
 		}
+
+		// If the client is nil, we know we're using the HttpGetter directly. In this case,
+		// we don't know exactly which protocols are configued, but we can make a good guess.
+		//
+		// This prevents all default getters from being allowed when only using the
+		// HttpGetter directly. To enable protocol switching, a client ""wrapper"" must
+		// be used.
+		if g.client == nil {
+			opts = append(opts, WithGetters(map[string]Getter{
+				""http"":  g,
+				""https"": g,
+			}))
+		}
+
+		// Ensure we pass along the context we constructed in this function.
+		//
+		// This is especially important to enforce a limit on X-Terraform-Get redirects
+		// which could be setup, if configured, at the top of this function.
+		opts = append(opts, WithContext(ctx))
+
+		// Note: this allows the protocol to be switched to another configured getters.
 		return Get(dst, source, opts...)
 	}
 
",[False]
GO-2022-0586,hashicorp,go-getter,a2ebce998f8d4105bd4b78d6c99a12803ad97a45," func (g *HttpGetter) Get(dst string, u *url.URL) error {
 // appended.
 func (g *HttpGetter) GetFile(dst string, src *url.URL) error {
 	ctx := g.Context()
+
+	// Optionally enforce a maxiumum HTTP response body size.
+	if g.MaxBytes > 0 {
+		ctx = context.WithValue(ctx, httpMaxBytesValue, g.MaxBytes)
+	}
+
 	if g.Netrc {
 		// Add auth from netrc if we can
 		if err := addAuthFromNetrc(src); err != nil {
",[False]
GO-2022-0586,hashicorp,go-getter,a2ebce998f8d4105bd4b78d6c99a12803ad97a45," func (g *HttpGetter) GetFile(dst string, src *url.URL) error {
 		}
 	}
 
-	var currentFileSize int64
+	var (
+		currentFileSize int64
+		req             *http.Request
+	)
 
-	// We first make a HEAD request so we can check
-	// if the server supports range queries. If the server/URL doesn't
-	// support HEAD requests, we just fall back to GET.
-	req, err := http.NewRequestWithContext(ctx, ""HEAD"", src.String(), nil)
-	if err != nil {
-		return err
-	}
-	if g.Header != nil {
-		req.Header = g.Header.Clone()
-	}
-	headResp, err := g.Client.Do(req)
-	if err == nil {
-		headResp.Body.Close()
-		if headResp.StatusCode == 200 {
-			// If the HEAD request succeeded, then attempt to set the range
-			// query if we can.
-			if headResp.Header.Get(""Accept-Ranges"") == ""bytes"" && headResp.ContentLength >= 0 {
-				if fi, err := f.Stat(); err == nil {
-					if _, err = f.Seek(0, io.SeekEnd); err == nil {
-						currentFileSize = fi.Size()
-						if currentFileSize >= headResp.ContentLength {
-							// file already present
-							return nil
+	if !g.DoNotCheckHeadFirst {
+		headCtx := ctx
+
+		if g.HeadFirstTimeout > 0 {
+			var cancel context.CancelFunc
+
+			headCtx, cancel = context.WithTimeout(ctx, g.HeadFirstTimeout)
+			defer cancel()
+		}
+
+		// We first make a HEAD request so we can check
+		// if the server supports range queries. If the server/URL doesn't
+		// support HEAD requests, we just fall back to GET.
+		req, err = http.NewRequestWithContext(headCtx, ""HEAD"", src.String(), nil)
+		if err != nil {
+			return err
+		}
+		if g.Header != nil {
+			req.Header = g.Header.Clone()
+		}
+		headResp, err := g.Client.Do(req)
+		if err == nil {
+			headResp.Body.Close()
+			if headResp.StatusCode == 200 {
+				// If the HEAD request succeeded, then attempt to set the range
+				// query if we can.
+				if headResp.Header.Get(""Accept-Ranges"") == ""bytes"" && headResp.ContentLength >= 0 {
+					if fi, err := f.Stat(); err == nil {
+						if _, err = f.Seek(0, io.SeekEnd); err == nil {
+							currentFileSize = fi.Size()
+							if currentFileSize >= headResp.ContentLength {
+								// file already present
+								return nil
+							}
 						}
 					}
 				}
",[False]
GO-2022-0586,hashicorp,go-getter,a2ebce998f8d4105bd4b78d6c99a12803ad97a45," func (g *HttpGetter) GetFile(dst string, src *url.URL) error {
 		}
 	}
 
-	req, err = http.NewRequestWithContext(ctx, ""GET"", src.String(), nil)
+	readCtx := ctx
+
+	if g.ReadTimeout > 0 {
+		var cancel context.CancelFunc
+		readCtx, cancel = context.WithTimeout(ctx, g.ReadTimeout)
+		defer cancel()
+	}
+
+	req, err = http.NewRequestWithContext(readCtx, ""GET"", src.String(), nil)
 	if err != nil {
 		return err
 	}
",[False]
GO-2022-0586,hashicorp,go-getter,a2ebce998f8d4105bd4b78d6c99a12803ad97a45," func (g *HttpGetter) GetFile(dst string, src *url.URL) error {
 
 	body := resp.Body
 
+	if maxBytes := httpMaxBytesFromContext(ctx); maxBytes > 0 {
+		body = newLimitedWrappedReaderCloser(body, maxBytes)
+	}
+
 	if g.client != nil && g.client.ProgressListener != nil {
 		// track download
 		fn := filepath.Base(src.EscapedPath())
",[False]
GO-2022-0586,hashicorp,go-getter,a2ebce998f8d4105bd4b78d6c99a12803ad97a45," func (g *HttpGetter) GetFile(dst string, src *url.URL) error {
 	}
 	defer body.Close()
 
-	n, err := Copy(ctx, f, body)
+	n, err := Copy(readCtx, f, body)
 	if err == nil && n < resp.ContentLength {
 		err = io.ErrShortWrite
 	}
",[False]
GO-2022-0586,hashicorp,go-getter,a2ebce998f8d4105bd4b78d6c99a12803ad97a45," import (
 // a S3 bucket.
 type S3Getter struct {
 	getter
+
+	// Timeout sets a deadline which all S3 operations should
+	// complete within. Zero value means no timeout.
+	Timeout time.Duration
 }
 
 func (g *S3Getter) ClientMode(u *url.URL) (ClientMode, error) {
 	// Parse URL
+	ctx := g.Context()
+
+	if g.Timeout > 0 {
+		var cancel context.CancelFunc
+		ctx, cancel = context.WithTimeout(ctx, g.Timeout)
+		defer cancel()
+	}
+
 	region, bucket, path, _, creds, err := g.parseUrl(u)
 	if err != nil {
 		return 0, err
",[False]
GO-2022-0586,hashicorp,go-getter,a2ebce998f8d4105bd4b78d6c99a12803ad97a45," func (g *S3Getter) ClientMode(u *url.URL) (ClientMode, error) {
 		Bucket: aws.String(bucket),
 		Prefix: aws.String(path),
 	}
-	resp, err := client.ListObjects(req)
+	resp, err := client.ListObjectsWithContext(ctx, req)
 	if err != nil {
 		return 0, err
 	}
",[False]
GO-2022-0586,hashicorp,go-getter,a2ebce998f8d4105bd4b78d6c99a12803ad97a45," func (g *S3Getter) ClientMode(u *url.URL) (ClientMode, error) {
 func (g *S3Getter) Get(dst string, u *url.URL) error {
 	ctx := g.Context()
 
+	if g.Timeout > 0 {
+		var cancel context.CancelFunc
+		ctx, cancel = context.WithTimeout(ctx, g.Timeout)
+		defer cancel()
+	}
+
 	// Parse URL
 	region, bucket, path, _, creds, err := g.parseUrl(u)
 	if err != nil {
",[False]
GO-2022-0586,hashicorp,go-getter,a2ebce998f8d4105bd4b78d6c99a12803ad97a45," func (g *S3Getter) Get(dst string, u *url.URL) error {
 			req.Marker = aws.String(lastMarker)
 		}
 
-		resp, err := client.ListObjects(req)
+		resp, err := client.ListObjectsWithContext(ctx, req)
 		if err != nil {
 			return err
 		}
",[False]
GO-2022-0586,hashicorp,go-getter,a2ebce998f8d4105bd4b78d6c99a12803ad97a45," func (g *S3Getter) Get(dst string, u *url.URL) error {
 
 func (g *S3Getter) GetFile(dst string, u *url.URL) error {
 	ctx := g.Context()
+
+	if g.Timeout > 0 {
+		var cancel context.CancelFunc
+		ctx, cancel = context.WithTimeout(ctx, g.Timeout)
+		defer cancel()
+	}
+
 	region, bucket, path, version, creds, err := g.parseUrl(u)
 	if err != nil {
 		return err
",[False]
GO-2022-0586,hashicorp,go-getter,a2ebce998f8d4105bd4b78d6c99a12803ad97a45," func (g *S3Getter) getObject(ctx context.Context, client *s3.S3, dst, bucket, ke
 		req.VersionId = aws.String(version)
 	}
 
-	resp, err := client.GetObject(req)
+	resp, err := client.GetObjectWithContext(ctx, req)
 	if err != nil {
 		return err
 	}
",[False]
GO-2022-0586,hashicorp,go-getter,a2ebce998f8d4105bd4b78d6c99a12803ad97a45," func SourceDirSubdir(src string) (string, string) {
 //
 // The returned path is the full absolute path.
 func SubdirGlob(dst, subDir string) (string, error) {
-	matches, err := filepath.Glob(filepath.Join(dst, subDir))
+	pattern := filepath.Join(dst, subDir)
+
+	matches, err := filepath.Glob(pattern)
 	if err != nil {
 		return """", err
 	}
",[False]
GO-2020-0027,google,fscrypt,3022c1603d968c22f147b4a2c49c4637dd1be91b," func NewHandle(pamh unsafe.Pointer) (*Handle, error) {
 		return nil, err
 	}
 
-	if h.PamUser, err = user.Lookup(C.GoString(pamUsername)); err != nil {
-		return nil, err
-	}
-	if h.OrigUser, err = util.EffectiveUser(); err != nil {
-		return nil, err
-	}
-	return h, nil
+	h.PamUser, err = user.Lookup(C.GoString(pamUsername))
+	return h, err
 }
 
 func (h *Handle) setData(name string, data unsafe.Pointer, cleanup C.CleanupFunc) error {
",[True]
GO-2021-0101,apache,thrift,264a3f318ed3e9e51573f67f963c8509786bcec2," func (p *TSimpleJSONProtocol) readNumeric() (Numeric, error) {
 func (p *TSimpleJSONProtocol) safePeekContains(b []byte) bool {
 	for i := 0; i < len(b); i++ {
 		a, _ := p.reader.Peek(i + 1)
-		if len(a) == 0 || a[i] != b[i] {
+		if len(a) < (i+1) || a[i] != b[i] {
 			return false
 		}
 	}
",[True]
GO-2020-0006,miekg,dns,43913f2f4fbd7dcff930b8a809e709591e4dd79e," func (srv *Server) serveTCP(l net.Listener) error {
 			}
 			return err
 		}
-		m, err := reader.ReadTCP(rw, rtimeout)
-		if err != nil {
-			continue
-		}
-		go srv.serve(rw.RemoteAddr(), handler, m, nil, nil, rw)
+		go func() {
+			m, err := reader.ReadTCP(rw, rtimeout)
+			if err != nil {
+				rw.Close()
+				return
+			}
+			srv.serve(rw.RemoteAddr(), handler, m, nil, nil, rw)
+		}()
 	}
 }
 
",[True]
GO-2021-0070,opencontainers,runc,69af385de62ea68e2e608335cffbb0f4aa3db091," func GetExecUserPath(userSpec string, defaults *ExecUser, passwdPath, groupPath
 //     * ""uid:gid
 //     * ""user:gid""
 //     * ""uid:group""
+//
+// It should be noted that if you specify a numeric user or group id, they will
+// not be evaluated as usernames (only the metadata will be filled). So attempting
+// to parse a user with user.Name = ""1337"" will produce the user with a UID of
+// 1337.
 func GetExecUser(userSpec string, defaults *ExecUser, passwd, group io.Reader) (*ExecUser, error) {
 	var (
 		userArg, groupArg string
-		name              string
 	)
 
 	if defaults == nil {
",[True]
GO-2021-0070,opencontainers,runc,69af385de62ea68e2e608335cffbb0f4aa3db091," func GetExecUser(userSpec string, defaults *ExecUser, passwd, group io.Reader) (
 	// allow for userArg to have either ""user"" syntax, or optionally ""user:group"" syntax
 	parseLine(userSpec, &userArg, &groupArg)
 
+	// Convert userArg and groupArg to be numeric, so we don't have to execute
+	// Atoi *twice* for each iteration over lines.
+	uidArg, uidErr := strconv.Atoi(userArg)
+	gidArg, gidErr := strconv.Atoi(groupArg)
+
 	users, err := ParsePasswdFilter(passwd, func(u User) bool {
 		if userArg == """" {
 			return u.Uid == user.Uid
 		}
-		return u.Name == userArg || strconv.Itoa(u.Uid) == userArg
+
+		if uidErr == nil {
+			// If the userArg is numeric, always treat it as a UID.
+			return uidArg == u.Uid
+		}
+
+		return u.Name == userArg
 	})
 	if err != nil && passwd != nil {
 		if userArg == """" {
",[True]
GO-2021-0070,opencontainers,runc,69af385de62ea68e2e608335cffbb0f4aa3db091," func GetExecUser(userSpec string, defaults *ExecUser, passwd, group io.Reader) (
 		return nil, fmt.Errorf(""Unable to find user %v: %v"", userArg, err)
 	}
 
-	haveUser := users != nil && len(users) > 0
-	if haveUser {
-		// if we found any user entries that matched our filter, let's take the first one as ""correct""
-		name = users[0].Name
+	var matchedUserName string
+	if len(users) > 0 {
+		// First match wins, even if there's more than one matching entry.
+		matchedUserName = users[0].Name
 		user.Uid = users[0].Uid
 		user.Gid = users[0].Gid
 		user.Home = users[0].Home
 	} else if userArg != """" {
-		// we asked for a user but didn't find them...  let's check to see if we wanted a numeric user
-		user.Uid, err = strconv.Atoi(userArg)
-		if err != nil {
-			// not numeric - we have to bail
-			return nil, fmt.Errorf(""Unable to find user %v"", userArg)
+		// If we can't find a user with the given username, the only other valid
+		// option is if it's a numeric username with no associated entry in passwd.
+
+		if uidErr != nil {
+			// Not numeric.
+			return nil, fmt.Errorf(""unable to find user %s: %v"", userArg, ErrNoPasswdEntries)
 		}
+		user.Uid = uidArg
 
 		// Must be inside valid uid range.
 		if user.Uid < minId || user.Uid > maxId {
 			return nil, ErrRange
 		}
 
-		// if userArg couldn't be found in /etc/passwd but is numeric, just roll with it - this is legit
+		// Okay, so it's numeric. We can just roll with this.
 	}
 
-	if groupArg != """" || name != """" {
+	// On to the groups. If we matched a username, we need to do this because of
+	// the supplementary group IDs.
+	if groupArg != """" || matchedUserName != """" {
 		groups, err := ParseGroupFilter(group, func(g Group) bool {
-			// Explicit group format takes precedence.
-			if groupArg != """" {
-				return g.Name == groupArg || strconv.Itoa(g.Gid) == groupArg
+			// If the group argument isn't explicit, we'll just search for it.
+			if groupArg == """" {
+				// Check if user is a member of this group.
+				for _, u := range g.List {
+					if u == matchedUserName {
+						return true
+					}
+				}
+				return false
 			}
 
-			// Check if user is a member.
-			for _, u := range g.List {
-				if u == name {
-					return true
-				}
+			if gidErr == nil {
+				// If the groupArg is numeric, always treat it as a GID.
+				return gidArg == g.Gid
 			}
 
-			return false
+			return g.Name == groupArg
 		})
 		if err != nil && group != nil {
-			return nil, fmt.Errorf(""Unable to find groups for user %v: %v"", users[0].Name, err)
+			return nil, fmt.Errorf(""unable to find groups for spec %v: %v"", matchedUserName, err)
 		}
 
 		haveGroup := groups != nil && len(groups) > 0
",[True]
GO-2021-0070,opencontainers,runc,69af385de62ea68e2e608335cffbb0f4aa3db091," func GetExecUser(userSpec string, defaults *ExecUser, passwd, group io.Reader) (
 			if haveGroup {
 				// if we found any group entries that matched our filter, let's take the first one as ""correct""
 				user.Gid = groups[0].Gid
-			} else {
-				// we asked for a group but didn't find id...  let's check to see if we wanted a numeric group
-				user.Gid, err = strconv.Atoi(groupArg)
-				if err != nil {
-					// not numeric - we have to bail
-					return nil, fmt.Errorf(""Unable to find group %v"", groupArg)
+			} else if groupArg != """" {
+				// If we can't find a group with the given name, the only other valid
+				// option is if it's a numeric group name with no associated entry in group.
+
+				if gidErr != nil {
+					// Not numeric.
+					return nil, fmt.Errorf(""unable to find group %s: %v"", groupArg, ErrNoGroupEntries)
 				}
+				user.Gid = gidArg
 
 				// Ensure gid is inside gid range.
 				if user.Gid < minId || user.Gid > maxId {
 					return nil, ErrRange
 				}
 
-				// if groupArg couldn't be found in /etc/group but is numeric, just roll with it - this is legit
+				// Okay, so it's numeric. We can just roll with this.
 			}
-		} else if haveGroup {
-			// If implicit group format, fill supplementary gids.
+		} else if len(groups) > 0 {
+			// Supplementary group ids only make sense if in the implicit form.
 			user.Sgids = make([]int, len(groups))
 			for i, group := range groups {
 				user.Sgids[i] = group.Gid
",[True]
GO-2023-2074,gomarkdown,markdown,14b16010c2ee7ff33a940a541d993bd043a88940," func (p *Parser) Block(data []byte) {
 		// <div>
 		//     ...
 		// </div>
+
+		if len(data) == 0 {
+			continue
+		}
+
 		if data[0] == '<' {
 			if i := p.html(data, true); i > 0 {
 				data = data[i:]
",[False]
GO-2023-2074,gomarkdown,markdown,14b16010c2ee7ff33a940a541d993bd043a88940," func (p *Parser) AddBlock(n ast.Node) ast.Node {
 }
 
 func (p *Parser) isPrefixHeading(data []byte) bool {
-	if data[0] != '#' {
+	if len(data) > 0 && data[0] != '#' {
 		return false
 	}
 
",[True]
GO-2023-2074,gomarkdown,markdown,14b16010c2ee7ff33a940a541d993bd043a88940," func citation(p *Parser, data []byte, offset int) (int, ast.Node) {
 		}
 
 		citeType := ast.CitationTypeInformative
+
+		if len(citation) < 2 {
+			continue
+		}
+
 		j = 1
 		switch citation[j] {
 		case '!':
",[True]
GO-2021-0237,AndrewBurian,powermux,5e60a8a0372b35a898796c2697c40e8daabed8e9," func newRoute() *Route {
 // a route.
 func (r *Route) execute(ex *routeExecution, method, pattern string) {
 
+	if strings.Contains(pattern, ""//"") {
+		ex.handler = r.badRequest(""Invalid path"")
+		return
+	}
+
 	pathParts := pathPartsPool.Get().([]string)[0:0]
+	defer pathPartsPool.Put(pathParts)
 	pathParts = append(pathParts, """")
 	start := 1
 	for i := 1; i < len(pattern); i++ {
",[True]
GO-2021-0237,AndrewBurian,powermux,5e60a8a0372b35a898796c2697c40e8daabed8e9," func (r *Route) execute(ex *routeExecution, method, pattern string) {
 		}
 	}
 
+	// redirect trailing slashes
+	if pattern != ""/"" && strings.HasSuffix(pattern, ""/"") {
+		target := strings.TrimSuffix(pattern, ""/"")
+		ex.handler = http.RedirectHandler(target, http.StatusPermanentRedirect)
+		ex.pattern = target
+		return
+	}
+
 	// get the trailing path param
 	if pattern != ""/"" {
 		pathParts = append(pathParts, pattern[start:])
",[True]
GO-2021-0237,AndrewBurian,powermux,5e60a8a0372b35a898796c2697c40e8daabed8e9," func (r *Route) execute(ex *routeExecution, method, pattern string) {
 	// Fill the execution
 	r.getExecution(method, pathParts, ex)
 
-	// return path parts
-	pathPartsPool.Put(pathParts)
 }
 
 // getExecution is a recursive step in the tree traversal. It checks to see if this node matches,
",[True]
GO-2021-0237,AndrewBurian,powermux,5e60a8a0372b35a898796c2697c40e8daabed8e9," func NewServeMux() *ServeMux {
 func (s *ServeMux) getAll(r *http.Request, ex *routeExecution) {
 	path := r.URL.EscapedPath()
 
-	// Check for redirect
-	if path != ""/"" && strings.HasSuffix(path, ""/"") {
-		r.URL.Path = strings.TrimRight(path, ""/"")
-		ex.handler = http.RedirectHandler(r.URL.RequestURI(), http.StatusPermanentRedirect)
-		ex.pattern = r.URL.EscapedPath()
-		return
-	}
-
 	// fill it
 	if route, ok := s.hostRoutes[r.URL.Host]; ok {
 		route.execute(ex, r.Method, path)
",[False]
GO-2022-0978,open-policy-agent,opa,25a597bc3f4985162e7f65f9c36599f4f8f55823," func (c *Compiler) rewriteWithModifiers() {
 			if !ok {
 				return x, nil
 			}
-			body, err := rewriteWithModifiersInBody(c, f, body)
+			body, err := rewriteWithModifiersInBody(c, c.unsafeBuiltinsMap, f, body)
 			if err != nil {
 				c.err(err)
 			}
",[True]
GO-2022-0978,open-policy-agent,opa,25a597bc3f4985162e7f65f9c36599f4f8f55823," func (qc *queryCompiler) checkDeprecatedBuiltins(_ *QueryContext, body Body) (Bo
 
 func (qc *queryCompiler) rewriteWithModifiers(_ *QueryContext, body Body) (Body, error) {
 	f := newEqualityFactory(newLocalVarGenerator(""q"", body))
-	body, err := rewriteWithModifiersInBody(qc.compiler, f, body)
+	body, err := rewriteWithModifiersInBody(qc.compiler, qc.unsafeBuiltinsMap(), f, body)
 	if err != nil {
 		return nil, Errors{err}
 	}
",[False]
GO-2022-0978,open-policy-agent,opa,25a597bc3f4985162e7f65f9c36599f4f8f55823," func rewriteDeclaredVar(g *localVarGenerator, stack *localDeclaredVars, v Var, o
 // rewriteWithModifiersInBody will rewrite the body so that with modifiers do
 // not contain terms that require evaluation as values. If this function
 // encounters an invalid with modifier target then it will raise an error.
-func rewriteWithModifiersInBody(c *Compiler, f *equalityFactory, body Body) (Body, *Error) {
+func rewriteWithModifiersInBody(c *Compiler, unsafeBuiltinsMap map[string]struct{}, f *equalityFactory, body Body) (Body, *Error) {
 	var result Body
 	for i := range body {
-		exprs, err := rewriteWithModifier(c, f, body[i])
+		exprs, err := rewriteWithModifier(c, unsafeBuiltinsMap, f, body[i])
 		if err != nil {
 			return nil, err
 		}
",[True]
GO-2022-0978,open-policy-agent,opa,25a597bc3f4985162e7f65f9c36599f4f8f55823," func rewriteWithModifiersInBody(c *Compiler, f *equalityFactory, body Body) (Bod
 	return result, nil
 }
 
-func rewriteWithModifier(c *Compiler, f *equalityFactory, expr *Expr) ([]*Expr, *Error) {
+func rewriteWithModifier(c *Compiler, unsafeBuiltinsMap map[string]struct{}, f *equalityFactory, expr *Expr) ([]*Expr, *Error) {
 
 	var result []*Expr
 	for i := range expr.With {
-		eval, err := validateWith(c, expr, i)
+		eval, err := validateWith(c, unsafeBuiltinsMap, expr, i)
 		if err != nil {
 			return nil, err
 		}
",[True]
GO-2022-0978,open-policy-agent,opa,25a597bc3f4985162e7f65f9c36599f4f8f55823," func rewriteWithModifier(c *Compiler, f *equalityFactory, expr *Expr) ([]*Expr,
 	return append(result, expr), nil
 }
 
-func validateWith(c *Compiler, expr *Expr, i int) (bool, *Error) {
+func validateWith(c *Compiler, unsafeBuiltinsMap map[string]struct{}, expr *Expr, i int) (bool, *Error) {
 	target, value := expr.With[i].Target, expr.With[i].Value
 
 	// Ensure that values that are built-ins are rewritten to Ref (not Var)
",[True]
GO-2022-0978,open-policy-agent,opa,25a597bc3f4985162e7f65f9c36599f4f8f55823," func validateWith(c *Compiler, expr *Expr, i int) (bool, *Error) {
 			value.Value = Ref([]*Term{NewTerm(v)})
 		}
 	}
+	isBuiltinRefOrVar, err := isBuiltinRefOrVar(c.builtins, unsafeBuiltinsMap, target)
+	if err != nil {
+		return false, err
+	}
 
 	switch {
 	case isDataRef(target):
",[True]
GO-2022-0978,open-policy-agent,opa,25a597bc3f4985162e7f65f9c36599f4f8f55823," func validateWith(c *Compiler, expr *Expr, i int) (bool, *Error) {
 			if child := node.Child(ref[len(ref)-1].Value); child != nil {
 				for _, v := range child.Values {
 					if len(v.(*Rule).Head.Args) > 0 {
-						if validateWithFunctionValue(c.builtins, c.RuleTree, value) {
-							return false, nil
+						if ok, err := validateWithFunctionValue(c.builtins, unsafeBuiltinsMap, c.RuleTree, value); err != nil || ok {
+							return false, err // may be nil
 						}
 					}
 				}
 			}
 		}
 	case isInputRef(target): // ok, valid
-	case isBuiltinRefOrVar(c.builtins, target):
+	case isBuiltinRefOrVar:
 
 		// NOTE(sr): first we ensure that parsed Var builtins (`count`, `concat`, etc)
 		// are rewritten to their proper Ref convention
",[True]
GO-2022-0978,open-policy-agent,opa,25a597bc3f4985162e7f65f9c36599f4f8f55823," func validateWith(c *Compiler, expr *Expr, i int) (bool, *Error) {
 			return false, err
 		}
 
-		if validateWithFunctionValue(c.builtins, c.RuleTree, value) {
-			return false, nil
+		if ok, err := validateWithFunctionValue(c.builtins, unsafeBuiltinsMap, c.RuleTree, value); err != nil || ok {
+			return false, err // may be nil
 		}
 	default:
 		return false, NewError(TypeErr, target.Location, ""with keyword target must reference existing %v, %v, or a function"", InputRootDocument, DefaultRootDocument)
",[True]
GO-2022-0978,open-policy-agent,opa,25a597bc3f4985162e7f65f9c36599f4f8f55823," func validateWithBuiltinTarget(bi *Builtin, target Ref, loc *location.Location)
 	return nil
 }
 
-func validateWithFunctionValue(bs map[string]*Builtin, ruleTree *TreeNode, value *Term) bool {
+func validateWithFunctionValue(bs map[string]*Builtin, unsafeMap map[string]struct{}, ruleTree *TreeNode, value *Term) (bool, *Error) {
 	if v, ok := value.Value.(Ref); ok {
 		if ruleTree.Find(v) != nil { // ref exists in rule tree
-			return true
+			return true, nil
 		}
 	}
-	return isBuiltinRefOrVar(bs, value)
+	return isBuiltinRefOrVar(bs, unsafeMap, value)
 }
 
 func isInputRef(term *Term) bool {
",[True]
GO-2022-0978,open-policy-agent,opa,25a597bc3f4985162e7f65f9c36599f4f8f55823," func isDataRef(term *Term) bool {
 	return false
 }
 
-func isBuiltinRefOrVar(bs map[string]*Builtin, term *Term) bool {
+func isBuiltinRefOrVar(bs map[string]*Builtin, unsafeBuiltinsMap map[string]struct{}, term *Term) (bool, *Error) {
 	switch v := term.Value.(type) {
 	case Ref, Var:
+		if _, ok := unsafeBuiltinsMap[v.String()]; ok {
+			return false, NewError(CompileErr, term.Location, ""with keyword replacing built-in function: target must not be unsafe: %q"", v)
+		}
 		_, ok := bs[v.String()]
-		return ok
+		return ok, nil
 	}
-	return false
+	return false, nil
 }
 
 func isVirtual(node *TreeNode, ref Ref) bool {
",[True]
GO-2022-0978,open-policy-agent,opa,3e8c754ed007b22393cf65e48751ad9f6457fee8," func (c *Compiler) rewriteWithModifiers() {
 			if !ok {
 				return x, nil
 			}
-			body, err := rewriteWithModifiersInBody(c, f, body)
+			body, err := rewriteWithModifiersInBody(c, c.unsafeBuiltinsMap, f, body)
 			if err != nil {
 				c.err(err)
 			}
",[True]
GO-2022-0978,open-policy-agent,opa,3e8c754ed007b22393cf65e48751ad9f6457fee8," func (qc *queryCompiler) checkDeprecatedBuiltins(_ *QueryContext, body Body) (Bo
 
 func (qc *queryCompiler) rewriteWithModifiers(_ *QueryContext, body Body) (Body, error) {
 	f := newEqualityFactory(newLocalVarGenerator(""q"", body))
-	body, err := rewriteWithModifiersInBody(qc.compiler, f, body)
+	body, err := rewriteWithModifiersInBody(qc.compiler, qc.unsafeBuiltinsMap(), f, body)
 	if err != nil {
 		return nil, Errors{err}
 	}
",[False]
GO-2022-0978,open-policy-agent,opa,3e8c754ed007b22393cf65e48751ad9f6457fee8," func rewriteDeclaredVar(g *localVarGenerator, stack *localDeclaredVars, v Var, o
 // rewriteWithModifiersInBody will rewrite the body so that with modifiers do
 // not contain terms that require evaluation as values. If this function
 // encounters an invalid with modifier target then it will raise an error.
-func rewriteWithModifiersInBody(c *Compiler, f *equalityFactory, body Body) (Body, *Error) {
+func rewriteWithModifiersInBody(c *Compiler, unsafeBuiltinsMap map[string]struct{}, f *equalityFactory, body Body) (Body, *Error) {
 	var result Body
 	for i := range body {
-		exprs, err := rewriteWithModifier(c, f, body[i])
+		exprs, err := rewriteWithModifier(c, unsafeBuiltinsMap, f, body[i])
 		if err != nil {
 			return nil, err
 		}
",[True]
GO-2022-0978,open-policy-agent,opa,3e8c754ed007b22393cf65e48751ad9f6457fee8," func rewriteWithModifiersInBody(c *Compiler, f *equalityFactory, body Body) (Bod
 	return result, nil
 }
 
-func rewriteWithModifier(c *Compiler, f *equalityFactory, expr *Expr) ([]*Expr, *Error) {
+func rewriteWithModifier(c *Compiler, unsafeBuiltinsMap map[string]struct{}, f *equalityFactory, expr *Expr) ([]*Expr, *Error) {
 
 	var result []*Expr
 	for i := range expr.With {
-		eval, err := validateWith(c, expr, i)
+		eval, err := validateWith(c, unsafeBuiltinsMap, expr, i)
 		if err != nil {
 			return nil, err
 		}
",[True]
GO-2022-0978,open-policy-agent,opa,3e8c754ed007b22393cf65e48751ad9f6457fee8," func rewriteWithModifier(c *Compiler, f *equalityFactory, expr *Expr) ([]*Expr,
 	return append(result, expr), nil
 }
 
-func validateWith(c *Compiler, expr *Expr, i int) (bool, *Error) {
+func validateWith(c *Compiler, unsafeBuiltinsMap map[string]struct{}, expr *Expr, i int) (bool, *Error) {
 	target, value := expr.With[i].Target, expr.With[i].Value
 
 	// Ensure that values that are built-ins are rewritten to Ref (not Var)
",[True]
GO-2022-0978,open-policy-agent,opa,3e8c754ed007b22393cf65e48751ad9f6457fee8," func validateWith(c *Compiler, expr *Expr, i int) (bool, *Error) {
 			value.Value = Ref([]*Term{NewTerm(v)})
 		}
 	}
+	isBuiltinRefOrVar, err := isBuiltinRefOrVar(c.builtins, unsafeBuiltinsMap, target)
+	if err != nil {
+		return false, err
+	}
 
 	switch {
 	case isDataRef(target):
",[True]
GO-2022-0978,open-policy-agent,opa,3e8c754ed007b22393cf65e48751ad9f6457fee8," func validateWith(c *Compiler, expr *Expr, i int) (bool, *Error) {
 			if child := node.Child(ref[len(ref)-1].Value); child != nil {
 				for _, v := range child.Values {
 					if len(v.(*Rule).Head.Args) > 0 {
-						if validateWithFunctionValue(c.builtins, c.RuleTree, value) {
-							return false, nil
+						if ok, err := validateWithFunctionValue(c.builtins, unsafeBuiltinsMap, c.RuleTree, value); err != nil || ok {
+							return false, err // may be nil
 						}
 					}
 				}
 			}
 		}
 	case isInputRef(target): // ok, valid
-	case isBuiltinRefOrVar(c.builtins, target):
+	case isBuiltinRefOrVar:
 
 		// NOTE(sr): first we ensure that parsed Var builtins (`count`, `concat`, etc)
 		// are rewritten to their proper Ref convention
",[True]
GO-2022-0978,open-policy-agent,opa,3e8c754ed007b22393cf65e48751ad9f6457fee8," func validateWith(c *Compiler, expr *Expr, i int) (bool, *Error) {
 			return false, err
 		}
 
-		if validateWithFunctionValue(c.builtins, c.RuleTree, value) {
-			return false, nil
+		if ok, err := validateWithFunctionValue(c.builtins, unsafeBuiltinsMap, c.RuleTree, value); err != nil || ok {
+			return false, err // may be nil
 		}
 	default:
 		return false, NewError(TypeErr, target.Location, ""with keyword target must reference existing %v, %v, or a function"", InputRootDocument, DefaultRootDocument)
",[True]
GO-2022-0978,open-policy-agent,opa,3e8c754ed007b22393cf65e48751ad9f6457fee8," func validateWithBuiltinTarget(bi *Builtin, target Ref, loc *location.Location)
 	return nil
 }
 
-func validateWithFunctionValue(bs map[string]*Builtin, ruleTree *TreeNode, value *Term) bool {
+func validateWithFunctionValue(bs map[string]*Builtin, unsafeMap map[string]struct{}, ruleTree *TreeNode, value *Term) (bool, *Error) {
 	if v, ok := value.Value.(Ref); ok {
 		if ruleTree.Find(v) != nil { // ref exists in rule tree
-			return true
+			return true, nil
 		}
 	}
-	return isBuiltinRefOrVar(bs, value)
+	return isBuiltinRefOrVar(bs, unsafeMap, value)
 }
 
 func isInputRef(term *Term) bool {
",[True]
GO-2022-0978,open-policy-agent,opa,3e8c754ed007b22393cf65e48751ad9f6457fee8," func isDataRef(term *Term) bool {
 	return false
 }
 
-func isBuiltinRefOrVar(bs map[string]*Builtin, term *Term) bool {
+func isBuiltinRefOrVar(bs map[string]*Builtin, unsafeBuiltinsMap map[string]struct{}, term *Term) (bool, *Error) {
 	switch v := term.Value.(type) {
 	case Ref, Var:
+		if _, ok := unsafeBuiltinsMap[v.String()]; ok {
+			return false, NewError(CompileErr, term.Location, ""with keyword replacing built-in function: target must not be unsafe: %q"", v)
+		}
 		_, ok := bs[v.String()]
-		return ok
+		return ok, nil
 	}
-	return false
+	return false, nil
 }
 
 func isVirtual(node *TreeNode, ref Ref) bool {
",[True]
GO-2023-1713,sjqzhang,go-fastdfs,61cbff5124c61e292994099372b11c06cdb5b80b," func (c *Server) Download(w http.ResponseWriter, r *http.Request) {
 		smallPath string
 		fi        os.FileInfo
 	)
+	// check uri is contains ..
+	if strings.Contains(r.RequestURI, "".."") {
+		c.NotPermit(w, r)
+		return
+	}
 	// redirect to upload
 	if r.RequestURI == ""/"" || r.RequestURI == """" ||
 		r.RequestURI == ""/""+Config().Group ||
",[True]
GO-2023-1713,sjqzhang,go-fastdfs,61cbff5124c61e292994099372b11c06cdb5b80b," package server
 import ""net/http""
 
 func (c *Server) CrossOrigin(w http.ResponseWriter, r *http.Request) {
+	r.Header.Set(""Origin"", ""*"")
 	w.Header().Set(""Access-Control-Allow-Origin"", ""*"")
 	w.Header().Set(""Access-Control-Allow-Headers"", ""Authorization, Content-Type, Depth, User-Agent, X-File-Size, X-Requested-With, X-Requested-By, If-Modified-Since, X-File-Name, X-File-Type, Cache-Control, Origin"")
 	w.Header().Set(""Access-Control-Allow-Methods"", ""GET, POST, OPTIONS, PUT, DELETE"")
",[True]
GO-2023-1713,sjqzhang,go-fastdfs,61cbff5124c61e292994099372b11c06cdb5b80b," func (c *Server) upload(w http.ResponseWriter, r *http.Request) {
 		}
 		if Config().EnableCustomPath {
 			fileInfo.Path = r.FormValue(""path"")
+			//replace . to """"
+			fileInfo.Path = strings.Replace(fileInfo.Path, ""."", """", -1)
 			fileInfo.Path = strings.Trim(fileInfo.Path, ""/"")
 		}
 		scene = r.FormValue(""scene"")
",[True]
GO-2023-2133,nats-io,nats-server,fa5b7afcb64e7e887e49afdd032358802b5c4478," func (o *Options) processConfigFileLine(k string, v interface{}, errors *[]error
 			*errors = append(*errors, err)
 			return
 		}
-
+		o.authBlockDefined = true
 		o.Username = auth.user
 		o.Password = auth.pass
 		o.Authorization = auth.token
",[True]
GO-2023-2133,nats-io,nats-server,fa5b7afcb64e7e887e49afdd032358802b5c4478," func (s *Server) configureAccounts(reloading bool) (map[string]struct{}, error)
 		// If we have defined a system account here check to see if its just us and the $G account.
 		// We would do this to add user/pass to the system account. If this is the case add in
 		// no-auth-user for $G.
-		// Only do this if non-operator mode.
-		if len(opts.TrustedOperators) == 0 && numAccounts == 2 && opts.NoAuthUser == _EMPTY_ {
+		// Only do this if non-operator mode and we did not have an authorization block defined.
+		if len(opts.TrustedOperators) == 0 && numAccounts == 2 && opts.NoAuthUser == _EMPTY_ && !opts.authBlockDefined {
 			// If we come here from config reload, let's not recreate the fake user name otherwise
 			// it will cause currently clients to be disconnected.
 			uname := s.sysAccOnlyNoAuthUser
",[True]
GO-2022-0603,go-yaml,yaml,8f96da9f5d5eff988554c1aae1784627c4bf6754," func (p *parser) peek() yaml_event_type_t {
 	if p.event.typ != yaml_NO_EVENT {
 		return p.event.typ
 	}
-	if !yaml_parser_parse(&p.parser, &p.event) {
+	// It's curious choice from the underlying API to generally return a
+	// positive result on success, but on this case return true in an error
+	// scenario. This was the source of bugs in the past (issue #666).
+	if !yaml_parser_parse(&p.parser, &p.event) || p.parser.error != yaml_NO_ERROR {
 		p.fail()
 	}
 	return p.event.typ
",[False]
GO-2023-1573,containerd,containerd,0c314901076a74a7b797a545d2f462285fdbb8c4," func ImportIndex(ctx context.Context, store content.Store, reader io.Reader, opt
 	return writeManifest(ctx, store, idx, ocispec.MediaTypeImageIndex)
 }
 
+const (
+	kib       = 1024
+	mib       = 1024 * kib
+	jsonLimit = 20 * mib
+)
+
 func onUntarJSON(r io.Reader, j interface{}) error {
-	b, err := io.ReadAll(r)
-	if err != nil {
-		return err
-	}
-	return json.Unmarshal(b, j)
+	return json.NewDecoder(io.LimitReader(r, jsonLimit)).Decode(j)
 }
 
 func onUntarBlob(ctx context.Context, r io.Reader, store content.Ingester, size int64, ref string) (digest.Digest, error) {
",[True]
GO-2023-1872,openfga,openfga,087ce392595f3c319ab3028b5089118ea4063452," func ValidateAllAuthorizationModels(ctx context.Context, db storage.OpenFGADatas
 
 				// validate each model
 				for _, model := range models {
-					_, err := typesystem.NewAndValidate(model)
+					_, err := typesystem.NewAndValidate(context.Background(), model)
 
 					validationResult := validationResult{
 						StoreID:       store.Id,
",[False]
GO-2023-1872,openfga,openfga,087ce392595f3c319ab3028b5089118ea4063452," func (q *ExpandQuery) Execute(ctx context.Context, req *openfgapb.ExpandRequest)
 		return nil, serverErrors.ValidationError(typesystem.ErrInvalidSchemaVersion)
 	}
 
-	typesys := typesystem.New(model)
+	typesys, err := typesystem.NewAndValidate(ctx, model)
+	if err != nil {
+		return nil, serverErrors.ValidationError(typesystem.ErrInvalidModel)
+	}
 
 	if err = validation.ValidateObject(typesys, tk); err != nil {
 		return nil, serverErrors.ValidationError(err)
",[False]
GO-2023-1872,openfga,openfga,087ce392595f3c319ab3028b5089118ea4063452," func (w *WriteAuthorizationModelCommand) Execute(ctx context.Context, req *openf
 		TypeDefinitions: req.GetTypeDefinitions(),
 	}
 
-	_, err := typesystem.NewAndValidate(model)
+	_, err := typesystem.NewAndValidate(ctx, model)
 	if err != nil {
 		return nil, serverErrors.InvalidAuthorizationModelInput(err)
 	}
",[False]
GO-2023-1872,openfga,openfga,087ce392595f3c319ab3028b5089118ea4063452," func (s *Server) ListObjects(ctx context.Context, req *openfgapb.ListObjectsRequ
 		return nil, err
 	}
 
-	typesys := typesystem.New(model)
+	typesys, err := typesystem.NewAndValidate(ctx, model)
+	if err != nil {
+		return nil, serverErrors.ValidationError(typesystem.ErrInvalidModel)
+	}
 
 	ctx = typesystem.ContextWithTypesystem(ctx, typesys)
 
",[False]
GO-2023-1872,openfga,openfga,087ce392595f3c319ab3028b5089118ea4063452," func (s *Server) StreamedListObjects(req *openfgapb.StreamedListObjectsRequest,
 		return serverErrors.HandleError("""", err)
 	}
 
-	typesys := typesystem.New(model)
+	typesys, err := typesystem.NewAndValidate(ctx, model)
+	if err != nil {
+		return serverErrors.ValidationError(typesystem.ErrInvalidModel)
+	}
 
 	ctx = typesystem.ContextWithTypesystem(ctx, typesys)
 
",[False]
GO-2023-1872,openfga,openfga,087ce392595f3c319ab3028b5089118ea4063452," func (s *Server) Check(ctx context.Context, req *openfgapb.CheckRequest) (*openf
 		return nil, serverErrors.ValidationError(typesystem.ErrInvalidSchemaVersion)
 	}
 
-	typesys := typesystem.New(model)
+	typesys, err := typesystem.NewAndValidate(ctx, model)
+	if err != nil {
+		return nil, serverErrors.ValidationError(typesystem.ErrInvalidModel)
+	}
 
 	if err := validation.ValidateUserObjectRelation(typesys, tk); err != nil {
 		return nil, serverErrors.ValidationError(err)
",[False]
GO-2023-1872,openfga,openfga,087ce392595f3c319ab3028b5089118ea4063452," func New(model *openfgapb.AuthorizationModel) *TypeSystem {
 	relations := make(map[string]map[string]*openfgapb.Relation, len(model.GetTypeDefinitions()))
 
 	for _, td := range model.GetTypeDefinitions() {
-		tds[td.GetType()] = td
+		typeName := td.GetType()
+
+		tds[typeName] = td
 		tdRelations := make(map[string]*openfgapb.Relation, len(td.GetRelations()))
 
 		for relation, rewrite := range td.GetRelations() {
",[True]
GO-2023-1872,openfga,openfga,087ce392595f3c319ab3028b5089118ea4063452," func New(model *openfgapb.AuthorizationModel) *TypeSystem {
 
 			tdRelations[relation] = r
 		}
-		relations[td.GetType()] = tdRelations
+		relations[typeName] = tdRelations
 	}
 
 	return &TypeSystem{
",[True]
GO-2023-1872,openfga,openfga,087ce392595f3c319ab3028b5089118ea4063452," func (t *TypeSystem) relationInvolvesExclusion(objectType, relation string, visi
 	return false, nil
 }
 
+// hasEntrypoints recursively walks the rewrite definition for the given relation to determine if there is at least
+// one path in the rewrite rule that could relate to at least one concrete object type. If there is no such path that
+// could lead to at least one relationship with some object type, then false is returned along with an error indicating
+// no entrypoints were found. If at least one relationship with a specific object type is found while walking the rewrite,
+// then true is returned along with a nil error.
+func hasEntrypoints(
+	typedefs map[string]map[string]*openfgapb.Relation,
+	typeName, relationName string,
+	rewrite *openfgapb.Userset,
+	visitedRelations map[string]map[string]struct{},
+) (bool, error) {
+
+	v := maps.Clone(visitedRelations)
+
+	if val, ok := v[typeName]; ok {
+		val[relationName] = struct{}{}
+	} else {
+		v[typeName] = map[string]struct{}{
+			relationName: {},
+		}
+	}
+
+	relation, ok := typedefs[typeName][relationName]
+	if !ok {
+		return false, fmt.Errorf(""undefined type definition for '%s#%s'"", typeName, relationName)
+	}
+
+	switch rw := rewrite.Userset.(type) {
+	case *openfgapb.Userset_This:
+		for _, assignableType := range relation.GetTypeInfo().GetDirectlyRelatedUserTypes() {
+			if assignableType.GetRelationOrWildcard() == nil || assignableType.GetWildcard() != nil {
+				return true, nil
+			}
+
+			assignableTypeName := assignableType.GetType()
+			assignableRelationName := assignableType.GetRelation()
+
+			assignableRelation, ok := typedefs[assignableTypeName][assignableRelationName]
+			if !ok {
+				return false, fmt.Errorf(""undefined type definition for '%s#%s'"", assignableTypeName, assignableRelationName)
+			}
+
+			if _, ok := v[assignableTypeName][assignableRelationName]; ok {
+				continue
+			}
+
+			hasEntrypoint, err := hasEntrypoints(typedefs, assignableTypeName, assignableRelationName, assignableRelation.GetRewrite(), v)
+			if err != nil {
+				return false, err
+			}
+
+			if hasEntrypoint {
+				return true, nil
+			}
+		}
+
+		return false, nil
+	case *openfgapb.Userset_ComputedUserset:
+
+		computedRelationName := rw.ComputedUserset.GetRelation()
+		computedRelation, ok := typedefs[typeName][computedRelationName]
+		if !ok {
+			return false, fmt.Errorf(""undefined type definition for '%s#%s'"", typeName, computedRelationName)
+		}
+
+		if _, ok := v[typeName][computedRelationName]; ok {
+			return false, nil
+		}
+
+		hasEntrypoint, err := hasEntrypoints(typedefs, typeName, computedRelationName, computedRelation.GetRewrite(), v)
+		if err != nil {
+			return false, err
+		}
+
+		return hasEntrypoint, nil
+	case *openfgapb.Userset_TupleToUserset:
+		tuplesetRelationName := rw.TupleToUserset.GetTupleset().GetRelation()
+		computedRelationName := rw.TupleToUserset.ComputedUserset.GetRelation()
+
+		tuplesetRelation, ok := typedefs[typeName][tuplesetRelationName]
+		if !ok {
+			return false, fmt.Errorf(""undefined type definition for '%s#%s'"", typeName, tuplesetRelationName)
+		}
+
+		for _, assignableType := range tuplesetRelation.GetTypeInfo().GetDirectlyRelatedUserTypes() {
+			assignableTypeName := assignableType.GetType()
+
+			if assignableRelation, ok := typedefs[assignableTypeName][computedRelationName]; ok {
+				if _, ok := v[assignableTypeName][computedRelationName]; ok {
+					continue
+				}
+
+				hasEntrypoint, err := hasEntrypoints(typedefs, assignableTypeName, computedRelationName, assignableRelation.GetRewrite(), v)
+				if err != nil {
+					return false, err
+				}
+
+				if hasEntrypoint {
+					return true, nil
+				}
+			}
+		}
+
+		return false, nil
+
+	case *openfgapb.Userset_Union:
+
+		for _, child := range rw.Union.Child {
+
+			hasEntrypoints, err := hasEntrypoints(typedefs, typeName, relationName, child, maps.Clone(visitedRelations))
+			if err != nil {
+				return false, err
+			}
+
+			if hasEntrypoints {
+				return true, nil
+			}
+		}
+
+		return false, nil
+	case *openfgapb.Userset_Intersection:
+
+		for _, child := range rw.Intersection.Child {
+
+			// all of the children must have an entrypoint
+			hasEntrypoints, err := hasEntrypoints(typedefs, typeName, relationName, child, maps.Clone(visitedRelations))
+			if err != nil {
+				return false, err
+			}
+
+			if !hasEntrypoints {
+				return false, nil
+			}
+		}
+
+		return true, nil
+	case *openfgapb.Userset_Difference:
+
+		v := maps.Clone(visitedRelations)
+
+		hasEntrypoint, err := hasEntrypoints(typedefs, typeName, relationName, rw.Difference.GetBase(), v)
+		if err != nil {
+			return false, err
+		}
+
+		if !hasEntrypoint {
+			return false, nil
+		}
+
+		hasEntrypoint, err = hasEntrypoints(typedefs, typeName, relationName, rw.Difference.GetSubtract(), v)
+		if err != nil {
+			return false, err
+		}
+
+		if !hasEntrypoint {
+			return false, nil
+		}
+
+		return true, nil
+	}
+
+	return false, nil
+}
+
 // NewAndValidate is like New but also validates the model according to the following rules:
 //  1. Checks that the *TypeSystem have a valid schema version.
 //  2. For every rewrite the relations in the rewrite must:
",[False]
GO-2023-1872,openfga,openfga,087ce392595f3c319ab3028b5089118ea4063452," func (t *TypeSystem) relationInvolvesExclusion(objectType, relation string, visi
 //     a. For a type (e.g. user) this means checking that this type is in the *TypeSystem
 //     b. For a type#relation this means checking that this type with this relation is in the *TypeSystem
 //  4. Check that a relation is assignable if and only if it has a non-zero list of types
-func NewAndValidate(model *openfgapb.AuthorizationModel) (*TypeSystem, error) {
+func NewAndValidate(ctx context.Context, model *openfgapb.AuthorizationModel) (*TypeSystem, error) {
+	_, span := tracer.Start(ctx, ""typesystem.NewAndValidate"")
+	defer span.End()
+
 	t := New(model)
 	schemaVersion := t.GetSchemaVersion()
 
",[True]
GO-2023-1872,openfga,openfga,087ce392595f3c319ab3028b5089118ea4063452," func NewAndValidate(model *openfgapb.AuthorizationModel) (*TypeSystem, error) {
 		return nil, err
 	}
 
-	// Validate the userset rewrites
-	for _, td := range t.typeDefinitions {
-		for relation, rewrite := range td.GetRelations() {
-			err := t.isUsersetRewriteValid(td.GetType(), relation, rewrite)
+	typedefsMap := t.typeDefinitions
+
+	typeNames := make([]string, 0, len(typedefsMap))
+	for typeName := range typedefsMap {
+		typeNames = append(typeNames, typeName)
+	}
+
+	// range over the type definitions in sorted order to produce a deterministic outcome
+	sort.Strings(typeNames)
+
+	for _, typeName := range typeNames {
+		typedef := typedefsMap[typeName]
+
+		relationMap := typedef.GetRelations()
+		relationNames := make([]string, 0, len(relationMap))
+		for relationName := range relationMap {
+			relationNames = append(relationNames, relationName)
+		}
+
+		// range over the relations in sorted order to produce a deterministic outcome
+		sort.Strings(relationNames)
+
+		for _, relationName := range relationNames {
+
+			err := t.validateRelation(typeName, relationName, relationMap)
 			if err != nil {
 				return nil, err
 			}
",[True]
GO-2023-1872,openfga,openfga,087ce392595f3c319ab3028b5089118ea4063452," func containsDuplicateType(model *openfgapb.AuthorizationModel) bool {
 func (t *TypeSystem) validateNames() error {
 	for _, td := range t.typeDefinitions {
 		objectType := td.GetType()
+
+		if objectType == """" {
+			return fmt.Errorf(""the type name of a type definition cannot be an empty string"")
+		}
+
 		if objectType == ""self"" || objectType == ""this"" {
 			return &InvalidTypeError{ObjectType: objectType, Cause: ErrReservedKeywords}
 		}
 
 		for relation := range td.GetRelations() {
+			if relation == """" {
+				return fmt.Errorf(""type '%s' defines a relation with an empty string for a name"", objectType)
+			}
+
 			if relation == ""self"" || relation == ""this"" {
 				return &InvalidRelationError{ObjectType: objectType, Relation: relation, Cause: ErrReservedKeywords}
 			}
",[True]
GO-2023-1534,pion,dtls,a50d26c5e4eed2ca87509494ffef2d2ebd22b1eb," func (m *MessageHelloVerifyRequest) Unmarshal(data []byte) error {
 	}
 	m.Version.Major = data[0]
 	m.Version.Minor = data[1]
-	cookieLength := data[2]
-	if len(data) < (int(cookieLength) + 3) {
+	cookieLength := int(data[2])
+	if len(data) < cookieLength+3 {
 		return errBufferTooSmall
 	}
 	m.Cookie = make([]byte, cookieLength)
",[True]
GO-2020-0042,sassoftware,go-rpmutils,a64058cf21b8aada501bba923c9aab66fb6febf0," const (
 	S_ISSOCK = 0140000 // Socket
 )
 
+// Extract the contents of a cpio stream from r to the destination directory dest
 func Extract(rs io.Reader, dest string) error {
+	dest = filepath.Clean(filepath.FromSlash(dest))
 	linkMap := make(map[int][]string)
 
 	stream := NewCpioStream(rs)
",[True]
GO-2020-0042,sassoftware,go-rpmutils,a64058cf21b8aada501bba923c9aab66fb6febf0," func Extract(rs io.Reader, dest string) error {
 			break
 		}
 
-		target := path.Join(dest, path.Clean(entry.Header.filename))
-		parent := path.Dir(target)
-
+		// sanitize path
+		target := path.Clean(entry.Header.filename)
+		for strings.HasPrefix(target, ""../"") {
+			target = target[3:]
+		}
+		target = filepath.Join(dest, filepath.FromSlash(target))
+		if !strings.HasPrefix(target, dest+string(filepath.Separator)) && dest != target {
+			// this shouldn't happen due to the sanitization above but always check
+			return fmt.Errorf(""invalid cpio path %q"", entry.Header.filename)
+		}
 		// Create the parent directory if it doesn't exist.
-		if _, err := os.Stat(parent); os.IsNotExist(err) {
-			if err := os.MkdirAll(parent, 0755); err != nil {
-				return err
-			}
+		parent := filepath.Dir(target)
+		if err := os.MkdirAll(parent, 0755); err != nil {
+			return err
 		}
-
 		// FIXME: Need a makedev implementation in go.
 
 		switch entry.Header.Mode() &^ 07777 {
",[True]
GO-2023-1859,lestrrat-go,jwx,6c41e3822485fc7e11dd70b4b0524b075d66b103," func (c Hmac) Open(dst, nonce, ciphertext, data []byte) ([]byte, error) {
 		return nil, fmt.Errorf(`failed to compute auth tag: %w`, err)
 	}
 
-	if subtle.ConstantTimeCompare(expectedTag, tag) != 1 {
-		return nil, fmt.Errorf(`invalid ciphertext (tag mismatch)`)
-	}
-
 	cbc := cipher.NewCBCDecrypter(c.blockCipher, nonce)
 	buf := make([]byte, tagOffset)
 	cbc.CryptBlocks(buf, ciphertext)
 
-	plaintext, err := unpad(buf, c.blockCipher.BlockSize())
-	if err != nil {
-		return nil, fmt.Errorf(`failed to generate plaintext from decrypted blocks: %w`, err)
+	toRemove, good := extractPadding(buf)
+	cmp := subtle.ConstantTimeCompare(expectedTag, tag) & int(good)
+	if cmp != 1 {
+		return nil, errors.New(`invalid ciphertext`)
 	}
+
+	plaintext := buf[:len(buf)-toRemove]
 	ret := ensureSize(dst, len(plaintext))
 	out := ret[len(dst):]
 	copy(out, plaintext)
",[False]
GO-2023-1859,lestrrat-go,jwx,d9ddbc8e5009cfdd8c28413390b67afa7f576dd6," func _main() error {
 		},
 		{
 			name:     `EllipticCurveAlgorithm`,
-			comment:  ` EllipticCurveAlgorithm represents the algorithms used for EC keys`,
+			comment:  `EllipticCurveAlgorithm represents the algorithms used for EC keys`,
 			filename: `elliptic_gen.go`,
 			elements: []element{
 				{
",[False]
GO-2023-1859,lestrrat-go,jwx,d9ddbc8e5009cfdd8c28413390b67afa7f576dd6," func (c Hmac) Open(dst, nonce, ciphertext, data []byte) ([]byte, error) {
 	buf := make([]byte, tagOffset)
 	cbc.CryptBlocks(buf, ciphertext)
 
-	plaintext, err := unpad(buf, c.blockCipher.BlockSize())
-	if err != nil {
-		return nil, errors.Wrap(err, `failed to generate plaintext from decrypted blocks`)
+	toRemove, good := extractPadding(buf)
+	cmp := subtle.ConstantTimeCompare(expectedTag, tag) & int(good)
+	if cmp != 1 {
+		return nil, errors.New(""invalid ciphertext"")
 	}
+
+	plaintext := buf[:len(buf)-toRemove]
 	ret := ensureSize(dst, len(plaintext))
 	out := ret[len(dst):]
 	copy(out, plaintext)
",[False]
GO-2022-0646,aws,aws-sdk-go,ae9b9fd92af132cfd8d879809d8611825ba135f4," func (s S3Target) GoString() string {
 	return s.String()
 }
 
+// SetConnectionName sets the ConnectionName field's value.
+func (s *S3Target) SetConnectionName(v string) *S3Target {
+	s.ConnectionName = &v
+	return s
+}
+
 // SetExclusions sets the Exclusions field's value.
 func (s *S3Target) SetExclusions(v []*string) *S3Target {
 	s.Exclusions = v
",[False]
GO-2022-0646,aws,aws-sdk-go,ae9b9fd92af132cfd8d879809d8611825ba135f4," func (s *AppSummary) SetDescription(v string) *AppSummary {
 	return s
 }
 
+// SetImportedAppId sets the ImportedAppId field's value.
+func (s *AppSummary) SetImportedAppId(v string) *AppSummary {
+	s.ImportedAppId = &v
+	return s
+}
+
 // SetLastModified sets the LastModified field's value.
 func (s *AppSummary) SetLastModified(v time.Time) *AppSummary {
 	s.LastModified = &v
",[False]
GO-2022-0646,aws,aws-sdk-go,ae9b9fd92af132cfd8d879809d8611825ba135f4," func (s *AppSummary) SetLatestReplicationTime(v time.Time) *AppSummary {
 	return s
 }
 
+// SetLaunchConfigurationStatus sets the LaunchConfigurationStatus field's value.
+func (s *AppSummary) SetLaunchConfigurationStatus(v string) *AppSummary {
+	s.LaunchConfigurationStatus = &v
+	return s
+}
+
 // SetLaunchDetails sets the LaunchDetails field's value.
 func (s *AppSummary) SetLaunchDetails(v *LaunchDetails) *AppSummary {
 	s.LaunchDetails = v
",[False]
GO-2022-0646,aws,aws-sdk-go,ae9b9fd92af132cfd8d879809d8611825ba135f4," func (s *AppSummary) SetName(v string) *AppSummary {
 	return s
 }
 
+// SetReplicationConfigurationStatus sets the ReplicationConfigurationStatus field's value.
+func (s *AppSummary) SetReplicationConfigurationStatus(v string) *AppSummary {
+	s.ReplicationConfigurationStatus = &v
+	return s
+}
+
 // SetReplicationStatus sets the ReplicationStatus field's value.
 func (s *AppSummary) SetReplicationStatus(v string) *AppSummary {
 	s.ReplicationStatus = &v
",[False]
GO-2022-0646,aws,aws-sdk-go,ae9b9fd92af132cfd8d879809d8611825ba135f4," func (s *GetAppLaunchConfigurationOutput) SetAppId(v string) *GetAppLaunchConfig
 	return s
 }
 
+// SetAutoLaunch sets the AutoLaunch field's value.
+func (s *GetAppLaunchConfigurationOutput) SetAutoLaunch(v bool) *GetAppLaunchConfigurationOutput {
+	s.AutoLaunch = &v
+	return s
+}
+
 // SetRoleName sets the RoleName field's value.
 func (s *GetAppLaunchConfigurationOutput) SetRoleName(v string) *GetAppLaunchConfigurationOutput {
 	s.RoleName = &v
",[False]
GO-2022-0646,aws,aws-sdk-go,ae9b9fd92af132cfd8d879809d8611825ba135f4," func (s S3Location) GoString() string {
 	return s.String()
 }
 
+// Validate inspects the fields of the type to determine if they are valid.
+func (s *S3Location) Validate() error {
+	invalidParams := request.ErrInvalidParams{Context: ""S3Location""}
+	if s.Bucket != nil && len(*s.Bucket) < 3 {
+		invalidParams.Add(request.NewErrParamMinLen(""Bucket"", 3))
+	}
+
+	if invalidParams.Len() > 0 {
+		return invalidParams
+	}
+	return nil
+}
+
 // SetBucket sets the Bucket field's value.
 func (s *S3Location) SetBucket(v string) *S3Location {
 	s.Bucket = &v
",[False]
GO-2022-0646,aws,aws-sdk-go,ae9b9fd92af132cfd8d879809d8611825ba135f4," func (s ServerGroupLaunchConfiguration) GoString() string {
 	return s.String()
 }
 
+// Validate inspects the fields of the type to determine if they are valid.
+func (s *ServerGroupLaunchConfiguration) Validate() error {
+	invalidParams := request.ErrInvalidParams{Context: ""ServerGroupLaunchConfiguration""}
+	if s.ServerLaunchConfigurations != nil {
+		for i, v := range s.ServerLaunchConfigurations {
+			if v == nil {
+				continue
+			}
+			if err := v.Validate(); err != nil {
+				invalidParams.AddNested(fmt.Sprintf(""%s[%v]"", ""ServerLaunchConfigurations"", i), err.(request.ErrInvalidParams))
+			}
+		}
+	}
+
+	if invalidParams.Len() > 0 {
+		return invalidParams
+	}
+	return nil
+}
+
 // SetLaunchOrder sets the LaunchOrder field's value.
 func (s *ServerGroupLaunchConfiguration) SetLaunchOrder(v int64) *ServerGroupLaunchConfiguration {
 	s.LaunchOrder = &v
",[False]
GO-2021-0110,ory,fosite,0c9e0f6d654913ad57c507dd9a36631e1858a3e9," func (f *Fosite) AuthenticateClient(ctx context.Context, r *http.Request, form u
 			return nil, errors.WithStack(ErrInvalidClient.WithHint(""Unable to type assert claims from request parameter \""client_assertion\""."").WithDebugf(`Got claims of type %T but expected type ""*jwt.MapClaims"".`, token.Claims))
 		}
 
+		var jti string
 		if !claims.VerifyIssuer(clientID, true) {
 			return nil, errors.WithStack(ErrInvalidClient.WithHint(""Claim \""iss\"" from \""client_assertion\"" must match the \""client_id\"" of the OAuth 2.0 Client.""))
 		} else if f.TokenURL == """" {
 			return nil, errors.WithStack(ErrMisconfiguration.WithHint(""The authorization server's token endpoint URL has not been set.""))
 		} else if sub, ok := (*claims)[""sub""].(string); !ok || sub != clientID {
 			return nil, errors.WithStack(ErrInvalidClient.WithHint(""Claim \""sub\"" from \""client_assertion\"" must match the \""client_id\"" of the OAuth 2.0 Client.""))
-		} else if jti, ok := (*claims)[""jti""].(string); !ok || len(jti) == 0 {
+		} else if jti, ok = (*claims)[""jti""].(string); !ok || len(jti) == 0 {
 			return nil, errors.WithStack(ErrInvalidClient.WithHint(""Claim \""jti\"" from \""client_assertion\"" must be set but is not.""))
+		} else if f.Store.ClientAssertionJWTValid(context.Background(), jti) != nil {
+			return nil, errors.WithStack(ErrJTIKnown.WithHint(""Claim \""jti\"" from \""client_assertion\"" MUST only be used once.""))
+		}
+
+		// type conversion according to jwt.MapClaims.VerifyExpiresAt
+		var expiry int64
+		err = nil
+		switch exp := (*claims)[""exp""].(type) {
+		case float64:
+			expiry = int64(exp)
+		case json.Number:
+			expiry, err = exp.Int64()
+		default:
+			err = ErrInvalidClient.WithHint(""Unable to type assert the expiry time from claims. This should not happen as we validate the expiry time already earlier with token.Claims.Valid()"")
+		}
+
+		if err != nil {
+			return nil, errors.WithStack(err)
+		}
+		if err := f.Store.SetClientAssertionJWT(context.Background(), jti, time.Unix(expiry, 0)); err != nil {
+			return nil, err
 		}
 
 		if auds, ok := (*claims)[""aud""].([]interface{}); !ok {
",[True]
GO-2021-0110,ory,fosite,0c9e0f6d654913ad57c507dd9a36631e1858a3e9," func (m *MockAccessResponder) EXPECT() *MockAccessResponderMockRecorder {
 
 // GetAccessToken mocks base method
 func (m *MockAccessResponder) GetAccessToken() string {
+	m.ctrl.T.Helper()
 	ret := m.ctrl.Call(m, ""GetAccessToken"")
 	ret0, _ := ret[0].(string)
 	return ret0
",[False]
GO-2021-0110,ory,fosite,0c9e0f6d654913ad57c507dd9a36631e1858a3e9," func (m *MockAccessResponder) ToMap() map[string]interface{} {
 
 // ToMap indicates an expected call of ToMap
 func (mr *MockAccessResponderMockRecorder) ToMap() *gomock.Call {
+	mr.mock.ctrl.T.Helper()
 	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""ToMap"", reflect.TypeOf((*MockAccessResponder)(nil).ToMap))
 }
",[False]
GO-2021-0110,ory,fosite,0c9e0f6d654913ad57c507dd9a36631e1858a3e9," func (m *MockAccessTokenStorage) EXPECT() *MockAccessTokenStorageMockRecorder {
 
 // CreateAccessTokenSession mocks base method
 func (m *MockAccessTokenStorage) CreateAccessTokenSession(arg0 context.Context, arg1 string, arg2 fosite.Requester) error {
+	m.ctrl.T.Helper()
 	ret := m.ctrl.Call(m, ""CreateAccessTokenSession"", arg0, arg1, arg2)
 	ret0, _ := ret[0].(error)
 	return ret0
",[False]
GO-2021-0110,ory,fosite,0c9e0f6d654913ad57c507dd9a36631e1858a3e9," func (m *MockAccessTokenStorage) GetAccessTokenSession(arg0 context.Context, arg
 
 // GetAccessTokenSession indicates an expected call of GetAccessTokenSession
 func (mr *MockAccessTokenStorageMockRecorder) GetAccessTokenSession(arg0, arg1, arg2 interface{}) *gomock.Call {
+	mr.mock.ctrl.T.Helper()
 	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""GetAccessTokenSession"", reflect.TypeOf((*MockAccessTokenStorage)(nil).GetAccessTokenSession), arg0, arg1, arg2)
 }
",[False]
GO-2021-0110,ory,fosite,0c9e0f6d654913ad57c507dd9a36631e1858a3e9," func (m *MockAccessTokenStrategy) EXPECT() *MockAccessTokenStrategyMockRecorder
 
 // AccessTokenSignature mocks base method
 func (m *MockAccessTokenStrategy) AccessTokenSignature(arg0 string) string {
+	m.ctrl.T.Helper()
 	ret := m.ctrl.Call(m, ""AccessTokenSignature"", arg0)
 	ret0, _ := ret[0].(string)
 	return ret0
",[False]
GO-2021-0110,ory,fosite,0c9e0f6d654913ad57c507dd9a36631e1858a3e9," func (m *MockAccessTokenStrategy) ValidateAccessToken(arg0 context.Context, arg1
 
 // ValidateAccessToken indicates an expected call of ValidateAccessToken
 func (mr *MockAccessTokenStrategyMockRecorder) ValidateAccessToken(arg0, arg1, arg2 interface{}) *gomock.Call {
+	mr.mock.ctrl.T.Helper()
 	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""ValidateAccessToken"", reflect.TypeOf((*MockAccessTokenStrategy)(nil).ValidateAccessToken), arg0, arg1, arg2)
 }
",[False]
GO-2021-0110,ory,fosite,0c9e0f6d654913ad57c507dd9a36631e1858a3e9," func (m *MockAuthorizeCodeStorage) EXPECT() *MockAuthorizeCodeStorageMockRecorde
 
 // CreateAuthorizeCodeSession mocks base method
 func (m *MockAuthorizeCodeStorage) CreateAuthorizeCodeSession(arg0 context.Context, arg1 string, arg2 fosite.Requester) error {
+	m.ctrl.T.Helper()
 	ret := m.ctrl.Call(m, ""CreateAuthorizeCodeSession"", arg0, arg1, arg2)
 	ret0, _ := ret[0].(error)
 	return ret0
",[False]
GO-2021-0110,ory,fosite,0c9e0f6d654913ad57c507dd9a36631e1858a3e9," func (m *MockAuthorizeCodeStorage) InvalidateAuthorizeCodeSession(arg0 context.C
 
 // InvalidateAuthorizeCodeSession indicates an expected call of InvalidateAuthorizeCodeSession
 func (mr *MockAuthorizeCodeStorageMockRecorder) InvalidateAuthorizeCodeSession(arg0, arg1 interface{}) *gomock.Call {
+	mr.mock.ctrl.T.Helper()
 	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""InvalidateAuthorizeCodeSession"", reflect.TypeOf((*MockAuthorizeCodeStorage)(nil).InvalidateAuthorizeCodeSession), arg0, arg1)
 }
",[False]
GO-2021-0110,ory,fosite,0c9e0f6d654913ad57c507dd9a36631e1858a3e9," func (m *MockAuthorizeCodeStrategy) EXPECT() *MockAuthorizeCodeStrategyMockRecor
 
 // AuthorizeCodeSignature mocks base method
 func (m *MockAuthorizeCodeStrategy) AuthorizeCodeSignature(arg0 string) string {
+	m.ctrl.T.Helper()
 	ret := m.ctrl.Call(m, ""AuthorizeCodeSignature"", arg0)
 	ret0, _ := ret[0].(string)
 	return ret0
",[False]
GO-2021-0110,ory,fosite,0c9e0f6d654913ad57c507dd9a36631e1858a3e9," func (m *MockAuthorizeCodeStrategy) ValidateAuthorizeCode(arg0 context.Context,
 
 // ValidateAuthorizeCode indicates an expected call of ValidateAuthorizeCode
 func (mr *MockAuthorizeCodeStrategyMockRecorder) ValidateAuthorizeCode(arg0, arg1, arg2 interface{}) *gomock.Call {
+	mr.mock.ctrl.T.Helper()
 	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""ValidateAuthorizeCode"", reflect.TypeOf((*MockAuthorizeCodeStrategy)(nil).ValidateAuthorizeCode), arg0, arg1, arg2)
 }
",[False]
GO-2021-0110,ory,fosite,0c9e0f6d654913ad57c507dd9a36631e1858a3e9," func (m *MockAuthorizeEndpointHandler) EXPECT() *MockAuthorizeEndpointHandlerMoc
 
 // HandleAuthorizeEndpointRequest mocks base method
 func (m *MockAuthorizeEndpointHandler) HandleAuthorizeEndpointRequest(arg0 context.Context, arg1 fosite.AuthorizeRequester, arg2 fosite.AuthorizeResponder) error {
+	m.ctrl.T.Helper()
 	ret := m.ctrl.Call(m, ""HandleAuthorizeEndpointRequest"", arg0, arg1, arg2)
 	ret0, _ := ret[0].(error)
 	return ret0
",[False]
GO-2021-0110,ory,fosite,0c9e0f6d654913ad57c507dd9a36631e1858a3e9," func (m *MockAuthorizeEndpointHandler) HandleAuthorizeEndpointRequest(arg0 conte
 
 // HandleAuthorizeEndpointRequest indicates an expected call of HandleAuthorizeEndpointRequest
 func (mr *MockAuthorizeEndpointHandlerMockRecorder) HandleAuthorizeEndpointRequest(arg0, arg1, arg2 interface{}) *gomock.Call {
+	mr.mock.ctrl.T.Helper()
 	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""HandleAuthorizeEndpointRequest"", reflect.TypeOf((*MockAuthorizeEndpointHandler)(nil).HandleAuthorizeEndpointRequest), arg0, arg1, arg2)
 }
",[False]
GO-2021-0110,ory,fosite,0c9e0f6d654913ad57c507dd9a36631e1858a3e9," func (m *MockAuthorizeResponder) GetQuery() url.Values {
 
 // GetQuery indicates an expected call of GetQuery
 func (mr *MockAuthorizeResponderMockRecorder) GetQuery() *gomock.Call {
+	mr.mock.ctrl.T.Helper()
 	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""GetQuery"", reflect.TypeOf((*MockAuthorizeResponder)(nil).GetQuery))
 }
",[False]
GO-2021-0110,ory,fosite,0c9e0f6d654913ad57c507dd9a36631e1858a3e9," func (m *MockClient) EXPECT() *MockClientMockRecorder {
 
 // GetAudience mocks base method
 func (m *MockClient) GetAudience() fosite.Arguments {
+	m.ctrl.T.Helper()
 	ret := m.ctrl.Call(m, ""GetAudience"")
 	ret0, _ := ret[0].(fosite.Arguments)
 	return ret0
",[False]
GO-2021-0110,ory,fosite,0c9e0f6d654913ad57c507dd9a36631e1858a3e9," func (m *MockClient) IsPublic() bool {
 
 // IsPublic indicates an expected call of IsPublic
 func (mr *MockClientMockRecorder) IsPublic() *gomock.Call {
+	mr.mock.ctrl.T.Helper()
 	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""IsPublic"", reflect.TypeOf((*MockClient)(nil).IsPublic))
 }
",[False]
GO-2021-0110,ory,fosite,0c9e0f6d654913ad57c507dd9a36631e1858a3e9," func (m *MockHasher) EXPECT() *MockHasherMockRecorder {
 
 // Compare mocks base method
 func (m *MockHasher) Compare(arg0 context.Context, arg1, arg2 []byte) error {
+	m.ctrl.T.Helper()
 	ret := m.ctrl.Call(m, ""Compare"", arg0, arg1, arg2)
 	ret0, _ := ret[0].(error)
 	return ret0
",[False]
GO-2021-0110,ory,fosite,0c9e0f6d654913ad57c507dd9a36631e1858a3e9," func (m *MockHasher) Hash(arg0 context.Context, arg1 []byte) ([]byte, error) {
 
 // Hash indicates an expected call of Hash
 func (mr *MockHasherMockRecorder) Hash(arg0, arg1 interface{}) *gomock.Call {
+	mr.mock.ctrl.T.Helper()
 	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""Hash"", reflect.TypeOf((*MockHasher)(nil).Hash), arg0, arg1)
 }
",[False]
GO-2021-0110,ory,fosite,0c9e0f6d654913ad57c507dd9a36631e1858a3e9," func (m *MockOpenIDConnectTokenStrategy) EXPECT() *MockOpenIDConnectTokenStrateg
 
 // GenerateIDToken mocks base method
 func (m *MockOpenIDConnectTokenStrategy) GenerateIDToken(arg0 context.Context, arg1 fosite.Requester) (string, error) {
+	m.ctrl.T.Helper()
 	ret := m.ctrl.Call(m, ""GenerateIDToken"", arg0, arg1)
 	ret0, _ := ret[0].(string)
 	ret1, _ := ret[1].(error)
",[False]
GO-2021-0110,ory,fosite,0c9e0f6d654913ad57c507dd9a36631e1858a3e9," func (m *MockOpenIDConnectTokenStrategy) GenerateIDToken(arg0 context.Context, a
 
 // GenerateIDToken indicates an expected call of GenerateIDToken
 func (mr *MockOpenIDConnectTokenStrategyMockRecorder) GenerateIDToken(arg0, arg1 interface{}) *gomock.Call {
+	mr.mock.ctrl.T.Helper()
 	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""GenerateIDToken"", reflect.TypeOf((*MockOpenIDConnectTokenStrategy)(nil).GenerateIDToken), arg0, arg1)
 }
",[False]
GO-2021-0110,ory,fosite,0c9e0f6d654913ad57c507dd9a36631e1858a3e9," func (m *MockTokenIntrospector) EXPECT() *MockTokenIntrospectorMockRecorder {
 
 // IntrospectToken mocks base method
 func (m *MockTokenIntrospector) IntrospectToken(arg0 context.Context, arg1 string, arg2 fosite.TokenType, arg3 fosite.AccessRequester, arg4 []string) (fosite.TokenType, error) {
+	m.ctrl.T.Helper()
 	ret := m.ctrl.Call(m, ""IntrospectToken"", arg0, arg1, arg2, arg3, arg4)
 	ret0, _ := ret[0].(fosite.TokenType)
 	ret1, _ := ret[1].(error)
",[False]
GO-2021-0110,ory,fosite,0c9e0f6d654913ad57c507dd9a36631e1858a3e9," func (m *MockTokenIntrospector) IntrospectToken(arg0 context.Context, arg1 strin
 
 // IntrospectToken indicates an expected call of IntrospectToken
 func (mr *MockTokenIntrospectorMockRecorder) IntrospectToken(arg0, arg1, arg2, arg3, arg4 interface{}) *gomock.Call {
+	mr.mock.ctrl.T.Helper()
 	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""IntrospectToken"", reflect.TypeOf((*MockTokenIntrospector)(nil).IntrospectToken), arg0, arg1, arg2, arg3, arg4)
 }
",[False]
GO-2021-0110,ory,fosite,0c9e0f6d654913ad57c507dd9a36631e1858a3e9," func (m *MockClientCredentialsGrantStorage) EXPECT() *MockClientCredentialsGrant
 
 // CreateAccessTokenSession mocks base method
 func (m *MockClientCredentialsGrantStorage) CreateAccessTokenSession(arg0 context.Context, arg1 string, arg2 fosite.Requester) error {
+	m.ctrl.T.Helper()
 	ret := m.ctrl.Call(m, ""CreateAccessTokenSession"", arg0, arg1, arg2)
 	ret0, _ := ret[0].(error)
 	return ret0
",[False]
GO-2021-0110,ory,fosite,0c9e0f6d654913ad57c507dd9a36631e1858a3e9," func (m *MockClientCredentialsGrantStorage) GetAccessTokenSession(arg0 context.C
 
 // GetAccessTokenSession indicates an expected call of GetAccessTokenSession
 func (mr *MockClientCredentialsGrantStorageMockRecorder) GetAccessTokenSession(arg0, arg1, arg2 interface{}) *gomock.Call {
+	mr.mock.ctrl.T.Helper()
 	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""GetAccessTokenSession"", reflect.TypeOf((*MockClientCredentialsGrantStorage)(nil).GetAccessTokenSession), arg0, arg1, arg2)
 }
",[False]
GO-2021-0110,ory,fosite,0c9e0f6d654913ad57c507dd9a36631e1858a3e9," func (m *MockResourceOwnerPasswordCredentialsGrantStorage) EXPECT() *MockResourc
 
 // Authenticate mocks base method
 func (m *MockResourceOwnerPasswordCredentialsGrantStorage) Authenticate(arg0 context.Context, arg1, arg2 string) error {
+	m.ctrl.T.Helper()
 	ret := m.ctrl.Call(m, ""Authenticate"", arg0, arg1, arg2)
 	ret0, _ := ret[0].(error)
 	return ret0
",[False]
GO-2021-0110,ory,fosite,0c9e0f6d654913ad57c507dd9a36631e1858a3e9," func (m *MockResourceOwnerPasswordCredentialsGrantStorage) GetRefreshTokenSessio
 
 // GetRefreshTokenSession indicates an expected call of GetRefreshTokenSession
 func (mr *MockResourceOwnerPasswordCredentialsGrantStorageMockRecorder) GetRefreshTokenSession(arg0, arg1, arg2 interface{}) *gomock.Call {
+	mr.mock.ctrl.T.Helper()
 	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""GetRefreshTokenSession"", reflect.TypeOf((*MockResourceOwnerPasswordCredentialsGrantStorage)(nil).GetRefreshTokenSession), arg0, arg1, arg2)
 }
",[False]
GO-2021-0110,ory,fosite,0c9e0f6d654913ad57c507dd9a36631e1858a3e9," func (m *MockTokenRevocationStorage) EXPECT() *MockTokenRevocationStorageMockRec
 
 // CreateAccessTokenSession mocks base method
 func (m *MockTokenRevocationStorage) CreateAccessTokenSession(arg0 context.Context, arg1 string, arg2 fosite.Requester) error {
+	m.ctrl.T.Helper()
 	ret := m.ctrl.Call(m, ""CreateAccessTokenSession"", arg0, arg1, arg2)
 	ret0, _ := ret[0].(error)
 	return ret0
",[False]
GO-2021-0110,ory,fosite,0c9e0f6d654913ad57c507dd9a36631e1858a3e9," func (m *MockTokenRevocationStorage) RevokeRefreshToken(arg0 context.Context, ar
 
 // RevokeRefreshToken indicates an expected call of RevokeRefreshToken
 func (mr *MockTokenRevocationStorageMockRecorder) RevokeRefreshToken(arg0, arg1 interface{}) *gomock.Call {
+	mr.mock.ctrl.T.Helper()
 	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""RevokeRefreshToken"", reflect.TypeOf((*MockTokenRevocationStorage)(nil).RevokeRefreshToken), arg0, arg1)
 }
",[False]
GO-2021-0110,ory,fosite,0c9e0f6d654913ad57c507dd9a36631e1858a3e9," func (m *MockCoreStorage) EXPECT() *MockCoreStorageMockRecorder {
 
 // CreateAccessTokenSession mocks base method
 func (m *MockCoreStorage) CreateAccessTokenSession(arg0 context.Context, arg1 string, arg2 fosite.Requester) error {
+	m.ctrl.T.Helper()
 	ret := m.ctrl.Call(m, ""CreateAccessTokenSession"", arg0, arg1, arg2)
 	ret0, _ := ret[0].(error)
 	return ret0
",[False]
GO-2021-0110,ory,fosite,0c9e0f6d654913ad57c507dd9a36631e1858a3e9," func (m *MockCoreStorage) InvalidateAuthorizeCodeSession(arg0 context.Context, a
 
 // InvalidateAuthorizeCodeSession indicates an expected call of InvalidateAuthorizeCodeSession
 func (mr *MockCoreStorageMockRecorder) InvalidateAuthorizeCodeSession(arg0, arg1 interface{}) *gomock.Call {
+	mr.mock.ctrl.T.Helper()
 	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""InvalidateAuthorizeCodeSession"", reflect.TypeOf((*MockCoreStorage)(nil).InvalidateAuthorizeCodeSession), arg0, arg1)
 }
",[False]
GO-2021-0110,ory,fosite,0c9e0f6d654913ad57c507dd9a36631e1858a3e9," func (m *MockCoreStrategy) EXPECT() *MockCoreStrategyMockRecorder {
 
 // AccessTokenSignature mocks base method
 func (m *MockCoreStrategy) AccessTokenSignature(arg0 string) string {
+	m.ctrl.T.Helper()
 	ret := m.ctrl.Call(m, ""AccessTokenSignature"", arg0)
 	ret0, _ := ret[0].(string)
 	return ret0
",[False]
GO-2021-0110,ory,fosite,0c9e0f6d654913ad57c507dd9a36631e1858a3e9," func (m *MockCoreStrategy) ValidateRefreshToken(arg0 context.Context, arg1 fosit
 
 // ValidateRefreshToken indicates an expected call of ValidateRefreshToken
 func (mr *MockCoreStrategyMockRecorder) ValidateRefreshToken(arg0, arg1, arg2 interface{}) *gomock.Call {
+	mr.mock.ctrl.T.Helper()
 	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""ValidateRefreshToken"", reflect.TypeOf((*MockCoreStrategy)(nil).ValidateRefreshToken), arg0, arg1, arg2)
 }
",[False]
GO-2021-0110,ory,fosite,0c9e0f6d654913ad57c507dd9a36631e1858a3e9," func (m *MockOpenIDConnectRequestStorage) EXPECT() *MockOpenIDConnectRequestStor
 
 // CreateOpenIDConnectSession mocks base method
 func (m *MockOpenIDConnectRequestStorage) CreateOpenIDConnectSession(arg0 context.Context, arg1 string, arg2 fosite.Requester) error {
+	m.ctrl.T.Helper()
 	ret := m.ctrl.Call(m, ""CreateOpenIDConnectSession"", arg0, arg1, arg2)
 	ret0, _ := ret[0].(error)
 	return ret0
",[False]
GO-2021-0110,ory,fosite,0c9e0f6d654913ad57c507dd9a36631e1858a3e9," func (m *MockOpenIDConnectRequestStorage) GetOpenIDConnectSession(arg0 context.C
 
 // GetOpenIDConnectSession indicates an expected call of GetOpenIDConnectSession
 func (mr *MockOpenIDConnectRequestStorageMockRecorder) GetOpenIDConnectSession(arg0, arg1, arg2 interface{}) *gomock.Call {
+	mr.mock.ctrl.T.Helper()
 	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""GetOpenIDConnectSession"", reflect.TypeOf((*MockOpenIDConnectRequestStorage)(nil).GetOpenIDConnectSession), arg0, arg1, arg2)
 }
",[False]
GO-2021-0110,ory,fosite,0c9e0f6d654913ad57c507dd9a36631e1858a3e9," func (m *MockPKCERequestStorage) EXPECT() *MockPKCERequestStorageMockRecorder {
 
 // CreatePKCERequestSession mocks base method
 func (m *MockPKCERequestStorage) CreatePKCERequestSession(arg0 context.Context, arg1 string, arg2 fosite.Requester) error {
+	m.ctrl.T.Helper()
 	ret := m.ctrl.Call(m, ""CreatePKCERequestSession"", arg0, arg1, arg2)
 	ret0, _ := ret[0].(error)
 	return ret0
",[False]
GO-2021-0110,ory,fosite,0c9e0f6d654913ad57c507dd9a36631e1858a3e9," func (m *MockPKCERequestStorage) GetPKCERequestSession(arg0 context.Context, arg
 
 // GetPKCERequestSession indicates an expected call of GetPKCERequestSession
 func (mr *MockPKCERequestStorageMockRecorder) GetPKCERequestSession(arg0, arg1, arg2 interface{}) *gomock.Call {
+	mr.mock.ctrl.T.Helper()
 	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""GetPKCERequestSession"", reflect.TypeOf((*MockPKCERequestStorage)(nil).GetPKCERequestSession), arg0, arg1, arg2)
 }
",[False]
GO-2021-0110,ory,fosite,0c9e0f6d654913ad57c507dd9a36631e1858a3e9," func (m *MockRefreshTokenStrategy) EXPECT() *MockRefreshTokenStrategyMockRecorde
 
 // GenerateRefreshToken mocks base method
 func (m *MockRefreshTokenStrategy) GenerateRefreshToken(arg0 context.Context, arg1 fosite.Requester) (string, string, error) {
+	m.ctrl.T.Helper()
 	ret := m.ctrl.Call(m, ""GenerateRefreshToken"", arg0, arg1)
 	ret0, _ := ret[0].(string)
 	ret1, _ := ret[1].(string)
",[False]
GO-2021-0110,ory,fosite,0c9e0f6d654913ad57c507dd9a36631e1858a3e9," func (m *MockRefreshTokenStrategy) ValidateRefreshToken(arg0 context.Context, ar
 
 // ValidateRefreshToken indicates an expected call of ValidateRefreshToken
 func (mr *MockRefreshTokenStrategyMockRecorder) ValidateRefreshToken(arg0, arg1, arg2 interface{}) *gomock.Call {
+	mr.mock.ctrl.T.Helper()
 	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""ValidateRefreshToken"", reflect.TypeOf((*MockRefreshTokenStrategy)(nil).ValidateRefreshToken), arg0, arg1, arg2)
 }
",[False]
GO-2021-0110,ory,fosite,0c9e0f6d654913ad57c507dd9a36631e1858a3e9," func (m *MockRevocationHandler) EXPECT() *MockRevocationHandlerMockRecorder {
 
 // RevokeToken mocks base method
 func (m *MockRevocationHandler) RevokeToken(arg0 context.Context, arg1 string, arg2 fosite.TokenType, arg3 fosite.Client) error {
+	m.ctrl.T.Helper()
 	ret := m.ctrl.Call(m, ""RevokeToken"", arg0, arg1, arg2, arg3)
 	ret0, _ := ret[0].(error)
 	return ret0
",[False]
GO-2021-0110,ory,fosite,0c9e0f6d654913ad57c507dd9a36631e1858a3e9," func (m *MockRevocationHandler) RevokeToken(arg0 context.Context, arg1 string, a
 
 // RevokeToken indicates an expected call of RevokeToken
 func (mr *MockRevocationHandlerMockRecorder) RevokeToken(arg0, arg1, arg2, arg3 interface{}) *gomock.Call {
+	mr.mock.ctrl.T.Helper()
 	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""RevokeToken"", reflect.TypeOf((*MockRevocationHandler)(nil).RevokeToken), arg0, arg1, arg2, arg3)
 }
",[False]
GO-2021-0110,ory,fosite,0c9e0f6d654913ad57c507dd9a36631e1858a3e9," func (m *MockTokenEndpointHandler) EXPECT() *MockTokenEndpointHandlerMockRecorde
 
 // HandleTokenEndpointRequest mocks base method
 func (m *MockTokenEndpointHandler) HandleTokenEndpointRequest(arg0 context.Context, arg1 fosite.AccessRequester) error {
+	m.ctrl.T.Helper()
 	ret := m.ctrl.Call(m, ""HandleTokenEndpointRequest"", arg0, arg1)
 	ret0, _ := ret[0].(error)
 	return ret0
",[False]
GO-2021-0110,ory,fosite,0c9e0f6d654913ad57c507dd9a36631e1858a3e9," func (m *MockTokenEndpointHandler) PopulateTokenEndpointResponse(arg0 context.Co
 
 // PopulateTokenEndpointResponse indicates an expected call of PopulateTokenEndpointResponse
 func (mr *MockTokenEndpointHandlerMockRecorder) PopulateTokenEndpointResponse(arg0, arg1, arg2 interface{}) *gomock.Call {
+	mr.mock.ctrl.T.Helper()
 	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""PopulateTokenEndpointResponse"", reflect.TypeOf((*MockTokenEndpointHandler)(nil).PopulateTokenEndpointResponse), arg0, arg1, arg2)
 }
",[False]
GO-2021-0110,ory,fosite,0c9e0f6d654913ad57c507dd9a36631e1858a3e9," func (m *MockTransactional) EXPECT() *MockTransactionalMockRecorder {
 
 // BeginTX mocks base method
 func (m *MockTransactional) BeginTX(arg0 context.Context) (context.Context, error) {
+	m.ctrl.T.Helper()
 	ret := m.ctrl.Call(m, ""BeginTX"", arg0)
 	ret0, _ := ret[0].(context.Context)
 	ret1, _ := ret[1].(error)
",[False]
GO-2021-0110,ory,fosite,0c9e0f6d654913ad57c507dd9a36631e1858a3e9," func (m *MockTransactional) Rollback(arg0 context.Context) error {
 
 // Rollback indicates an expected call of Rollback
 func (mr *MockTransactionalMockRecorder) Rollback(arg0 interface{}) *gomock.Call {
+	mr.mock.ctrl.T.Helper()
 	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""Rollback"", reflect.TypeOf((*MockTransactional)(nil).Rollback), arg0)
 }
",[False]
GO-2021-0110,ory,fosite,0c9e0f6d654913ad57c507dd9a36631e1858a3e9," func NewMemoryStore() *MemoryStore {
 		Users:                  make(map[string]MemoryUserRelation),
 		AccessTokenRequestIDs:  make(map[string]string),
 		RefreshTokenRequestIDs: make(map[string]string),
+		BlacklistedJTIs:        make(map[string]time.Time),
 	}
 }
 
",[False]
GO-2022-0460,pion,dtls,e0b2ce3592e8e7d73713ac67b363a2e192a4cecf," func (f *fragmentBuffer) pop() (content []byte, epoch uint16) {
 		for _, f := range frags {
 			if f.handshakeHeader.FragmentOffset == targetOffset {
 				fragmentEnd := (f.handshakeHeader.FragmentOffset + f.handshakeHeader.FragmentLength)
-				if fragmentEnd != f.handshakeHeader.Length {
+				if fragmentEnd != f.handshakeHeader.Length && f.handshakeHeader.FragmentLength != 0 {
 					if !appendMessage(fragmentEnd) {
 						return false
 					}
",[True]
GO-2022-0438,hashicorp,go-getter,36b68b2f68a3ed10ee7ecbb0cb9f6b1dc5da49cc," func RedactURL(u *url.URL) string {
 
 	ru := *u
 	if _, has := ru.User.Password(); has {
-		ru.User = url.UserPassword(ru.User.Username(), ""xxxxx"")
+		ru.User = url.UserPassword(ru.User.Username(), ""redacted"")
+	}
+	q := ru.Query()
+	if q.Get(""sshkey"") != """" {
+		q.Set(""sshkey"", ""redacted"")
+		ru.RawQuery = q.Encode()
 	}
 	return ru.String()
 }
",[True]
GO-2022-1201,openshift,osin,8612686d6dda34ae9ef6b5a974e4b7accb4fea29," func (d *DefaultClient) GetUserData() interface{} {
 
 // Implement the ClientSecretMatcher interface
 func (d *DefaultClient) ClientSecretMatches(secret string) bool {
-	return d.Secret == secret
+	return subtle.ConstantTimeCompare([]byte(d.Secret), []byte(secret)) == 1
 }
 
 func (d *DefaultClient) CopyFrom(client Client) {
",[True]
GO-2022-1201,openshift,osin,8612686d6dda34ae9ef6b5a974e4b7accb4fea29," func CheckClientSecret(client Client, secret string) bool {
 		return client.ClientSecretMatches(secret)
 	default:
 		// Fallback to the less secure method of extracting the plain text secret from the client for comparison
-		return client.GetSecret() == secret
+		return subtle.ConstantTimeCompare([]byte(client.GetSecret()), []byte(secret)) == 1
 	}
 }
 
",[True]
GO-2023-2101,Consensys,gnark-crypto,ec6be1a037f7c496d595c541a8a8d31c47bcfa3d," func (p *G1Jac) mulWindowed(a *G1Jac, s *big.Int) *G1Jac {
 	var res G1Jac
 	var ops [3]G1Jac
 
-	res.Set(&g1Infinity)
 	ops[0].Set(a)
+	e := s
+	if s.Sign() == -1 {
+		e = bigIntPool.Get().(*big.Int)
+		defer bigIntPool.Put(e)
+		e.Neg(s)
+		ops[0].Neg(&ops[0])
+	}
+	res.Set(&g1Infinity)
 	ops[1].Double(&ops[0])
 	ops[2].Set(&ops[0]).AddAssign(&ops[1])
 
",[True]
GO-2023-2101,Consensys,gnark-crypto,ec6be1a037f7c496d595c541a8a8d31c47bcfa3d," func (p *G2Jac) mulWindowed(a *G2Jac, s *big.Int) *G2Jac {
 	var res G2Jac
 	var ops [3]G2Jac
 
-	res.Set(&g2Infinity)
 	ops[0].Set(a)
+	e := s
+	if s.Sign() == -1 {
+		e = bigIntPool.Get().(*big.Int)
+		defer bigIntPool.Put(e)
+		e.Neg(s)
+		ops[0].Neg(&ops[0])
+	}
+	res.Set(&g2Infinity)
 	ops[1].Double(&ops[0])
 	ops[2].Set(&ops[0]).AddAssign(&ops[1])
 
",[True]
GO-2023-2101,Consensys,gnark-crypto,ec6be1a037f7c496d595c541a8a8d31c47bcfa3d," func (z *E12) ExpGLV(x E12, k *big.Int) *E12 {
 	s1 = s1.SetBigInt(&s[0]).Bits()
 	s2 = s2.SetBigInt(&s[1]).Bits()
 
+	maxBit := s1.BitLen()
+	if s2.BitLen() > maxBit {
+		maxBit = s2.BitLen()
+	}
+	hiWordIndex := (maxBit - 1) / 64
+
 	// loop starts from len(s1)/2 due to the bounds
-	for i := len(s1) / 2; i >= 0; i-- {
+	for i := hiWordIndex; i >= 0; i-- {
 		mask := uint64(3) << 62
 		for j := 0; j < 32; j++ {
 			res.CyclotomicSquare(&res).CyclotomicSquare(&res)
",[True]
GO-2023-2101,Consensys,gnark-crypto,ec6be1a037f7c496d595c541a8a8d31c47bcfa3d," func (z *E24) ExpGLV(x E24, k *big.Int) *E24 {
 	s1 = s1.SetBigInt(&s[0]).Bits()
 	s2 = s2.SetBigInt(&s[1]).Bits()
 
+	maxBit := s1.BitLen()
+	if s2.BitLen() > maxBit {
+		maxBit = s2.BitLen()
+	}
+	hiWordIndex := (maxBit - 1) / 64
+
 	// loop starts from len(s1)/2 due to the bounds
-	for i := len(s1)/2 + 1; i >= 0; i-- {
+	for i := hiWordIndex; i >= 0; i-- {
 		mask := uint64(3) << 62
 		for j := 0; j < 32; j++ {
 			res.CyclotomicSquare(&res).CyclotomicSquare(&res)
",[True]
GO-2023-2101,Consensys,gnark-crypto,ec6be1a037f7c496d595c541a8a8d31c47bcfa3d," func (z *E6) ExpGLV(x E6, k *big.Int) *E6 {
 	s1 = s1.SetBigInt(&s[0]).Bits()
 	s2 = s2.SetBigInt(&s[1]).Bits()
 
+	maxBit := s1.BitLen()
+	if s2.BitLen() > maxBit {
+		maxBit = s2.BitLen()
+	}
+	hiWordIndex := (maxBit - 1) / 64
+
 	// loop starts from len(s1)/2 due to the bounds
-	for i := len(s1) / 2; i >= 0; i-- {
+	for i := hiWordIndex; i >= 0; i-- {
 		mask := uint64(3) << 62
 		for j := 0; j < 32; j++ {
 			res.CyclotomicSquare(&res).CyclotomicSquare(&res)
",[True]
GO-2023-1611,gookit,goutil,d7b94fede71f018f129f7d21feb58c895d28dadc," func Unzip(archive, targetDir string) (err error) {
 	}
 
 	for _, file := range reader.File {
+
+		if strings.Contains(file.Name, "".."") {
+			return fmt.Errorf(""illegal file path in zip: %v"", file.Name)
+		}
+
 		fullPath := filepath.Join(targetDir, file.Name)
+
 		if file.FileInfo().IsDir() {
 			err = os.MkdirAll(fullPath, file.Mode())
 			if err != nil {
",[True]
GO-2022-0244,satori,go.uuid,75cca531ea763666bc46e531da3b4c3b95f64557," func (g *rfc4122Generator) NewV3(ns UUID, name string) UUID {
 // NewV4 returns random generated UUID.
 func (g *rfc4122Generator) NewV4() (UUID, error) {
 	u := UUID{}
-	if _, err := g.rand.Read(u[:]); err != nil {
+	if _, err := io.ReadFull(g.rand, u[:]); err != nil {
 		return Nil, err
 	}
 	u.SetVersion(V4)
",[True]
GO-2022-0244,satori,go.uuid,75cca531ea763666bc46e531da3b4c3b95f64557," func (g *rfc4122Generator) getClockSequence() (uint64, uint16, error) {
 	var err error
 	g.clockSequenceOnce.Do(func() {
 		buf := make([]byte, 2)
-		if _, err = g.rand.Read(buf); err != nil {
+		if _, err = io.ReadFull(g.rand, buf); err != nil {
 			return
 		}
 		g.clockSequence = binary.BigEndian.Uint16(buf)
",[True]
GO-2022-0244,satori,go.uuid,75cca531ea763666bc46e531da3b4c3b95f64557," func (g *rfc4122Generator) getHardwareAddr() ([]byte, error) {
 
 		// Initialize hardwareAddr randomly in case
 		// of real network interfaces absence.
-		if _, err = g.rand.Read(g.hardwareAddr[:]); err != nil {
+		if _, err = io.ReadFull(g.rand, g.hardwareAddr[:]); err != nil {
 			return
 		}
 		// Set multicast bit as recommended by RFC 4122
",[True]
GO-2021-0105,ethereum,go-ethereum,87c0ba92136a75db0ab2aba1046d4a9860375d6a," func (pre *Prestate) Apply(vmConfig vm.Config, chainConfig *params.ChainConfig,
 	}
 	execRs := &ExecutionResult{
 		StateRoot:   root,
-		TxRoot:      types.DeriveSha(includedTxs),
-		ReceiptRoot: types.DeriveSha(receipts),
+		TxRoot:      types.DeriveSha(includedTxs, new(trie.Trie)),
+		ReceiptRoot: types.DeriveSha(receipts, new(trie.Trie)),
 		Bloom:       types.CreateBloom(receipts),
 		LogsHash:    rlpHash(statedb.Logs()),
 		Receipts:    receipts,
",[False]
GO-2021-0105,ethereum,go-ethereum,87c0ba92136a75db0ab2aba1046d4a9860375d6a," func (c *Clique) FinalizeAndAssemble(chain consensus.ChainHeaderReader, header *
 	header.UncleHash = types.CalcUncleHash(nil)
 
 	// Assemble and return the final block for sealing
-	return types.NewBlock(header, txs, nil, receipts), nil
+	return types.NewBlock(header, txs, nil, receipts, new(trie.Trie)), nil
 }
 
 // Authorize injects a private key into the consensus engine to mint new blocks
",[False]
GO-2021-0105,ethereum,go-ethereum,87c0ba92136a75db0ab2aba1046d4a9860375d6a," func (ethash *Ethash) FinalizeAndAssemble(chain consensus.ChainHeaderReader, hea
 	header.Root = state.IntermediateRoot(chain.Config().IsEIP158(header.Number))
 
 	// Header seems complete, assemble into a block and return
-	return types.NewBlock(header, txs, uncles, receipts), nil
+	return types.NewBlock(header, txs, uncles, receipts, new(trie.Trie)), nil
 }
 
 // SealHash returns the hash of a block prior to it being sealed.
",[False]
GO-2021-0105,ethereum,go-ethereum,87c0ba92136a75db0ab2aba1046d4a9860375d6a," func (v *BlockValidator) ValidateBody(block *types.Block) error {
 	if hash := types.CalcUncleHash(block.Uncles()); hash != header.UncleHash {
 		return fmt.Errorf(""uncle root hash mismatch: have %x, want %x"", hash, header.UncleHash)
 	}
-	if hash := types.DeriveSha(block.Transactions()); hash != header.TxHash {
+	if hash := types.DeriveSha(block.Transactions(), new(trie.Trie)); hash != header.TxHash {
 		return fmt.Errorf(""transaction root hash mismatch: have %x, want %x"", hash, header.TxHash)
 	}
 	if !v.bc.HasBlockAndState(block.ParentHash(), block.NumberU64()-1) {
",[False]
GO-2021-0105,ethereum,go-ethereum,87c0ba92136a75db0ab2aba1046d4a9860375d6a," func (v *BlockValidator) ValidateState(block *types.Block, statedb *state.StateD
 		return fmt.Errorf(""invalid bloom (remote: %x  local: %x)"", header.Bloom, rbloom)
 	}
 	// Tre receipt Trie's root (R = (Tr [[H1, R1], ... [Hn, R1]]))
-	receiptSha := types.DeriveSha(receipts)
+	receiptSha := types.DeriveSha(receipts, new(trie.Trie))
 	if receiptSha != header.ReceiptHash {
 		return fmt.Errorf(""invalid receipt root hash (remote: %x local: %x)"", header.ReceiptHash, receiptSha)
 	}
",[False]
GO-2021-0105,ethereum,go-ethereum,87c0ba92136a75db0ab2aba1046d4a9860375d6a," func (g *Genesis) ToBlock(db ethdb.Database) *types.Block {
 	statedb.Commit(false)
 	statedb.Database().TrieDB().Commit(root, true, nil)
 
-	return types.NewBlock(head, nil, nil, nil)
+	return types.NewBlock(head, nil, nil, nil, new(trie.Trie))
 }
 
 // Commit writes the block and state of a genesis specification to the database.
",[False]
GO-2021-0105,ethereum,go-ethereum,87c0ba92136a75db0ab2aba1046d4a9860375d6a," func InspectDatabase(db ethdb.Database) error {
 		numHashPairing  common.StorageSize
 		hashNumPairing  common.StorageSize
 		trieSize        common.StorageSize
+		codeSize        common.StorageSize
 		txlookupSize    common.StorageSize
 		accountSnapSize common.StorageSize
 		storageSnapSize common.StorageSize
",[False]
GO-2021-0105,ethereum,go-ethereum,87c0ba92136a75db0ab2aba1046d4a9860375d6a," func InspectDatabase(db ethdb.Database) error {
 			chtTrieNodes += size
 		case bytes.HasPrefix(key, []byte(""blt-"")) && len(key) == 4+common.HashLength:
 			bloomTrieNodes += size
+		case bytes.HasPrefix(key, codePrefix) && len(key) == len(codePrefix)+common.HashLength:
+			codeSize += size
 		case len(key) == common.HashLength:
 			trieSize += size
 		default:
",[False]
GO-2021-0105,ethereum,go-ethereum,87c0ba92136a75db0ab2aba1046d4a9860375d6a," func InspectDatabase(db ethdb.Database) error {
 		{""Key-Value store"", ""Block hash->number"", hashNumPairing.String()},
 		{""Key-Value store"", ""Transaction index"", txlookupSize.String()},
 		{""Key-Value store"", ""Bloombit index"", bloomBitsSize.String()},
+		{""Key-Value store"", ""Contract codes"", codeSize.String()},
 		{""Key-Value store"", ""Trie nodes"", trieSize.String()},
 		{""Key-Value store"", ""Trie preimages"", preimageSize.String()},
 		{""Key-Value store"", ""Account snapshot"", accountSnapSize.String()},
",[False]
GO-2021-0105,ethereum,go-ethereum,87c0ba92136a75db0ab2aba1046d4a9860375d6a," func NewDatabaseWithCache(db ethdb.Database, cache int, journal string) Database
 	return &cachingDB{
 		db:            trie.NewDatabaseWithCache(db, cache, journal),
 		codeSizeCache: csc,
+		codeCache:     fastcache.New(codeCacheSize),
 	}
 }
 
 type cachingDB struct {
 	db            *trie.Database
 	codeSizeCache *lru.Cache
+	codeCache     *fastcache.Cache
 }
 
 // OpenTrie opens the main account trie at a specific root hash.
",[False]
GO-2021-0105,ethereum,go-ethereum,87c0ba92136a75db0ab2aba1046d4a9860375d6a," func (s *StateDB) createObject(addr common.Address) (newobj, prev *stateObject)
 		s.journal.append(resetObjectChange{prev: prev, prevdestruct: prevdestruct})
 	}
 	s.setStateObject(newobj)
-	return newobj, prev
+	if prev != nil && !prev.deleted {
+		return newobj, prev
+	}
+	return newobj, nil
 }
 
 // CreateAccount explicitly creates a state object. If a state object with the address
",[True]
GO-2021-0105,ethereum,go-ethereum,87c0ba92136a75db0ab2aba1046d4a9860375d6a," func (s *StateDB) Commit(deleteEmptyObjects bool) (common.Hash, error) {
 	s.IntermediateRoot(deleteEmptyObjects)
 
 	// Commit objects to the trie, measuring the elapsed time
+	codeWriter := s.db.TrieDB().DiskDB().NewBatch()
 	for addr := range s.stateObjectsDirty {
 		if obj := s.stateObjects[addr]; !obj.deleted {
 			// Write any contract code associated with the state object
 			if obj.code != nil && obj.dirtyCode {
-				s.db.TrieDB().InsertBlob(common.BytesToHash(obj.CodeHash()), obj.code)
+				rawdb.WriteCode(codeWriter, common.BytesToHash(obj.CodeHash()), obj.code)
 				obj.dirtyCode = false
 			}
 			// Write any storage changes in the state object to its storage trie
",[False]
GO-2021-0105,ethereum,go-ethereum,87c0ba92136a75db0ab2aba1046d4a9860375d6a," func (s *StateDB) Commit(deleteEmptyObjects bool) (common.Hash, error) {
 	if len(s.stateObjectsDirty) > 0 {
 		s.stateObjectsDirty = make(map[common.Address]struct{})
 	}
+	if codeWriter.ValueSize() > 0 {
+		if err := codeWriter.Write(); err != nil {
+			log.Crit(""Failed to commit dirty codes"", ""error"", err)
+		}
+	}
 	// Write the account trie changes, measuing the amount of wasted time
 	var start time.Time
 	if metrics.EnabledExpensive {
",[False]
GO-2021-0105,ethereum,go-ethereum,87c0ba92136a75db0ab2aba1046d4a9860375d6a," func NewStateSync(root common.Hash, database ethdb.KeyValueReader, bloom *trie.S
 			return err
 		}
 		syncer.AddSubTrie(obj.Root, 64, parent, nil)
-		syncer.AddRawEntry(common.BytesToHash(obj.CodeHash), 64, parent)
+		syncer.AddCodeEntry(common.BytesToHash(obj.CodeHash), 64, parent)
 		return nil
 	}
 	syncer = trie.NewSync(root, database, callback, bloom)
",[False]
GO-2021-0105,ethereum,go-ethereum,87c0ba92136a75db0ab2aba1046d4a9860375d6a," type storageblock struct {
 // The values of TxHash, UncleHash, ReceiptHash and Bloom in header
 // are ignored and set to values derived from the given txs, uncles
 // and receipts.
-func NewBlock(header *Header, txs []*Transaction, uncles []*Header, receipts []*Receipt) *Block {
+func NewBlock(header *Header, txs []*Transaction, uncles []*Header, receipts []*Receipt, hasher Hasher) *Block {
 	b := &Block{header: CopyHeader(header), td: new(big.Int)}
 
 	// TODO: panic if len(txs) != len(receipts)
 	if len(txs) == 0 {
 		b.header.TxHash = EmptyRootHash
 	} else {
-		b.header.TxHash = DeriveSha(Transactions(txs))
+		b.header.TxHash = DeriveSha(Transactions(txs), hasher)
 		b.transactions = make(Transactions, len(txs))
 		copy(b.transactions, txs)
 	}
",[False]
GO-2021-0105,ethereum,go-ethereum,87c0ba92136a75db0ab2aba1046d4a9860375d6a," func NewBlock(header *Header, txs []*Transaction, uncles []*Header, receipts []*
 	if len(receipts) == 0 {
 		b.header.ReceiptHash = EmptyRootHash
 	} else {
-		b.header.ReceiptHash = DeriveSha(Receipts(receipts))
+		b.header.ReceiptHash = DeriveSha(Receipts(receipts), hasher)
 		b.header.Bloom = CreateBloom(receipts)
 	}
 
",[False]
GO-2021-0105,ethereum,go-ethereum,87c0ba92136a75db0ab2aba1046d4a9860375d6a," import (
 
 	""github.com/ethereum/go-ethereum/common""
 	""github.com/ethereum/go-ethereum/rlp""
-	""github.com/ethereum/go-ethereum/trie""
 )
 
+// DerivableList is the interface which can derive the hash.
 type DerivableList interface {
 	Len() int
 	GetRlp(i int) []byte
 }
 
-func DeriveSha(list DerivableList) common.Hash {
+// Hasher is the tool used to calculate the hash of derivable list.
+type Hasher interface {
+	Reset()
+	Update([]byte, []byte)
+	Hash() common.Hash
+}
+
+func DeriveSha(list DerivableList, hasher Hasher) common.Hash {
+	hasher.Reset()
 	keybuf := new(bytes.Buffer)
-	trie := new(trie.Trie)
 	for i := 0; i < list.Len(); i++ {
 		keybuf.Reset()
 		rlp.Encode(keybuf, uint(i))
-		trie.Update(keybuf.Bytes(), list.GetRlp(i))
+		hasher.Update(keybuf.Bytes(), list.GetRlp(i))
 	}
-	return trie.Hash()
+	return hasher.Hash()
 }
",[False]
GO-2021-0105,ethereum,go-ethereum,87c0ba92136a75db0ab2aba1046d4a9860375d6a," func (q *queue) DeliverBodies(id string, txLists [][]*types.Transaction, uncleLi
 	q.lock.Lock()
 	defer q.lock.Unlock()
 	validate := func(index int, header *types.Header) error {
-		if types.DeriveSha(types.Transactions(txLists[index])) != header.TxHash {
+		if types.DeriveSha(types.Transactions(txLists[index]), new(trie.Trie)) != header.TxHash {
 			return errInvalidBody
 		}
 		if types.CalcUncleHash(uncleLists[index]) != header.UncleHash {
",[False]
GO-2021-0105,ethereum,go-ethereum,87c0ba92136a75db0ab2aba1046d4a9860375d6a," func (q *queue) DeliverReceipts(id string, receiptList [][]*types.Receipt) (int,
 	q.lock.Lock()
 	defer q.lock.Unlock()
 	validate := func(index int, header *types.Header) error {
-		if types.DeriveSha(types.Receipts(receiptList[index])) != header.ReceiptHash {
+		if types.DeriveSha(types.Receipts(receiptList[index]), new(trie.Trie)) != header.ReceiptHash {
 			return errInvalidReceipt
 		}
 		return nil
",[False]
GO-2021-0105,ethereum,go-ethereum,87c0ba92136a75db0ab2aba1046d4a9860375d6a," func (s *stateSync) process(req *stateReq) (int, error) {
 
 	// Iterate over all the delivered data and inject one-by-one into the trie
 	for _, blob := range req.response {
-		_, hash, err := s.processNodeData(blob)
+		hash, err := s.processNodeData(blob)
 		switch err {
 		case nil:
 			s.numUncommitted++
",[False]
GO-2021-0105,ethereum,go-ethereum,87c0ba92136a75db0ab2aba1046d4a9860375d6a," func (s *stateSync) process(req *stateReq) (int, error) {
 // processNodeData tries to inject a trie node data blob delivered from a remote
 // peer into the state trie, returning whether anything useful was written or any
 // error occurred.
-func (s *stateSync) processNodeData(blob []byte) (bool, common.Hash, error) {
+func (s *stateSync) processNodeData(blob []byte) (common.Hash, error) {
 	res := trie.SyncResult{Data: blob}
 	s.keccak.Reset()
 	s.keccak.Write(blob)
 	s.keccak.Sum(res.Hash[:0])
-	committed, _, err := s.sched.Process([]trie.SyncResult{res})
-	return committed, res.Hash, err
+	err := s.sched.Process(res)
+	return res.Hash, err
 }
 
 // updateStats bumps the various state sync progress counters and displays a log
",[False]
GO-2021-0105,ethereum,go-ethereum,87c0ba92136a75db0ab2aba1046d4a9860375d6a," func (f *BlockFetcher) loop() {
 						announce.time = task.time
 
 						// If the block is empty (header only), short circuit into the final import queue
-						if header.TxHash == types.DeriveSha(types.Transactions{}) && header.UncleHash == types.CalcUncleHash([]*types.Header{}) {
+						if header.TxHash == types.EmptyRootHash && header.UncleHash == types.EmptyUncleHash {
 							log.Trace(""Block empty, skipping body retrieval"", ""peer"", announce.origin, ""number"", header.Number, ""hash"", header.Hash())
 
 							block := types.NewBlockWithHeader(header)
",[False]
GO-2021-0105,ethereum,go-ethereum,87c0ba92136a75db0ab2aba1046d4a9860375d6a," func (f *BlockFetcher) loop() {
 							continue
 						}
 						if txnHash == (common.Hash{}) {
-							txnHash = types.DeriveSha(types.Transactions(task.transactions[i]))
+							txnHash = types.DeriveSha(types.Transactions(task.transactions[i]), new(trie.Trie))
 						}
 						if txnHash != announce.header.TxHash {
 							continue
",[False]
GO-2021-0105,ethereum,go-ethereum,87c0ba92136a75db0ab2aba1046d4a9860375d6a," func (pm *ProtocolManager) handleMsg(p *peer) error {
 				return errResp(ErrDecode, ""msg %v: %v"", msg, err)
 			}
 			// Retrieve the requested state entry, stopping if enough was found
-			if entry, err := pm.blockchain.TrieNode(hash); err == nil {
+			// todo now the code and trienode is mixed in the protocol level,
+			// separate these two types.
+			entry, err := pm.blockchain.TrieNode(hash)
+			if len(entry) == 0 || err != nil {
+				// Read the contract code with prefix only to save unnecessary lookups.
+				entry, err = pm.blockchain.ContractCodeWithPrefix(hash)
+			}
+			if err == nil && len(entry) > 0 {
 				data = append(data, entry)
 				bytes += len(entry)
 			}
",[False]
GO-2021-0105,ethereum,go-ethereum,87c0ba92136a75db0ab2aba1046d4a9860375d6a," func (pm *ProtocolManager) handleMsg(p *peer) error {
 			log.Warn(""Propagated block has invalid uncles"", ""have"", hash, ""exp"", request.Block.UncleHash())
 			break // TODO(karalabe): return error eventually, but wait a few releases
 		}
-		if hash := types.DeriveSha(request.Block.Transactions()); hash != request.Block.TxHash() {
+		if hash := types.DeriveSha(request.Block.Transactions(), new(trie.Trie)); hash != request.Block.TxHash() {
 			log.Warn(""Propagated block has invalid body"", ""have"", hash, ""exp"", request.Block.TxHash())
 			break // TODO(karalabe): return error eventually, but wait a few releases
 		}
",[False]
GO-2021-0105,ethereum,go-ethereum,87c0ba92136a75db0ab2aba1046d4a9860375d6a," func (r *BlockRequest) Validate(db ethdb.Database, msg *Msg) error {
 	if r.Header == nil {
 		return errHeaderUnavailable
 	}
-	if r.Header.TxHash != types.DeriveSha(types.Transactions(body.Transactions)) {
+	if r.Header.TxHash != types.DeriveSha(types.Transactions(body.Transactions), new(trie.Trie)) {
 		return errTxHashMismatch
 	}
 	if r.Header.UncleHash != types.CalcUncleHash(body.Uncles) {
",[False]
GO-2021-0105,ethereum,go-ethereum,87c0ba92136a75db0ab2aba1046d4a9860375d6a," func (r *ReceiptsRequest) Validate(db ethdb.Database, msg *Msg) error {
 	if r.Header == nil {
 		return errHeaderUnavailable
 	}
-	if r.Header.ReceiptHash != types.DeriveSha(receipt) {
+	if r.Header.ReceiptHash != types.DeriveSha(receipt, new(trie.Trie)) {
 		return errReceiptHashMismatch
 	}
 	// Validations passed, store and return
",[False]
GO-2021-0105,ethereum,go-ethereum,87c0ba92136a75db0ab2aba1046d4a9860375d6a," func (h *serverHandler) handleMsg(p *clientPeer, wg *sync.WaitGroup) error {
 						p.bumpInvalid()
 						continue
 					}
-					code, err := triedb.Node(common.BytesToHash(account.CodeHash))
+					code, err := h.blockchain.StateCache().ContractCode(common.BytesToHash(request.AccKey), common.BytesToHash(account.CodeHash))
 					if err != nil {
 						p.Log().Warn(""Failed to retrieve account code"", ""block"", header.Number, ""hash"", header.Hash(), ""account"", common.BytesToHash(request.AccKey), ""codehash"", common.BytesToHash(account.CodeHash), ""err"", err)
 						continue
",[False]
GO-2021-0105,ethereum,go-ethereum,87c0ba92136a75db0ab2aba1046d4a9860375d6a," type CodeRequest struct {
 
 // StoreResult stores the retrieved data in local database
 func (req *CodeRequest) StoreResult(db ethdb.Database) {
-	db.Put(req.Hash[:], req.Data)
+	rawdb.WriteCode(db, req.Hash, req.Data)
 }
 
 // BlockRequest is the ODR request type for retrieving block bodies
",[False]
GO-2021-0105,ethereum,go-ethereum,87c0ba92136a75db0ab2aba1046d4a9860375d6a," func (db *odrDatabase) ContractCode(addrHash, codeHash common.Hash) ([]byte, err
 	if codeHash == sha3Nil {
 		return nil, nil
 	}
-	if code, err := db.backend.Database().Get(codeHash[:]); err == nil {
+	code := rawdb.ReadCode(db.backend.Database(), codeHash)
+	if len(code) != 0 {
 		return code, nil
 	}
 	id := *db.id
",[False]
GO-2021-0105,ethereum,go-ethereum,87c0ba92136a75db0ab2aba1046d4a9860375d6a," func (w *worker) updateSnapshot() {
 		w.current.txs,
 		uncles,
 		w.current.receipts,
+		new(trie.Trie),
 	)
 
 	w.snapshotState = w.current.state.Copy()
",[False]
GO-2021-0105,ethereum,go-ethereum,87c0ba92136a75db0ab2aba1046d4a9860375d6a," var cachedNodeSize = int(reflect.TypeOf(cachedNode{}).Size())
 // reference map.
 const cachedNodeChildrenSize = 48
 
-// rlp returns the raw rlp encoded blob of the cached node, either directly from
-// the cache, or by regenerating it from the collapsed node.
+// rlp returns the raw rlp encoded blob of the cached trie node, either directly
+// from the cache, or by regenerating it from the collapsed node.
 func (n *cachedNode) rlp() []byte {
 	if node, ok := n.node.(rawNode); ok {
 		return node
",[False]
GO-2021-0105,ethereum,go-ethereum,87c0ba92136a75db0ab2aba1046d4a9860375d6a," func (n *cachedNode) obj(hash common.Hash) node {
 	return expandNode(hash[:], n.node)
 }
 
-// forChilds invokes the callback for  all the tracked children of this node,
-// both the implicit ones  from inside the node as well as the explicit ones
-//from outside the node.
+// forChilds invokes the callback for all the tracked children of this node,
+// both the implicit ones from inside the node as well as the explicit ones
+// from outside the node.
 func (n *cachedNode) forChilds(onChild func(hash common.Hash)) {
 	for child := range n.children {
 		onChild(child)
",[False]
GO-2021-0105,ethereum,go-ethereum,87c0ba92136a75db0ab2aba1046d4a9860375d6a," func (db *Database) Nodes() []common.Hash {
 }
 
 // Reference adds a new reference from a parent node to a child node.
+// This function is used to add reference between internal trie node
+// and external node(e.g. storage trie root), all internal trie nodes
+// are referenced together by database itself.
 func (db *Database) Reference(child common.Hash, parent common.Hash) {
 	db.lock.Lock()
 	defer db.lock.Unlock()
",[False]
GO-2021-0105,ethereum,go-ethereum,87c0ba92136a75db0ab2aba1046d4a9860375d6a," func (db *Database) Cap(limit common.StorageSize) error {
 	size := db.dirtiesSize + common.StorageSize((len(db.dirties)-1)*cachedNodeSize)
 	size += db.childrenSize - common.StorageSize(len(db.dirties[common.Hash{}].children)*(common.HashLength+2))
 
-	// We reuse an ephemeral buffer for the keys. The batch Put operation
-	// copies it internally, so we can reuse it.
-	var keyBuf [secureKeyLength]byte
-	copy(keyBuf[:], secureKeyPrefix)
-
 	// If the preimage cache got large enough, push to disk. If it's still small
 	// leave for later to deduplicate writes.
 	flushPreimages := db.preimagesSize > 4*1024*1024
 	if flushPreimages {
-		for hash, preimage := range db.preimages {
-			copy(keyBuf[secureKeyPrefixLength:], hash[:])
-			if err := batch.Put(keyBuf[:], preimage); err != nil {
-				log.Error(""Failed to commit preimage from trie database"", ""err"", err)
+		rawdb.WritePreimages(batch, db.preimages)
+		if batch.ValueSize() > ethdb.IdealBatchSize {
+			if err := batch.Write(); err != nil {
 				return err
 			}
-			if batch.ValueSize() > ethdb.IdealBatchSize {
-				if err := batch.Write(); err != nil {
-					return err
-				}
-				batch.Reset()
-			}
+			batch.Reset()
 		}
 	}
 	// Keep committing nodes from the flush-list until we're below allowance
",[False]
GO-2021-0105,ethereum,go-ethereum,87c0ba92136a75db0ab2aba1046d4a9860375d6a," func (db *Database) Cap(limit common.StorageSize) error {
 	for size > limit && oldest != (common.Hash{}) {
 		// Fetch the oldest referenced node and push into the batch
 		node := db.dirties[oldest]
-		if err := batch.Put(oldest[:], node.rlp()); err != nil {
-			return err
-		}
+		rawdb.WriteTrieNode(batch, oldest, node.rlp())
+
 		// If we exceeded the ideal batch size, commit and reset
 		if batch.ValueSize() >= ethdb.IdealBatchSize {
 			if err := batch.Write(); err != nil {
",[False]
GO-2021-0105,ethereum,go-ethereum,87c0ba92136a75db0ab2aba1046d4a9860375d6a," func (db *Database) Cap(limit common.StorageSize) error {
 	defer db.lock.Unlock()
 
 	if flushPreimages {
-		db.preimages = make(map[common.Hash][]byte)
-		db.preimagesSize = 0
+		db.preimages, db.preimagesSize = make(map[common.Hash][]byte), 0
 	}
 	for db.oldest != oldest {
 		node := db.dirties[db.oldest]
",[False]
GO-2021-0105,ethereum,go-ethereum,87c0ba92136a75db0ab2aba1046d4a9860375d6a," func (db *Database) Commit(node common.Hash, report bool, callback func(common.H
 	start := time.Now()
 	batch := db.diskdb.NewBatch()
 
-	// We reuse an ephemeral buffer for the keys. The batch Put operation
-	// copies it internally, so we can reuse it.
-	var keyBuf [secureKeyLength]byte
-	copy(keyBuf[:], secureKeyPrefix)
-
 	// Move all of the accumulated preimages into a write batch
-	for hash, preimage := range db.preimages {
-		copy(keyBuf[secureKeyPrefixLength:], hash[:])
-		if err := batch.Put(keyBuf[:], preimage); err != nil {
-			log.Error(""Failed to commit preimage from trie database"", ""err"", err)
+	rawdb.WritePreimages(batch, db.preimages)
+	if batch.ValueSize() > ethdb.IdealBatchSize {
+		if err := batch.Write(); err != nil {
 			return err
 		}
-		// If the batch is too large, flush to disk
-		if batch.ValueSize() > ethdb.IdealBatchSize {
-			if err := batch.Write(); err != nil {
-				return err
-			}
-			batch.Reset()
-		}
+		batch.Reset()
 	}
 	// Since we're going to replay trie node writes into the clean cache, flush out
 	// any batched pre-images before continuing.
",[False]
GO-2021-0105,ethereum,go-ethereum,87c0ba92136a75db0ab2aba1046d4a9860375d6a," func (db *Database) Commit(node common.Hash, report bool, callback func(common.H
 	batch.Reset()
 
 	// Reset the storage counters and bumpd metrics
-	db.preimages = make(map[common.Hash][]byte)
-	db.preimagesSize = 0
+	db.preimages, db.preimagesSize = make(map[common.Hash][]byte), 0
 
 	memcacheCommitTimeTimer.Update(time.Since(start))
 	memcacheCommitSizeMeter.Mark(int64(storage - db.dirtiesSize))
",[False]
GO-2021-0105,ethereum,go-ethereum,87c0ba92136a75db0ab2aba1046d4a9860375d6a," func (db *Database) commit(hash common.Hash, batch ethdb.Batch, uncacher *cleane
 	if err != nil {
 		return err
 	}
-	if err := batch.Put(hash[:], node.rlp()); err != nil {
-		return err
-	}
+	// If we've reached an optimal batch size, commit and start over
+	rawdb.WriteTrieNode(batch, hash, node.rlp())
 	if callback != nil {
 		callback(hash)
 	}
-	// If we've reached an optimal batch size, commit and start over
 	if batch.ValueSize() >= ethdb.IdealBatchSize {
 		if err := batch.Write(); err != nil {
 			return err
",[False]
GO-2021-0105,ethereum,go-ethereum,87c0ba92136a75db0ab2aba1046d4a9860375d6a," func (t *SecureTrie) GetKey(shaKey []byte) []byte {
 	if key, ok := t.getSecKeyCache()[string(shaKey)]; ok {
 		return key
 	}
-	key, _ := t.trie.db.preimage(common.BytesToHash(shaKey))
-	return key
+	return t.trie.db.preimage(common.BytesToHash(shaKey))
 }
 
 // Commit writes all nodes and the secure hash pre-images to the trie's database.
",[False]
GO-2021-0105,ethereum,go-ethereum,87c0ba92136a75db0ab2aba1046d4a9860375d6a," func NewSync(root common.Hash, database ethdb.KeyValueReader, callback LeafCallb
 	ts := &Sync{
 		database: database,
 		membatch: newSyncMemBatch(),
-		requests: make(map[common.Hash]*request),
+		nodeReqs: make(map[common.Hash]*request),
+		codeReqs: make(map[common.Hash]*request),
 		queue:    prque.New(nil),
 		bloom:    bloom,
 	}
",[False]
GO-2021-0105,ethereum,go-ethereum,87c0ba92136a75db0ab2aba1046d4a9860375d6a," func (s *Sync) AddSubTrie(root common.Hash, depth int, parent common.Hash, callb
 	if root == emptyRoot {
 		return
 	}
-	if _, ok := s.membatch.batch[root]; ok {
+	if s.membatch.hasNode(root) {
 		return
 	}
 	if s.bloom == nil || s.bloom.Contains(root[:]) {
-		// Bloom filter says this might be a duplicate, double check
-		blob, _ := s.database.Get(root[:])
-		if local, err := decodeNode(root[:], blob); local != nil && err == nil {
+		// Bloom filter says this might be a duplicate, double check.
+		// If database says yes, then at least the trie node is present
+		// and we hold the assumption that it's NOT legacy contract code.
+		blob := rawdb.ReadTrieNode(s.database, root)
+		if len(blob) > 0 {
 			return
 		}
 		// False positive, bump fault meter
",[False]
GO-2021-0105,ethereum,go-ethereum,87c0ba92136a75db0ab2aba1046d4a9860375d6a," func (s *Sync) AddSubTrie(root common.Hash, depth int, parent common.Hash, callb
 	}
 	// If this sub-trie has a designated parent, link them together
 	if parent != (common.Hash{}) {
-		ancestor := s.requests[parent]
+		ancestor := s.nodeReqs[parent]
 		if ancestor == nil {
 			panic(fmt.Sprintf(""sub-trie ancestor not found: %x"", parent))
 		}
",[False]
GO-2021-0105,ethereum,go-ethereum,87c0ba92136a75db0ab2aba1046d4a9860375d6a," func (s *Sync) children(req *request, object node) ([]*request, error) {
 		if node, ok := (child.node).(hashNode); ok {
 			// Try to resolve the node from the local database
 			hash := common.BytesToHash(node)
-			if _, ok := s.membatch.batch[hash]; ok {
+			if s.membatch.hasNode(hash) {
 				continue
 			}
 			if s.bloom == nil || s.bloom.Contains(node) {
-				// Bloom filter says this might be a duplicate, double check
-				if ok, _ := s.database.Has(node); ok {
+				// Bloom filter says this might be a duplicate, double check.
+				// If database says yes, then at least the trie node is present
+				// and we hold the assumption that it's NOT legacy contract code.
+				if blob := rawdb.ReadTrieNode(s.database, common.BytesToHash(node)); len(blob) > 0 {
 					continue
 				}
 				// False positive, bump fault meter
",[False]
GO-2021-0105,ethereum,go-ethereum,87c0ba92136a75db0ab2aba1046d4a9860375d6a," func (s *Sync) children(req *request, object node) ([]*request, error) {
 // committed themselves.
 func (s *Sync) commit(req *request) (err error) {
 	// Write the node content to the membatch
-	s.membatch.batch[req.hash] = req.data
-
-	delete(s.requests, req.hash)
-
+	if req.code {
+		s.membatch.codes[req.hash] = req.data
+		delete(s.codeReqs, req.hash)
+	} else {
+		s.membatch.nodes[req.hash] = req.data
+		delete(s.nodeReqs, req.hash)
+	}
 	// Check all parents for completion
 	for _, parent := range req.parents {
 		parent.deps--
",[False]
GO-2021-0105,ethereum,go-ethereum,87c0ba92136a75db0ab2aba1046d4a9860375d6a," func (b *SyncBloom) init(database ethdb.Iteratee) {
 	)
 	for it.Next() && atomic.LoadUint32(&b.closed) == 0 {
 		// If the database entry is a trie node, add it to the bloom
-		if key := it.Key(); len(key) == common.HashLength {
+		key := it.Key()
+		if len(key) == common.HashLength {
 			b.bloom.Add(syncBloomHasher(key))
 			bloomLoadMeter.Mark(1)
 		}
+		// If the database entry is a contract code, add it to the bloom
+		if ok, hash := rawdb.IsCodeKey(key); ok {
+			b.bloom.Add(syncBloomHasher(hash))
+			bloomLoadMeter.Mark(1)
+		}
 		// If enough time elapsed since the last iterator swap, restart
 		if time.Since(swap) > 8*time.Second {
 			key := common.CopyBytes(it.Key())
",[False]
GO-2021-0105,ethereum,go-ethereum,87c0ba92136a75db0ab2aba1046d4a9860375d6a," func (t *Trie) hashRoot(db *Database) (node, node, error) {
 	t.unhashed = 0
 	return hashed, cached, nil
 }
+
+// Reset drops the referenced root node and cleans all internal state.
+func (t *Trie) Reset() {
+	t.root = nil
+	t.unhashed = 0
+}
",[False]
GO-2021-0105,ethereum,go-ethereum,87c0ba92136a75db0ab2aba1046d4a9860375d6a," func (s *StateDB) Commit(deleteEmptyObjects bool) (common.Hash, error) {
 		if account.Root != emptyRoot {
 			s.db.TrieDB().Reference(account.Root, parent)
 		}
-		code := common.BytesToHash(account.CodeHash)
-		if code != emptyCode {
-			s.db.TrieDB().Reference(code, parent)
-		}
 		return nil
 	})
 	if metrics.EnabledExpensive {
",[False]
GO-2022-0248,cloudflare,cfrpki,eb9cc4db7b7b79e44f56dfaa959fccdfb2af8284," func (s *state) WriteRsyncFileOnDisk(path string, data []byte, withdraw bool) er
 	if err != nil {
 		log.Fatal(err)
 	}
-	// GHSA-cqh2-vc2f-q4fh: Prevent parent directory writes outside of Basepath
-	fPath = strings.ReplaceAll(fPath, ""../"", """")
+	// GHSA-8459-6rc9-8vf8: Prevent parent directory writes outside of Basepath
+	if strings.Contains(fPath, ""../"") || strings.Contains(fPath, ""..\\"") {
+		return fmt.Errorf(""Path %q contains illegal path element"", fPath)
+	}
 
 	f, err := os.Create(filepath.Join(s.Basepath, fPath))
 	if err != nil {
",[False]
GO-2022-0248,cloudflare,cfrpki,eb9cc4db7b7b79e44f56dfaa959fccdfb2af8284," func (v *Validator) ValidateROA(roa *librpki.RPKIROA) error {
 }
 
 func (v *Validator) AddManifest(pkifile *PKIFile, mft *librpki.RPKIManifest) (bool, []*PKIFile, *Resource, error) {
-	pathCert := ExtractPathManifest(mft)
+	pathCert, err := ExtractPathManifest(mft)
+	if err != nil {
+		return false, nil, nil, fmt.Errorf(""ExtractPathManifest failed: %v"", err)
+	}
 
 	valid, _, res, err := v.AddCert(mft.Certificate, false)
 	if res == nil {
",[False]
GO-2022-0248,cloudflare,cfrpki,eb9cc4db7b7b79e44f56dfaa959fccdfb2af8284," func ExtractPathCert(cert *librpki.RPKICertificate) []*PKIFile {
 }
 
 // Returns the list of files from the Manifest
-func ExtractPathManifest(mft *librpki.RPKIManifest) []*PKIFile {
+func ExtractPathManifest(mft *librpki.RPKIManifest) ([]*PKIFile, error) {
 	fileList := make([]*PKIFile, 0)
 	for _, file := range mft.Content.FileList {
 		curFile := file.Name
 		path := string(curFile)
-		// GHSA-cqh2-vc2f-q4fh: Prevent file path references to parent
+		// GHSA-8459-6rc9-8vf8: Prevent file path references to parent
 		// directories.
-		path = strings.ReplaceAll(path, ""../"", """")
+		if strings.Contains(path, ""../"") || strings.Contains(path, ""..\\"") {
+			return nil, fmt.Errorf(""Path %q contains illegal path element"", path)
+		}
 		item := PKIFile{
 			Type:         DetermineType(path),
 			Path:         path,
",[True]
GO-2022-0248,cloudflare,cfrpki,eb9cc4db7b7b79e44f56dfaa959fccdfb2af8284," func ExtractPathManifest(mft *librpki.RPKIManifest) []*PKIFile {
 		}
 		fileList = append(fileList, &item)
 	}
-	return fileList
+	return fileList, nil
 }
 
 func (sm *SimpleManager) AddInitial(fileList []*PKIFile) {
",[True]
GO-2023-1559,ipfs,go-unixfsnode,59050ea8bc458ae55246ae09243e6e165923e076," func NewUnixFSHAMTShard(ctx context.Context, substrate dagpb.PBNode, data data.U
 		return nil, err
 	}
 	shardCache := make(map[ipld.Link]*_UnixFSHAMTShard, substrate.FieldLinks().Length())
-	bf := bitField(data)
+	bf, err := bitField(data)
+	if err != nil {
+		return nil, err
+	}
 	return &_UnixFSHAMTShard{
 		ctx:          ctx,
 		_substrate:   substrate,
",[True]
GO-2023-1559,ipfs,go-unixfsnode,59050ea8bc458ae55246ae09243e6e165923e076," func maxPadLength(nd data.UnixFSData) int {
 	return len(fmt.Sprintf(""%X"", nd.FieldFanout().Must().Int()-1))
 }
 
-func bitField(nd data.UnixFSData) bitfield.Bitfield {
-	bf := bitfield.NewBitfield(int(nd.FieldFanout().Must().Int()))
+const maximumHamtWidth = 1 << 10
+
+func bitField(nd data.UnixFSData) (bitfield.Bitfield, error) {
+	fanout := int(nd.FieldFanout().Must().Int())
+	if fanout > maximumHamtWidth {
+		return nil, fmt.Errorf(""hamt witdh (%d) exceed maximum allowed (%d)"", fanout, maximumHamtWidth)
+	}
+	bf, err := bitfield.NewBitfield(fanout)
+	if err != nil {
+		return nil, err
+	}
 	bf.SetBytes(nd.FieldData().Must().Bytes())
-	return bf
+	return bf, nil
 }
 
 func checkLogTwo(v int) error {
",[True]
GO-2023-1623,crossplane,crossplane-runtime,53508a9f4374604db140dd8ab2fa52276441e738," func (p *Paved) setValue(s Segments, value any) error {
 				return errors.Errorf(""%s is not an array"", s[:i])
 			}
 
+			if p.maxFieldPathIndexEnabled() && current.Index > p.maxFieldPathIndex {
+				return errors.Errorf(""index %d is greater than max allowed index %d"", current.Index, p.maxFieldPathIndex)
+			}
+
 			if final {
 				array[current.Index] = v
 				return nil
",[False]
GO-2021-0063,ethereum,go-ethereum,bddd103a9f0af27ef533f04e06ea429cf76b6d46," func (h *serverHandler) handleMsg(p *clientPeer, wg *sync.WaitGroup) error {
 		var (
 			lastBHash common.Hash
 			root      common.Hash
+			header    *types.Header
 		)
 		reqCnt := len(req.Reqs)
 		if accept(req.ReqID, uint64(reqCnt), MaxProofsFetch) {
",[True]
GO-2021-0063,ethereum,go-ethereum,bddd103a9f0af27ef533f04e06ea429cf76b6d46," func (h *serverHandler) handleMsg(p *clientPeer, wg *sync.WaitGroup) error {
 					// Open the account or storage trie for the request
 					statedb := h.blockchain.StateCache()
 
+					var trie state.Trie
 					switch len(request.AccKey) {
 					case 0:
 						// No account key specified, open an account trie
",[True]
GO-2021-0063,ethereum,go-ethereum,bddd103a9f0af27ef533f04e06ea429cf76b6d46," func (h *serverHandler) handleMsg(p *clientPeer, wg *sync.WaitGroup) error {
 						return
 					}
 					// Look up the root hash belonging to the request
-					var (
-						header *types.Header
-						trie   state.Trie
-					)
 					if request.BHash != lastBHash {
 						root, lastBHash = common.Hash{}, request.BHash
 
",[True]
GO-2020-0022,cloudflare,golz4,199f5f7878062ca17a98e079f2dbe1205e2ed898," func clen(s []byte) C.int {
 
 // Uncompress with a known output size. len(out) should be equal to
 // the length of the uncompressed out.
-func Uncompress(in, out []byte) (err error) {
-	read := int(C.LZ4_uncompress(p(in), p(out), clen(out)))
-
-	if read != len(in) {
-		err = fmt.Errorf(""uncompress read %d bytes should have read %d"",
-			read, len(in))
+func Uncompress(in, out []byte) (error) {
+	if int(C.LZ4_decompress_safe(p(in), p(out), clen(in), clen(out))) < 0 {
+		return errors.New(""Malformed compression stream"")
 	}
-	return
+
+	return nil
 }
 
 // CompressBound calculates the size of the output buffer needed by
",[True]
GO-2023-1765,cloudflare,circl,ff8d91225f8954b4970b6d6382d2e4c78f4a4cf8," func DeriveAttributeKeysCCA(rand io.Reader, sp *SecretParams, attrs *Attributes)
 
 func EncryptCCA(rand io.Reader, public *PublicParams, policy *Policy, msg []byte) ([]byte, error) {
 	seed := make([]byte, macKeySeedSize)
-	_, err := rand.Read(seed)
+	_, err := io.ReadFull(rand, seed)
 	if err != nil {
 		return nil, err
 	}
",[True]
GO-2023-1765,cloudflare,circl,ff8d91225f8954b4970b6d6382d2e4c78f4a4cf8," func (v RSAVerifier) Blind(random io.Reader, message []byte) ([]byte, blindsign.
 	}
 
 	salt := make([]byte, v.hash.Size())
-	_, err := random.Read(salt)
+	_, err := io.ReadFull(random, salt)
 	if err != nil {
 		return nil, nil, err
 	}
",[True]
GO-2023-1765,cloudflare,circl,ff8d91225f8954b4970b6d6382d2e4c78f4a4cf8," func generateKeyPair(rand io.Reader) (*PublicKey, *PrivateKey, error) {
 func (pk *PublicKey) EncapsulateTo(ct []byte, ss []byte, seed []byte) {
 	if seed == nil {
 		seed = make([]byte, EncapsulationSeedSize)
-		_, _ = cryptoRand.Read(seed[:])
+		if _, err := cryptoRand.Read(seed[:]); err != nil {
+			panic(err)
+		}
 	}
 	if len(seed) != EncapsulationSeedSize {
 		panic(""seed must be of length EncapsulationSeedSize"")
",[True]
GO-2023-1765,cloudflare,circl,ff8d91225f8954b4970b6d6382d2e4c78f4a4cf8," func GenerateKeyPair(rand io.Reader) (*PublicKey, *PrivateKey, error) {
 func (pk *PublicKey) EncapsulateTo(ct, ss []byte, seed []byte) {
 	if seed == nil {
 		seed = make([]byte, EncapsulationSeedSize)
-		cryptoRand.Read(seed[:])
+		if _, err := cryptoRand.Read(seed[:]); err != nil {
+			panic(err)
+		}
 	} else {
 		if len(seed) != EncapsulationSeedSize {
 			panic(""seed must be of length EncapsulationSeedSize"")
",[True]
GO-2023-1765,cloudflare,circl,ff8d91225f8954b4970b6d6382d2e4c78f4a4cf8," func (*scheme) DeriveKeyPair(seed []byte) (kem.PublicKey, kem.PrivateKey) {
 
 func (sch *scheme) Encapsulate(pk kem.PublicKey) (ct []byte, ss []byte, err error) {
 	var seed [EncapsulationSeedSize]byte
-	cryptoRand.Read(seed[:])
+	if _, err := cryptoRand.Read(seed[:]); err != nil {
+		return nil, nil, err
+	}
 	return sch.EncapsulateDeterministically(pk, seed[:])
 }
 
",[True]
GO-2023-1566,usememos,memos,b11d2130a084385eb65c3761a3c841ebe9f81ae8," func (s *Server) registerResourceRoutes(g *echo.Group) {
 		}
 
 		resourceCreate.CreatorID = userID
+		// Only allow those external links with http prefix.
+		if resourceCreate.ExternalLink != """" && !strings.HasPrefix(resourceCreate.ExternalLink, ""http"") {
+			return echo.NewHTTPError(http.StatusBadRequest, ""Invalid external link"")
+		}
 		resource, err := s.Store.CreateResource(ctx, resourceCreate)
 		if err != nil {
 			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to create resource"").SetInternal(err)
",[True]
GO-2023-1566,usememos,memos,b11d2130a084385eb65c3761a3c841ebe9f81ae8," func (s *Server) registerResourceRoutes(g *echo.Group) {
 			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to fetch resource"").SetInternal(err)
 		}
 
-		c.Response().Writer.WriteHeader(http.StatusOK)
-		c.Response().Writer.Header().Set(""Content-Type"", resource.Type)
-		c.Response().Writer.Header().Set(echo.HeaderContentSecurityPolicy, ""default-src 'self'"")
-		if _, err := c.Response().Writer.Write(resource.Blob); err != nil {
-			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to write resource blob"").SetInternal(err)
-		}
-		return nil
+		return c.Stream(http.StatusOK, resource.Type, bytes.NewReader(resource.Blob))
 	})
 
 	g.PATCH(""/resource/:resourceId"", func(c echo.Context) error {
",[True]
GO-2023-1566,usememos,memos,b11d2130a084385eb65c3761a3c841ebe9f81ae8," func (s *Server) registerResourcePublicRoutes(g *echo.Group) {
 		}
 		resource, err := s.Store.FindResource(ctx, resourceFind)
 		if err != nil {
-			return echo.NewHTTPError(http.StatusInternalServerError, fmt.Sprintf(""Failed to fetch resource ID: %v"", resourceID)).SetInternal(err)
+			return echo.NewHTTPError(http.StatusInternalServerError, fmt.Sprintf(""Failed to find resource by ID: %v"", resourceID)).SetInternal(err)
 		}
 
-		resourceType := strings.ToLower(resource.Type)
-		if strings.HasPrefix(resourceType, ""text"") || (strings.HasPrefix(resourceType, ""application"") && resourceType != ""application/pdf"") {
-			resourceType = echo.MIMETextPlain
-		}
 		c.Response().Writer.Header().Set(echo.HeaderCacheControl, ""max-age=31536000, immutable"")
 		c.Response().Writer.Header().Set(echo.HeaderContentSecurityPolicy, ""default-src 'self'"")
-		if strings.HasPrefix(resourceType, ""video"") || strings.HasPrefix(resourceType, ""audio"") {
+		resourceType := strings.ToLower(resource.Type)
+		if strings.HasPrefix(resourceType, ""text"") {
+			resourceType = echo.MIMETextPlainCharsetUTF8
+		} else if strings.HasPrefix(resourceType, ""video"") || strings.HasPrefix(resourceType, ""audio"") {
 			http.ServeContent(c.Response(), c.Request(), resource.Filename, time.Unix(resource.UpdatedTs, 0), bytes.NewReader(resource.Blob))
 			return nil
 		}
",[True]
GO-2020-0038,pion,dtls,fd73a5df2ff0e1fb6ae6a51e2777d7a16cc4f4e0," func (c *Conn) handleIncomingPacket(buf []byte) (*alert, error) {
 		c.log.Trace(""<- ChangeCipherSpec"")
 		c.setRemoteEpoch(c.getRemoteEpoch() + 1)
 	case *applicationData:
+		if h.epoch == 0 {
+			return &alert{alertLevelFatal, alertUnexpectedMessage}, fmt.Errorf(""ApplicationData with epoch of 0"")
+		}
+
 		c.decrypted <- content.data
 	default:
 		return &alert{alertLevelFatal, alertUnexpectedMessage}, fmt.Errorf(""unhandled contentType %d"", content.contentType())
",[True]
GO-2021-0087,opencontainers,runc,2fc03cc11c775b7a8b2e48d7ee447cb9bef32ad0," func mountToRootfs(m *configs.Mount, rootfs, mountLabel string, enableCgroupns b
 
 	switch m.Device {
 	case ""proc"", ""sysfs"":
+		// If the destination already exists and is not a directory, we bail
+		// out This is to avoid mounting through a symlink or similar -- which
+		// has been a ""fun"" attack scenario in the past.
+		// TODO: This won't be necessary once we switch to libpathrs and we can
+		//       stop all of these symlink-exchange attacks.
+		if fi, err := os.Lstat(dest); err != nil {
+			if !os.IsNotExist(err) {
+				return err
+			}
+		} else if fi.Mode()&os.ModeDir == 0 {
+			return fmt.Errorf(""filesystem %q must be mounted on ordinary directory"", m.Device)
+		}
 		if err := os.MkdirAll(dest, 0755); err != nil {
 			return err
 		}
",[True]
GO-2021-0058,crewjam,saml,da4f1a0612c0a8dd0452cf8b3c7a6518f6b4d053," func NewIdpAuthnRequest(idp *IdentityProvider, r *http.Request) (*IdpAuthnReques
 	default:
 		return nil, fmt.Errorf(""method not allowed"")
 	}
+
 	return req, nil
 }
 
",[False]
GO-2021-0058,crewjam,saml,da4f1a0612c0a8dd0452cf8b3c7a6518f6b4d053," func NewIdpAuthnRequest(idp *IdentityProvider, r *http.Request) (*IdpAuthnReques
 // the AuthnRequest and Metadata properties. Returns a non-nil error if the
 // request is not valid.
 func (req *IdpAuthnRequest) Validate() error {
+	if err := xrv.Validate(bytes.NewReader(req.RequestBuffer)); err != nil {
+		return err
+	}
+
 	if err := xml.Unmarshal(req.RequestBuffer, &req.Request); err != nil {
 		return err
 	}
",[True]
GO-2021-0058,crewjam,saml,da4f1a0612c0a8dd0452cf8b3c7a6518f6b4d053," func randomBytes(n int) []byte {
 }
 
 func getSPMetadata(r io.Reader) (spMetadata *saml.EntityDescriptor, err error) {
-	var bytes []byte
-
-	if bytes, err = ioutil.ReadAll(r); err != nil {
+	var data []byte
+	if data, err = ioutil.ReadAll(r); err != nil {
 		return nil, err
 	}
 
 	spMetadata = &saml.EntityDescriptor{}
+	if err := xrv.Validate(bytes.NewBuffer(data)); err != nil {
+		return nil, err
+	}
 
-	if err := xml.Unmarshal(bytes, &spMetadata); err != nil {
+	if err := xml.Unmarshal(data, &spMetadata); err != nil {
 		if err.Error() == ""expected element type <EntityDescriptor> but have <EntitiesDescriptor>"" {
 			entities := &saml.EntitiesDescriptor{}
-
-			if err := xml.Unmarshal(bytes, &entities); err != nil {
+			if err := xml.Unmarshal(data, &entities); err != nil {
 				return nil, err
 			}
 
",[True]
GO-2021-0058,crewjam,saml,da4f1a0612c0a8dd0452cf8b3c7a6518f6b4d053," import (
 // <EntityDescriptor>.
 func ParseMetadata(data []byte) (*saml.EntityDescriptor, error) {
 	entity := &saml.EntityDescriptor{}
+
+	if err := xrv.Validate(bytes.NewBuffer(data)); err != nil {
+		return nil, err
+	}
+
 	err := xml.Unmarshal(data, entity)
 
 	// this comparison is ugly, but it is how the error is generated in encoding/xml
",[True]
GO-2021-0058,crewjam,saml,da4f1a0612c0a8dd0452cf8b3c7a6518f6b4d053," func (sp *ServiceProvider) ParseXMLResponse(decodedResponseXML []byte, possibleR
 		Response: string(decodedResponseXML),
 	}
 
+	// ensure that the response XML is well formed before we parse it
+	if err := xrv.Validate(bytes.NewReader(decodedResponseXML)); err != nil {
+		retErr.PrivateErr = fmt.Errorf(""invalid xml: %s"", err)
+		return nil, retErr
+	}
+
 	// do some validation first before we decrypt
 	resp := Response{}
-	if err := xml.Unmarshal([]byte(decodedResponseXML), &resp); err != nil {
+	if err := xml.Unmarshal(decodedResponseXML, &resp); err != nil {
 		retErr.PrivateErr = fmt.Errorf(""cannot unmarshal response: %s"", err)
 		return nil, retErr
 	}
",[True]
GO-2021-0058,crewjam,saml,da4f1a0612c0a8dd0452cf8b3c7a6518f6b4d053," func (sp *ServiceProvider) ParseXMLResponse(decodedResponseXML []byte, possibleR
 		}
 		retErr.Response = string(plaintextAssertion)
 
+		// TODO(ross): add test case for this
+		if err := xrv.Validate(bytes.NewReader(plaintextAssertion)); err != nil {
+			retErr.PrivateErr = fmt.Errorf(""plaintext response contains invalid XML: %s"", err)
+			return nil, retErr
+		}
+
 		doc = etree.NewDocument()
 		if err := doc.ReadFromBytes(plaintextAssertion); err != nil {
 			retErr.PrivateErr = fmt.Errorf(""cannot parse plaintext response %v"", err)
",[True]
GO-2021-0058,crewjam,saml,da4f1a0612c0a8dd0452cf8b3c7a6518f6b4d053," func (sp *ServiceProvider) ParseXMLResponse(decodedResponseXML []byte, possibleR
 		}
 
 		assertion = &Assertion{}
+		// Note: plaintextAssertion is known to be safe to parse because
+		// plaintextAssertion is unmodified from when xrv.Validate() was called above.
 		if err := xml.Unmarshal(plaintextAssertion, assertion); err != nil {
 			retErr.PrivateErr = err
 			return nil, retErr
",[True]
GO-2021-0058,crewjam,saml,da4f1a0612c0a8dd0452cf8b3c7a6518f6b4d053," func (sp *ServiceProvider) ValidateLogoutResponseForm(postFormData string) error
 		return fmt.Errorf(""unable to parse base64: %s"", err)
 	}
 
-	var resp LogoutResponse
+	// TODO(ross): add test case for this (SLO does not have tests right now)
+	if err := xrv.Validate(bytes.NewReader(rawResponseBuf)); err != nil {
+		return fmt.Errorf(""response contains invalid XML: %s"", err)
+	}
 
+	var resp LogoutResponse
 	if err := xml.Unmarshal(rawResponseBuf, &resp); err != nil {
 		return fmt.Errorf(""cannot unmarshal response: %s"", err)
 	}
",[True]
GO-2021-0058,crewjam,saml,da4f1a0612c0a8dd0452cf8b3c7a6518f6b4d053," func (sp *ServiceProvider) ValidateLogoutResponseRedirect(queryParameterData str
 		return fmt.Errorf(""unable to parse base64: %s"", err)
 	}
 
-	gr := flate.NewReader(bytes.NewBuffer(rawResponseBuf))
+	gr, err := ioutil.ReadAll(flate.NewReader(bytes.NewBuffer(rawResponseBuf)))
+	if err != nil {
+		return err
+	}
+
+	if err := xrv.Validate(bytes.NewReader(gr)); err != nil {
+		return err
+	}
 
-	decoder := xml.NewDecoder(gr)
+	decoder := xml.NewDecoder(bytes.NewReader(gr))
 
 	var resp LogoutResponse
 
",[True]
GO-2021-0058,crewjam,saml,da4f1a0612c0a8dd0452cf8b3c7a6518f6b4d053," func (sp *ServiceProvider) ValidateLogoutResponseRedirect(queryParameterData str
 	}
 
 	doc := etree.NewDocument()
-	if _, err := doc.ReadFrom(gr); err != nil {
+	if _, err := doc.ReadFrom(bytes.NewReader(gr)); err != nil {
 		return err
 	}
 
",[True]
GO-2021-0098,git-lfs,git-lfs,fc664697ed2c2081ee9633010de0a7f9debea72a," func PipeMediaCommand(name string, args ...string) error {
 }
 
 func PipeCommand(name string, args ...string) error {
-	cmd := exec.Command(name, args...)
+	cmd := subprocess.ExecCommand(name, args...)
 	cmd.Stdin = os.Stdin
 	cmd.Stderr = os.Stderr
 	cmd.Stdout = os.Stdout
",[True]
GO-2021-0098,git-lfs,git-lfs,fc664697ed2c2081ee9633010de0a7f9debea72a," func (a *AskPassCredentialHelper) getFromProgram(valueType credValueType, u *url
 
 	// 'cmd' will run the GIT_ASKPASS (or core.askpass) command prompting
 	// for the desired valueType (`Username` or `Password`)
-	cmd := exec.Command(a.Program, a.args(fmt.Sprintf(""%s for %q"", valueString, u))...)
+	cmd := subprocess.ExecCommand(a.Program, a.args(fmt.Sprintf(""%s for %q"", valueString, u))...)
 	cmd.Stderr = &err
 	cmd.Stdout = &value
 
",[True]
GO-2021-0098,git-lfs,git-lfs,fc664697ed2c2081ee9633010de0a7f9debea72a," func (h *commandCredentialHelper) Approve(creds Creds) error {
 
 func (h *commandCredentialHelper) exec(subcommand string, input Creds) (Creds, error) {
 	output := new(bytes.Buffer)
-	cmd := exec.Command(""git"", ""credential"", subcommand)
+	cmd := subprocess.ExecCommand(""git"", ""credential"", subcommand)
 	cmd.Stdin = bufferCreds(input)
 	cmd.Stdout = output
 	/*
",[False]
GO-2021-0098,git-lfs,git-lfs,fc664697ed2c2081ee9633010de0a7f9debea72a," func pipeExtensions(cfg *config.Configuration, request *pipeRequest) (response p
 			arg := strings.Replace(value, ""%f"", request.fileName, -1)
 			args = append(args, arg)
 		}
-		cmd := exec.Command(name, args...)
+		cmd := subprocess.ExecCommand(name, args...)
 		ec := &extCommand{cmd: cmd, result: &pipeExtResult{name: e.Name}}
 		extcmds = append(extcmds, ec)
 	}
",[True]
GO-2021-0098,git-lfs,git-lfs,fc664697ed2c2081ee9633010de0a7f9debea72a," func (c *sshAuthClient) Resolve(e Endpoint, method string) (sshAuthResponse, err
 	}
 
 	exe, args := sshGetLFSExeAndArgs(c.os, c.git, e, method)
-	cmd := exec.Command(exe, args...)
+	cmd := subprocess.ExecCommand(exe, args...)
 
 	// Save stdout and stderr in separate buffers
 	var outbuf, errbuf bytes.Buffer
",[True]
GO-2022-0417,containers,buildah,e7e55c988c05dd74005184ceb64f097a0cfe645b," func setCapabilities(spec *specs.Spec, keepCaps ...string) error {
 	capMap := map[capability.CapType][]string{
 		capability.BOUNDING:    spec.Process.Capabilities.Bounding,
 		capability.EFFECTIVE:   spec.Process.Capabilities.Effective,
-		capability.INHERITABLE: spec.Process.Capabilities.Inheritable,
+		capability.INHERITABLE: []string{},
 		capability.PERMITTED:   spec.Process.Capabilities.Permitted,
 		capability.AMBIENT:     spec.Process.Capabilities.Ambient,
 	}
",[True]
GO-2022-0417,containers,buildah,e7e55c988c05dd74005184ceb64f097a0cfe645b," func setupCapAdd(g *generate.Generator, caps ...string) error {
 		if err := g.AddProcessCapabilityEffective(cap); err != nil {
 			return errors.Wrapf(err, ""error adding %q to the effective capability set"", cap)
 		}
-		if err := g.AddProcessCapabilityInheritable(cap); err != nil {
-			return errors.Wrapf(err, ""error adding %q to the inheritable capability set"", cap)
-		}
 		if err := g.AddProcessCapabilityPermitted(cap); err != nil {
 			return errors.Wrapf(err, ""error adding %q to the permitted capability set"", cap)
 		}
",[True]
GO-2022-0417,containers,buildah,e7e55c988c05dd74005184ceb64f097a0cfe645b," func setupCapDrop(g *generate.Generator, caps ...string) error {
 		if err := g.DropProcessCapabilityEffective(cap); err != nil {
 			return errors.Wrapf(err, ""error removing %q from the effective capability set"", cap)
 		}
-		if err := g.DropProcessCapabilityInheritable(cap); err != nil {
-			return errors.Wrapf(err, ""error removing %q from the inheritable capability set"", cap)
-		}
 		if err := g.DropProcessCapabilityPermitted(cap); err != nil {
 			return errors.Wrapf(err, ""error removing %q from the permitted capability set"", cap)
 		}
",[True]
GO-2023-1602,russellhaering,gosaml2,f9d66040241093e8702649baff50cc70d2c683c0," func (sp *SAMLServiceProvider) ValidateEncodedLogoutRequestPOST(encodedRequest s
 	}
 
 	// Parse the raw request - parseResponse is generic
-	doc, el, err := parseResponse(raw)
+	doc, el, err := parseResponse(raw, sp.MaximumDecompressedBodySize)
 	if err != nil {
 		return nil, err
 	}
",[True]
GO-2023-1602,russellhaering,gosaml2,f9d66040241093e8702649baff50cc70d2c683c0," func (sp *SAMLServiceProvider) decryptAssertions(el *etree.Element) error {
 			return fmt.Errorf(""unable to decrypt encrypted assertion: %v"", derr)
 		}
 
-		doc, _, err := parseResponse(raw)
+		doc, _, err := parseResponse(raw, sp.MaximumDecompressedBodySize)
 		if err != nil {
 			return fmt.Errorf(""unable to create element from decrypted assertion bytes: %v"", err)
 		}
",[False]
GO-2023-1602,russellhaering,gosaml2,f9d66040241093e8702649baff50cc70d2c683c0," func (sp *SAMLServiceProvider) validateAssertionSignatures(el *etree.Element) er
 	}
 }
 
-//ValidateEncodedResponse both decodes and validates, based on SP
-//configuration, an encoded, signed response. It will also appropriately
-//decrypt a response if the assertion was encrypted
+// ValidateEncodedResponse both decodes and validates, based on SP
+// configuration, an encoded, signed response. It will also appropriately
+// decrypt a response if the assertion was encrypted
 func (sp *SAMLServiceProvider) ValidateEncodedResponse(encodedResponse string) (*types.Response, error) {
 	raw, err := base64.StdEncoding.DecodeString(encodedResponse)
 	if err != nil {
",[True]
GO-2023-1602,russellhaering,gosaml2,f9d66040241093e8702649baff50cc70d2c683c0," func (sp *SAMLServiceProvider) ValidateEncodedResponse(encodedResponse string) (
 	}
 
 	// Parse the raw response
-	doc, el, err := parseResponse(raw)
+	doc, el, err := parseResponse(raw, sp.MaximumDecompressedBodySize)
 	if err != nil {
 		return nil, err
 	}
",[True]
GO-2023-1602,russellhaering,gosaml2,f9d66040241093e8702649baff50cc70d2c683c0," func DecodeUnverifiedBaseResponse(encodedResponse string) (*types.UnverifiedBase
 
 	var response *types.UnverifiedBaseResponse
 
-	err = maybeDeflate(raw, func(maybeXML []byte) error {
+	err = maybeDeflate(raw, defaultMaxDecompressedResponseSize, func(maybeXML []byte) error {
 		response = &types.UnverifiedBaseResponse{}
 		return xml.Unmarshal(maybeXML, response)
 	})
",[True]
GO-2023-1602,russellhaering,gosaml2,f9d66040241093e8702649baff50cc70d2c683c0," func DecodeUnverifiedLogoutResponse(encodedResponse string) (*types.LogoutRespon
 
 	var response *types.LogoutResponse
 
-	err = maybeDeflate(raw, func(maybeXML []byte) error {
+	err = maybeDeflate(raw, defaultMaxDecompressedResponseSize, func(maybeXML []byte) error {
 		response = &types.LogoutResponse{}
 		return xml.Unmarshal(maybeXML, response)
 	})
",[True]
GO-2023-1602,russellhaering,gosaml2,f9d66040241093e8702649baff50cc70d2c683c0," func (sp *SAMLServiceProvider) ValidateEncodedLogoutResponsePOST(encodedResponse
 	}
 
 	// Parse the raw response
-	doc, el, err := parseResponse(raw)
+	doc, el, err := parseResponse(raw, sp.MaximumDecompressedBodySize)
 	if err != nil {
 		return nil, err
 	}
",[True]
GO-2022-0980,hashicorp,consul-template,d6a6f4af219c28e67d847ba0e0b2bea8f5bb9076," func (t *Template) Execute(i *ExecuteInput) (*ExecuteResult, error) {
 	// Execute the template into the writer
 	var b bytes.Buffer
 	if err := tmpl.Execute(&b, nil); err != nil {
-		return nil, errors.Wrap(err, ""execute"")
+		return nil, errors.Wrap(redactinator(&used, i.Brain, err), ""execute"")
 	}
 
 	return &ExecuteResult{
",[True]
GO-2022-0980,hashicorp,consul-template,d6a6f4af219c28e67d847ba0e0b2bea8f5bb9076," func (t *Template) Execute(i *ExecuteInput) (*ExecuteResult, error) {
 	}, nil
 }
 
+func redactinator(used *dep.Set, b *Brain, err error) error {
+	pairs := make([]string, 0, used.Len())
+	for _, d := range used.List() {
+		if data, ok := b.Recall(d); ok {
+			if vd, ok := data.(*dep.Secret); ok {
+				for _, v := range vd.Data {
+					pairs = append(pairs, fmt.Sprintf(""%v"", v), ""[redacted]"")
+				}
+			}
+		}
+	}
+	return fmt.Errorf(strings.NewReplacer(pairs...).Replace(err.Error()))
+}
+
 // funcMapInput is input to the funcMap, which builds the template functions.
 type funcMapInput struct {
 	newTmpl          *template.Template
",[False]
GO-2021-0090,tendermint,tendermint,480b995a31727593f58b361af979054d17d84340," func (voteSet *VoteSet) sumTotalFrac() (int64, int64, float64) {
 //--------------------------------------------------------------------------------
 // Commit
 
-// MakeCommit constructs a Commit from the VoteSet.
-// Panics if the vote type is not PrecommitType or if
-// there's no +2/3 votes for a single block.
+// MakeCommit constructs a Commit from the VoteSet. It only includes precommits
+// for the block, which has 2/3+ majority, and nil.
+//
+// Panics if the vote type is not PrecommitType or if there's no +2/3 votes for
+// a single block.
 func (voteSet *VoteSet) MakeCommit() *Commit {
 	if voteSet.signedMsgType != tmproto.PrecommitType {
 		panic(""Cannot MakeCommit() unless VoteSet.Type is PrecommitType"")
",[True]
GO-2021-0090,tendermint,tendermint,480b995a31727593f58b361af979054d17d84340," func (voteSet *VoteSet) MakeCommit() *Commit {
 	// For every validator, get the precommit
 	commitSigs := make([]CommitSig, len(voteSet.votes))
 	for i, v := range voteSet.votes {
-		commitSigs[i] = v.CommitSig()
+		commitSig := v.CommitSig()
+		// if block ID exists but doesn't match, exclude sig
+		if commitSig.ForBlock() && !v.BlockID.Equals(*voteSet.maj23) {
+			commitSig = NewCommitSigAbsent()
+		}
+		commitSigs[i] = commitSig
 	}
 
 	return NewCommit(voteSet.GetHeight(), voteSet.GetRound(), *voteSet.maj23, commitSigs)
",[True]
GO-2020-0025,cloudfoundry,archiver,09b5706aa9367972c09144a450bb4523049ee840," func extractTarArchive(tarReader *tar.Reader, dest string) error {
 }
 
 func extractTarArchiveFile(header *tar.Header, dest string, input io.Reader) error {
-	filePath := filepath.Join(dest, header.Name)
+	filePath, err := securejoin.SecureJoin(dest, header.Name)
+	if err != nil {
+		return err
+	}
 	fileInfo := header.FileInfo()
 
 	if fileInfo.IsDir() {
 		return os.MkdirAll(filePath, fileInfo.Mode())
 	}
 
-	err := os.MkdirAll(filepath.Dir(filePath), 0755)
+	err = os.MkdirAll(filepath.Dir(filePath), 0755)
 	if err != nil {
 		return err
 	}
",[True]
GO-2020-0025,cloudfoundry,archiver,09b5706aa9367972c09144a450bb4523049ee840," func extractZip(src, dest string) error {
 }
 
 func extractZipArchiveFile(file *zip.File, dest string, input io.Reader) error {
-	filePath := filepath.Join(dest, file.Name)
+	filePath, err := securejoin.SecureJoin(dest, file.Name)
 	fileInfo := file.FileInfo()
 
 	if fileInfo.IsDir() {
-		err := os.MkdirAll(filePath, fileInfo.Mode())
+		err = os.MkdirAll(filePath, fileInfo.Mode())
 		if err != nil {
 			return err
 		}
 	} else {
-		err := os.MkdirAll(filepath.Dir(filePath), 0755)
+		err = os.MkdirAll(filepath.Dir(filePath), 0755)
 		if err != nil {
 			return err
 		}
",[True]
GO-2021-0072,distribution,distribution,91c507a39abfce14b5c8541cf284330e22208c0f," func (buh *blobUploadHandler) PatchBlobData(w http.ResponseWriter, r *http.Reque
 
 	// TODO(dmcgowan): support Content-Range header to seek and write range
 
-	if err := copyFullPayload(w, r, buh.Upload, buh, ""blob PATCH"", &buh.Errors); err != nil {
-		// copyFullPayload reports the error if necessary
+	if err := copyFullPayload(w, r, buh.Upload, -1, buh, ""blob PATCH""); err != nil {
+		buh.Errors = append(buh.Errors, errcode.ErrorCodeUnknown.WithDetail(err.Error()))
 		return
 	}
 
",[False]
GO-2021-0072,distribution,distribution,91c507a39abfce14b5c8541cf284330e22208c0f," func (buh *blobUploadHandler) PutBlobUploadComplete(w http.ResponseWriter, r *ht
 		return
 	}
 
-	if err := copyFullPayload(w, r, buh.Upload, buh, ""blob PUT"", &buh.Errors); err != nil {
-		// copyFullPayload reports the error if necessary
+	if err := copyFullPayload(w, r, buh.Upload, -1, buh, ""blob PUT""); err != nil {
+		buh.Errors = append(buh.Errors, errcode.ErrorCodeUnknown.WithDetail(err.Error()))
 		return
 	}
 
",[False]
GO-2021-0072,distribution,distribution,91c507a39abfce14b5c8541cf284330e22208c0f," func closeResources(handler http.Handler, closers ...io.Closer) http.Handler {
 // copyFullPayload copies the payload of an HTTP request to destWriter. If it
 // receives less content than expected, and the client disconnected during the
 // upload, it avoids sending a 400 error to keep the logs cleaner.
-func copyFullPayload(responseWriter http.ResponseWriter, r *http.Request, destWriter io.Writer, context ctxu.Context, action string, errSlice *errcode.Errors) error {
+//
+// The copy will be limited to `limit` bytes, if limit is greater than zero.
+func copyFullPayload(responseWriter http.ResponseWriter, r *http.Request, destWriter io.Writer, limit int64, context ctxu.Context, action string) error {
 	// Get a channel that tells us if the client disconnects
 	var clientClosed <-chan bool
 	if notifier, ok := responseWriter.(http.CloseNotifier); ok {
",[True]
GO-2021-0072,distribution,distribution,91c507a39abfce14b5c8541cf284330e22208c0f," func copyFullPayload(responseWriter http.ResponseWriter, r *http.Request, destWr
 		ctxu.GetLogger(context).Warnf(""the ResponseWriter does not implement CloseNotifier (type: %T)"", responseWriter)
 	}
 
+	var body = r.Body
+	if limit > 0 {
+		body = http.MaxBytesReader(responseWriter, body, limit)
+	}
+
 	// Read in the data, if any.
-	copied, err := io.Copy(destWriter, r.Body)
+	copied, err := io.Copy(destWriter, body)
 	if clientClosed != nil && (err != nil || (r.ContentLength > 0 && copied < r.ContentLength)) {
 		// Didn't receive as much content as expected. Did the client
 		// disconnect during the request? If so, avoid returning a 400
",[True]
GO-2021-0072,distribution,distribution,91c507a39abfce14b5c8541cf284330e22208c0f," func (imh *manifestHandler) PutManifest(w http.ResponseWriter, r *http.Request)
 	}
 
 	var jsonBuf bytes.Buffer
-	if err := copyFullPayload(w, r, &jsonBuf, imh, ""image manifest PUT"", &imh.Errors); err != nil {
+	if err := copyFullPayload(w, r, &jsonBuf, maxManifestBodySize, imh, ""image manifest PUT""); err != nil {
 		// copyFullPayload reports the error if necessary
+		imh.Errors = append(imh.Errors, v2.ErrorCodeManifestInvalid.WithDetail(err.Error()))
 		return
 	}
 
",[False]
GO-2021-0072,distribution,distribution,91c507a39abfce14b5c8541cf284330e22208c0f," func (bs *blobStore) Get(ctx context.Context, dgst digest.Digest) ([]byte, error
 		return nil, err
 	}
 
-	p, err := bs.driver.GetContent(ctx, bp)
+	p, err := getContent(ctx, bs.driver, bp)
 	if err != nil {
 		switch err.(type) {
 		case driver.PathNotFoundError:
",[True]
GO-2021-0072,distribution,distribution,91c507a39abfce14b5c8541cf284330e22208c0f," func (bs *blobStore) Get(ctx context.Context, dgst digest.Digest) ([]byte, error
 		return nil, err
 	}
 
-	return p, err
+	return p, nil
 }
 
 func (bs *blobStore) Open(ctx context.Context, dgst digest.Digest) (distribution.ReadSeekCloser, error) {
",[True]
GO-2021-0072,distribution,distribution,91c507a39abfce14b5c8541cf284330e22208c0f," func copyFullPayload(responseWriter http.ResponseWriter, r *http.Request, destWr
 
 	if err != nil {
 		ctxu.GetLogger(context).Errorf(""unknown error reading request payload: %v"", err)
-		*errSlice = append(*errSlice, errcode.ErrorCodeUnknown.WithDetail(err))
 		return err
 	}
 
",[True]
GO-2020-0023,robbert229,jwt,ca1404ee6e83fcbafb66b09ed0d543850a15b654," func (a *Algorithm) validateSignature(encoded string) error {
 
 	b64SignedAttempt := base64.RawURLEncoding.EncodeToString([]byte(signedAttempt))
 
-	if strings.Compare(b64Signature, b64SignedAttempt) != 0 {
+	if !hmac.Equal([]byte(b64Signature), []byte(b64SignedAttempt)) {
 		return errors.New(""invalid signature"")
 	}
 
",[True]
GO-2022-0300,graph-gophers,graphql-go,eae31ca73eb3473c544710955d1dbebc22605bfe," func Validate(s *types.Schema, doc *types.ExecutableDefinition, variables map[st
 
 		// Check if max depth is exceeded, if it's set. If max depth is exceeded,
 		// don't continue to validate the document and exit early.
-		if validateMaxDepth(opc, op.Selections, 1) {
+		if validateMaxDepth(opc, op.Selections, nil, 1) {
 			return c.errs
 		}
 
",[False]
GO-2022-0300,graph-gophers,graphql-go,eae31ca73eb3473c544710955d1dbebc22605bfe," func validateValue(c *opContext, v *types.InputValueDefinition, val interface{},
 
 // validates the query doesn't go deeper than maxDepth (if set). Returns whether
 // or not query validated max depth to avoid excessive recursion.
-func validateMaxDepth(c *opContext, sels []types.Selection, depth int) bool {
+//
+// The visited map is necessary to ensure that max depth validation does not get stuck in cyclical
+// fragment spreads.
+func validateMaxDepth(c *opContext, sels []types.Selection, visited map[*types.FragmentDefinition]struct{}, depth int) bool {
 	// maxDepth checking is turned off when maxDepth is 0
 	if c.maxDepth == 0 {
 		return false
 	}
 
 	exceededMaxDepth := false
+	if visited == nil {
+		visited = map[*types.FragmentDefinition]struct{}{}
+	}
 
 	for _, sel := range sels {
 		switch sel := sel.(type) {
",[False]
GO-2022-0300,graph-gophers,graphql-go,eae31ca73eb3473c544710955d1dbebc22605bfe," func validateMaxDepth(c *opContext, sels []types.Selection, depth int) bool {
 				c.addErr(sel.Alias.Loc, ""MaxDepthExceeded"", ""Field %q has depth %d that exceeds max depth %d"", sel.Name.Name, depth, c.maxDepth)
 				continue
 			}
-			exceededMaxDepth = exceededMaxDepth || validateMaxDepth(c, sel.SelectionSet, depth+1)
+			exceededMaxDepth = exceededMaxDepth || validateMaxDepth(c, sel.SelectionSet, visited, depth+1)
+
 		case *types.InlineFragment:
 			// Depth is not checked because inline fragments resolve to other fields which are checked.
 			// Depth is not incremented because inline fragments have the same depth as neighboring fields
-			exceededMaxDepth = exceededMaxDepth || validateMaxDepth(c, sel.Selections, depth)
+			exceededMaxDepth = exceededMaxDepth || validateMaxDepth(c, sel.Selections, visited, depth)
 		case *types.FragmentSpread:
 			// Depth is not checked because fragments resolve to other fields which are checked.
 			frag := c.doc.Fragments.Get(sel.Name.Name)
",[False]
GO-2022-0300,graph-gophers,graphql-go,eae31ca73eb3473c544710955d1dbebc22605bfe," func validateMaxDepth(c *opContext, sels []types.Selection, depth int) bool {
 				c.addErr(sel.Loc, ""MaxDepthEvaluationError"", ""Unknown fragment %q. Unable to evaluate depth."", sel.Name.Name)
 				continue
 			}
+
+			if _, ok := visited[frag]; ok {
+				// we've already seen this fragment, don't check depth again.
+				continue
+			}
+			visited[frag] = struct{}{}
+
 			// Depth is not incremented because fragments have the same depth as surrounding fields
-			exceededMaxDepth = exceededMaxDepth || validateMaxDepth(c, frag.Selections, depth)
+			exceededMaxDepth = exceededMaxDepth || validateMaxDepth(c, frag.Selections, visited, depth)
 		}
 	}
 
",[False]
GO-2022-0962,helm,helm,10466e3e179cc8cad4b0bb451108d3c442c69fbc," func setIndex(list []interface{}, index int, val interface{}) (l2 []interface{},
 	if index < 0 {
 		return list, fmt.Errorf(""negative %d index not allowed"", index)
 	}
+	if index > MaxIndex {
+		return list, fmt.Errorf(""index of %d is greater than maximum supported index of %d"", index, MaxIndex)
+	}
 	if len(list) <= index {
 		newlist := make([]interface{}, index+1)
 		copy(newlist, list)
",[True]
GO-2023-1497,sylabs,scs-library-client,68ac4cab5cda0afd8758ff5b5e2e57be6a22fcfa," type Downloader struct {
 
 // httpGetRangeRequest performs HTTP GET range request to URL specified by 'u' in range start-end.
 func (c *Client) httpGetRangeRequest(ctx context.Context, url string, start, end int64) (*http.Response, error) {
-	req, err := c.newRequestWithURL(ctx, http.MethodGet, url, nil)
+	req, err := http.NewRequestWithContext(ctx, http.MethodGet, url, nil)
 	if err != nil {
 		return nil, err
 	}
 
+	if v := c.UserAgent; v != """" {
+		req.Header.Set(""User-Agent"", v)
+	}
+
 	req.Header.Add(""Range"", fmt.Sprintf(""bytes=%d-%d"", start, end))
 
 	return c.HTTPClient.Do(req)
",[True]
GO-2022-1114,duke-git,lancet,f133b32faa05eb93e66175d01827afa4b7094572," func UnZip(zipFile string, destPath string) error {
 	defer zipReader.Close()
 
 	for _, f := range zipReader.File {
-		path := filepath.Join(destPath, f.Name)
+		//issue#62: fix ZipSlip bug
+		path, err := safeFilepathJoin(destPath, f.Name)
+		if err != nil {
+			return err
+		}
 		if f.FileInfo().IsDir() {
 			os.MkdirAll(path, os.ModePerm)
 		} else {
",[True]
GO-2022-1114,duke-git,lancet,f133b32faa05eb93e66175d01827afa4b7094572," func UnZip(zipFile string, destPath string) error {
 	return nil
 }
 
+func safeFilepathJoin(path1, path2 string) (string, error) {
+	relPath, err := filepath.Rel(""."", path2)
+	if err != nil || strings.HasPrefix(relPath, "".."") {
+		return """", fmt.Errorf(""(zipslip) filepath is unsafe %q: %v"", path2, err)
+	}
+	if path1 == """" {
+		path1 = "".""
+	}
+	return filepath.Join(path1, filepath.Join(""/"", relPath)), nil
+}
+
 // IsLink checks if a file is symbol link or not
 func IsLink(path string) bool {
 	fi, err := os.Lstat(path)
",[False]
GO-2022-1114,duke-git,lancet,f869a0a67098e92d24ddd913e188b32404fa72c9," func UnZip(zipFile string, destPath string) error {
 		path := filepath.Join(destPath, f.Name)
 
 		//issue#62: fix ZipSlip bug
-		if !strings.HasPrefix(path, destPath) {
-			return fmt.Errorf(""%s: illegal file path"", path)
+		path, err := safeFilepathJoin(destPath, f.Name)
+		if err != nil {
+			return err
 		}
 
 		if f.FileInfo().IsDir() {
",[True]
GO-2022-1114,duke-git,lancet,f869a0a67098e92d24ddd913e188b32404fa72c9," func UnZip(zipFile string, destPath string) error {
 	return nil
 }
 
+func safeFilepathJoin(path1, path2 string) (string, error) {
+	relPath, err := filepath.Rel(""."", path2)
+	if err != nil || strings.HasPrefix(relPath, "".."") {
+		return """", fmt.Errorf(""(zipslip) filepath is unsafe %q: %v"", path2, err)
+	}
+	if path1 == """" {
+		path1 = "".""
+	}
+	return filepath.Join(path1, filepath.Join(""/"", relPath)), nil
+}
+
 // IsLink checks if a file is symbol link or not
 func IsLink(path string) bool {
 	fi, err := os.Lstat(path)
",[False]
GO-2022-1114,duke-git,lancet,f869a0a67098e92d24ddd913e188b32404fa72c9," func Zip(fpath string, destPath string) error {
 
 // UnZip unzip the file and save it to destPath
 func UnZip(zipFile string, destPath string) error {
-	destPath = filepath.Clean(destPath) + string(os.PathSeparator)
 
 	zipReader, err := zip.OpenReader(zipFile)
 	if err != nil {
",[True]
GO-2023-1832,notaryproject,notation-go,39c8ed050a65cca3f3f308534acb612096735a64," func NewRepository() Repository {
 }
 
 func (t Repository) Resolve(ctx context.Context, reference string) (ocispec.Descriptor, error) {
+	if t.MissMatchDigest {
+		return ocispec.Descriptor{
+			MediaType:   ""application/vnd.docker.distribution.manifest.v2+json"",
+			Digest:      ZeroDigest,
+			Size:        528,
+			Annotations: Annotations,
+		}, nil
+	}
 	return t.ResolveResponse, t.ResolveError
 }
 
",[False]
GO-2023-1832,notaryproject,notation-go,39c8ed050a65cca3f3f308534acb612096735a64," func Verify(ctx context.Context, verifier Verifier, repo registry.Repository, ve
 		// artifactRef is not a digest reference
 		logger.Infof(""Resolved artifact tag `%s` to digest `%s` before verification"", ref.Reference, artifactDescriptor.Digest.String())
 		logger.Warn(""The resolved digest may not point to the same signed artifact, since tags are mutable"")
+	} else if ref.Reference != artifactDescriptor.Digest.String() {
+		return ocispec.Descriptor{}, nil, ErrorSignatureRetrievalFailed{Msg: fmt.Sprintf(""user input digest %s does not match the resolved digest %s"", ref.Reference, artifactDescriptor.Digest.String())}
 	}
 
 	var verificationOutcomes []*VerificationOutcome
",[True]
GO-2023-1832,notaryproject,notation-go,eba60f5aed9c9e05dee55324423c95fe34700b4c," func Sign(ctx context.Context, signer Signer, repo registry.Repository, signOpts
 	if err != nil {
 		return ocispec.Descriptor{}, fmt.Errorf(""failed to resolve reference: %w"", err)
 	}
+	// artifactRef is a tag or a digest, if it's a digest it has to match
+	// the resolved digest
 	if artifactRef != targetDesc.Digest.String() {
-		// artifactRef is not a digest reference
+		if _, err := digest.Parse(artifactRef); err == nil {
+			// artifactRef is a digest, but does not match the resolved digest
+			return ocispec.Descriptor{}, fmt.Errorf(""user input digest %s does not match the resolved digest %s"", artifactRef, targetDesc.Digest.String())
+		}
+		// artifactRef is a tag
 		logger.Warnf(""Always sign the artifact using digest(`@sha256:...`) rather than a tag(`:%s`) because tags are mutable and a tag reference can point to a different artifact than the one signed"", artifactRef)
 		logger.Infof(""Resolved artifact tag `%s` to digest `%s` before signing"", artifactRef, targetDesc.Digest.String())
 	}
-
 	descToSign, err := addUserMetadataToDescriptor(ctx, targetDesc, signOpts.UserMetadata)
 	if err != nil {
 		return ocispec.Descriptor{}, err
",[True]
GO-2020-0007,seccomp,libseccomp-golang,06e7a29f36a34b8cf419aeb87b979ee508e58f9e," func (f *ScmpFilter) setFilterAttr(attr scmpFilterAttr, value C.uint32_t) error
 // DOES NOT LOCK OR CHECK VALIDITY
 // Assumes caller has already done this
 // Wrapper for seccomp_rule_add_... functions
-func (f *ScmpFilter) addRuleWrapper(call ScmpSyscall, action ScmpAction, exact bool, cond C.scmp_cast_t) error {
-	var length C.uint
-	if cond != nil {
-		length = 1
-	} else {
-		length = 0
+func (f *ScmpFilter) addRuleWrapper(call ScmpSyscall, action ScmpAction, exact bool, length C.uint, cond C.scmp_cast_t) error {
+	if length != 0 && cond == nil {
+		return fmt.Errorf(""null conditions list, but length is nonzero"")
 	}
 
 	var retCode C.int
",[False]
GO-2020-0007,seccomp,libseccomp-golang,06e7a29f36a34b8cf419aeb87b979ee508e58f9e," func (f *ScmpFilter) addRuleWrapper(call ScmpSyscall, action ScmpAction, exact b
 		return fmt.Errorf(""unrecognized syscall"")
 	} else if syscall.Errno(-1*retCode) == syscall.EPERM {
 		return fmt.Errorf(""requested action matches default action of filter"")
+	} else if syscall.Errno(-1*retCode) == syscall.EINVAL {
+		return fmt.Errorf(""two checks on same syscall argument"")
 	} else if retCode != 0 {
 		return syscall.Errno(-1 * retCode)
 	}
",[False]
GO-2020-0007,seccomp,libseccomp-golang,06e7a29f36a34b8cf419aeb87b979ee508e58f9e," func (f *ScmpFilter) addRuleGeneric(call ScmpSyscall, action ScmpAction, exact b
 	}
 
 	if len(conds) == 0 {
-		if err := f.addRuleWrapper(call, action, exact, nil); err != nil {
+		if err := f.addRuleWrapper(call, action, exact, 0, nil); err != nil {
 			return err
 		}
 	} else {
",[True]
GO-2020-0007,seccomp,libseccomp-golang,06e7a29f36a34b8cf419aeb87b979ee508e58f9e," func (f *ScmpFilter) addRuleGeneric(call ScmpSyscall, action ScmpAction, exact b
 			}
 		}
 
-		for _, cond := range conds {
-			cmpStruct := C.make_struct_arg_cmp(C.uint(cond.Argument), cond.Op.toNative(), C.uint64_t(cond.Operand1), C.uint64_t(cond.Operand2))
-			defer C.free(cmpStruct)
+		argsArr := C.make_arg_cmp_array(C.uint(len(conds)))
+		if argsArr == nil {
+			return fmt.Errorf(""error allocating memory for conditions"")
+		}
+		defer C.free(argsArr)
+
+		for i, cond := range conds {
+			C.add_struct_arg_cmp(C.scmp_cast_t(argsArr), C.uint(i),
+				C.uint(cond.Argument), cond.Op.toNative(),
+				C.uint64_t(cond.Operand1), C.uint64_t(cond.Operand2))
+		}
 
-			if err := f.addRuleWrapper(call, action, exact, C.scmp_cast_t(cmpStruct)); err != nil {
-				return err
-			}
+		if err := f.addRuleWrapper(call, action, exact, C.uint(len(conds)), C.scmp_cast_t(argsArr)); err != nil {
+			return err
 		}
 	}
 
",[True]
GO-2021-0059,tidwall,gjson,f0ee9ebde4b619767ae4ac03e8e42addb530f6bc," func squash(json string) string {
 					}
 				}
 				if depth == 0 {
+					if i >= len(json) {
+						return json
+					}
 					return json[:i+1]
 				}
 			case '{', '[', '(':
",[True]
GO-2022-0444,theupdateframework,go-tuf,ed6788e710fc3093a7ecc2d078bf734c0f200d8d," func (c *Client) Update() (data.TargetFiles, error) {
 		return nil, err
 	}
 
-	// Get timestamp.json, extract snapshot.json file meta and save the
-	// timestamp.json locally
+	// Load trusted metadata files, if any, and verify them against the latest root
+	c.getLocalMeta()
+
+	// 5.4.1 - Download the timestamp metadata
 	timestampJSON, err := c.downloadMetaUnsafe(""timestamp.json"", defaultTimestampDownloadLimit)
 	if err != nil {
 		return nil, err
 	}
+	// 5.4.(2,3 and 4) - Verify timestamp against various attacks
+	// Returns the extracted snapshot metadata
 	snapshotMeta, err := c.decodeTimestamp(timestampJSON)
 	if err != nil {
 		return nil, err
 	}
+	// 5.4.5 - Persist the timestamp metadata
 	if err := c.local.SetMeta(""timestamp.json"", timestampJSON); err != nil {
 		return nil, err
 	}
 
-	// Get snapshot.json, then extract file metas.
-	// root.json meta should not be stored in the snapshot, if it is,
-	// the root will be checked, re-downloaded
+	// 5.5.1 - Download snapshot metadata
+	// 5.5.2 and 5.5.4 - Check against timestamp role's snapshot hash and version
 	snapshotJSON, err := c.downloadMetaFromTimestamp(""snapshot.json"", snapshotMeta)
 	if err != nil {
 		return nil, err
 	}
+	// 5.5.(3,5 and 6) - Verify snapshot against various attacks
+	// Returns the extracted metadata files
 	snapshotMetas, err := c.decodeSnapshot(snapshotJSON)
 	if err != nil {
 		return nil, err
 	}
-
-	// Save the snapshot.json
+	// 5.5.7 - Persist snapshot metadata
 	if err := c.local.SetMeta(""snapshot.json"", snapshotJSON); err != nil {
 		return nil, err
 	}
",[True]
GO-2022-0444,theupdateframework,go-tuf,ed6788e710fc3093a7ecc2d078bf734c0f200d8d," func (c *Client) Update() (data.TargetFiles, error) {
 	var updatedTargets data.TargetFiles
 	targetsMeta := snapshotMetas[""targets.json""]
 	if !c.hasMetaFromSnapshot(""targets.json"", targetsMeta) {
+		// 5.6.1 - Download the top-level targets metadata file
+		// 5.6.2 and 5.6.4 - Check against snapshot role's targets hash and version
 		targetsJSON, err := c.downloadMetaFromSnapshot(""targets.json"", targetsMeta)
 		if err != nil {
 			return nil, err
 		}
+		// 5.6.(3 and 5) - Verify signatures and check against freeze attack
 		updatedTargets, err = c.decodeTargets(targetsJSON)
 		if err != nil {
 			return nil, err
 		}
+		// 5.6.6 - Persist targets metadata
 		if err := c.local.SetMeta(""targets.json"", targetsJSON); err != nil {
 			return nil, err
 		}
",[True]
GO-2022-0444,theupdateframework,go-tuf,ed6788e710fc3093a7ecc2d078bf734c0f200d8d," func (c *Client) UpdateRoots() error {
 // getLocalMeta decodes and verifies metadata from local storage.
 // The verification of local files is purely for consistency, if an attacker
 // has compromised the local storage, there is no guarantee it can be trusted.
+// Before trying to load the metadata files, it clears the in-memory copy of the local metadata.
+// This is to insure that all of the loaded metadata files at the end are indeed verified by the latest root.
+// If some of the metadata files fail to load it will proceed with trying to load the rest,
+// but still return an error at the end, if such occurred. Otherwise returns nil.
 func (c *Client) getLocalMeta() error {
+	var retErr error
+	loadFailed := false
+	// Clear the in-memory copy of the local metadata. The goal is to reload and take into account
+	// only the metadata files that are verified by the latest root. Otherwise, their content should
+	// be ignored.
+	c.localMeta = make(map[string]json.RawMessage)
+
+	// Load the latest root meta
 	if err := c.loadAndVerifyLocalRootMeta( /*ignoreExpiredCheck=*/ false); err != nil {
 		return err
 	}
 
+	// Load into memory the existing meta, if any, from the local storage
 	meta, err := c.local.GetMeta()
 	if err != nil {
 		return nil
 	}
 
+	// Verify the top-level metadata (timestamp, snapshot and targets) against the latest root and load it, if okay
 	if timestampJSON, ok := meta[""timestamp.json""]; ok {
 		timestamp := &data.Timestamp{}
 		if err := c.db.UnmarshalTrusted(timestampJSON, timestamp, ""timestamp""); err != nil {
-			return err
+			loadFailed = true
+			retErr = err
+		} else {
+			c.localMeta[""timestamp.json""] = meta[""timestamp.json""]
+			c.timestampVer = timestamp.Version
 		}
-		c.timestampVer = timestamp.Version
 	}
 
 	if snapshotJSON, ok := meta[""snapshot.json""]; ok {
 		snapshot := &data.Snapshot{}
 		if err := c.db.UnmarshalTrusted(snapshotJSON, snapshot, ""snapshot""); err != nil {
-			return err
+			loadFailed = true
+			retErr = err
+		} else {
+			c.localMeta[""snapshot.json""] = meta[""snapshot.json""]
+			c.snapshotVer = snapshot.Version
 		}
-		c.snapshotVer = snapshot.Version
 	}
 
 	if targetsJSON, ok := meta[""targets.json""]; ok {
 		targets := &data.Targets{}
 		if err := c.db.UnmarshalTrusted(targetsJSON, targets, ""targets""); err != nil {
-			return err
+			loadFailed = true
+			retErr = err
+		} else {
+			c.localMeta[""targets.json""] = meta[""targets.json""]
+			c.targetsVer = targets.Version
+			// FIXME(TUF-0.9) temporarily support files with leading path separators.
+			// c.targets = targets.Targets
+			c.loadTargets(targets.Targets)
 		}
-		c.targetsVer = targets.Version
-		// FIXME(TUF-0.9) temporarily support files with leading path separators.
-		// c.targets = targets.Targets
-		c.loadTargets(targets.Targets)
 	}
-
-	c.localMeta = meta
+	if loadFailed {
+		// If any of the metadata failed to be verified, return the reason for that failure
+		return retErr
+	}
 	return nil
 }
 
",[False]
GO-2022-0444,theupdateframework,go-tuf,ed6788e710fc3093a7ecc2d078bf734c0f200d8d," func (c *Client) downloadMetaFromSnapshot(name string, m data.SnapshotFileMeta)
 	if err != nil {
 		return nil, err
 	}
+	// 5.6.2 and 5.6.4 - Check against snapshot role's targets hash and version
 	if err := util.SnapshotFileMetaEqual(meta, m); err != nil {
 		return nil, ErrDownloadFailed{name, err}
 	}
",[True]
GO-2022-0444,theupdateframework,go-tuf,ed6788e710fc3093a7ecc2d078bf734c0f200d8d," func (c *Client) downloadMetaFromTimestamp(name string, m data.TimestampFileMeta
 	if err != nil {
 		return nil, err
 	}
+	// 5.5.2 and 5.5.4 - Check against timestamp role's snapshot hash and version
 	if err := util.TimestampFileMetaEqual(meta, m); err != nil {
 		return nil, ErrDownloadFailed{name, err}
 	}
",[True]
GO-2022-0444,theupdateframework,go-tuf,ed6788e710fc3093a7ecc2d078bf734c0f200d8d," func (c *Client) decodeRoot(b json.RawMessage) error {
 // root and targets file meta.
 func (c *Client) decodeSnapshot(b json.RawMessage) (data.SnapshotFiles, error) {
 	snapshot := &data.Snapshot{}
+	// 5.5.(3 and 6) - Verify it's signed correctly and it's not expired
 	if err := c.db.Unmarshal(b, snapshot, ""snapshot"", c.snapshotVer); err != nil {
 		return data.SnapshotFiles{}, ErrDecodeFailed{""snapshot.json"", err}
 	}
-	c.snapshotVer = snapshot.Version
+	// 5.5.5 - Check for top-level targets rollback attack
+	// Verify explicitly that current targets meta version is less than or equal to the new one
+	if snapshot.Meta[""targets.json""].Version < c.targetsVer {
+		return data.SnapshotFiles{}, verify.ErrLowVersion{Actual: snapshot.Meta[""targets.json""].Version, Current: c.targetsVer}
+	}
+
+	// 5.5.5 - Get the local/trusted snapshot metadata, if any, and check all target metafiles against rollback attack
+	// In case the local snapshot metadata was not verified by the keys in the latest root during getLocalMeta(),
+	// snapshot.json won't be present in c.localMeta and thus this check will not be processed.
+	if snapshotJSON, ok := c.localMeta[""snapshot.json""]; ok {
+		currentSnapshot := &data.Snapshot{}
+		if err := c.db.UnmarshalTrusted(snapshotJSON, currentSnapshot, ""snapshot""); err != nil {
+			return data.SnapshotFiles{}, err
+		}
+		// 5.5.5 - Check for rollback attacks in both top-level and delegated targets roles (note that the Meta object includes both)
+		for path, local := range currentSnapshot.Meta {
+			if newMeta, ok := snapshot.Meta[path]; ok {
+				// 5.5.5 - Check for rollback attack
+				if newMeta.Version < local.Version {
+					return data.SnapshotFiles{}, verify.ErrLowVersion{Actual: newMeta.Version, Current: local.Version}
+				}
+			} else {
+				// 5.5.5 - Abort the update if a target file has been removed from the new snapshot file
+				return data.SnapshotFiles{}, verify.ErrMissingTargetFile
+			}
+		}
+	}
+	// At this point we can trust the new snapshot, the top-level targets, and any delegated targets versions it refers to
+	// so we can update the client's trusted versions and proceed with persisting the new snapshot metadata
+	// c.snapshotVer was already set when we verified the timestamp metadata
+	c.targetsVer = snapshot.Meta[""targets.json""].Version
 	return snapshot.Meta, nil
 }
 
",[False]
GO-2022-0444,theupdateframework,go-tuf,ed6788e710fc3093a7ecc2d078bf734c0f200d8d," func (c *Client) decodeSnapshot(b json.RawMessage) (data.SnapshotFiles, error) {
 // returns updated targets.
 func (c *Client) decodeTargets(b json.RawMessage) (data.TargetFiles, error) {
 	targets := &data.Targets{}
+	// 5.6.(3 and 5) - Verify signatures and check against freeze attack
 	if err := c.db.Unmarshal(b, targets, ""targets"", c.targetsVer); err != nil {
 		return nil, ErrDecodeFailed{""targets.json"", err}
 	}
+	// Generate a list with the updated targets
 	updatedTargets := make(data.TargetFiles)
 	for path, meta := range targets.Targets {
 		if local, ok := c.targets[path]; ok {
",[True]
GO-2022-0444,theupdateframework,go-tuf,ed6788e710fc3093a7ecc2d078bf734c0f200d8d," func (c *Client) decodeTargets(b json.RawMessage) (data.TargetFiles, error) {
 		}
 		updatedTargets[path] = meta
 	}
-	c.targetsVer = targets.Version
+	// c.targetsVer was already updated when we verified the snapshot metadata
 	// FIXME(TUF-0.9) temporarily support files with leading path separators.
 	// c.targets = targets.Targets
 	c.loadTargets(targets.Targets)
",[True]
GO-2022-0444,theupdateframework,go-tuf,ed6788e710fc3093a7ecc2d078bf734c0f200d8d," func (c *Client) decodeTimestamp(b json.RawMessage) (data.TimestampFileMeta, err
 	if err := c.db.Unmarshal(b, timestamp, ""timestamp"", c.timestampVer); err != nil {
 		return data.TimestampFileMeta{}, ErrDecodeFailed{""timestamp.json"", err}
 	}
+	// 5.4.3.2 - Check for snapshot rollback attack
+	// Verify that the current snapshot meta version is less than or equal to the new one
+	if timestamp.Meta[""snapshot.json""].Version < c.snapshotVer {
+		return data.TimestampFileMeta{}, verify.ErrLowVersion{Actual: timestamp.Meta[""snapshot.json""].Version, Current: c.snapshotVer}
+	}
+	// At this point we can trust the new timestamp and the snaphost version it refers to
+	// so we can update the client's trusted versions and proceed with persisting the new timestamp
 	c.timestampVer = timestamp.Version
+	c.snapshotVer = timestamp.Meta[""snapshot.json""].Version
 	return timestamp.Meta[""snapshot.json""], nil
 }
 
",[True]
GO-2022-0444,theupdateframework,go-tuf,ed6788e710fc3093a7ecc2d078bf734c0f200d8d," func (t *tmpFile) Delete() error {
 }
 
 func cmdGet(args *docopt.Args, client *tuf.Client) error {
-	if _, err := client.Update(); err != nil && !tuf.IsLatestSnapshot(err) {
+	if _, err := client.Update(); err != nil {
 		return err
 	}
 	target := util.NormalizeTarget(args.String[""<target>""])
",[False]
GO-2022-0444,theupdateframework,go-tuf,ed6788e710fc3093a7ecc2d078bf734c0f200d8d," List available target files.
 }
 
 func cmdList(args *docopt.Args, client *tuf.Client) error {
-	if _, err := client.Update(); err != nil && !tuf.IsLatestSnapshot(err) {
+	if _, err := client.Update(); err != nil {
 		return err
 	}
 	targets, err := client.Targets()
",[False]
GO-2022-0444,theupdateframework,go-tuf,ed6788e710fc3093a7ecc2d078bf734c0f200d8d," func SnapshotFileMetaEqual(actual data.SnapshotFileMeta, expected data.SnapshotF
 	if expected.Length != 0 && actual.Length != expected.Length {
 		return ErrWrongLength{expected.Length, actual.Length}
 	}
-
+	// 5.6.2 - Check against snapshot role's targets hash
 	if len(expected.Hashes) != 0 {
 		if err := hashEqual(actual.Hashes, expected.Hashes); err != nil {
 			return err
 		}
 	}
-
+	// 5.6.4 - Check against snapshot role's snapshot version
 	if err := versionEqual(actual.Version, expected.Version); err != nil {
 		return err
 	}
",[False]
GO-2022-0444,theupdateframework,go-tuf,ed6788e710fc3093a7ecc2d078bf734c0f200d8d," func TargetFileMetaEqual(actual data.TargetFileMeta, expected data.TargetFileMet
 }
 
 func TimestampFileMetaEqual(actual data.TimestampFileMeta, expected data.TimestampFileMeta) error {
-	// As opposed to snapshots, the length and hashes are still required in
-	// TUF-1.0. See:
-	// https://github.com/theupdateframework/specification/issues/38
-	if err := FileMetaEqual(actual.FileMeta, expected.FileMeta); err != nil {
-		return err
+	// TUF no longer considers the length and hashes to be a required
+	// member of Timestamp.
+	if expected.Length != 0 && actual.Length != expected.Length {
+		return ErrWrongLength{expected.Length, actual.Length}
 	}
-
+	// 5.5.2 - Check against timestamp role's snapshot hash
+	if len(expected.Hashes) != 0 {
+		if err := hashEqual(actual.Hashes, expected.Hashes); err != nil {
+			return err
+		}
+	}
+	// 5.5.4 - Check against timestamp role's snapshot version
 	if err := versionEqual(actual.Version, expected.Version); err != nil {
 		return err
 	}
",[True]
GO-2022-0444,theupdateframework,go-tuf,ed6788e710fc3093a7ecc2d078bf734c0f200d8d," func (db *DB) VerifyIgnoreExpiredCheck(s *data.Signed, role string, minVersion i
 }
 
 func (db *DB) Verify(s *data.Signed, role string, minVersion int64) error {
-
+	// Verify signatures and versions
 	err := db.VerifyIgnoreExpiredCheck(s, role, minVersion)
 
 	if err != nil {
",[False]
GO-2022-0444,theupdateframework,go-tuf,ed6788e710fc3093a7ecc2d078bf734c0f200d8d," func (db *DB) Verify(s *data.Signed, role string, minVersion int64) error {
 	if err := json.Unmarshal(s.Signed, sm); err != nil {
 		return err
 	}
-
+	// Verify expiration
 	if IsExpired(sm.Expires) {
 		return ErrExpired{sm.Expires}
 	}
",[False]
GO-2022-1188,sajari,docconv,42bcff666855ab978e67a9041d0cdea552f20301," func ConvertDocx(r io.Reader) (string, map[string]string, error) {
 		size = si.Size()
 		ra = f
 	} else {
-		b, err := ioutil.ReadAll(r)
+		b, err := ioutil.ReadAll(io.LimitReader(r, maxBytes))
 		if err != nil {
 			return """", nil, nil
 		}
",[False]
GO-2022-1188,sajari,docconv,42bcff666855ab978e67a9041d0cdea552f20301," func ConvertODT(r io.Reader) (string, map[string]string, error) {
 	meta := make(map[string]string)
 	var textBody string
 
-	b, err := ioutil.ReadAll(r)
+	b, err := ioutil.ReadAll(io.LimitReader(r, maxBytes))
 	if err != nil {
 		return """", nil, err
 	}
",[False]
GO-2022-1188,sajari,docconv,42bcff666855ab978e67a9041d0cdea552f20301," func ConvertPages(r io.Reader) (string, map[string]string, error) {
 	meta := make(map[string]string)
 	var textBody string
 
-	b, err := ioutil.ReadAll(r)
+	b, err := ioutil.ReadAll(io.LimitReader(r, maxBytes))
 	if err != nil {
 		return """", nil, fmt.Errorf(""error reading data: %v"", err)
 	}
",[False]
GO-2022-1188,sajari,docconv,42bcff666855ab978e67a9041d0cdea552f20301," func ConvertXML(r io.Reader) (string, map[string]string, error) {
 func XMLToText(r io.Reader, breaks []string, skip []string, strict bool) (string, error) {
 	var result string
 
-	dec := xml.NewDecoder(r)
+	dec := xml.NewDecoder(io.LimitReader(r, maxBytes))
 	dec.Strict = strict
 	for {
 		t, err := dec.Token()
",[False]
GO-2022-1188,sajari,docconv,42bcff666855ab978e67a9041d0cdea552f20301," func XMLToText(r io.Reader, breaks []string, skip []string, strict bool) (string
 // XMLToMap converts XML to a nested string map.
 func XMLToMap(r io.Reader) (map[string]string, error) {
 	m := make(map[string]string)
-	dec := xml.NewDecoder(r)
+	dec := xml.NewDecoder(io.LimitReader(r, maxBytes))
 	var tagName string
 	for {
 		t, err := dec.Token()
",[False]
GO-2020-0045,dinever,golf,3776f338be48b5bc5e8cf9faff7851fc52a3f1fe,"
 package golf
 
 import (
+	""crypto/rand""
 	""encoding/hex""
-	""math/rand""
-	""time""
 )
 
 const chars = ""abcdefghijklmnopqrstuvwxyz0123456789""
 
 func randomBytes(strlen int) []byte {
-	rand.Seed(time.Now().UTC().UnixNano())
-	result := make([]byte, strlen)
-	for i := 0; i < strlen; i++ {
-		result[i] = chars[rand.Intn(len(chars))]
+	b := make([]byte, strlen)
+	_, err := rand.Read(b)
+	if err != nil {
+		// panic on failure since this indicates a failure of the system's
+		// CSPRNG
+		panic(err)
 	}
-	return result
+	return b
 }
 
 func decodeXSRFToken(maskedToken string) ([]byte, []byte, error) {
",[True]
GO-2020-0033,go-aah,aah,881dc9f71d1f7a4e8a9a39df9c5c081d3a2da1ec," func (e *HTTPEngine) Handle(w http.ResponseWriter, r *http.Request) {
 		defer e.a.accessLog.Log(ctx)
 	}
 
+	// Path Clean
+	r.URL.Path = path.Clean(r.URL.Path)
+
 	ctx.Req, ctx.Res = ahttp.AcquireRequest(r), ahttp.AcquireResponseWriter(w)
 
 	// Recovery handling
",[True]
GO-2020-0033,go-aah,aah,881dc9f71d1f7a4e8a9a39df9c5c081d3a2da1ec," func (s *staticManager) Serve(ctx *Context) error {
 
 	// Serve directory
 	if fi.Mode().IsDir() && ctx.route.ListDir {
+		fmt.Println(""here 1"")
 		// redirect if the directory name doesn't end in a slash
 		if ctx.Req.Path[len(ctx.Req.Path)-1] != '/' {
 			ctx.Log().Debugf(""redirecting to dir: %s"", ctx.Req.Path+""/"")
",[False]
GO-2023-1923,mastercactapus,proxyprotocol,5c4a101121fc3e868026189c7a73f7f19eef90ac," func parseV2(r *bufio.Reader) (*HeaderV2, error) {
 	}
 
 	// highest 4 indicate address family
-	if (rawHdr.FamProto >> 4) > 3 {
+	switch rawHdr.FamProto >> 4 {
+	case 0: // local
+		if rawHdr.Len != 0 {
+			return nil, &InvalidHeaderErr{Read: buf[:16], error: errors.New(""invalid length"")}
+		}
+	case 1: // ipv4
+		if rawHdr.Len != 12 {
+			return nil, &InvalidHeaderErr{Read: buf[:16], error: errors.New(""invalid length"")}
+		}
+	case 2: // ipv6
+		if rawHdr.Len != 36 {
+			return nil, &InvalidHeaderErr{Read: buf[:16], error: errors.New(""invalid length"")}
+		}
+	case 3: // unix
+		if rawHdr.Len != 216 {
+			return nil, &InvalidHeaderErr{Read: buf[:16], error: errors.New(""invalid length"")}
+		}
+	default:
 		return nil, &InvalidHeaderErr{Read: buf[:16], error: errors.New(""invalid v2 address family"")}
 	}
 
",[True]
GO-2023-1923,mastercactapus,proxyprotocol,5c4a101121fc3e868026189c7a73f7f19eef90ac," func parseV2(r *bufio.Reader) (*HeaderV2, error) {
 		return nil, &InvalidHeaderErr{Read: buf[:16], error: errors.New(""invalid v2 transport protocol"")}
 	}
 
-	if 16+int(rawHdr.Len) > len(buf) {
-		newBuf := make([]byte, 16+int(rawHdr.Len))
-		copy(newBuf, buf[:16])
-		buf = newBuf
-	} else {
-		buf = buf[:16+int(rawHdr.Len)]
-	}
+	buf = buf[:16+int(rawHdr.Len)]
 
 	n, err = io.ReadFull(r, buf[16:])
 	if err != nil {
",[True]
GO-2021-0095,google,go-tpm,d7806cce857a1a020190c03348e5361725d8f141," func LoadKey2(rw io.ReadWriter, keyBlob []byte, srkAuth []byte) (tpmutil.Handle,
 	defer zeroBytes(sharedSecret[:])
 
 	authIn := []interface{}{ordLoadKey2, k}
-	ca, err := newCommandAuth(osapr.AuthHandle, osapr.NonceEven, sharedSecret[:], authIn)
+	ca, err := newCommandAuth(osapr.AuthHandle, osapr.NonceEven, nil, sharedSecret[:], authIn)
 	if err != nil {
 		return 0, err
 	}
",[False]
GO-2021-0095,google,go-tpm,d7806cce857a1a020190c03348e5361725d8f141," func Quote2(rw io.ReadWriter, handle tpmutil.Handle, data []byte, pcrVals []int,
 		return nil, err
 	}
 	authIn := []interface{}{ordQuote2, hash, pcrSel, addVersion}
-	ca, err := newCommandAuth(osapr.AuthHandle, osapr.NonceEven, sharedSecret[:], authIn)
+	ca, err := newCommandAuth(osapr.AuthHandle, osapr.NonceEven, nil, sharedSecret[:], authIn)
 	if err != nil {
 		return nil, err
 	}
",[False]
GO-2021-0095,google,go-tpm,d7806cce857a1a020190c03348e5361725d8f141," func GetPubKey(rw io.ReadWriter, keyHandle tpmutil.Handle, srkAuth []byte) ([]by
 	defer zeroBytes(sharedSecret[:])
 
 	authIn := []interface{}{ordGetPubKey}
-	ca, err := newCommandAuth(osapr.AuthHandle, osapr.NonceEven, sharedSecret[:], authIn)
+	ca, err := newCommandAuth(osapr.AuthHandle, osapr.NonceEven, nil, sharedSecret[:], authIn)
 	if err != nil {
 		return nil, err
 	}
",[False]
GO-2021-0095,google,go-tpm,d7806cce857a1a020190c03348e5361725d8f141," func newOSAPSession(rw io.ReadWriter, entityType uint16, entityValue tpmutil.Han
 }
 
 // newCommandAuth creates a new commandAuth structure over the given
-// parameters, using the given secret for HMAC computation.
-func newCommandAuth(authHandle tpmutil.Handle, nonceEven Nonce, key []byte, params []interface{}) (*commandAuth, error) {
+// parameters, using the given secret and the given odd nonce, if provided,
+// for the HMAC. If no odd nonce is provided, one is randomly generated.
+func newCommandAuth(authHandle tpmutil.Handle, nonceEven Nonce, nonceOdd *Nonce, key []byte, params []interface{}) (*commandAuth, error) {
 	// Auth = HMAC-SHA1(key, SHA1(params) || NonceEven || NonceOdd || ContSession)
 	digestBytes, err := tpmutil.Pack(params...)
 	if err != nil {
 		return nil, err
 	}
-
 	digest := sha1.Sum(digestBytes)
-	ca := &commandAuth{AuthHandle: authHandle}
-	if _, err := rand.Read(ca.NonceOdd[:]); err != nil {
-		return nil, err
+
+	// Use the passed-in nonce if non-nil, otherwise generate it now.
+	var odd Nonce
+	if nonceOdd != nil {
+		odd = *nonceOdd
+	} else {
+		if _, err := rand.Read(odd[:]); err != nil {
+			return nil, err
+		}
+	}
+
+	ca := &commandAuth{
+		AuthHandle: authHandle,
+		NonceOdd:   odd,
 	}
 
 	authBytes, err := tpmutil.Pack(digest, nonceEven, ca.NonceOdd, ca.ContSession)
",[False]
GO-2021-0095,google,go-tpm,d7806cce857a1a020190c03348e5361725d8f141," func sealHelper(rw io.ReadWriter, pcrInfo *pcrInfoLong, data []byte, srkAuth []b
 	//               len(data) || data)
 	//
 	authIn := []interface{}{ordSeal, sc.EncAuth, uint32(binary.Size(pcrInfo)), pcrInfo, tpmutil.U32Bytes(data)}
-	ca, err := newCommandAuth(osapr.AuthHandle, osapr.NonceEven, sharedSecret[:], authIn)
+	ca, err := newCommandAuth(osapr.AuthHandle, osapr.NonceEven, nil, sharedSecret[:], authIn)
 	if err != nil {
 		return nil, err
 	}
",[False]
GO-2021-0095,google,go-tpm,d7806cce857a1a020190c03348e5361725d8f141," func Unseal(rw io.ReadWriter, sealed []byte, srkAuth []byte) ([]byte, error) {
 	authIn := []interface{}{ordUnseal, tsd}
 
 	// The first commandAuth uses the shared secret as an HMAC key.
-	ca1, err := newCommandAuth(osapr.AuthHandle, osapr.NonceEven, sharedSecret[:], authIn)
+	ca1, err := newCommandAuth(osapr.AuthHandle, osapr.NonceEven, nil, sharedSecret[:], authIn)
 	if err != nil {
 		return nil, err
 	}
 
 	// The second commandAuth is based on OIAP instead of OSAP and uses the
 	// SRK auth value as an HMAC key instead of the shared secret.
-	ca2, err := newCommandAuth(oiapr.AuthHandle, oiapr.NonceEven, srkAuth, authIn)
+	ca2, err := newCommandAuth(oiapr.AuthHandle, oiapr.NonceEven, nil, srkAuth, authIn)
 	if err != nil {
 		return nil, err
 	}
",[False]
GO-2021-0095,google,go-tpm,d7806cce857a1a020190c03348e5361725d8f141," func Quote(rw io.ReadWriter, handle tpmutil.Handle, data []byte, pcrNums []int,
 		return nil, nil, err
 	}
 	authIn := []interface{}{ordQuote, hash, pcrSel}
-	ca, err := newCommandAuth(osapr.AuthHandle, osapr.NonceEven, sharedSecret[:], authIn)
+	ca, err := newCommandAuth(osapr.AuthHandle, osapr.NonceEven, nil, sharedSecret[:], authIn)
 	if err != nil {
 		return nil, nil, err
 	}
",[False]
GO-2021-0095,google,go-tpm,d7806cce857a1a020190c03348e5361725d8f141," func MakeIdentity(rw io.ReadWriter, srkAuth []byte, ownerAuth []byte, aikAuth []
 	// digest = SHA1(ordMakeIdentity || encAuth || caDigest || aik)
 	//
 	authIn := []interface{}{ordMakeIdentity, encAuth, caDigest, aik}
-	ca1, err := newCommandAuth(osaprSRK.AuthHandle, osaprSRK.NonceEven, sharedSecretSRK[:], authIn)
+	ca1, err := newCommandAuth(osaprSRK.AuthHandle, osaprSRK.NonceEven, nil, sharedSecretSRK[:], authIn)
 	if err != nil {
 		return nil, err
 	}
 
-	ca2, err := newCommandAuth(osaprOwn.AuthHandle, osaprOwn.NonceEven, sharedSecretOwn[:], authIn)
+	ca2, err := newCommandAuth(osaprOwn.AuthHandle, osaprOwn.NonceEven, nil, sharedSecretOwn[:], authIn)
 	if err != nil {
 		return nil, err
 	}
",[False]
GO-2021-0095,google,go-tpm,d7806cce857a1a020190c03348e5361725d8f141," func ActivateIdentity(rw io.ReadWriter, aikAuth []byte, ownerAuth []byte, aik tp
 	defer zeroBytes(sharedSecretOwn[:])
 
 	authIn := []interface{}{ordActivateIdentity, tpmutil.U32Bytes(asym)}
-	ca1, err := newCommandAuth(oiaprAIK.AuthHandle, oiaprAIK.NonceEven, aikAuth, authIn)
+	ca1, err := newCommandAuth(oiaprAIK.AuthHandle, oiaprAIK.NonceEven, nil, aikAuth, authIn)
 	if err != nil {
 		return nil, fmt.Errorf(""newCommandAuth failed: %v"", err)
 	}
-	ca2, err := newCommandAuth(osaprOwn.AuthHandle, osaprOwn.NonceEven, sharedSecretOwn[:], authIn)
+	ca2, err := newCommandAuth(osaprOwn.AuthHandle, osaprOwn.NonceEven, nil, sharedSecretOwn[:], authIn)
 	if err != nil {
 		return nil, fmt.Errorf(""newCommandAuth failed: %v"", err)
 	}
",[False]
GO-2021-0095,google,go-tpm,d7806cce857a1a020190c03348e5361725d8f141," func ResetLockValue(rw io.ReadWriter, ownerAuth Digest) error {
 	// digest = SHA1(ordResetLockValue)
 	//
 	authIn := []interface{}{ordResetLockValue}
-	ca, err := newCommandAuth(osaprOwn.AuthHandle, osaprOwn.NonceEven, sharedSecretOwn[:], authIn)
+	ca, err := newCommandAuth(osaprOwn.AuthHandle, osaprOwn.NonceEven, nil, sharedSecretOwn[:], authIn)
 	if err != nil {
 		return err
 	}
",[False]
GO-2021-0095,google,go-tpm,d7806cce857a1a020190c03348e5361725d8f141," func ownerReadInternalHelper(rw io.ReadWriter, kh tpmutil.Handle, ownerAuth Dige
 	// digest = SHA1(ordOwnerReadInternalPub || kh)
 	//
 	authIn := []interface{}{ordOwnerReadInternalPub, kh}
-	ca, err := newCommandAuth(osaprOwn.AuthHandle, osaprOwn.NonceEven, sharedSecretOwn[:], authIn)
+	ca, err := newCommandAuth(osaprOwn.AuthHandle, osaprOwn.NonceEven, nil, sharedSecretOwn[:], authIn)
 	if err != nil {
 		return nil, err
 	}
",[False]
GO-2021-0095,google,go-tpm,d7806cce857a1a020190c03348e5361725d8f141," func NVDefineSpace(rw io.ReadWriter, nvData NVDataPublic, ownAuth []byte) error
 		encAuthData := sha1.Sum(xorData)
 
 		authIn := []interface{}{ordNVDefineSpace, nvData, encAuthData}
-		ca, err := newCommandAuth(osaprOwn.AuthHandle, osaprOwn.NonceEven, sharedSecretOwn[:], authIn)
+		ca, err := newCommandAuth(osaprOwn.AuthHandle, osaprOwn.NonceEven, nil, sharedSecretOwn[:], authIn)
 		if err != nil {
 			return err
 		}
",[False]
GO-2021-0095,google,go-tpm,d7806cce857a1a020190c03348e5361725d8f141," func NVReadValue(rw io.ReadWriter, index, offset, len uint32, ownAuth []byte) ([
 	defer osaprOwn.Close(rw)
 	defer zeroBytes(sharedSecretOwn[:])
 	authIn := []interface{}{ordNVReadValue, index, offset, len}
-	ca, err := newCommandAuth(osaprOwn.AuthHandle, osaprOwn.NonceEven, sharedSecretOwn[:], authIn)
+	ca, err := newCommandAuth(osaprOwn.AuthHandle, osaprOwn.NonceEven, nil, sharedSecretOwn[:], authIn)
 	if err != nil {
 		return nil, fmt.Errorf(""failed to construct owner auth fields: %v"", err)
 	}
",[False]
GO-2021-0095,google,go-tpm,d7806cce857a1a020190c03348e5361725d8f141," func NVReadValueAuth(rw io.ReadWriter, index, offset, len uint32, auth []byte) (
 	defer osapr.Close(rw)
 	defer zeroBytes(sharedSecret[:])
 	authIn := []interface{}{ordNVReadValueAuth, index, offset, len}
-	ca, err := newCommandAuth(osapr.AuthHandle, osapr.NonceEven, sharedSecret[:], authIn)
+	ca, err := newCommandAuth(osapr.AuthHandle, osapr.NonceEven, nil, sharedSecret[:], authIn)
 	if err != nil {
 		return nil, fmt.Errorf(""failed to construct auth fields: %v"", err)
 	}
",[False]
GO-2021-0095,google,go-tpm,d7806cce857a1a020190c03348e5361725d8f141," func NVWriteValue(rw io.ReadWriter, index, offset uint32, data []byte, ownAuth [
 	defer osaprOwn.Close(rw)
 	defer zeroBytes(sharedSecretOwn[:])
 	authIn := []interface{}{ordNVWriteValue, index, offset, len(data), data}
-	ca, err := newCommandAuth(osaprOwn.AuthHandle, osaprOwn.NonceEven, sharedSecretOwn[:], authIn)
+	ca, err := newCommandAuth(osaprOwn.AuthHandle, osaprOwn.NonceEven, nil, sharedSecretOwn[:], authIn)
 	if err != nil {
 		return fmt.Errorf(""failed to construct owner auth fields: %v"", err)
 	}
",[False]
GO-2021-0095,google,go-tpm,d7806cce857a1a020190c03348e5361725d8f141," func NVWriteValueAuth(rw io.ReadWriter, index, offset uint32, data []byte, auth
 	defer osapr.Close(rw)
 	defer zeroBytes(sharedSecret[:])
 	authIn := []interface{}{ordNVWriteValueAuth, index, offset, len(data), data}
-	ca, err := newCommandAuth(osapr.AuthHandle, osapr.NonceEven, sharedSecret[:], authIn)
+	ca, err := newCommandAuth(osapr.AuthHandle, osapr.NonceEven, nil, sharedSecret[:], authIn)
 	if err != nil {
 		return fmt.Errorf(""failed to construct auth fields: %v"", err)
 	}
",[False]
GO-2021-0095,google,go-tpm,d7806cce857a1a020190c03348e5361725d8f141," func OwnerClear(rw io.ReadWriter, ownerAuth Digest) error {
 	// digest = SHA1(ordOwnerClear)
 	//
 	authIn := []interface{}{ordOwnerClear}
-	ca, err := newCommandAuth(osaprOwn.AuthHandle, osaprOwn.NonceEven, sharedSecretOwn[:], authIn)
+	ca, err := newCommandAuth(osaprOwn.AuthHandle, osaprOwn.NonceEven, nil, sharedSecretOwn[:], authIn)
 	if err != nil {
 		return err
 	}
",[False]
GO-2021-0095,google,go-tpm,d7806cce857a1a020190c03348e5361725d8f141," func TakeOwnership(rw io.ReadWriter, newOwnerAuth Digest, newSRKAuth Digest, pub
 	// The digest for TakeOwnership is
 	//
 	// SHA1(ordTakeOwnership || pidOwner || encOwnerAuth || encSRKAuth || srk)
-	authIn := []interface{}{ordTakeOwnership, pidOwner, encOwnerAuth, encSRKAuth, srk}
-	ca, err := newCommandAuth(oiapr.AuthHandle, oiapr.NonceEven, newOwnerAuth[:], authIn)
+	authIn := []interface{}{ordTakeOwnership, pidOwner, tpmutil.U32Bytes(encOwnerAuth), tpmutil.U32Bytes(encSRKAuth), srk}
+	ca, err := newCommandAuth(oiapr.AuthHandle, oiapr.NonceEven, nil, newOwnerAuth[:], authIn)
 	if err != nil {
 		return err
 	}
",[False]
GO-2021-0095,google,go-tpm,d7806cce857a1a020190c03348e5361725d8f141," func Sign(rw io.ReadWriter, keyAuth []byte, keyHandle tpmutil.Handle, hash crypt
 	defer zeroBytes(sharedSecret[:])
 
 	authIn := []interface{}{ordSign, tpmutil.U32Bytes(data)}
-	ca, err := newCommandAuth(osapr.AuthHandle, osapr.NonceEven, sharedSecret[:], authIn)
+	ca, err := newCommandAuth(osapr.AuthHandle, osapr.NonceEven, nil, sharedSecret[:], authIn)
 	if err != nil {
 		return nil, err
 	}
",[False]
GO-2023-1640,dablelv,go-huge-util,0e308b0fac8973e6fa251b0ab095cdc5c1c0956b," func IsFileE(path string) (bool, error) {
 	return false, err
 }
 
-// IsSymlink checks a file whether is a symbolic link.
+// IsSymlink checks a file whether is a symbolic link on Linux.
 // Note that this doesn't work for the shortcut file on windows.
+// If you want to check a file whether is a shortcut file on Windows please use IsShortcut function.
 func IsSymlink(path string) bool {
 	if info, err := os.Lstat(path); err == nil && info.Mode()&os.ModeSymlink != 0 {
 		return true
",[False]
GO-2023-1640,dablelv,go-huge-util,0e308b0fac8973e6fa251b0ab095cdc5c1c0956b," func IsSymlink(path string) bool {
 	return false
 }
 
-// IsSymlinkE checks a file whether is a symbolic link.
+// IsSymlinkE checks a file whether is a symbolic link on Linux.
 // Note that this doesn't work for the shortcut file on windows.
+// If you want to check a file whether is a shortcut file on Windows please use IsShortcut function.
 func IsSymlinkE(path string) (bool, error) {
 	info, err := os.Lstat(path)
 	if err == nil && info.Mode()&os.ModeSymlink != 0 {
",[False]
GO-2023-1640,dablelv,go-huge-util,0e308b0fac8973e6fa251b0ab095cdc5c1c0956b," func FileToBytes(path string) []byte {
 	return byteStream
 }
 
-// BytesToFile writes data to a file. If the file does not exist it will be created with permission mode 0644.
-func BytesToFile(filePath string, data []byte) error {
-	exist, _ := IsPathExist(filePath)
+// BytesToFile writes data to a file.
+// If the file does not exist it will be created with permission mode 0644.
+func BytesToFile(path string, data []byte) error {
+	exist, _ := IsExist(path)
 	if !exist {
-		if err := CreateFile(filePath); err != nil {
+		if err := CreateFile(path); err != nil {
 			return err
 		}
 	}
-	return ioutil.WriteFile(filePath, data, 0644)
+	return ioutil.WriteFile(path, data, 0644)
 }
 
 // GetDirAllEntryPaths gets all the file or dir paths in the specified directory recursively.
",[False]
GO-2023-1640,dablelv,go-huge-util,0e308b0fac8973e6fa251b0ab095cdc5c1c0956b," func GetDirAllEntryPathsFollowSymlink(dirname string, incl bool) ([]string, erro
 	}
 	return paths, nil
 }
+
+// ClearFile clears a file content.
+func ClearFile(path string) error {
+	f, err := os.OpenFile(path, os.O_WRONLY|os.O_TRUNC, 0777)
+	if err != nil {
+		return err
+	}
+	defer f.Close()
+	return nil
+}
",[False]
GO-2023-1640,dablelv,go-huge-util,0e308b0fac8973e6fa251b0ab095cdc5c1c0956b," func Unzip(zipPath, dstDir string) error {
 }
 
 func unzipFile(file *zip.File, dstDir string) error {
-	// create the directory of file
-	filePath := path.Join(dstDir, file.Name)
+	// Prevent path traversal vulnerability.
+	// Such as if the file name is ""../../../path/to/file.txt"" which will be cleaned to ""path/to/file.txt"".
+	name := strings.TrimPrefix(filepath.Join(string(filepath.Separator), file.Name), string(filepath.Separator))
+	filePath := path.Join(dstDir, name)
+
+	// Create the directory of file.
 	if file.FileInfo().IsDir() {
 		if err := os.MkdirAll(filePath, os.ModePerm); err != nil {
 			return err
",[True]
GO-2023-1640,dablelv,go-huge-util,0e308b0fac8973e6fa251b0ab095cdc5c1c0956b," func unzipFile(file *zip.File, dstDir string) error {
 		return err
 	}
 
-	// open the file
+	// Open the file.
 	r, err := file.Open()
 	if err != nil {
 		return err
 	}
 	defer r.Close()
 
-	// create the file
+	// Create the file.
 	w, err := os.Create(filePath)
 	if err != nil {
 		return err
 	}
 	defer w.Close()
 
-	// save the decompressed file content
+	// Save the decompressed file content.
 	_, err = io.Copy(w, r)
 	return err
 }
",[True]
GO-2023-1640,dablelv,go-huge-util,0e308b0fac8973e6fa251b0ab095cdc5c1c0956b," import (
 // dir
 // ├── bar.txt
 // └── foo.txt
-// Note that if a file is a symbolic link it will be skipped.
+// Note that if a file is a symbolic link on Linux it will be skipped.
+// If you want to follow a symbolic link please use the function ZipFollowSymlink.
 func Zip(zipPath string, paths ...string) error {
 	// Create zip file and it's parent dir.
 	if err := os.MkdirAll(filepath.Dir(zipPath), os.ModePerm); err != nil {
",[False]
GO-2022-0588,microcosm-cc,bluemonday,c788a2a4d42e081ad54a31368478820bb4a42fb4," func (p *Policy) AllowElementsContent(names ...string) *Policy {
 	return p
 }
 
+// AllowUnsafe permits fundamentally unsafe elements.
+//
+// If false (default) then elements such as `style` and `script` will not be
+// permitted even if declared in a policy. These elements when combined with
+// untrusted input cannot be safely handled by bluemonday at this point in
+// time.
+//
+// If true then `style` and `script` would be permitted by bluemonday if a
+// policy declares them. However this is not recommended under any circumstance
+// and can lead to XSS being rendered thus defeating the purpose of using a
+// HTML sanitizer.
+func (p *Policy) AllowUnsafe(allowUnsafe bool) *Policy {
+	p.init()
+	p.allowUnsafe = allowUnsafe
+	return p
+}
+
 // addDefaultElementsWithoutAttrs adds the HTML elements that we know are valid
 // without any attributes to an internal map.
 // i.e. we know that <table> is valid, but <bdo> isn't valid as the ""dir"" attr
",[False]
GO-2022-0588,microcosm-cc,bluemonday,c788a2a4d42e081ad54a31368478820bb4a42fb4," func (p *Policy) sanitize(r io.Reader, w io.Writer) error {
 
 			mostRecentlyStartedToken = normaliseElementName(token.Data)
 
+			switch normaliseElementName(token.Data) {
+			case `script`:
+				if !p.allowUnsafe {
+					continue
+				}
+			case `style`:
+				if !p.allowUnsafe {
+					continue
+				}
+			}
+
 			aps, ok := p.elsAndAttrs[token.Data]
 			if !ok {
 				aa, matched := p.matchRegex(token.Data)
",[False]
GO-2022-0588,microcosm-cc,bluemonday,c788a2a4d42e081ad54a31368478820bb4a42fb4," func (p *Policy) sanitize(r io.Reader, w io.Writer) error {
 				mostRecentlyStartedToken = """"
 			}
 
+			switch normaliseElementName(token.Data) {
+			case `script`:
+				if !p.allowUnsafe {
+					continue
+				}
+			case `style`:
+				if !p.allowUnsafe {
+					continue
+				}
+			}
+
 			if skipClosingTag && closingTagToSkipStack[len(closingTagToSkipStack)-1] == token.Data {
 				closingTagToSkipStack = closingTagToSkipStack[:len(closingTagToSkipStack)-1]
 				if len(closingTagToSkipStack) == 0 {
",[False]
GO-2022-0588,microcosm-cc,bluemonday,c788a2a4d42e081ad54a31368478820bb4a42fb4," func (p *Policy) sanitize(r io.Reader, w io.Writer) error {
 
 		case html.SelfClosingTagToken:
 
+			switch normaliseElementName(token.Data) {
+			case `script`:
+				if !p.allowUnsafe {
+					continue
+				}
+			case `style`:
+				if !p.allowUnsafe {
+					continue
+				}
+			}
+
 			aps, ok := p.elsAndAttrs[token.Data]
 			if !ok {
 				aa, matched := p.matchRegex(token.Data)
",[False]
GO-2022-0588,microcosm-cc,bluemonday,c788a2a4d42e081ad54a31368478820bb4a42fb4," func (p *Policy) sanitize(r io.Reader, w io.Writer) error {
 				case `script`:
 					// not encouraged, but if a policy allows JavaScript we
 					// should not HTML escape it as that would break the output
-					if _, err := buff.WriteString(token.Data); err != nil {
-						return err
+					//
+					// requires p.AllowUnsafe()
+					if p.allowUnsafe {
+						if _, err := buff.WriteString(token.Data); err != nil {
+							return err
+						}
 					}
 				case ""style"":
 					// not encouraged, but if a policy allows CSS styles we
 					// should not HTML escape it as that would break the output
-					if _, err := buff.WriteString(token.Data); err != nil {
-						return err
+					//
+					// requires p.AllowUnsafe()
+					if p.allowUnsafe {
+						if _, err := buff.WriteString(token.Data); err != nil {
+							return err
+						}
 					}
 				default:
 					// HTML escape the text
",[False]
GO-2021-0057,buger,jsonparser,df3ea76ece10095374fd1c9a22a4fb85a44efc42," func searchKeys(data []byte, keys ...string) int {
 		case '[':
 			// If we want to get array element by index
 			if keyLevel == level && keys[level][0] == '[' {
-				aIdx, err := strconv.Atoi(keys[level][1 : len(keys[level])-1])
+				var keyLen = len(keys[level])
+				if keyLen < 3 || keys[level][0] != '[' || keys[level][keyLen-1] != ']' {
+					return -1
+				}
+				aIdx, err := strconv.Atoi(keys[level][1 : keyLen-1])
 				if err != nil {
 					return -1
 				}
",[True]
GO-2023-1578,hashicorp,go-getter,78e6721a2a76266718dc92c3c03c1571dffdefdc," func (d *Bzip2Decompressor) Decompress(dst, src string, dir bool, umask os.FileM
 	bzipR := bzip2.NewReader(f)
 
 	// Copy it out
-	return copyReader(dst, bzipR, 0622, umask)
+	return copyReader(dst, bzipR, 0622, umask, d.FileSizeLimit)
 }
",[False]
GO-2023-1578,hashicorp,go-getter,78e6721a2a76266718dc92c3c03c1571dffdefdc," func (d *GzipDecompressor) Decompress(dst, src string, dir bool, umask os.FileMo
 	defer gzipR.Close()
 
 	// Copy it out
-	return copyReader(dst, gzipR, 0622, umask)
+	return copyReader(dst, gzipR, 0622, umask, d.FileSizeLimit)
 }
",[False]
GO-2023-1578,hashicorp,go-getter,78e6721a2a76266718dc92c3c03c1571dffdefdc," import (
 
 // untar is a shared helper for untarring an archive. The reader should provide
 // an uncompressed view of the tar archive.
-func untar(input io.Reader, dst, src string, dir bool, umask os.FileMode) error {
+func untar(input io.Reader, dst, src string, dir bool, umask os.FileMode, fileSizeLimit int64, filesLimit int) error {
 	tarR := tar.NewReader(input)
 	done := false
 	dirHdrs := []*tar.Header{}
 	now := time.Now()
+
+	var (
+		fileSize   int64
+		filesCount int
+	)
+
 	for {
+		if filesLimit > 0 {
+			filesCount++
+			if filesCount > filesLimit {
+				return fmt.Errorf(""tar archive contains too many files: %d > %d"", filesCount, filesLimit)
+			}
+		}
+
 		hdr, err := tarR.Next()
 		if err == io.EOF {
 			if !done {
",[True]
GO-2023-1578,hashicorp,go-getter,78e6721a2a76266718dc92c3c03c1571dffdefdc," func untar(input io.Reader, dst, src string, dir bool, umask os.FileMode) error
 			path = filepath.Join(path, hdr.Name)
 		}
 
-		if hdr.FileInfo().IsDir() {
+		fileInfo := hdr.FileInfo()
+
+		fileSize += fileInfo.Size()
+
+		if fileSizeLimit > 0 && fileSize > fileSizeLimit {
+			return fmt.Errorf(""tar archive larger than limit: %d"", fileSizeLimit)
+		}
+
+		if fileInfo.IsDir() {
 			if !dir {
 				return fmt.Errorf(""expected a single file: %s"", src)
 			}
",[True]
GO-2023-1578,hashicorp,go-getter,78e6721a2a76266718dc92c3c03c1571dffdefdc," func untar(input io.Reader, dst, src string, dir bool, umask os.FileMode) error
 		// Mark that we're done so future in single file mode errors
 		done = true
 
-		// Open the file for writing
-		err = copyReader(path, tarR, hdr.FileInfo().Mode(), umask)
+		// Size limit is tracked using the returned file info.
+		err = copyReader(path, tarR, hdr.FileInfo().Mode(), umask, 0)
 		if err != nil {
 			return err
 		}
",[True]
GO-2023-1578,hashicorp,go-getter,78e6721a2a76266718dc92c3c03c1571dffdefdc," func (d *TarDecompressor) Decompress(dst, src string, dir bool, umask os.FileMod
 	}
 	defer f.Close()
 
-	return untar(f, dst, src, dir, umask)
+	return untar(f, dst, src, dir, umask, d.FileSizeLimit, d.FilesLimit)
 }
",[False]
GO-2023-1578,hashicorp,go-getter,78e6721a2a76266718dc92c3c03c1571dffdefdc," func (d *TarBzip2Decompressor) Decompress(dst, src string, dir bool, umask os.Fi
 
 	// Bzip2 compression is second
 	bzipR := bzip2.NewReader(f)
-	return untar(bzipR, dst, src, dir, umask)
+	return untar(bzipR, dst, src, dir, umask, d.FileSizeLimit, d.FilesLimit)
 }
",[False]
GO-2023-1578,hashicorp,go-getter,78e6721a2a76266718dc92c3c03c1571dffdefdc," func (d *TarGzipDecompressor) Decompress(dst, src string, dir bool, umask os.Fil
 	}
 	defer gzipR.Close()
 
-	return untar(gzipR, dst, src, dir, umask)
+	return untar(gzipR, dst, src, dir, umask, d.FileSizeLimit, d.FilesLimit)
 }
",[False]
GO-2023-1578,hashicorp,go-getter,78e6721a2a76266718dc92c3c03c1571dffdefdc," func (d *TarXzDecompressor) Decompress(dst, src string, dir bool, umask os.FileM
 		return fmt.Errorf(""Error opening an xz reader for %s: %s"", src, err)
 	}
 
-	return untar(txzR, dst, src, dir, umask)
+	return untar(txzR, dst, src, dir, umask, d.FileSizeLimit, d.FilesLimit)
 }
",[False]
GO-2023-1578,hashicorp,go-getter,78e6721a2a76266718dc92c3c03c1571dffdefdc," func (d *TarZstdDecompressor) Decompress(dst, src string, dir bool, umask os.Fil
 	}
 	defer zstdR.Close()
 
-	return untar(zstdR, dst, src, dir, umask)
+	return untar(zstdR, dst, src, dir, umask, d.FileSizeLimit, d.FilesLimit)
 }
",[False]
GO-2023-1578,hashicorp,go-getter,78e6721a2a76266718dc92c3c03c1571dffdefdc," func (d *XzDecompressor) Decompress(dst, src string, dir bool, umask os.FileMode
 		return err
 	}
 
-	// Copy it out
-	return copyReader(dst, xzR, 0622, umask)
+	// Copy it out, potentially using a file size limit.
+	return copyReader(dst, xzR, 0622, umask, d.FileSizeLimit)
 }
",[False]
GO-2023-1578,hashicorp,go-getter,78e6721a2a76266718dc92c3c03c1571dffdefdc," func (d *ZipDecompressor) Decompress(dst, src string, dir bool, umask os.FileMod
 		return fmt.Errorf(""expected a single file: %s"", src)
 	}
 
+	if d.FilesLimit > 0 && len(zipR.File) > d.FilesLimit {
+		return fmt.Errorf(""zip archive contains too many files: %d > %d"", len(zipR.File), d.FilesLimit)
+	}
+
+	var fileSizeTotal int64
+
 	// Go through and unarchive
 	for _, f := range zipR.File {
 		path := dst
",[True]
GO-2023-1578,hashicorp,go-getter,78e6721a2a76266718dc92c3c03c1571dffdefdc," func (d *ZipDecompressor) Decompress(dst, src string, dir bool, umask os.FileMod
 			path = filepath.Join(path, f.Name)
 		}
 
-		if f.FileInfo().IsDir() {
+		fileInfo := f.FileInfo()
+
+		fileSizeTotal += fileInfo.Size()
+
+		if d.FileSizeLimit > 0 && fileSizeTotal > d.FileSizeLimit {
+			return fmt.Errorf(""zip archive larger than limit: %d"", d.FileSizeLimit)
+		}
+
+		if fileInfo.IsDir() {
 			if !dir {
 				return fmt.Errorf(""expected a single file: %s"", src)
 			}
",[True]
GO-2023-1578,hashicorp,go-getter,78e6721a2a76266718dc92c3c03c1571dffdefdc," func (d *ZipDecompressor) Decompress(dst, src string, dir bool, umask os.FileMod
 			return err
 		}
 
-		err = copyReader(path, srcF, f.Mode(), umask)
+		// Size limit is tracked using the returned file info.
+		err = copyReader(path, srcF, f.Mode(), umask, 0)
 		srcF.Close()
 		if err != nil {
 			return err
",[True]
GO-2023-1578,hashicorp,go-getter,78e6721a2a76266718dc92c3c03c1571dffdefdc," func (d *ZstdDecompressor) Decompress(dst, src string, dir bool, umask os.FileMo
 	}
 	defer zstdR.Close()
 
-	// Copy it out
-	return copyReader(dst, zstdR, 0622, umask)
+	// Copy it out, potentially using a file size limit.
+	return copyReader(dst, zstdR, 0622, umask, d.FileSizeLimit)
 }
",[False]
GO-2023-1578,hashicorp,go-getter,78e6721a2a76266718dc92c3c03c1571dffdefdc," func Copy(ctx context.Context, dst io.Writer, src io.Reader) (int64, error) {
 }
 
 // copyReader copies from an io.Reader into a file, using umask to create the dst file
-func copyReader(dst string, src io.Reader, fmode, umask os.FileMode) error {
+func copyReader(dst string, src io.Reader, fmode, umask os.FileMode, fileSizeLimit int64) error {
 	dstF, err := os.OpenFile(dst, os.O_RDWR|os.O_CREATE|os.O_TRUNC, fmode)
 	if err != nil {
 		return err
 	}
 	defer dstF.Close()
 
+	if fileSizeLimit > 0 {
+		src = io.LimitReader(src, fileSizeLimit)
+	}
+
 	_, err = io.Copy(dstF, src)
 	if err != nil {
 		return err
",[True]
GO-2023-1578,hashicorp,go-getter,78e6721a2a76266718dc92c3c03c1571dffdefdc," func (g *GCSGetter) getObject(ctx context.Context, client *storage.Client, dst,
 		return err
 	}
 
-	return copyReader(dst, rc, 0666, g.client.umask())
+	// There is no limit set for the size of an object from GCS
+	return copyReader(dst, rc, 0666, g.client.umask(), 0)
 }
 
 func (g *GCSGetter) parseURL(u *url.URL) (bucket, path, fragment string, err error) {
",[False]
GO-2023-1578,hashicorp,go-getter,78e6721a2a76266718dc92c3c03c1571dffdefdc," func (g *S3Getter) getObject(ctx context.Context, client *s3.S3, dst, bucket, ke
 	}
 	defer body.Close()
 
-	return copyReader(dst, body, 0666, g.client.umask())
+	// There is no limit set for the size of an object from S3
+	return copyReader(dst, body, 0666, g.client.umask(), 0)
 }
 
 func (g *S3Getter) getAWSConfig(region string, url *url.URL, creds *credentials.Credentials) *aws.Config {
",[False]
GO-2021-0061,go-yaml,yaml,bb4e33bf68bf89cad44d386192cbed201f35b241," func (d *decoder) prepare(n *node, out reflect.Value) (newout reflect.Value, unm
 }
 
 func (d *decoder) unmarshal(n *node, out reflect.Value) (good bool) {
+	d.decodeCount++
+	if d.aliasDepth > 0 {
+		d.aliasCount++
+	}
+	if d.aliasCount > 100 && d.decodeCount > 1000 && float64(d.aliasCount)/float64(d.decodeCount) > 0.99 {
+		failf(""document contains excessive aliasing"")
+	}
 	switch n.kind {
 	case documentNode:
 		return d.document(n, out)
",[True]
GO-2021-0061,go-yaml,yaml,bb4e33bf68bf89cad44d386192cbed201f35b241," func (d *decoder) alias(n *node, out reflect.Value) (good bool) {
 		failf(""anchor '%s' value contains itself"", n.value)
 	}
 	d.aliases[n] = true
+	d.aliasDepth++
 	good = d.unmarshal(n.alias, out)
+	d.aliasDepth--
 	delete(d.aliases, n)
 	return good
 }
",[False]
GO-2020-0026,openshift,source-to-image,f5cbcbc5cc6f8cc2f479a7302443bea407a700cb," func New(client dockerpkg.Client, config *api.Config, fs fs.FileSystem, override
 		config.PullAuthentication,
 		fs,
 	)
-	tarHandler := tar.New(fs)
+	tarHandler := tar.NewParanoid(fs)
 	tarHandler.SetExclusionPattern(excludePattern)
 
 	builder := &STI{
",[True]
GO-2020-0026,openshift,source-to-image,f5cbcbc5cc6f8cc2f479a7302443bea407a700cb," func New(fs fs.FileSystem) Tar {
 	}
 }
 
+// NewParanoid creates a new Tar that has restrictions
+// on what it can do while extracting files.
+func NewParanoid(fs fs.FileSystem) Tar {
+	return &stiTar{
+		FileSystem:           fs,
+		exclude:              DefaultExclusionPattern,
+		timeout:              defaultTimeout,
+		disallowOverwrite:    true,
+		disallowOutsidePaths: true,
+		disallowSpecialFiles: true,
+	}
+}
+
 // stiTar is an implementation of the Tar interface
 type stiTar struct {
 	fs.FileSystem
-	timeout          time.Duration
-	exclude          *regexp.Regexp
-	includeDirInPath bool
+	timeout              time.Duration
+	exclude              *regexp.Regexp
+	includeDirInPath     bool
+	disallowOverwrite    bool
+	disallowOutsidePaths bool
+	disallowSpecialFiles bool
 }
 
 // SetExclusionPattern sets the exclusion pattern for tar creation.  The
",[False]
GO-2020-0026,openshift,source-to-image,f5cbcbc5cc6f8cc2f479a7302443bea407a700cb," func (t *stiTar) ExtractTarStreamFromTarReader(dir string, tarReader Reader, log
 				glog.Errorf(""Error reading next tar header: %v"", err)
 				return err
 			}
+
+			if t.disallowSpecialFiles {
+				switch header.Typeflag {
+				case tar.TypeReg, tar.TypeRegA, tar.TypeLink, tar.TypeSymlink, tar.TypeDir, tar.TypeGNUSparse:
+				default:
+					glog.Warningf(""Skipping special file %s, type: %v"", header.Name, header.Typeflag)
+					continue
+				}
+			}
+
+			p := header.Name
+			if t.disallowOutsidePaths {
+				p = filepath.Clean(filepath.Join(dir, p))
+				if !strings.HasPrefix(p, dir) {
+					glog.Warningf(""Skipping relative path file in tar: %s"", header.Name)
+					continue
+				}
+			}
+
 			if header.FileInfo().IsDir() {
-				dirPath := filepath.Join(dir, header.Name)
+				dirPath := filepath.Join(dir, filepath.Clean(header.Name))
 				glog.V(3).Infof(""Creating directory %s"", dirPath)
 				if err = os.MkdirAll(dirPath, 0700); err != nil {
 					glog.Errorf(""Error creating dir %q: %v"", dirPath, err)
",[True]
GO-2020-0026,openshift,source-to-image,f5cbcbc5cc6f8cc2f479a7302443bea407a700cb," func (t *stiTar) ExtractTarStreamFromTarReader(dir string, tarReader Reader, log
 				t.Chmod(dirPath, header.FileInfo().Mode())
 			} else {
 				fileDir := filepath.Dir(header.Name)
-				dirPath := filepath.Join(dir, fileDir)
+				dirPath := filepath.Join(dir, filepath.Clean(fileDir))
 				glog.V(3).Infof(""Creating directory %s"", dirPath)
 				if err = os.MkdirAll(dirPath, 0700); err != nil {
 					glog.Errorf(""Error creating dir %q: %v"", dirPath, err)
",[True]
GO-2020-0026,openshift,source-to-image,f5cbcbc5cc6f8cc2f479a7302443bea407a700cb," func (t *stiTar) extractLink(dir string, header *tar.Header, tarReader io.Reader
 	dest := filepath.Join(dir, header.Name)
 	source := header.Linkname
 
+	if t.disallowOutsidePaths {
+		target := filepath.Clean(filepath.Join(dest, "".."", source))
+		if !strings.HasPrefix(target, dir) {
+			glog.Warningf(""Skipping symlink that points to relative path: %s"", header.Linkname)
+			return nil
+		}
+	}
+
+	if t.disallowOverwrite {
+		if _, err := os.Stat(dest); !os.IsNotExist(err) {
+			glog.Warningf(""Refusing to overwrite existing file: %s"", dest)
+			return nil
+		}
+	}
+
 	glog.V(3).Infof(""Creating symbolic link from %q to %q"", dest, source)
 
 	// TODO: set mtime for symlink (unfortunately we can't use os.Chtimes() and probably should use syscall)
",[True]
GO-2020-0026,openshift,source-to-image,f5cbcbc5cc6f8cc2f479a7302443bea407a700cb," func (t *stiTar) extractLink(dir string, header *tar.Header, tarReader io.Reader
 
 func (t *stiTar) extractFile(dir string, header *tar.Header, tarReader io.Reader) error {
 	path := filepath.Join(dir, header.Name)
+	if t.disallowOverwrite {
+		if _, err := os.Stat(path); !os.IsNotExist(err) {
+			glog.Warningf(""Refusing to overwrite existing file: %s"", path)
+			return nil
+		}
+	}
+
 	glog.V(3).Infof(""Creating %s"", path)
 
 	file, err := os.Create(path)
",[False]
GO-2023-1535,pion,dtls,7a14903448b70069fd9e02adf210ca23083c56d2," func (m *MessageServerHello) Unmarshal(data []byte) error {
 	m.SessionID = append([]byte{}, data[currOffset:currOffset+n]...)
 	currOffset += len(m.SessionID)
 
+	if len(data) < currOffset+2 {
+		return errBufferTooSmall
+	}
 	m.CipherSuiteID = new(uint16)
 	*m.CipherSuiteID = binary.BigEndian.Uint16(data[currOffset:])
 	currOffset += 2
 
-	if len(data) < currOffset {
+	if len(data) <= currOffset {
 		return errBufferTooSmall
 	}
 	if compressionMethod, ok := protocol.CompressionMethods()[protocol.CompressionMethodID(data[currOffset])]; ok {
",[True]
GO-2020-0004,nanobox-io,golang-nanoauth,063a3fb69896acf985759f0fe3851f15973993f3," func init() {
 
 // ServeHTTP is to implement the http.Handler interface. Also let clients know
 // when I have no matching route listeners
-func (self Auth) ServeHTTP(rw http.ResponseWriter, req *http.Request) {
+func (self *Auth) ServeHTTP(rw http.ResponseWriter, req *http.Request) {
 	reqPath := req.URL.Path
 	skipOnce := false
 
",[True]
GO-2020-0004,nanobox-io,golang-nanoauth,063a3fb69896acf985759f0fe3851f15973993f3," func (self Auth) ServeHTTP(rw http.ResponseWriter, req *http.Request) {
 		skipOnce = true
 	}
 
-	if !skipOnce && check {
+	if !skipOnce {
 		auth := """"
 		if auth = req.Header.Get(self.Header); auth == """" {
 			// check form value (case sensitive) if header not set
 			auth = req.FormValue(self.Header)
 		}
 
-		if auth != self.Token {
+		if subtle.ConstantTimeCompare([]byte(auth), []byte(self.Token)) == 0 {
 			rw.WriteHeader(http.StatusUnauthorized)
 			return
 		}
",[True]
GO-2020-0004,nanobox-io,golang-nanoauth,063a3fb69896acf985759f0fe3851f15973993f3," func (self Auth) ServeHTTP(rw http.ResponseWriter, req *http.Request) {
 
 // ListenAndServeTLS starts a TLS listener and handles serving https
 func (self *Auth) ListenAndServeTLS(addr, token string, h http.Handler, excludedPaths ...string) error {
+	if token == """" {
+		return errors.New(""nanoauth: token missing"")
+	}
 	config := &tls.Config{
 		Certificates: []tls.Certificate{*self.Certificate},
 	}
",[True]
GO-2020-0004,nanobox-io,golang-nanoauth,063a3fb69896acf985759f0fe3851f15973993f3," func (self *Auth) ListenAndServeTLS(addr, token string, h http.Handler, excluded
 // ListenAndServe starts a normal tcp listener and handles serving http while
 // still validating the auth token.
 func (self *Auth) ListenAndServe(addr, token string, h http.Handler, excludedPaths ...string) error {
+	if token == """" {
+		return errors.New(""nanoauth: token missing"")
+	}
 	httpListener, err := net.Listen(""tcp"", addr)
 	if err != nil {
 		return err
 	}
 
-	if token == """" {
-		check = false
-	}
 	self.ExcludedPaths = excludedPaths
 	self.Token = token
 
",[True]
GO-2020-0004,nanobox-io,golang-nanoauth,063a3fb69896acf985759f0fe3851f15973993f3," func (self *Auth) ListenAndServeTLS(addr, token string, h http.Handler, excluded
 		return err
 	}
 
-	if token == """" {
-		check = false
-	}
 	self.ExcludedPaths = excludedPaths
 	self.Token = token
 
",[True]
GO-2021-0108,gofiber,fiber,f698b5d5066cfe594102ae252cd58a1fe57cf56f," func (ctx *Ctx) Attachment(filename ...string) {
 	if len(filename) > 0 {
 		fname := filepath.Base(filename[0])
 		ctx.Type(filepath.Ext(fname))
-		ctx.Set(HeaderContentDisposition, `attachment; filename=""`+fname+`""`)
+		ctx.Set(HeaderContentDisposition, `attachment; filename=""`+url.QueryEscape(fname)+`""`)
 		return
 	}
 	ctx.Set(HeaderContentDisposition, ""attachment"")
",[True]
GO-2023-1595,FiloSottile,nistec,c58aa1223ccf3943513e1e661cebce95af137244," func p256PointDoubleAsm(res, in *P256Point)
 // Montgomery domain (with R 2²⁵⁶) as four uint64 limbs in little-endian order.
 type p256OrdElement [4]uint64
 
+// p256OrdReduce ensures s is in the range [0, ord(G)-1].
+func p256OrdReduce(s *p256OrdElement) {
+	// Since 2 * ord(G) > 2²⁵⁶, we can just conditionally subtract ord(G),
+	// keeping the result if it doesn't underflow.
+	t0, b := bits.Sub64(s[0], 0xf3b9cac2fc632551, 0)
+	t1, b := bits.Sub64(s[1], 0xbce6faada7179e84, b)
+	t2, b := bits.Sub64(s[2], 0xffffffffffffffff, b)
+	t3, b := bits.Sub64(s[3], 0xffffffff00000000, b)
+	tMask := b - 1 // zero if subtraction underflowed
+	s[0] ^= (t0 ^ s[0]) & tMask
+	s[1] ^= (t1 ^ s[1]) & tMask
+	s[2] ^= (t2 ^ s[2]) & tMask
+	s[3] ^= (t3 ^ s[3]) & tMask
+}
+
 // Add sets q = p1 + p2, and returns q. The points may overlap.
 func (q *P256Point) Add(r1, r2 *P256Point) *P256Point {
 	var sum, double P256Point
",[False]
GO-2023-1595,FiloSottile,nistec,c58aa1223ccf3943513e1e661cebce95af137244," func (r *P256Point) ScalarBaseMult(scalar []byte) (*P256Point, error) {
 	}
 	scalarReversed := new(p256OrdElement)
 	p256OrdBigToLittle(scalarReversed, (*[32]byte)(scalar))
+	p256OrdReduce(scalarReversed)
 
 	r.p256BaseMult(scalarReversed)
 	return r, nil
",[True]
GO-2023-1595,FiloSottile,nistec,c58aa1223ccf3943513e1e661cebce95af137244," func (r *P256Point) ScalarMult(q *P256Point, scalar []byte) (*P256Point, error)
 	}
 	scalarReversed := new(p256OrdElement)
 	p256OrdBigToLittle(scalarReversed, (*[32]byte)(scalar))
+	p256OrdReduce(scalarReversed)
 
 	r.Set(q).p256ScalarMult(scalarReversed)
 	return r, nil
",[True]
GO-2023-1595,FiloSottile,nistec,c58aa1223ccf3943513e1e661cebce95af137244," func p256OrdInverse(k []byte) ([]byte, error) {
 
 	x := new(p256OrdElement)
 	p256OrdBigToLittle(x, (*[32]byte)(k))
+	p256OrdReduce(x)
 
 	// Inversion is implemented as exponentiation by n - 2, per Fermat's little theorem.
 	//
",[True]
GO-2021-0102,cloudfoundry,gorouter,b1b5c44e050f73b399b379ca63a42a2c5780a83f," func (gcm *AesGCM) Encrypt(plainText []byte) (cipherText, nonce []byte, err erro
 }
 
 func (gcm *AesGCM) Decrypt(cipherText, nonce []byte) ([]byte, error) {
+	if len(nonce) != gcm.NonceSize() {
+		return nil, errors.New(""incorrect nonce length"")
+	}
+
 	plainText, err := gcm.Open(nil, nonce, cipherText, []byte{})
 	if err != nil {
 		return nil, err
",[True]
GO-2022-1040,helm,helm,6ce9ba60b73013857e2e7c73d3f86ed70bc1ac9a," func newRepoUpdateCmd(out io.Writer) *cobra.Command {
 
 func (o *repoUpdateOptions) run(out io.Writer) error {
 	f, err := repo.LoadFile(o.repoFile)
-	if isNotExist(err) || len(f.Repositories) == 0 {
+	switch {
+	case isNotExist(err):
+		return errNoRepositories
+	case err != nil:
+		return errors.Wrapf(err, ""failed loading file: %s"", o.repoFile)
+	case len(f.Repositories) == 0:
 		return errNoRepositories
 	}
+
 	var repos []*repo.ChartRepository
 	for _, cfg := range f.Repositories {
 		r, err := repo.NewChartRepository(cfg, getter.All(settings))
",[False]
GO-2022-1040,helm,helm,6ce9ba60b73013857e2e7c73d3f86ed70bc1ac9a," func (o *searchRepoOptions) setupSearchedVersion() {
 }
 
 func (o *searchRepoOptions) applyConstraint(res []*search.Result) ([]*search.Result, error) {
-	if len(o.version) == 0 {
+	if o.version == """" {
 		return res, nil
 	}
 
",[False]
GO-2022-1040,helm,helm,6ce9ba60b73013857e2e7c73d3f86ed70bc1ac9a," func (o *searchRepoOptions) applyConstraint(res []*search.Result) ([]*search.Res
 
 	data := res[:0]
 	foundNames := map[string]bool{}
-	appendSearchResults := func(res *search.Result) {
-		data = append(data, res)
-		if !o.versions {
-			foundNames[res.Name] = true // If user hasn't requested all versions, only show the latest that matches
-		}
-	}
 	for _, r := range res {
-		if _, found := foundNames[r.Name]; found {
+		// if not returning all versions and already have found a result,
+		// you're done!
+		if !o.versions && foundNames[r.Name] {
 			continue
 		}
 		v, err := semver.NewVersion(r.Chart.Version)
-
 		if err != nil {
-			// If the current version number check appears ErrSegmentStartsZero or ErrInvalidPrerelease error and not devel mode, ignore
-			if (err == semver.ErrSegmentStartsZero || err == semver.ErrInvalidPrerelease) && !o.devel {
-				continue
-			}
-			appendSearchResults(r)
-		} else if constraint.Check(v) {
-			appendSearchResults(r)
+			continue
+		}
+		if constraint.Check(v) {
+			data = append(data, r)
+			foundNames[r.Name] = true
 		}
 	}
 
",[False]
GO-2022-1040,helm,helm,6ce9ba60b73013857e2e7c73d3f86ed70bc1ac9a," func (o *searchRepoOptions) buildIndex() (*search.Index, error) {
 		ind, err := repo.LoadIndexFile(f)
 		if err != nil {
 			warning(""Repo %q is corrupt or missing. Try 'helm repo update'."", n)
+			warning(""%s"", err)
 			continue
 		}
 
",[False]
GO-2022-1040,helm,helm,6ce9ba60b73013857e2e7c73d3f86ed70bc1ac9a," type Dependency struct {
 	Alias string `json:""alias,omitempty""`
 }
 
+// Validate checks for common problems with the dependency datastructure in
+// the chart. This check must be done at load time before the dependency's charts are
+// loaded.
+func (d *Dependency) Validate() error {
+	d.Name = sanitizeString(d.Name)
+	d.Version = sanitizeString(d.Version)
+	d.Repository = sanitizeString(d.Repository)
+	d.Condition = sanitizeString(d.Condition)
+	for i := range d.Tags {
+		d.Tags[i] = sanitizeString(d.Tags[i])
+	}
+	if d.Alias != """" && !aliasNameFormat.MatchString(d.Alias) {
+		return ValidationErrorf(""dependency %q has disallowed characters in the alias"", d.Name)
+	}
+	return nil
+}
+
 // Lock is a lock file for dependencies.
 //
 // It represents the state that the dependencies should be in.
",[False]
GO-2022-1040,helm,helm,6ce9ba60b73013857e2e7c73d3f86ed70bc1ac9a," type Maintainer struct {
 	URL string `json:""url,omitempty""`
 }
 
+// Validate checks valid data and sanitizes string characters.
+func (m *Maintainer) Validate() error {
+	m.Name = sanitizeString(m.Name)
+	m.Email = sanitizeString(m.Email)
+	m.URL = sanitizeString(m.URL)
+	return nil
+}
+
 // Metadata for a Chart file. This models the structure of a Chart.yaml file.
 type Metadata struct {
-	// The name of the chart
+	// The name of the chart. Required.
 	Name string `json:""name,omitempty""`
 	// The URL to a relevant project page, git repo, or contact person
 	Home string `json:""home,omitempty""`
 	// Source is the URL to the source code of this chart
 	Sources []string `json:""sources,omitempty""`
-	// A SemVer 2 conformant version string of the chart
+	// A SemVer 2 conformant version string of the chart. Required.
 	Version string `json:""version,omitempty""`
 	// A one-sentence description of the chart
 	Description string `json:""description,omitempty""`
",[False]
GO-2022-1040,helm,helm,6ce9ba60b73013857e2e7c73d3f86ed70bc1ac9a," type Metadata struct {
 	Type string `json:""type,omitempty""`
 }
 
-// Validate checks the metadata for known issues, returning an error if metadata is not correct
+// Validate checks the metadata for known issues and sanitizes string
+// characters.
 func (md *Metadata) Validate() error {
 	if md == nil {
 		return ValidationError(""chart.metadata is required"")
 	}
+
+	md.Name = sanitizeString(md.Name)
+	md.Description = sanitizeString(md.Description)
+	md.Home = sanitizeString(md.Home)
+	md.Icon = sanitizeString(md.Icon)
+	md.Condition = sanitizeString(md.Condition)
+	md.Tags = sanitizeString(md.Tags)
+	md.AppVersion = sanitizeString(md.AppVersion)
+	md.KubeVersion = sanitizeString(md.KubeVersion)
+	for i := range md.Sources {
+		md.Sources[i] = sanitizeString(md.Sources[i])
+	}
+	for i := range md.Keywords {
+		md.Keywords[i] = sanitizeString(md.Keywords[i])
+	}
+
 	if md.APIVersion == """" {
 		return ValidationError(""chart.metadata.apiVersion is required"")
 	}
",[True]
GO-2022-1040,helm,helm,6ce9ba60b73013857e2e7c73d3f86ed70bc1ac9a," func (md *Metadata) Validate() error {
 	if md.Version == """" {
 		return ValidationError(""chart.metadata.version is required"")
 	}
+	if !isValidSemver(md.Version) {
+		return ValidationErrorf(""chart.metadata.version %q is invalid"", md.Version)
+	}
 	if !isValidChartType(md.Type) {
 		return ValidationError(""chart.metadata.type must be application or library"")
 	}
 
+	for _, m := range md.Maintainers {
+		if err := m.Validate(); err != nil {
+			return err
+		}
+	}
+
 	// Aliases need to be validated here to make sure that the alias name does
 	// not contain any illegal characters.
 	for _, dependency := range md.Dependencies {
-		if err := validateDependency(dependency); err != nil {
+		if err := dependency.Validate(); err != nil {
 			return err
 		}
 	}
-
-	// TODO validate valid semver here?
 	return nil
 }
 
",[True]
GO-2022-1040,helm,helm,6ce9ba60b73013857e2e7c73d3f86ed70bc1ac9a," func NewChartRepository(cfg *Entry, getters getter.Providers) (*ChartRepository,
 // Load loads a directory of charts as if it were a repository.
 //
 // It requires the presence of an index.yaml file in the directory.
+//
+// Deprecated: remove in Helm 4.
 func (r *ChartRepository) Load() error {
 	dirInfo, err := os.Stat(r.Config.Name)
 	if err != nil {
",[False]
GO-2022-1040,helm,helm,6ce9ba60b73013857e2e7c73d3f86ed70bc1ac9a," func (r *ChartRepository) Load() error {
 			if strings.Contains(f.Name(), ""-index.yaml"") {
 				i, err := LoadIndexFile(path)
 				if err != nil {
-					return nil
+					return err
 				}
 				r.IndexFile = i
 			} else if strings.HasSuffix(f.Name(), "".tgz"") {
",[False]
GO-2022-1040,helm,helm,6ce9ba60b73013857e2e7c73d3f86ed70bc1ac9a," func (r *ChartRepository) DownloadIndexFile() (string, error) {
 		return """", err
 	}
 
-	indexFile, err := loadIndex(index)
+	indexFile, err := loadIndex(index, r.Config.URL)
 	if err != nil {
 		return """", err
 	}
",[False]
GO-2022-1040,helm,helm,6ce9ba60b73013857e2e7c73d3f86ed70bc1ac9a," func (r *ChartRepository) generateIndex() error {
 		}
 
 		if !r.IndexFile.Has(ch.Name(), ch.Metadata.Version) {
-			r.IndexFile.Add(ch.Metadata, path, r.Config.URL, digest)
+			if err := r.IndexFile.MustAdd(ch.Metadata, path, r.Config.URL, digest); err != nil {
+				return errors.Wrapf(err, ""failed adding to %s to index"", path)
+			}
 		}
 		// TODO: If a chart exists, but has a different Digest, should we error?
 	}
",[False]
GO-2023-2098,Consensys,gnark,59a4087261a6c73f13e80d695c17b398c3d0934f," func (builder *builder) IsZero(i1 frontend.Variable) frontend.Variable {
 // Cmp returns 1 if i1>i2, 0 if i1=i2, -1 if i1<i2
 func (builder *builder) Cmp(i1, i2 frontend.Variable) frontend.Variable {
 
-	vars, _ := builder.toVariables(i1, i2)
-	bi1 := builder.ToBinary(vars[0], builder.cs.FieldBitLen())
-	bi2 := builder.ToBinary(vars[1], builder.cs.FieldBitLen())
+	nbBits := builder.cs.FieldBitLen()
+	// in AssertIsLessOrEq we omitted comparison against modulus for the left
+	// side as if `a+r<b` implies `a<b`, then here we compute the inequality
+	// directly.
+	bi1 := bits.ToBinary(builder, i1, bits.WithNbDigits(nbBits))
+	bi2 := bits.ToBinary(builder, i2, bits.WithNbDigits(nbBits))
 
 	res := builder.cstZero()
 
",[True]
GO-2023-2098,Consensys,gnark,59a4087261a6c73f13e80d695c17b398c3d0934f," func (builder *builder) AssertIsLessOrEqual(v frontend.Variable, bound frontend.
 		}
 	}
 
+	nbBits := builder.cs.FieldBitLen()
+	vBits := bits.ToBinary(builder, v, bits.WithNbDigits(nbBits), bits.WithUnconstrainedOutputs())
+
 	// bound is constant
 	if bConst {
-		vv := builder.toVariable(v)
-		builder.mustBeLessOrEqCst(vv, builder.cs.ToBigInt(cb))
+		builder.MustBeLessOrEqCst(vBits, builder.cs.ToBigInt(cb), v)
 		return
 	}
 
",[True]
GO-2023-2098,Consensys,gnark,59a4087261a6c73f13e80d695c17b398c3d0934f," func (builder *builder) mustBeLessOrEqVar(a, bound frontend.Variable) {
 
 	nbBits := builder.cs.FieldBitLen()
 
-	aBits := bits.ToBinary(builder, a, bits.WithNbDigits(nbBits), bits.WithUnconstrainedOutputs())
-	boundBits := builder.ToBinary(bound, nbBits)
+	aBits := bits.ToBinary(builder, a, bits.WithNbDigits(nbBits), bits.WithUnconstrainedOutputs(), bits.OmitModulusCheck())
+	boundBits := bits.ToBinary(builder, bound, bits.WithNbDigits(nbBits))
 
 	// constraint added
 	added := make([]int, 0, nbBits)
",[True]
GO-2023-2098,Consensys,gnark,59a4087261a6c73f13e80d695c17b398c3d0934f," func (builder *builder) IsZero(i1 frontend.Variable) frontend.Variable {
 // Cmp returns 1 if i1>i2, 0 if i1=i2, -1 if i1<i2
 func (builder *builder) Cmp(i1, i2 frontend.Variable) frontend.Variable {
 
-	bi1 := builder.ToBinary(i1, builder.cs.FieldBitLen())
-	bi2 := builder.ToBinary(i2, builder.cs.FieldBitLen())
+	nbBits := builder.cs.FieldBitLen()
+	// in AssertIsLessOrEq we omitted comparison against modulus for the left
+	// side as if `a+r<b` implies `a<b`, then here we compute the inequality
+	// directly.
+	bi1 := bits.ToBinary(builder, i1, bits.WithNbDigits(nbBits))
+	bi2 := bits.ToBinary(builder, i2, bits.WithNbDigits(nbBits))
 
 	var res frontend.Variable
 	res = 0
",[True]
GO-2023-2098,Consensys,gnark,59a4087261a6c73f13e80d695c17b398c3d0934f," func (builder *builder) AssertIsBoolean(i1 frontend.Variable) {
 
 // AssertIsLessOrEqual fails if  v > bound
 func (builder *builder) AssertIsLessOrEqual(v frontend.Variable, bound frontend.Variable) {
-	switch b := bound.(type) {
-	case expr.Term:
+	cv, vConst := builder.constantValue(v)
+	cb, bConst := builder.constantValue(bound)
+
+	// both inputs are constants
+	if vConst && bConst {
+		bv, bb := builder.cs.ToBigInt(cv), builder.cs.ToBigInt(cb)
+		if bv.Cmp(bb) == 1 {
+			panic(fmt.Sprintf(""AssertIsLessOrEqual: %s > %s"", bv.String(), bb.String()))
+		}
+	}
+
+	nbBits := builder.cs.FieldBitLen()
+	vBits := bits.ToBinary(builder, v, bits.WithNbDigits(nbBits), bits.WithUnconstrainedOutputs())
+
+	// bound is constant
+	if bConst {
+		builder.MustBeLessOrEqCst(vBits, builder.cs.ToBigInt(cb), v)
+		return
+	}
+
+	if b, ok := bound.(expr.Term); ok {
 		builder.mustBeLessOrEqVar(v, b)
-	default:
-		builder.mustBeLessOrEqCst(v, utils.FromInterface(b))
+	} else {
+		panic(fmt.Sprintf(""expected bound type expr.Term, got %T"", bound))
 	}
 }
 
",[True]
GO-2023-2098,Consensys,gnark,59a4087261a6c73f13e80d695c17b398c3d0934f," func (builder *builder) mustBeLessOrEqVar(a frontend.Variable, bound expr.Term)
 
 	nbBits := builder.cs.FieldBitLen()
 
-	aBits := bits.ToBinary(builder, a, bits.WithNbDigits(nbBits), bits.WithUnconstrainedOutputs())
-	boundBits := builder.ToBinary(bound, nbBits)
+	aBits := bits.ToBinary(builder, a, bits.WithNbDigits(nbBits), bits.WithUnconstrainedOutputs(), bits.OmitModulusCheck())
+	boundBits := bits.ToBinary(builder, bound, bits.WithNbDigits(nbBits)) // enforces range check against modulus
 
 	p := make([]frontend.Variable, nbBits+1)
 	p[nbBits] = 1
",[True]
GO-2023-2098,Consensys,gnark,59a4087261a6c73f13e80d695c17b398c3d0934f," func (circuit *recursiveHint) Define(api frontend.API) error {
 	// api.ToBinary calls another hint (bits.NBits) with linearExpression as input
 	// however, when the solver will resolve bits[...] it will need to detect w1 as a dependency
 	// in order to compute the correct linearExpression value
-	bits := api.ToBinary(linearExpression, 10)
+	bits := api.ToBinary(linearExpression, 6)
 
 	a := api.FromBinary(bits...)
 
",[True]
GO-2023-2098,Consensys,gnark,59a4087261a6c73f13e80d695c17b398c3d0934f," type baseConversionConfig struct {
 	NbDigits             int
 	UnconstrainedOutputs bool
 	UnconstrainedInputs  bool
+
+	omitModulusCheck bool
 }
 
 // BaseConversionOption configures the behaviour of scalar decomposition.
 type BaseConversionOption func(opt *baseConversionConfig) error
 
-// WithNbDigits sets the resulting number of digits (nbDigits) to be used in the base conversion.
-// nbDigits must be > 0. If nbDigits is lower than the length of full decomposition and
-// WithUnconstrainedOutputs option is not used, then the conversion functions will generate an
-// unsatisfiable constraint. If WithNbDigits option is not set, then the full decomposition is
-// returned.
+// WithNbDigits sets the resulting number of digits (nbDigits) to be used in the
+// base conversion.
+//
+// nbDigits must be > 0. If nbDigits is lower than the length of full
+// decomposition and [WithUnconstrainedOutputs] option is not used, then the
+// conversion functions will generate an unsatisfiable constraint.
+//
+// If nbDigits is larger than the bitlength of the modulus, then the returned
+// slice has length nbDigits with excess bits being 0.
+//
+// If WithNbDigits option is not set, then the full decomposition is returned.
 func WithNbDigits(nbDigits int) BaseConversionOption {
 	return func(opt *baseConversionConfig) error {
 		if nbDigits <= 0 {
",[True]
GO-2023-2098,Consensys,gnark,59a4087261a6c73f13e80d695c17b398c3d0934f," func WithUnconstrainedInputs() BaseConversionOption {
 		return nil
 	}
 }
+
+// OmitModulusCheck omits the comparison against native field modulus in
+// case the bitlength of the decomposed value (if [WithNbDigits] not set or set
+// to bitlength of the native modulus) eqals bitlength of the modulus.
+//
+// The check is otherwise required as there are possibly multiple correct binary
+// decompositions. For example, when decomposing small a the decomposition could
+// return the slices for both a or a+r, where r is the native modulus and the
+// enforced constraints are correct due to implicit modular reduction by r.
+//
+// This option can be used in case the decomposed output is manually checked to
+// be unique or if uniqueness is not required.
+func OmitModulusCheck() BaseConversionOption {
+	return func(opt *baseConversionConfig) error {
+		opt.omitModulusCheck = true
+		return nil
+	}
+}
",[False]
GO-2023-2098,Consensys,gnark,59a4087261a6c73f13e80d695c17b398c3d0934f," func toBinary(api frontend.API, v frontend.Variable, opts ...BaseConversionOptio
 		}
 	}
 
+	// by default we also check that the value to be decomposed is less than the
+	// modulus. However, we can omit the check when the number of bits we want
+	// to decompose to is less than the modulus or it was strictly requested.
+	omitReducednessCheck := cfg.omitModulusCheck || cfg.NbDigits < api.Compiler().FieldBitLen()
+
 	// when cfg.NbDigits == 1, v itself has to be a binary digit. This if clause
 	// saves one constraint.
 	if cfg.NbDigits == 1 {
 		api.AssertIsBoolean(v)
 		return []frontend.Variable{v}
 	}
+	// if we decompose into more bits than fieldbitlen then the rest would be
+	// always zeros. Reduce the always-zeros to have fewer edge-cases elsewhere.
+	var paddingBits int
+	if cfg.NbDigits > api.Compiler().FieldBitLen() {
+		paddingBits = cfg.NbDigits - api.Compiler().FieldBitLen()
+		cfg.NbDigits = api.Compiler().FieldBitLen()
+	}
 
 	c := big.NewInt(1)
 
",[False]
GO-2023-2098,Consensys,gnark,59a4087261a6c73f13e80d695c17b398c3d0934f," func toBinary(api frontend.API, v frontend.Variable, opts ...BaseConversionOptio
 
 	// record the constraint Σ (2**i * b[i]) == a
 	api.AssertIsEqual(Σbi, v)
+	if !omitReducednessCheck {
+		if cmper, ok := api.Compiler().(bitsComparatorConstant); ok {
+			bound := new(big.Int).Sub(api.Compiler().Field(), big.NewInt(1))
+			cmper.MustBeLessOrEqCst(bits, api.Compiler().Field(), bound)
+		} else {
+			panic(""builder does not expose comparison to constant"")
+		}
+	}
+
+	// restore the zero bits which exceed the field bit-length when requested by
+	// setting WithNbDigits larger than the field bitlength.
+	bits = append(bits, make([]frontend.Variable, paddingBits)...)
+	for i := cfg.NbDigits; i < len(bits); i++ {
+		bits[i] = 0 // frontend.Variable is interface{}, we get nil pointer err if trying to access it.
+	}
 
 	return bits
 }
",[False]
GO-2021-0060,russellhaering,gosaml2,42606dafba60c58c458f14f75c4c230459672ab9," func maybeDeflate(data []byte, decoder func([]byte) error) error {
 // parseResponse is a helper function that was refactored out so that the XML parsing behavior can be isolated and unit tested
 func parseResponse(xml []byte) (*etree.Document, *etree.Element, error) {
 	var doc *etree.Document
+	var rawXML []byte
 
 	err := maybeDeflate(xml, func(xml []byte) error {
 		doc = etree.NewDocument()
+		rawXML = xml
 		return doc.ReadFromBytes(xml)
 	})
 	if err != nil {
",[True]
GO-2021-0060,russellhaering,gosaml2,42606dafba60c58c458f14f75c4c230459672ab9," func parseResponse(xml []byte) (*etree.Document, *etree.Element, error) {
 		return nil, nil, fmt.Errorf(""unable to parse response"")
 	}
 
+	// Examine the response for attempts to exploit weaknesses in Go's encoding/xml
+	err = rtvalidator.Validate(bytes.NewReader(rawXML))
+	if err != nil {
+		return nil, nil, err
+	}
+
 	return doc, el, nil
 }
 
",[True]
GO-2022-0345,containers,buildah,a468ce0ffd347035d53ee0e26c205ef604097fb0," func RunUsingChroot(spec *specs.Spec, bundlePath, homeDir string, stdin io.Reade
 	cmd := unshare.Command(runUsingChrootCommand)
 	cmd.Stdin, cmd.Stdout, cmd.Stderr = stdin, stdout, stderr
 	cmd.Dir = ""/""
-	cmd.Env = append([]string{fmt.Sprintf(""LOGLEVEL=%d"", logrus.GetLevel())}, os.Environ()...)
+	cmd.Env = []string{fmt.Sprintf(""LOGLEVEL=%d"", logrus.GetLevel())}
 
 	logrus.Debugf(""Running %#v in %#v"", cmd.Cmd, cmd)
 	confwg.Add(1)
",[True]
GO-2022-0345,containers,buildah,a468ce0ffd347035d53ee0e26c205ef604097fb0," func runUsingChrootMain() {
 		os.Exit(1)
 	}
 
-	if options.Spec == nil {
+	if options.Spec == nil || options.Spec.Process == nil {
 		fmt.Fprintf(os.Stderr, ""invalid options spec in runUsingChrootMain\n"")
 		os.Exit(1)
 	}
",[False]
GO-2022-0345,containers,buildah,a468ce0ffd347035d53ee0e26c205ef604097fb0," func runUsingChroot(spec *specs.Spec, bundlePath string, ctty *os.File, stdin io
 	cmd := unshare.Command(append([]string{runUsingChrootExecCommand}, spec.Process.Args...)...)
 	cmd.Stdin, cmd.Stdout, cmd.Stderr = stdin, stdout, stderr
 	cmd.Dir = ""/""
-	cmd.Env = append([]string{fmt.Sprintf(""LOGLEVEL=%d"", logrus.GetLevel())}, os.Environ()...)
+	cmd.Env = []string{fmt.Sprintf(""LOGLEVEL=%d"", logrus.GetLevel())}
 	cmd.UnshareFlags = syscall.CLONE_NEWUTS | syscall.CLONE_NEWNS
 	requestedUserNS := false
 	for _, ns := range spec.Linux.Namespaces {
",[False]
GO-2022-0345,containers,buildah,a468ce0ffd347035d53ee0e26c205ef604097fb0," func runUsingChrootExecMain() {
 	// Set the hostname.  We're already in a distinct UTS namespace and are admins in the user
 	// namespace which created it, so we shouldn't get a permissions error, but seccomp policy
 	// might deny our attempt to call sethostname() anyway, so log a debug message for that.
-	if options.Spec == nil {
+	if options.Spec == nil || options.Spec.Process == nil {
 		fmt.Fprintf(os.Stderr, ""invalid options spec passed in\n"")
 		os.Exit(1)
 	}
",[False]
GO-2022-0345,containers,buildah,a468ce0ffd347035d53ee0e26c205ef604097fb0," func logNamespaceDiagnostics(spec *specs.Spec) {
 			}
 		case specs.UserNamespace:
 			if ns.Path != """" {
-				logrus.Debugf(""unable to join user namespace %q, creating a new one"", ns.Path)
+				logrus.Debugf(""unable to join user namespace, sorry about that"")
 			}
-			sawUserNS = true
 		case specs.UTSNamespace:
 			if ns.Path != """" {
 				logrus.Debugf(""unable to join UTS namespace %q, creating a new one"", ns.Path)
",[False]
GO-2022-0345,containers,buildah,a468ce0ffd347035d53ee0e26c205ef604097fb0," func runUsingChrootExecMain() {
 // Output debug messages when that differs from what we're being asked to do.
 func logNamespaceDiagnostics(spec *specs.Spec) {
 	sawMountNS := false
-	sawUserNS := false
 	sawUTSNS := false
 	for _, ns := range spec.Linux.Namespaces {
 		switch ns.Type {
",[False]
GO-2022-0345,containers,buildah,a468ce0ffd347035d53ee0e26c205ef604097fb0," func logNamespaceDiagnostics(spec *specs.Spec) {
 	if !sawMountNS {
 		logrus.Debugf(""mount namespace not requested, but creating a new one anyway"")
 	}
-	if !sawUserNS {
-		logrus.Debugf(""user namespace not requested, but creating a new one anyway"")
-	}
 	if !sawUTSNS {
 		logrus.Debugf(""UTS namespace not requested, but creating a new one anyway"")
 	}
",[False]
GO-2021-0052,gin-gonic,gin,5929d521715610c9dd14898ebbe1d188d5de8937," func (c *Context) ClientIP() string {
 
 	if trusted && c.engine.ForwardedByClientIP && c.engine.RemoteIPHeaders != nil {
 		for _, headerName := range c.engine.RemoteIPHeaders {
-			ip, valid := validateHeader(c.requestHeader(headerName))
+			ip, valid := c.engine.validateHeader(c.requestHeader(headerName))
 			if valid {
 				return ip
 			}
",[True]
GO-2021-0052,gin-gonic,gin,5929d521715610c9dd14898ebbe1d188d5de8937," func (c *Context) ClientIP() string {
 	return remoteIP.String()
 }
 
+func (e *Engine) isTrustedProxy(ip net.IP) bool {
+	if e.trustedCIDRs != nil {
+		for _, cidr := range e.trustedCIDRs {
+			if cidr.Contains(ip) {
+				return true
+			}
+		}
+	}
+	return false
+}
+
 // RemoteIP parses the IP from Request.RemoteAddr, normalizes and returns the IP (without the port).
 // It also checks if the remoteIP is a trusted proxy or not.
 // In order to perform this validation, it will see if the IP is contained within at least one of the CIDR blocks
",[False]
GO-2021-0052,gin-gonic,gin,bfc8ca285eb46dad60e037d57c545cd260636711," func New() *Engine {
 		RedirectFixedPath:      false,
 		HandleMethodNotAllowed: false,
 		ForwardedByClientIP:    true,
+		RemoteIPHeaders:        []string{""X-Forwarded-For"", ""X-Real-IP""},
+		TrustedProxies:         []string{""0.0.0.0/0""},
 		AppEngine:              defaultAppEngine,
 		UseRawPath:             false,
 		RemoveExtraSlash:       false,
",[False]
GO-2021-0052,gin-gonic,gin,03e5e05ae089bc989f1ca41841f05504d29e3fd9," func (c *Context) RemoteIP() (net.IP, bool) {
 		return nil, false
 	}
 
-	trustedCIDRs, _ := c.engine.prepareTrustedCIDRs()
-	c.engine.trustedCIDRs = trustedCIDRs
 	if c.engine.trustedCIDRs != nil {
 		for _, cidr := range c.engine.trustedCIDRs {
 			if cidr.Contains(remoteIP) {
",[True]
GO-2022-1175,cortexproject,cortex,03e023d8b012887b31cc268d0d011b01e1e65506," func validateAlertmanagerConfig(cfg interface{}) error {
 			return err
 		}
 
+	case reflect.TypeOf(config.OpsGenieConfig{}):
+		if err := validateOpsGenieConfig(v.Interface().(config.OpsGenieConfig)); err != nil {
+			return err
+		}
+
 	case reflect.TypeOf(commoncfg.TLSConfig{}):
 		if err := validateReceiverTLSConfig(v.Interface().(commoncfg.TLSConfig)); err != nil {
 			return err
",[True]
GO-2021-0097,dhowden,tag,d52dcb253c63a153632bfee5f269dd411dcd8e96," func (t Comm) String() string {
 // Description         <text string according to encoding> $00 (00)
 // Value               <text string according to encoding>
 func readTextWithDescrFrame(b []byte, hasLang bool, encoded bool) (*Comm, error) {
+	if len(b) == 0 {
+		return nil, errors.New(""error decoding tag description text: invalid encoding"")
+	}
 	enc := b[0]
 	b = b[1:]
 
 	c := &Comm{}
 	if hasLang {
 		if len(b) < 3 {
-			return nil, fmt.Errorf(""hasLang set but not enough data for language information"")
+			return nil, errors.New(""hasLang set but not enough data for language information"")
 		}
 		c.Language = string(b[:3])
 		b = b[3:]
 	}
 
 	descTextSplit := dataSplit(b, enc)
-	if len(descTextSplit) < 1 {
-		return nil, fmt.Errorf(""error decoding tag description text: invalid encoding"")
+	if len(descTextSplit) == 0 {
+		return nil, errors.New(""error decoding tag description text: invalid encoding"")
 	}
 
 	desc, err := decodeText(enc, descTextSplit[0])
",[True]
GO-2021-0097,dhowden,tag,a92213460e4838490ce3066ef11dc823cdc1740e," func readPICFrame(b []byte) (*Picture, error) {
 // Description     <text string according to encoding> $00 (00)
 // Picture data    <binary data>
 func readAPICFrame(b []byte) (*Picture, error) {
+	if len(b) == 0 {
+		return nil, errors.New(""error decoding APIC: invalid encoding"")
+	}
 	enc := b[0]
 	mimeDataSplit := bytes.SplitN(b[1:], singleZero, 2)
+	if len(mimeDataSplit) != 2 {
+		return nil, errors.New(""error decoding APIC: invalid encoding"")
+	}
+
 	mimeType := string(mimeDataSplit[0])
 
 	b = mimeDataSplit[1]
",[True]
GO-2021-0097,dhowden,tag,4b595ed4fac79f467594aa92f8953f90f817116e," func (m metadataMP4) readAtomData(r io.ReadSeeker, name string, size uint32, pro
 		// ""data"" + size (4 bytes each)
 		b = b[8:]
 
-		if len(b) < 3 {
-			return fmt.Errorf(""invalid encoding: expected at least %d bytes, for class, got %d"", 3, len(b))
+		if len(b) < 4 {
+			return fmt.Errorf(""invalid encoding: expected at least %d bytes, for class, got %d"", 4, len(b))
 		}
 		class := getInt(b[1:4])
 		var ok bool
",[True]
GO-2021-0097,dhowden,tag,6b18201aa5c5535511802ddfb4e4117686b4866d," func (p Picture) String() string {
 // Description        <textstring> $00 (00)
 // Picture data       <binary data>
 func readPICFrame(b []byte) (*Picture, error) {
+	if len(b) < 5 {
+		return nil, errors.New(""invalid PIC frame"")
+	}
+
 	enc := b[0]
 	ext := string(b[1:4])
 	picType := b[4]
",[True]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (s *ImmuStore) DualProof(sourceTxHdr, targetTxHdr *TxHeader) (proof *DualPr
 	}
 	proof.LinearProof = lproof
 
+	laproof, err := s.LinearAdvanceProof(
+		sourceTxHdr.BlTxID,
+		minUint64(sourceTxHdr.ID, targetTxHdr.BlTxID),
+		targetTxHdr.BlTxID,
+	)
+	if err != nil {
+		return nil, err
+	}
+	proof.LinearAdvanceProof = laproof
+
 	return
 }
 
",[True]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func maxUint64(a, b uint64) uint64 {
 	}
 	return a
 }
+
+func minUint64(a, b uint64) uint64 {
+	if a >= b {
+		return b
+	}
+	return a
+}
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func VerifyDualProof(proof *DualProof, sourceTxID, targetTxID uint64, sourceAlh,
 	}
 
 	if proof.SourceTxHeader.BlTxID > 0 {
-		verfifies := ahtree.VerifyConsistency(
+		verifies := ahtree.VerifyConsistency(
 			proof.ConsistencyProof,
 			proof.SourceTxHeader.BlTxID,
 			proof.TargetTxHeader.BlTxID,
",[True]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func VerifyDualProof(proof *DualProof, sourceTxID, targetTxID uint64, sourceAlh,
 			proof.TargetTxHeader.BlRoot,
 		)
 
-		if !verfifies {
+		if !verifies {
 			return false
 		}
 	}
",[True]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func VerifyDualProof(proof *DualProof, sourceTxID, targetTxID uint64, sourceAlh,
 	}
 
 	if sourceTxID < proof.TargetTxHeader.BlTxID {
-		return VerifyLinearProof(proof.LinearProof, proof.TargetTxHeader.BlTxID, targetTxID, proof.TargetBlTxAlh, targetAlh)
+		verifies := VerifyLinearProof(proof.LinearProof, proof.TargetTxHeader.BlTxID, targetTxID, proof.TargetBlTxAlh, targetAlh)
+		if !verifies {
+			return false
+		}
+
+		// Verify that the part of the linear proof consumed by the new merkle tree is consistent with that Merkle Tree
+		// In this case, this is the whole chain to the SourceTxID from the previous Merkle Tree.
+		// The sourceTxID consistency is already proven using proof.InclusionProof
+		if !VerifyLinearAdvanceProof(
+			proof.LinearAdvanceProof,
+			proof.SourceTxHeader.BlTxID,
+			sourceTxID,
+			sourceAlh,
+			proof.TargetTxHeader.BlRoot,
+			proof.TargetTxHeader.BlTxID,
+		) {
+			return false
+		}
+
+	} else {
+
+		verifies := VerifyLinearProof(proof.LinearProof, sourceTxID, targetTxID, sourceAlh, targetAlh)
+		if !verifies {
+			return false
+		}
+
+		// Verify that the part of the linear proof consumed by the new merkle tree is consistent with that Merkle Tree
+		// In this case, this is the whole linear chain between the old Merkle Tree and the new Merkle Tree. The last entry
+		// in the new Merkle Tree is already proven through the LastInclusionProof, the remaining part of the liner proof
+		// that goes outside of the target Merkle Tree will be validated in future DualProof validations
+		if !VerifyLinearAdvanceProof(
+			proof.LinearAdvanceProof,
+			proof.SourceTxHeader.BlTxID,
+			proof.TargetTxHeader.BlTxID,
+			proof.TargetBlTxAlh,
+			proof.TargetTxHeader.BlRoot,
+			proof.TargetTxHeader.BlTxID,
+		) {
+			return false
+		}
 	}
 
-	return VerifyLinearProof(proof.LinearProof, sourceTxID, targetTxID, sourceAlh, targetAlh)
+	return true
 }
 
 func leafFor(d [sha256.Size]byte) [sha256.Size]byte {
",[True]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func DualProofToProto(dualProof *store.DualProof) *DualProof {
 		TargetBlTxAlh:      dualProof.TargetBlTxAlh[:],
 		LastInclusionProof: DigestsToProto(dualProof.LastInclusionProof),
 		LinearProof:        LinearProofToProto(dualProof.LinearProof),
+		LinearAdvanceProof: LinearAdvanceProofToProto(dualProof.LinearAdvanceProof),
 	}
 }
 
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func DualProofFromProto(dproof *DualProof) *store.DualProof {
 		TargetBlTxAlh:      DigestFromProto(dproof.TargetBlTxAlh),
 		LastInclusionProof: DigestsFromProto(dproof.LastInclusionProof),
 		LinearProof:        LinearProofFromProto(dproof.LinearProof),
+		LinearAdvanceProof: LinearAdvanceProofFromProto(dproof.LinearAdvanceProof),
 	}
 }
 
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type DualProof struct {
 	LastInclusionProof [][]byte `protobuf:""bytes,6,rep,name=lastInclusionProof,proto3"" json:""lastInclusionProof,omitempty""`
 	// Linear proof starting from targetBlTxAlh to the final state value
 	LinearProof *LinearProof `protobuf:""bytes,7,opt,name=linearProof,proto3"" json:""linearProof,omitempty""`
+	// Proof of consistency between some part of older linear chain and newer Merkle Tree
+	LinearAdvanceProof *LinearAdvanceProof `protobuf:""bytes,8,opt,name=LinearAdvanceProof,proto3"" json:""LinearAdvanceProof,omitempty""`
 }
 
 func (x *DualProof) Reset() {
 	*x = DualProof{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[29]
+		mi := &file_schema_proto_msgTypes[30]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *DualProof) String() string {
 func (*DualProof) ProtoMessage() {}
 
 func (x *DualProof) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[29]
+	mi := &file_schema_proto_msgTypes[30]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *DualProof) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use DualProof.ProtoReflect.Descriptor instead.
 func (*DualProof) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{29}
+	return file_schema_proto_rawDescGZIP(), []int{30}
 }
 
 func (x *DualProof) GetSourceTxHeader() *TxHeader {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *DualProof) GetLinearProof() *LinearProof {
 	return nil
 }
 
+func (x *DualProof) GetLinearAdvanceProof() *LinearAdvanceProof {
+	if x != nil {
+		return x.LinearAdvanceProof
+	}
+	return nil
+}
+
 type Tx struct {
 	state         protoimpl.MessageState
 	sizeCache     protoimpl.SizeCache
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type Tx struct {
 func (x *Tx) Reset() {
 	*x = Tx{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[30]
+		mi := &file_schema_proto_msgTypes[31]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *Tx) String() string {
 func (*Tx) ProtoMessage() {}
 
 func (x *Tx) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[30]
+	mi := &file_schema_proto_msgTypes[31]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *Tx) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use Tx.ProtoReflect.Descriptor instead.
 func (*Tx) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{30}
+	return file_schema_proto_rawDescGZIP(), []int{31}
 }
 
 func (x *Tx) GetHeader() *TxHeader {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type TxEntry struct {
 func (x *TxEntry) Reset() {
 	*x = TxEntry{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[31]
+		mi := &file_schema_proto_msgTypes[32]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *TxEntry) String() string {
 func (*TxEntry) ProtoMessage() {}
 
 func (x *TxEntry) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[31]
+	mi := &file_schema_proto_msgTypes[32]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *TxEntry) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use TxEntry.ProtoReflect.Descriptor instead.
 func (*TxEntry) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{31}
+	return file_schema_proto_rawDescGZIP(), []int{32}
 }
 
 func (x *TxEntry) GetKey() []byte {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type KVMetadata struct {
 func (x *KVMetadata) Reset() {
 	*x = KVMetadata{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[32]
+		mi := &file_schema_proto_msgTypes[33]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *KVMetadata) String() string {
 func (*KVMetadata) ProtoMessage() {}
 
 func (x *KVMetadata) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[32]
+	mi := &file_schema_proto_msgTypes[33]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *KVMetadata) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use KVMetadata.ProtoReflect.Descriptor instead.
 func (*KVMetadata) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{32}
+	return file_schema_proto_rawDescGZIP(), []int{33}
 }
 
 func (x *KVMetadata) GetDeleted() bool {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type Expiration struct {
 func (x *Expiration) Reset() {
 	*x = Expiration{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[33]
+		mi := &file_schema_proto_msgTypes[34]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *Expiration) String() string {
 func (*Expiration) ProtoMessage() {}
 
 func (x *Expiration) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[33]
+	mi := &file_schema_proto_msgTypes[34]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *Expiration) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use Expiration.ProtoReflect.Descriptor instead.
 func (*Expiration) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{33}
+	return file_schema_proto_rawDescGZIP(), []int{34}
 }
 
 func (x *Expiration) GetExpiresAt() int64 {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type VerifiableTx struct {
 func (x *VerifiableTx) Reset() {
 	*x = VerifiableTx{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[34]
+		mi := &file_schema_proto_msgTypes[35]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *VerifiableTx) String() string {
 func (*VerifiableTx) ProtoMessage() {}
 
 func (x *VerifiableTx) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[34]
+	mi := &file_schema_proto_msgTypes[35]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *VerifiableTx) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use VerifiableTx.ProtoReflect.Descriptor instead.
 func (*VerifiableTx) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{34}
+	return file_schema_proto_rawDescGZIP(), []int{35}
 }
 
 func (x *VerifiableTx) GetTx() *Tx {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type VerifiableEntry struct {
 func (x *VerifiableEntry) Reset() {
 	*x = VerifiableEntry{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[35]
+		mi := &file_schema_proto_msgTypes[36]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *VerifiableEntry) String() string {
 func (*VerifiableEntry) ProtoMessage() {}
 
 func (x *VerifiableEntry) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[35]
+	mi := &file_schema_proto_msgTypes[36]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *VerifiableEntry) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use VerifiableEntry.ProtoReflect.Descriptor instead.
 func (*VerifiableEntry) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{35}
+	return file_schema_proto_rawDescGZIP(), []int{36}
 }
 
 func (x *VerifiableEntry) GetEntry() *Entry {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type InclusionProof struct {
 func (x *InclusionProof) Reset() {
 	*x = InclusionProof{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[36]
+		mi := &file_schema_proto_msgTypes[37]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *InclusionProof) String() string {
 func (*InclusionProof) ProtoMessage() {}
 
 func (x *InclusionProof) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[36]
+	mi := &file_schema_proto_msgTypes[37]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *InclusionProof) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use InclusionProof.ProtoReflect.Descriptor instead.
 func (*InclusionProof) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{36}
+	return file_schema_proto_rawDescGZIP(), []int{37}
 }
 
 func (x *InclusionProof) GetLeaf() int32 {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type SetRequest struct {
 func (x *SetRequest) Reset() {
 	*x = SetRequest{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[37]
+		mi := &file_schema_proto_msgTypes[38]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *SetRequest) String() string {
 func (*SetRequest) ProtoMessage() {}
 
 func (x *SetRequest) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[37]
+	mi := &file_schema_proto_msgTypes[38]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *SetRequest) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use SetRequest.ProtoReflect.Descriptor instead.
 func (*SetRequest) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{37}
+	return file_schema_proto_rawDescGZIP(), []int{38}
 }
 
 func (x *SetRequest) GetKVs() []*KeyValue {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type KeyRequest struct {
 func (x *KeyRequest) Reset() {
 	*x = KeyRequest{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[38]
+		mi := &file_schema_proto_msgTypes[39]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *KeyRequest) String() string {
 func (*KeyRequest) ProtoMessage() {}
 
 func (x *KeyRequest) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[38]
+	mi := &file_schema_proto_msgTypes[39]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *KeyRequest) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use KeyRequest.ProtoReflect.Descriptor instead.
 func (*KeyRequest) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{38}
+	return file_schema_proto_rawDescGZIP(), []int{39}
 }
 
 func (x *KeyRequest) GetKey() []byte {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type KeyListRequest struct {
 func (x *KeyListRequest) Reset() {
 	*x = KeyListRequest{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[39]
+		mi := &file_schema_proto_msgTypes[40]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *KeyListRequest) String() string {
 func (*KeyListRequest) ProtoMessage() {}
 
 func (x *KeyListRequest) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[39]
+	mi := &file_schema_proto_msgTypes[40]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *KeyListRequest) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use KeyListRequest.ProtoReflect.Descriptor instead.
 func (*KeyListRequest) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{39}
+	return file_schema_proto_rawDescGZIP(), []int{40}
 }
 
 func (x *KeyListRequest) GetKeys() [][]byte {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type DeleteKeysRequest struct {
 func (x *DeleteKeysRequest) Reset() {
 	*x = DeleteKeysRequest{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[40]
+		mi := &file_schema_proto_msgTypes[41]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *DeleteKeysRequest) String() string {
 func (*DeleteKeysRequest) ProtoMessage() {}
 
 func (x *DeleteKeysRequest) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[40]
+	mi := &file_schema_proto_msgTypes[41]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *DeleteKeysRequest) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use DeleteKeysRequest.ProtoReflect.Descriptor instead.
 func (*DeleteKeysRequest) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{40}
+	return file_schema_proto_rawDescGZIP(), []int{41}
 }
 
 func (x *DeleteKeysRequest) GetKeys() [][]byte {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type VerifiableSetRequest struct {
 func (x *VerifiableSetRequest) Reset() {
 	*x = VerifiableSetRequest{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[41]
+		mi := &file_schema_proto_msgTypes[42]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *VerifiableSetRequest) String() string {
 func (*VerifiableSetRequest) ProtoMessage() {}
 
 func (x *VerifiableSetRequest) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[41]
+	mi := &file_schema_proto_msgTypes[42]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *VerifiableSetRequest) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use VerifiableSetRequest.ProtoReflect.Descriptor instead.
 func (*VerifiableSetRequest) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{41}
+	return file_schema_proto_rawDescGZIP(), []int{42}
 }
 
 func (x *VerifiableSetRequest) GetSetRequest() *SetRequest {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type VerifiableGetRequest struct {
 func (x *VerifiableGetRequest) Reset() {
 	*x = VerifiableGetRequest{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[42]
+		mi := &file_schema_proto_msgTypes[43]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *VerifiableGetRequest) String() string {
 func (*VerifiableGetRequest) ProtoMessage() {}
 
 func (x *VerifiableGetRequest) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[42]
+	mi := &file_schema_proto_msgTypes[43]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *VerifiableGetRequest) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use VerifiableGetRequest.ProtoReflect.Descriptor instead.
 func (*VerifiableGetRequest) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{42}
+	return file_schema_proto_rawDescGZIP(), []int{43}
 }
 
 func (x *VerifiableGetRequest) GetKeyRequest() *KeyRequest {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type ServerInfoRequest struct {
 func (x *ServerInfoRequest) Reset() {
 	*x = ServerInfoRequest{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[43]
+		mi := &file_schema_proto_msgTypes[44]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *ServerInfoRequest) String() string {
 func (*ServerInfoRequest) ProtoMessage() {}
 
 func (x *ServerInfoRequest) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[43]
+	mi := &file_schema_proto_msgTypes[44]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *ServerInfoRequest) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use ServerInfoRequest.ProtoReflect.Descriptor instead.
 func (*ServerInfoRequest) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{43}
+	return file_schema_proto_rawDescGZIP(), []int{44}
 }
 
 // ServerInfoResponse contains information about the server instance.
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type ServerInfoResponse struct {
 func (x *ServerInfoResponse) Reset() {
 	*x = ServerInfoResponse{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[44]
+		mi := &file_schema_proto_msgTypes[45]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *ServerInfoResponse) String() string {
 func (*ServerInfoResponse) ProtoMessage() {}
 
 func (x *ServerInfoResponse) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[44]
+	mi := &file_schema_proto_msgTypes[45]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *ServerInfoResponse) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use ServerInfoResponse.ProtoReflect.Descriptor instead.
 func (*ServerInfoResponse) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{44}
+	return file_schema_proto_rawDescGZIP(), []int{45}
 }
 
 func (x *ServerInfoResponse) GetVersion() string {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type HealthResponse struct {
 func (x *HealthResponse) Reset() {
 	*x = HealthResponse{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[45]
+		mi := &file_schema_proto_msgTypes[46]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *HealthResponse) String() string {
 func (*HealthResponse) ProtoMessage() {}
 
 func (x *HealthResponse) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[45]
+	mi := &file_schema_proto_msgTypes[46]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *HealthResponse) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use HealthResponse.ProtoReflect.Descriptor instead.
 func (*HealthResponse) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{45}
+	return file_schema_proto_rawDescGZIP(), []int{46}
 }
 
 func (x *HealthResponse) GetStatus() bool {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type DatabaseHealthResponse struct {
 func (x *DatabaseHealthResponse) Reset() {
 	*x = DatabaseHealthResponse{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[46]
+		mi := &file_schema_proto_msgTypes[47]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *DatabaseHealthResponse) String() string {
 func (*DatabaseHealthResponse) ProtoMessage() {}
 
 func (x *DatabaseHealthResponse) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[46]
+	mi := &file_schema_proto_msgTypes[47]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *DatabaseHealthResponse) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use DatabaseHealthResponse.ProtoReflect.Descriptor instead.
 func (*DatabaseHealthResponse) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{46}
+	return file_schema_proto_rawDescGZIP(), []int{47}
 }
 
 func (x *DatabaseHealthResponse) GetPendingRequests() uint32 {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type ImmutableState struct {
 func (x *ImmutableState) Reset() {
 	*x = ImmutableState{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[47]
+		mi := &file_schema_proto_msgTypes[48]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *ImmutableState) String() string {
 func (*ImmutableState) ProtoMessage() {}
 
 func (x *ImmutableState) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[47]
+	mi := &file_schema_proto_msgTypes[48]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *ImmutableState) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use ImmutableState.ProtoReflect.Descriptor instead.
 func (*ImmutableState) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{47}
+	return file_schema_proto_rawDescGZIP(), []int{48}
 }
 
 func (x *ImmutableState) GetDb() string {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type ReferenceRequest struct {
 func (x *ReferenceRequest) Reset() {
 	*x = ReferenceRequest{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[48]
+		mi := &file_schema_proto_msgTypes[49]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *ReferenceRequest) String() string {
 func (*ReferenceRequest) ProtoMessage() {}
 
 func (x *ReferenceRequest) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[48]
+	mi := &file_schema_proto_msgTypes[49]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *ReferenceRequest) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use ReferenceRequest.ProtoReflect.Descriptor instead.
 func (*ReferenceRequest) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{48}
+	return file_schema_proto_rawDescGZIP(), []int{49}
 }
 
 func (x *ReferenceRequest) GetKey() []byte {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type VerifiableReferenceRequest struct {
 func (x *VerifiableReferenceRequest) Reset() {
 	*x = VerifiableReferenceRequest{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[49]
+		mi := &file_schema_proto_msgTypes[50]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *VerifiableReferenceRequest) String() string {
 func (*VerifiableReferenceRequest) ProtoMessage() {}
 
 func (x *VerifiableReferenceRequest) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[49]
+	mi := &file_schema_proto_msgTypes[50]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *VerifiableReferenceRequest) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use VerifiableReferenceRequest.ProtoReflect.Descriptor instead.
 func (*VerifiableReferenceRequest) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{49}
+	return file_schema_proto_rawDescGZIP(), []int{50}
 }
 
 func (x *VerifiableReferenceRequest) GetReferenceRequest() *ReferenceRequest {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type ZAddRequest struct {
 func (x *ZAddRequest) Reset() {
 	*x = ZAddRequest{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[50]
+		mi := &file_schema_proto_msgTypes[51]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *ZAddRequest) String() string {
 func (*ZAddRequest) ProtoMessage() {}
 
 func (x *ZAddRequest) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[50]
+	mi := &file_schema_proto_msgTypes[51]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *ZAddRequest) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use ZAddRequest.ProtoReflect.Descriptor instead.
 func (*ZAddRequest) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{50}
+	return file_schema_proto_rawDescGZIP(), []int{51}
 }
 
 func (x *ZAddRequest) GetSet() []byte {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type Score struct {
 func (x *Score) Reset() {
 	*x = Score{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[51]
+		mi := &file_schema_proto_msgTypes[52]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *Score) String() string {
 func (*Score) ProtoMessage() {}
 
 func (x *Score) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[51]
+	mi := &file_schema_proto_msgTypes[52]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *Score) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use Score.ProtoReflect.Descriptor instead.
 func (*Score) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{51}
+	return file_schema_proto_rawDescGZIP(), []int{52}
 }
 
 func (x *Score) GetScore() float64 {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type ZScanRequest struct {
 func (x *ZScanRequest) Reset() {
 	*x = ZScanRequest{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[52]
+		mi := &file_schema_proto_msgTypes[53]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *ZScanRequest) String() string {
 func (*ZScanRequest) ProtoMessage() {}
 
 func (x *ZScanRequest) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[52]
+	mi := &file_schema_proto_msgTypes[53]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *ZScanRequest) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use ZScanRequest.ProtoReflect.Descriptor instead.
 func (*ZScanRequest) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{52}
+	return file_schema_proto_rawDescGZIP(), []int{53}
 }
 
 func (x *ZScanRequest) GetSet() []byte {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type HistoryRequest struct {
 func (x *HistoryRequest) Reset() {
 	*x = HistoryRequest{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[53]
+		mi := &file_schema_proto_msgTypes[54]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *HistoryRequest) String() string {
 func (*HistoryRequest) ProtoMessage() {}
 
 func (x *HistoryRequest) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[53]
+	mi := &file_schema_proto_msgTypes[54]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *HistoryRequest) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use HistoryRequest.ProtoReflect.Descriptor instead.
 func (*HistoryRequest) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{53}
+	return file_schema_proto_rawDescGZIP(), []int{54}
 }
 
 func (x *HistoryRequest) GetKey() []byte {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type VerifiableZAddRequest struct {
 func (x *VerifiableZAddRequest) Reset() {
 	*x = VerifiableZAddRequest{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[54]
+		mi := &file_schema_proto_msgTypes[55]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *VerifiableZAddRequest) String() string {
 func (*VerifiableZAddRequest) ProtoMessage() {}
 
 func (x *VerifiableZAddRequest) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[54]
+	mi := &file_schema_proto_msgTypes[55]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *VerifiableZAddRequest) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use VerifiableZAddRequest.ProtoReflect.Descriptor instead.
 func (*VerifiableZAddRequest) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{54}
+	return file_schema_proto_rawDescGZIP(), []int{55}
 }
 
 func (x *VerifiableZAddRequest) GetZAddRequest() *ZAddRequest {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type TxRequest struct {
 func (x *TxRequest) Reset() {
 	*x = TxRequest{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[55]
+		mi := &file_schema_proto_msgTypes[56]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *TxRequest) String() string {
 func (*TxRequest) ProtoMessage() {}
 
 func (x *TxRequest) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[55]
+	mi := &file_schema_proto_msgTypes[56]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *TxRequest) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use TxRequest.ProtoReflect.Descriptor instead.
 func (*TxRequest) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{55}
+	return file_schema_proto_rawDescGZIP(), []int{56}
 }
 
 func (x *TxRequest) GetTx() uint64 {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type EntriesSpec struct {
 func (x *EntriesSpec) Reset() {
 	*x = EntriesSpec{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[56]
+		mi := &file_schema_proto_msgTypes[57]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *EntriesSpec) String() string {
 func (*EntriesSpec) ProtoMessage() {}
 
 func (x *EntriesSpec) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[56]
+	mi := &file_schema_proto_msgTypes[57]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *EntriesSpec) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use EntriesSpec.ProtoReflect.Descriptor instead.
 func (*EntriesSpec) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{56}
+	return file_schema_proto_rawDescGZIP(), []int{57}
 }
 
 func (x *EntriesSpec) GetKvEntriesSpec() *EntryTypeSpec {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type EntryTypeSpec struct {
 func (x *EntryTypeSpec) Reset() {
 	*x = EntryTypeSpec{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[57]
+		mi := &file_schema_proto_msgTypes[58]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *EntryTypeSpec) String() string {
 func (*EntryTypeSpec) ProtoMessage() {}
 
 func (x *EntryTypeSpec) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[57]
+	mi := &file_schema_proto_msgTypes[58]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *EntryTypeSpec) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use EntryTypeSpec.ProtoReflect.Descriptor instead.
 func (*EntryTypeSpec) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{57}
+	return file_schema_proto_rawDescGZIP(), []int{58}
 }
 
 func (x *EntryTypeSpec) GetAction() EntryTypeAction {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type VerifiableTxRequest struct {
 func (x *VerifiableTxRequest) Reset() {
 	*x = VerifiableTxRequest{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[58]
+		mi := &file_schema_proto_msgTypes[59]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *VerifiableTxRequest) String() string {
 func (*VerifiableTxRequest) ProtoMessage() {}
 
 func (x *VerifiableTxRequest) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[58]
+	mi := &file_schema_proto_msgTypes[59]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *VerifiableTxRequest) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use VerifiableTxRequest.ProtoReflect.Descriptor instead.
 func (*VerifiableTxRequest) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{58}
+	return file_schema_proto_rawDescGZIP(), []int{59}
 }
 
 func (x *VerifiableTxRequest) GetTx() uint64 {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type TxScanRequest struct {
 func (x *TxScanRequest) Reset() {
 	*x = TxScanRequest{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[59]
+		mi := &file_schema_proto_msgTypes[60]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *TxScanRequest) String() string {
 func (*TxScanRequest) ProtoMessage() {}
 
 func (x *TxScanRequest) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[59]
+	mi := &file_schema_proto_msgTypes[60]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *TxScanRequest) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use TxScanRequest.ProtoReflect.Descriptor instead.
 func (*TxScanRequest) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{59}
+	return file_schema_proto_rawDescGZIP(), []int{60}
 }
 
 func (x *TxScanRequest) GetInitialTx() uint64 {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type TxList struct {
 func (x *TxList) Reset() {
 	*x = TxList{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[60]
+		mi := &file_schema_proto_msgTypes[61]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *TxList) String() string {
 func (*TxList) ProtoMessage() {}
 
 func (x *TxList) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[60]
+	mi := &file_schema_proto_msgTypes[61]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *TxList) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use TxList.ProtoReflect.Descriptor instead.
 func (*TxList) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{60}
+	return file_schema_proto_rawDescGZIP(), []int{61}
 }
 
 func (x *TxList) GetTxs() []*Tx {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type ExportTxRequest struct {
 func (x *ExportTxRequest) Reset() {
 	*x = ExportTxRequest{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[61]
+		mi := &file_schema_proto_msgTypes[62]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *ExportTxRequest) String() string {
 func (*ExportTxRequest) ProtoMessage() {}
 
 func (x *ExportTxRequest) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[61]
+	mi := &file_schema_proto_msgTypes[62]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *ExportTxRequest) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use ExportTxRequest.ProtoReflect.Descriptor instead.
 func (*ExportTxRequest) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{61}
+	return file_schema_proto_rawDescGZIP(), []int{62}
 }
 
 func (x *ExportTxRequest) GetTx() uint64 {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type ReplicaState struct {
 func (x *ReplicaState) Reset() {
 	*x = ReplicaState{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[62]
+		mi := &file_schema_proto_msgTypes[63]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *ReplicaState) String() string {
 func (*ReplicaState) ProtoMessage() {}
 
 func (x *ReplicaState) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[62]
+	mi := &file_schema_proto_msgTypes[63]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *ReplicaState) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use ReplicaState.ProtoReflect.Descriptor instead.
 func (*ReplicaState) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{62}
+	return file_schema_proto_rawDescGZIP(), []int{63}
 }
 
 func (x *ReplicaState) GetUUID() string {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type Database struct {
 func (x *Database) Reset() {
 	*x = Database{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[63]
+		mi := &file_schema_proto_msgTypes[64]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *Database) String() string {
 func (*Database) ProtoMessage() {}
 
 func (x *Database) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[63]
+	mi := &file_schema_proto_msgTypes[64]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *Database) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use Database.ProtoReflect.Descriptor instead.
 func (*Database) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{63}
+	return file_schema_proto_rawDescGZIP(), []int{64}
 }
 
 func (x *Database) GetDatabaseName() string {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type DatabaseSettings struct {
 func (x *DatabaseSettings) Reset() {
 	*x = DatabaseSettings{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[64]
+		mi := &file_schema_proto_msgTypes[65]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *DatabaseSettings) String() string {
 func (*DatabaseSettings) ProtoMessage() {}
 
 func (x *DatabaseSettings) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[64]
+	mi := &file_schema_proto_msgTypes[65]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *DatabaseSettings) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use DatabaseSettings.ProtoReflect.Descriptor instead.
 func (*DatabaseSettings) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{64}
+	return file_schema_proto_rawDescGZIP(), []int{65}
 }
 
 func (x *DatabaseSettings) GetDatabaseName() string {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type CreateDatabaseRequest struct {
 func (x *CreateDatabaseRequest) Reset() {
 	*x = CreateDatabaseRequest{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[65]
+		mi := &file_schema_proto_msgTypes[66]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *CreateDatabaseRequest) String() string {
 func (*CreateDatabaseRequest) ProtoMessage() {}
 
 func (x *CreateDatabaseRequest) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[65]
+	mi := &file_schema_proto_msgTypes[66]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *CreateDatabaseRequest) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use CreateDatabaseRequest.ProtoReflect.Descriptor instead.
 func (*CreateDatabaseRequest) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{65}
+	return file_schema_proto_rawDescGZIP(), []int{66}
 }
 
 func (x *CreateDatabaseRequest) GetName() string {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type CreateDatabaseResponse struct {
 func (x *CreateDatabaseResponse) Reset() {
 	*x = CreateDatabaseResponse{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[66]
+		mi := &file_schema_proto_msgTypes[67]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *CreateDatabaseResponse) String() string {
 func (*CreateDatabaseResponse) ProtoMessage() {}
 
 func (x *CreateDatabaseResponse) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[66]
+	mi := &file_schema_proto_msgTypes[67]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *CreateDatabaseResponse) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use CreateDatabaseResponse.ProtoReflect.Descriptor instead.
 func (*CreateDatabaseResponse) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{66}
+	return file_schema_proto_rawDescGZIP(), []int{67}
 }
 
 func (x *CreateDatabaseResponse) GetName() string {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type UpdateDatabaseRequest struct {
 func (x *UpdateDatabaseRequest) Reset() {
 	*x = UpdateDatabaseRequest{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[67]
+		mi := &file_schema_proto_msgTypes[68]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *UpdateDatabaseRequest) String() string {
 func (*UpdateDatabaseRequest) ProtoMessage() {}
 
 func (x *UpdateDatabaseRequest) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[67]
+	mi := &file_schema_proto_msgTypes[68]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *UpdateDatabaseRequest) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use UpdateDatabaseRequest.ProtoReflect.Descriptor instead.
 func (*UpdateDatabaseRequest) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{67}
+	return file_schema_proto_rawDescGZIP(), []int{68}
 }
 
 func (x *UpdateDatabaseRequest) GetDatabase() string {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type UpdateDatabaseResponse struct {
 func (x *UpdateDatabaseResponse) Reset() {
 	*x = UpdateDatabaseResponse{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[68]
+		mi := &file_schema_proto_msgTypes[69]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *UpdateDatabaseResponse) String() string {
 func (*UpdateDatabaseResponse) ProtoMessage() {}
 
 func (x *UpdateDatabaseResponse) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[68]
+	mi := &file_schema_proto_msgTypes[69]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *UpdateDatabaseResponse) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use UpdateDatabaseResponse.ProtoReflect.Descriptor instead.
 func (*UpdateDatabaseResponse) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{68}
+	return file_schema_proto_rawDescGZIP(), []int{69}
 }
 
 func (x *UpdateDatabaseResponse) GetDatabase() string {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type DatabaseSettingsRequest struct {
 func (x *DatabaseSettingsRequest) Reset() {
 	*x = DatabaseSettingsRequest{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[69]
+		mi := &file_schema_proto_msgTypes[70]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *DatabaseSettingsRequest) String() string {
 func (*DatabaseSettingsRequest) ProtoMessage() {}
 
 func (x *DatabaseSettingsRequest) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[69]
+	mi := &file_schema_proto_msgTypes[70]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *DatabaseSettingsRequest) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use DatabaseSettingsRequest.ProtoReflect.Descriptor instead.
 func (*DatabaseSettingsRequest) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{69}
+	return file_schema_proto_rawDescGZIP(), []int{70}
 }
 
 type DatabaseSettingsResponse struct {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type DatabaseSettingsResponse struct {
 func (x *DatabaseSettingsResponse) Reset() {
 	*x = DatabaseSettingsResponse{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[70]
+		mi := &file_schema_proto_msgTypes[71]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *DatabaseSettingsResponse) String() string {
 func (*DatabaseSettingsResponse) ProtoMessage() {}
 
 func (x *DatabaseSettingsResponse) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[70]
+	mi := &file_schema_proto_msgTypes[71]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *DatabaseSettingsResponse) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use DatabaseSettingsResponse.ProtoReflect.Descriptor instead.
 func (*DatabaseSettingsResponse) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{70}
+	return file_schema_proto_rawDescGZIP(), []int{71}
 }
 
 func (x *DatabaseSettingsResponse) GetDatabase() string {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type NullableUint32 struct {
 func (x *NullableUint32) Reset() {
 	*x = NullableUint32{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[71]
+		mi := &file_schema_proto_msgTypes[72]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *NullableUint32) String() string {
 func (*NullableUint32) ProtoMessage() {}
 
 func (x *NullableUint32) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[71]
+	mi := &file_schema_proto_msgTypes[72]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *NullableUint32) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use NullableUint32.ProtoReflect.Descriptor instead.
 func (*NullableUint32) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{71}
+	return file_schema_proto_rawDescGZIP(), []int{72}
 }
 
 func (x *NullableUint32) GetValue() uint32 {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type NullableUint64 struct {
 func (x *NullableUint64) Reset() {
 	*x = NullableUint64{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[72]
+		mi := &file_schema_proto_msgTypes[73]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *NullableUint64) String() string {
 func (*NullableUint64) ProtoMessage() {}
 
 func (x *NullableUint64) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[72]
+	mi := &file_schema_proto_msgTypes[73]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *NullableUint64) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use NullableUint64.ProtoReflect.Descriptor instead.
 func (*NullableUint64) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{72}
+	return file_schema_proto_rawDescGZIP(), []int{73}
 }
 
 func (x *NullableUint64) GetValue() uint64 {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type NullableFloat struct {
 func (x *NullableFloat) Reset() {
 	*x = NullableFloat{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[73]
+		mi := &file_schema_proto_msgTypes[74]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *NullableFloat) String() string {
 func (*NullableFloat) ProtoMessage() {}
 
 func (x *NullableFloat) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[73]
+	mi := &file_schema_proto_msgTypes[74]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *NullableFloat) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use NullableFloat.ProtoReflect.Descriptor instead.
 func (*NullableFloat) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{73}
+	return file_schema_proto_rawDescGZIP(), []int{74}
 }
 
 func (x *NullableFloat) GetValue() float32 {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type NullableBool struct {
 func (x *NullableBool) Reset() {
 	*x = NullableBool{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[74]
+		mi := &file_schema_proto_msgTypes[75]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *NullableBool) String() string {
 func (*NullableBool) ProtoMessage() {}
 
 func (x *NullableBool) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[74]
+	mi := &file_schema_proto_msgTypes[75]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *NullableBool) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use NullableBool.ProtoReflect.Descriptor instead.
 func (*NullableBool) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{74}
+	return file_schema_proto_rawDescGZIP(), []int{75}
 }
 
 func (x *NullableBool) GetValue() bool {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type NullableString struct {
 func (x *NullableString) Reset() {
 	*x = NullableString{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[75]
+		mi := &file_schema_proto_msgTypes[76]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *NullableString) String() string {
 func (*NullableString) ProtoMessage() {}
 
 func (x *NullableString) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[75]
+	mi := &file_schema_proto_msgTypes[76]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *NullableString) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use NullableString.ProtoReflect.Descriptor instead.
 func (*NullableString) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{75}
+	return file_schema_proto_rawDescGZIP(), []int{76}
 }
 
 func (x *NullableString) GetValue() string {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type NullableMilliseconds struct {
 func (x *NullableMilliseconds) Reset() {
 	*x = NullableMilliseconds{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[76]
+		mi := &file_schema_proto_msgTypes[77]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *NullableMilliseconds) String() string {
 func (*NullableMilliseconds) ProtoMessage() {}
 
 func (x *NullableMilliseconds) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[76]
+	mi := &file_schema_proto_msgTypes[77]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *NullableMilliseconds) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use NullableMilliseconds.ProtoReflect.Descriptor instead.
 func (*NullableMilliseconds) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{76}
+	return file_schema_proto_rawDescGZIP(), []int{77}
 }
 
 func (x *NullableMilliseconds) GetValue() int64 {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type DatabaseNullableSettings struct {
 func (x *DatabaseNullableSettings) Reset() {
 	*x = DatabaseNullableSettings{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[77]
+		mi := &file_schema_proto_msgTypes[78]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *DatabaseNullableSettings) String() string {
 func (*DatabaseNullableSettings) ProtoMessage() {}
 
 func (x *DatabaseNullableSettings) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[77]
+	mi := &file_schema_proto_msgTypes[78]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *DatabaseNullableSettings) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use DatabaseNullableSettings.ProtoReflect.Descriptor instead.
 func (*DatabaseNullableSettings) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{77}
+	return file_schema_proto_rawDescGZIP(), []int{78}
 }
 
 func (x *DatabaseNullableSettings) GetReplicationSettings() *ReplicationNullableSettings {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type ReplicationNullableSettings struct {
 func (x *ReplicationNullableSettings) Reset() {
 	*x = ReplicationNullableSettings{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[78]
+		mi := &file_schema_proto_msgTypes[79]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *ReplicationNullableSettings) String() string {
 func (*ReplicationNullableSettings) ProtoMessage() {}
 
 func (x *ReplicationNullableSettings) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[78]
+	mi := &file_schema_proto_msgTypes[79]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *ReplicationNullableSettings) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use ReplicationNullableSettings.ProtoReflect.Descriptor instead.
 func (*ReplicationNullableSettings) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{78}
+	return file_schema_proto_rawDescGZIP(), []int{79}
 }
 
 func (x *ReplicationNullableSettings) GetReplica() *NullableBool {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type IndexNullableSettings struct {
 func (x *IndexNullableSettings) Reset() {
 	*x = IndexNullableSettings{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[79]
+		mi := &file_schema_proto_msgTypes[80]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *IndexNullableSettings) String() string {
 func (*IndexNullableSettings) ProtoMessage() {}
 
 func (x *IndexNullableSettings) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[79]
+	mi := &file_schema_proto_msgTypes[80]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *IndexNullableSettings) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use IndexNullableSettings.ProtoReflect.Descriptor instead.
 func (*IndexNullableSettings) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{79}
+	return file_schema_proto_rawDescGZIP(), []int{80}
 }
 
 func (x *IndexNullableSettings) GetFlushThreshold() *NullableUint32 {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type AHTNullableSettings struct {
 func (x *AHTNullableSettings) Reset() {
 	*x = AHTNullableSettings{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[80]
+		mi := &file_schema_proto_msgTypes[81]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *AHTNullableSettings) String() string {
 func (*AHTNullableSettings) ProtoMessage() {}
 
 func (x *AHTNullableSettings) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[80]
+	mi := &file_schema_proto_msgTypes[81]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *AHTNullableSettings) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use AHTNullableSettings.ProtoReflect.Descriptor instead.
 func (*AHTNullableSettings) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{80}
+	return file_schema_proto_rawDescGZIP(), []int{81}
 }
 
 func (x *AHTNullableSettings) GetSyncThreshold() *NullableUint32 {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type LoadDatabaseRequest struct {
 func (x *LoadDatabaseRequest) Reset() {
 	*x = LoadDatabaseRequest{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[81]
+		mi := &file_schema_proto_msgTypes[82]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *LoadDatabaseRequest) String() string {
 func (*LoadDatabaseRequest) ProtoMessage() {}
 
 func (x *LoadDatabaseRequest) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[81]
+	mi := &file_schema_proto_msgTypes[82]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *LoadDatabaseRequest) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use LoadDatabaseRequest.ProtoReflect.Descriptor instead.
 func (*LoadDatabaseRequest) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{81}
+	return file_schema_proto_rawDescGZIP(), []int{82}
 }
 
 func (x *LoadDatabaseRequest) GetDatabase() string {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type LoadDatabaseResponse struct {
 func (x *LoadDatabaseResponse) Reset() {
 	*x = LoadDatabaseResponse{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[82]
+		mi := &file_schema_proto_msgTypes[83]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *LoadDatabaseResponse) String() string {
 func (*LoadDatabaseResponse) ProtoMessage() {}
 
 func (x *LoadDatabaseResponse) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[82]
+	mi := &file_schema_proto_msgTypes[83]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *LoadDatabaseResponse) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use LoadDatabaseResponse.ProtoReflect.Descriptor instead.
 func (*LoadDatabaseResponse) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{82}
+	return file_schema_proto_rawDescGZIP(), []int{83}
 }
 
 func (x *LoadDatabaseResponse) GetDatabase() string {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type UnloadDatabaseRequest struct {
 func (x *UnloadDatabaseRequest) Reset() {
 	*x = UnloadDatabaseRequest{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[83]
+		mi := &file_schema_proto_msgTypes[84]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *UnloadDatabaseRequest) String() string {
 func (*UnloadDatabaseRequest) ProtoMessage() {}
 
 func (x *UnloadDatabaseRequest) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[83]
+	mi := &file_schema_proto_msgTypes[84]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *UnloadDatabaseRequest) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use UnloadDatabaseRequest.ProtoReflect.Descriptor instead.
 func (*UnloadDatabaseRequest) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{83}
+	return file_schema_proto_rawDescGZIP(), []int{84}
 }
 
 func (x *UnloadDatabaseRequest) GetDatabase() string {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type UnloadDatabaseResponse struct {
 func (x *UnloadDatabaseResponse) Reset() {
 	*x = UnloadDatabaseResponse{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[84]
+		mi := &file_schema_proto_msgTypes[85]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *UnloadDatabaseResponse) String() string {
 func (*UnloadDatabaseResponse) ProtoMessage() {}
 
 func (x *UnloadDatabaseResponse) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[84]
+	mi := &file_schema_proto_msgTypes[85]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *UnloadDatabaseResponse) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use UnloadDatabaseResponse.ProtoReflect.Descriptor instead.
 func (*UnloadDatabaseResponse) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{84}
+	return file_schema_proto_rawDescGZIP(), []int{85}
 }
 
 func (x *UnloadDatabaseResponse) GetDatabase() string {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type DeleteDatabaseRequest struct {
 func (x *DeleteDatabaseRequest) Reset() {
 	*x = DeleteDatabaseRequest{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[85]
+		mi := &file_schema_proto_msgTypes[86]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *DeleteDatabaseRequest) String() string {
 func (*DeleteDatabaseRequest) ProtoMessage() {}
 
 func (x *DeleteDatabaseRequest) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[85]
+	mi := &file_schema_proto_msgTypes[86]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *DeleteDatabaseRequest) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use DeleteDatabaseRequest.ProtoReflect.Descriptor instead.
 func (*DeleteDatabaseRequest) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{85}
+	return file_schema_proto_rawDescGZIP(), []int{86}
 }
 
 func (x *DeleteDatabaseRequest) GetDatabase() string {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type DeleteDatabaseResponse struct {
 func (x *DeleteDatabaseResponse) Reset() {
 	*x = DeleteDatabaseResponse{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[86]
+		mi := &file_schema_proto_msgTypes[87]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *DeleteDatabaseResponse) String() string {
 func (*DeleteDatabaseResponse) ProtoMessage() {}
 
 func (x *DeleteDatabaseResponse) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[86]
+	mi := &file_schema_proto_msgTypes[87]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *DeleteDatabaseResponse) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use DeleteDatabaseResponse.ProtoReflect.Descriptor instead.
 func (*DeleteDatabaseResponse) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{86}
+	return file_schema_proto_rawDescGZIP(), []int{87}
 }
 
 func (x *DeleteDatabaseResponse) GetDatabase() string {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type FlushIndexRequest struct {
 func (x *FlushIndexRequest) Reset() {
 	*x = FlushIndexRequest{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[87]
+		mi := &file_schema_proto_msgTypes[88]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *FlushIndexRequest) String() string {
 func (*FlushIndexRequest) ProtoMessage() {}
 
 func (x *FlushIndexRequest) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[87]
+	mi := &file_schema_proto_msgTypes[88]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *FlushIndexRequest) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use FlushIndexRequest.ProtoReflect.Descriptor instead.
 func (*FlushIndexRequest) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{87}
+	return file_schema_proto_rawDescGZIP(), []int{88}
 }
 
 func (x *FlushIndexRequest) GetCleanupPercentage() float32 {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type FlushIndexResponse struct {
 func (x *FlushIndexResponse) Reset() {
 	*x = FlushIndexResponse{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[88]
+		mi := &file_schema_proto_msgTypes[89]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *FlushIndexResponse) String() string {
 func (*FlushIndexResponse) ProtoMessage() {}
 
 func (x *FlushIndexResponse) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[88]
+	mi := &file_schema_proto_msgTypes[89]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *FlushIndexResponse) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use FlushIndexResponse.ProtoReflect.Descriptor instead.
 func (*FlushIndexResponse) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{88}
+	return file_schema_proto_rawDescGZIP(), []int{89}
 }
 
 func (x *FlushIndexResponse) GetDatabase() string {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type Table struct {
 func (x *Table) Reset() {
 	*x = Table{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[89]
+		mi := &file_schema_proto_msgTypes[90]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *Table) String() string {
 func (*Table) ProtoMessage() {}
 
 func (x *Table) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[89]
+	mi := &file_schema_proto_msgTypes[90]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *Table) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use Table.ProtoReflect.Descriptor instead.
 func (*Table) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{89}
+	return file_schema_proto_rawDescGZIP(), []int{90}
 }
 
 func (x *Table) GetTableName() string {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type SQLGetRequest struct {
 func (x *SQLGetRequest) Reset() {
 	*x = SQLGetRequest{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[90]
+		mi := &file_schema_proto_msgTypes[91]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *SQLGetRequest) String() string {
 func (*SQLGetRequest) ProtoMessage() {}
 
 func (x *SQLGetRequest) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[90]
+	mi := &file_schema_proto_msgTypes[91]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *SQLGetRequest) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use SQLGetRequest.ProtoReflect.Descriptor instead.
 func (*SQLGetRequest) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{90}
+	return file_schema_proto_rawDescGZIP(), []int{91}
 }
 
 func (x *SQLGetRequest) GetTable() string {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type VerifiableSQLGetRequest struct {
 func (x *VerifiableSQLGetRequest) Reset() {
 	*x = VerifiableSQLGetRequest{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[91]
+		mi := &file_schema_proto_msgTypes[92]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *VerifiableSQLGetRequest) String() string {
 func (*VerifiableSQLGetRequest) ProtoMessage() {}
 
 func (x *VerifiableSQLGetRequest) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[91]
+	mi := &file_schema_proto_msgTypes[92]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *VerifiableSQLGetRequest) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use VerifiableSQLGetRequest.ProtoReflect.Descriptor instead.
 func (*VerifiableSQLGetRequest) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{91}
+	return file_schema_proto_rawDescGZIP(), []int{92}
 }
 
 func (x *VerifiableSQLGetRequest) GetSqlGetRequest() *SQLGetRequest {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type SQLEntry struct {
 func (x *SQLEntry) Reset() {
 	*x = SQLEntry{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[92]
+		mi := &file_schema_proto_msgTypes[93]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *SQLEntry) String() string {
 func (*SQLEntry) ProtoMessage() {}
 
 func (x *SQLEntry) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[92]
+	mi := &file_schema_proto_msgTypes[93]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *SQLEntry) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use SQLEntry.ProtoReflect.Descriptor instead.
 func (*SQLEntry) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{92}
+	return file_schema_proto_rawDescGZIP(), []int{93}
 }
 
 func (x *SQLEntry) GetTx() uint64 {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type VerifiableSQLEntry struct {
 func (x *VerifiableSQLEntry) Reset() {
 	*x = VerifiableSQLEntry{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[93]
+		mi := &file_schema_proto_msgTypes[94]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *VerifiableSQLEntry) String() string {
 func (*VerifiableSQLEntry) ProtoMessage() {}
 
 func (x *VerifiableSQLEntry) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[93]
+	mi := &file_schema_proto_msgTypes[94]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *VerifiableSQLEntry) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use VerifiableSQLEntry.ProtoReflect.Descriptor instead.
 func (*VerifiableSQLEntry) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{93}
+	return file_schema_proto_rawDescGZIP(), []int{94}
 }
 
 func (x *VerifiableSQLEntry) GetSqlEntry() *SQLEntry {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type UseDatabaseReply struct {
 func (x *UseDatabaseReply) Reset() {
 	*x = UseDatabaseReply{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[94]
+		mi := &file_schema_proto_msgTypes[95]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *UseDatabaseReply) String() string {
 func (*UseDatabaseReply) ProtoMessage() {}
 
 func (x *UseDatabaseReply) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[94]
+	mi := &file_schema_proto_msgTypes[95]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *UseDatabaseReply) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use UseDatabaseReply.ProtoReflect.Descriptor instead.
 func (*UseDatabaseReply) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{94}
+	return file_schema_proto_rawDescGZIP(), []int{95}
 }
 
 func (x *UseDatabaseReply) GetToken() string {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type ChangePermissionRequest struct {
 func (x *ChangePermissionRequest) Reset() {
 	*x = ChangePermissionRequest{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[95]
+		mi := &file_schema_proto_msgTypes[96]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *ChangePermissionRequest) String() string {
 func (*ChangePermissionRequest) ProtoMessage() {}
 
 func (x *ChangePermissionRequest) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[95]
+	mi := &file_schema_proto_msgTypes[96]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *ChangePermissionRequest) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use ChangePermissionRequest.ProtoReflect.Descriptor instead.
 func (*ChangePermissionRequest) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{95}
+	return file_schema_proto_rawDescGZIP(), []int{96}
 }
 
 func (x *ChangePermissionRequest) GetAction() PermissionAction {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type SetActiveUserRequest struct {
 func (x *SetActiveUserRequest) Reset() {
 	*x = SetActiveUserRequest{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[96]
+		mi := &file_schema_proto_msgTypes[97]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *SetActiveUserRequest) String() string {
 func (*SetActiveUserRequest) ProtoMessage() {}
 
 func (x *SetActiveUserRequest) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[96]
+	mi := &file_schema_proto_msgTypes[97]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *SetActiveUserRequest) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use SetActiveUserRequest.ProtoReflect.Descriptor instead.
 func (*SetActiveUserRequest) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{96}
+	return file_schema_proto_rawDescGZIP(), []int{97}
 }
 
 func (x *SetActiveUserRequest) GetActive() bool {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type DatabaseListResponse struct {
 func (x *DatabaseListResponse) Reset() {
 	*x = DatabaseListResponse{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[97]
+		mi := &file_schema_proto_msgTypes[98]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *DatabaseListResponse) String() string {
 func (*DatabaseListResponse) ProtoMessage() {}
 
 func (x *DatabaseListResponse) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[97]
+	mi := &file_schema_proto_msgTypes[98]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *DatabaseListResponse) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use DatabaseListResponse.ProtoReflect.Descriptor instead.
 func (*DatabaseListResponse) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{97}
+	return file_schema_proto_rawDescGZIP(), []int{98}
 }
 
 func (x *DatabaseListResponse) GetDatabases() []*Database {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type DatabaseListRequestV2 struct {
 func (x *DatabaseListRequestV2) Reset() {
 	*x = DatabaseListRequestV2{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[98]
+		mi := &file_schema_proto_msgTypes[99]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *DatabaseListRequestV2) String() string {
 func (*DatabaseListRequestV2) ProtoMessage() {}
 
 func (x *DatabaseListRequestV2) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[98]
+	mi := &file_schema_proto_msgTypes[99]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *DatabaseListRequestV2) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use DatabaseListRequestV2.ProtoReflect.Descriptor instead.
 func (*DatabaseListRequestV2) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{98}
+	return file_schema_proto_rawDescGZIP(), []int{99}
 }
 
 type DatabaseListResponseV2 struct {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type DatabaseListResponseV2 struct {
 func (x *DatabaseListResponseV2) Reset() {
 	*x = DatabaseListResponseV2{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[99]
+		mi := &file_schema_proto_msgTypes[100]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *DatabaseListResponseV2) String() string {
 func (*DatabaseListResponseV2) ProtoMessage() {}
 
 func (x *DatabaseListResponseV2) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[99]
+	mi := &file_schema_proto_msgTypes[100]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *DatabaseListResponseV2) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use DatabaseListResponseV2.ProtoReflect.Descriptor instead.
 func (*DatabaseListResponseV2) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{99}
+	return file_schema_proto_rawDescGZIP(), []int{100}
 }
 
 func (x *DatabaseListResponseV2) GetDatabases() []*DatabaseWithSettings {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type DatabaseWithSettings struct {
 func (x *DatabaseWithSettings) Reset() {
 	*x = DatabaseWithSettings{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[100]
+		mi := &file_schema_proto_msgTypes[101]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *DatabaseWithSettings) String() string {
 func (*DatabaseWithSettings) ProtoMessage() {}
 
 func (x *DatabaseWithSettings) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[100]
+	mi := &file_schema_proto_msgTypes[101]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *DatabaseWithSettings) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use DatabaseWithSettings.ProtoReflect.Descriptor instead.
 func (*DatabaseWithSettings) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{100}
+	return file_schema_proto_rawDescGZIP(), []int{101}
 }
 
 func (x *DatabaseWithSettings) GetName() string {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type Chunk struct {
 func (x *Chunk) Reset() {
 	*x = Chunk{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[101]
+		mi := &file_schema_proto_msgTypes[102]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *Chunk) String() string {
 func (*Chunk) ProtoMessage() {}
 
 func (x *Chunk) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[101]
+	mi := &file_schema_proto_msgTypes[102]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *Chunk) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use Chunk.ProtoReflect.Descriptor instead.
 func (*Chunk) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{101}
+	return file_schema_proto_rawDescGZIP(), []int{102}
 }
 
 func (x *Chunk) GetContent() []byte {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type UseSnapshotRequest struct {
 func (x *UseSnapshotRequest) Reset() {
 	*x = UseSnapshotRequest{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[102]
+		mi := &file_schema_proto_msgTypes[103]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *UseSnapshotRequest) String() string {
 func (*UseSnapshotRequest) ProtoMessage() {}
 
 func (x *UseSnapshotRequest) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[102]
+	mi := &file_schema_proto_msgTypes[103]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *UseSnapshotRequest) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use UseSnapshotRequest.ProtoReflect.Descriptor instead.
 func (*UseSnapshotRequest) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{102}
+	return file_schema_proto_rawDescGZIP(), []int{103}
 }
 
 func (x *UseSnapshotRequest) GetSinceTx() uint64 {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type SQLExecRequest struct {
 func (x *SQLExecRequest) Reset() {
 	*x = SQLExecRequest{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[103]
+		mi := &file_schema_proto_msgTypes[104]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *SQLExecRequest) String() string {
 func (*SQLExecRequest) ProtoMessage() {}
 
 func (x *SQLExecRequest) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[103]
+	mi := &file_schema_proto_msgTypes[104]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *SQLExecRequest) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use SQLExecRequest.ProtoReflect.Descriptor instead.
 func (*SQLExecRequest) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{103}
+	return file_schema_proto_rawDescGZIP(), []int{104}
 }
 
 func (x *SQLExecRequest) GetSql() string {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type SQLQueryRequest struct {
 func (x *SQLQueryRequest) Reset() {
 	*x = SQLQueryRequest{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[104]
+		mi := &file_schema_proto_msgTypes[105]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *SQLQueryRequest) String() string {
 func (*SQLQueryRequest) ProtoMessage() {}
 
 func (x *SQLQueryRequest) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[104]
+	mi := &file_schema_proto_msgTypes[105]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *SQLQueryRequest) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use SQLQueryRequest.ProtoReflect.Descriptor instead.
 func (*SQLQueryRequest) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{104}
+	return file_schema_proto_rawDescGZIP(), []int{105}
 }
 
 func (x *SQLQueryRequest) GetSql() string {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type NamedParam struct {
 func (x *NamedParam) Reset() {
 	*x = NamedParam{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[105]
+		mi := &file_schema_proto_msgTypes[106]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *NamedParam) String() string {
 func (*NamedParam) ProtoMessage() {}
 
 func (x *NamedParam) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[105]
+	mi := &file_schema_proto_msgTypes[106]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *NamedParam) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use NamedParam.ProtoReflect.Descriptor instead.
 func (*NamedParam) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{105}
+	return file_schema_proto_rawDescGZIP(), []int{106}
 }
 
 func (x *NamedParam) GetName() string {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type SQLExecResult struct {
 func (x *SQLExecResult) Reset() {
 	*x = SQLExecResult{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[106]
+		mi := &file_schema_proto_msgTypes[107]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *SQLExecResult) String() string {
 func (*SQLExecResult) ProtoMessage() {}
 
 func (x *SQLExecResult) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[106]
+	mi := &file_schema_proto_msgTypes[107]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *SQLExecResult) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use SQLExecResult.ProtoReflect.Descriptor instead.
 func (*SQLExecResult) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{106}
+	return file_schema_proto_rawDescGZIP(), []int{107}
 }
 
 func (x *SQLExecResult) GetTxs() []*CommittedSQLTx {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type CommittedSQLTx struct {
 func (x *CommittedSQLTx) Reset() {
 	*x = CommittedSQLTx{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[107]
+		mi := &file_schema_proto_msgTypes[108]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *CommittedSQLTx) String() string {
 func (*CommittedSQLTx) ProtoMessage() {}
 
 func (x *CommittedSQLTx) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[107]
+	mi := &file_schema_proto_msgTypes[108]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *CommittedSQLTx) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use CommittedSQLTx.ProtoReflect.Descriptor instead.
 func (*CommittedSQLTx) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{107}
+	return file_schema_proto_rawDescGZIP(), []int{108}
 }
 
 func (x *CommittedSQLTx) GetHeader() *TxHeader {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type SQLQueryResult struct {
 func (x *SQLQueryResult) Reset() {
 	*x = SQLQueryResult{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[108]
+		mi := &file_schema_proto_msgTypes[109]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *SQLQueryResult) String() string {
 func (*SQLQueryResult) ProtoMessage() {}
 
 func (x *SQLQueryResult) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[108]
+	mi := &file_schema_proto_msgTypes[109]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *SQLQueryResult) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use SQLQueryResult.ProtoReflect.Descriptor instead.
 func (*SQLQueryResult) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{108}
+	return file_schema_proto_rawDescGZIP(), []int{109}
 }
 
 func (x *SQLQueryResult) GetColumns() []*Column {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type Column struct {
 func (x *Column) Reset() {
 	*x = Column{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[109]
+		mi := &file_schema_proto_msgTypes[110]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *Column) String() string {
 func (*Column) ProtoMessage() {}
 
 func (x *Column) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[109]
+	mi := &file_schema_proto_msgTypes[110]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *Column) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use Column.ProtoReflect.Descriptor instead.
 func (*Column) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{109}
+	return file_schema_proto_rawDescGZIP(), []int{110}
 }
 
 func (x *Column) GetName() string {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type Row struct {
 func (x *Row) Reset() {
 	*x = Row{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[110]
+		mi := &file_schema_proto_msgTypes[111]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *Row) String() string {
 func (*Row) ProtoMessage() {}
 
 func (x *Row) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[110]
+	mi := &file_schema_proto_msgTypes[111]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *Row) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use Row.ProtoReflect.Descriptor instead.
 func (*Row) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{110}
+	return file_schema_proto_rawDescGZIP(), []int{111}
 }
 
 func (x *Row) GetColumns() []string {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type SQLValue struct {
 func (x *SQLValue) Reset() {
 	*x = SQLValue{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[111]
+		mi := &file_schema_proto_msgTypes[112]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *SQLValue) String() string {
 func (*SQLValue) ProtoMessage() {}
 
 func (x *SQLValue) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[111]
+	mi := &file_schema_proto_msgTypes[112]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *SQLValue) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use SQLValue.ProtoReflect.Descriptor instead.
 func (*SQLValue) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{111}
+	return file_schema_proto_rawDescGZIP(), []int{112}
 }
 
 func (m *SQLValue) GetValue() isSQLValue_Value {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type NewTxRequest struct {
 func (x *NewTxRequest) Reset() {
 	*x = NewTxRequest{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[112]
+		mi := &file_schema_proto_msgTypes[113]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *NewTxRequest) String() string {
 func (*NewTxRequest) ProtoMessage() {}
 
 func (x *NewTxRequest) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[112]
+	mi := &file_schema_proto_msgTypes[113]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *NewTxRequest) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use NewTxRequest.ProtoReflect.Descriptor instead.
 func (*NewTxRequest) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{112}
+	return file_schema_proto_rawDescGZIP(), []int{113}
 }
 
 func (x *NewTxRequest) GetMode() TxMode {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type NewTxResponse struct {
 func (x *NewTxResponse) Reset() {
 	*x = NewTxResponse{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[113]
+		mi := &file_schema_proto_msgTypes[114]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *NewTxResponse) String() string {
 func (*NewTxResponse) ProtoMessage() {}
 
 func (x *NewTxResponse) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[113]
+	mi := &file_schema_proto_msgTypes[114]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *NewTxResponse) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use NewTxResponse.ProtoReflect.Descriptor instead.
 func (*NewTxResponse) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{113}
+	return file_schema_proto_rawDescGZIP(), []int{114}
 }
 
 func (x *NewTxResponse) GetTransactionID() string {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type ErrorInfo struct {
 func (x *ErrorInfo) Reset() {
 	*x = ErrorInfo{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[114]
+		mi := &file_schema_proto_msgTypes[115]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *ErrorInfo) String() string {
 func (*ErrorInfo) ProtoMessage() {}
 
 func (x *ErrorInfo) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[114]
+	mi := &file_schema_proto_msgTypes[115]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *ErrorInfo) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use ErrorInfo.ProtoReflect.Descriptor instead.
 func (*ErrorInfo) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{114}
+	return file_schema_proto_rawDescGZIP(), []int{115}
 }
 
 func (x *ErrorInfo) GetCode() string {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type DebugInfo struct {
 func (x *DebugInfo) Reset() {
 	*x = DebugInfo{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[115]
+		mi := &file_schema_proto_msgTypes[116]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *DebugInfo) String() string {
 func (*DebugInfo) ProtoMessage() {}
 
 func (x *DebugInfo) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[115]
+	mi := &file_schema_proto_msgTypes[116]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *DebugInfo) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use DebugInfo.ProtoReflect.Descriptor instead.
 func (*DebugInfo) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{115}
+	return file_schema_proto_rawDescGZIP(), []int{116}
 }
 
 func (x *DebugInfo) GetStack() string {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type RetryInfo struct {
 func (x *RetryInfo) Reset() {
 	*x = RetryInfo{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[116]
+		mi := &file_schema_proto_msgTypes[117]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *RetryInfo) String() string {
 func (*RetryInfo) ProtoMessage() {}
 
 func (x *RetryInfo) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[116]
+	mi := &file_schema_proto_msgTypes[117]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *RetryInfo) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use RetryInfo.ProtoReflect.Descriptor instead.
 func (*RetryInfo) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{116}
+	return file_schema_proto_rawDescGZIP(), []int{117}
 }
 
 func (x *RetryInfo) GetRetryDelay() int32 {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type Precondition_KeyMustExistPrecondition struct {
 func (x *Precondition_KeyMustExistPrecondition) Reset() {
 	*x = Precondition_KeyMustExistPrecondition{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[117]
+		mi := &file_schema_proto_msgTypes[118]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *Precondition_KeyMustExistPrecondition) String() string {
 func (*Precondition_KeyMustExistPrecondition) ProtoMessage() {}
 
 func (x *Precondition_KeyMustExistPrecondition) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[117]
+	mi := &file_schema_proto_msgTypes[118]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type Precondition_KeyMustNotExistPrecondition struct {
 func (x *Precondition_KeyMustNotExistPrecondition) Reset() {
 	*x = Precondition_KeyMustNotExistPrecondition{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[118]
+		mi := &file_schema_proto_msgTypes[119]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *Precondition_KeyMustNotExistPrecondition) String() string {
 func (*Precondition_KeyMustNotExistPrecondition) ProtoMessage() {}
 
 func (x *Precondition_KeyMustNotExistPrecondition) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[118]
+	mi := &file_schema_proto_msgTypes[119]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type Precondition_KeyNotModifiedAfterTXPrecondition struct {
 func (x *Precondition_KeyNotModifiedAfterTXPrecondition) Reset() {
 	*x = Precondition_KeyNotModifiedAfterTXPrecondition{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[119]
+		mi := &file_schema_proto_msgTypes[120]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *Precondition_KeyNotModifiedAfterTXPrecondition) String() string {
 func (*Precondition_KeyNotModifiedAfterTXPrecondition) ProtoMessage() {}
 
 func (x *Precondition_KeyNotModifiedAfterTXPrecondition) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[119]
+	mi := &file_schema_proto_msgTypes[120]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[29].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*DualProof); i {
+			switch v := v.(*LinearAdvanceProof); i {
 			case 0:
 				return &v.state
 			case 1:
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[30].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*Tx); i {
+			switch v := v.(*DualProof); i {
 			case 0:
 				return &v.state
 			case 1:
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[31].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*TxEntry); i {
+			switch v := v.(*Tx); i {
 			case 0:
 				return &v.state
 			case 1:
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[32].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*KVMetadata); i {
+			switch v := v.(*TxEntry); i {
 			case 0:
 				return &v.state
 			case 1:
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[33].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*Expiration); i {
+			switch v := v.(*KVMetadata); i {
 			case 0:
 				return &v.state
 			case 1:
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[34].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*VerifiableTx); i {
+			switch v := v.(*Expiration); i {
 			case 0:
 				return &v.state
 			case 1:
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[35].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*VerifiableEntry); i {
+			switch v := v.(*VerifiableTx); i {
 			case 0:
 				return &v.state
 			case 1:
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[36].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*InclusionProof); i {
+			switch v := v.(*VerifiableEntry); i {
 			case 0:
 				return &v.state
 			case 1:
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[37].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*SetRequest); i {
+			switch v := v.(*InclusionProof); i {
 			case 0:
 				return &v.state
 			case 1:
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[38].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*KeyRequest); i {
+			switch v := v.(*SetRequest); i {
 			case 0:
 				return &v.state
 			case 1:
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[39].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*KeyListRequest); i {
+			switch v := v.(*KeyRequest); i {
 			case 0:
 				return &v.state
 			case 1:
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[40].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*DeleteKeysRequest); i {
+			switch v := v.(*KeyListRequest); i {
 			case 0:
 				return &v.state
 			case 1:
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[41].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*VerifiableSetRequest); i {
+			switch v := v.(*DeleteKeysRequest); i {
 			case 0:
 				return &v.state
 			case 1:
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[42].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*VerifiableGetRequest); i {
+			switch v := v.(*VerifiableSetRequest); i {
 			case 0:
 				return &v.state
 			case 1:
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[43].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*ServerInfoRequest); i {
+			switch v := v.(*VerifiableGetRequest); i {
 			case 0:
 				return &v.state
 			case 1:
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[44].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*ServerInfoResponse); i {
+			switch v := v.(*ServerInfoRequest); i {
 			case 0:
 				return &v.state
 			case 1:
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[45].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*HealthResponse); i {
+			switch v := v.(*ServerInfoResponse); i {
 			case 0:
 				return &v.state
 			case 1:
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[46].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*DatabaseHealthResponse); i {
+			switch v := v.(*HealthResponse); i {
 			case 0:
 				return &v.state
 			case 1:
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[47].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*ImmutableState); i {
+			switch v := v.(*DatabaseHealthResponse); i {
 			case 0:
 				return &v.state
 			case 1:
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[48].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*ReferenceRequest); i {
+			switch v := v.(*ImmutableState); i {
 			case 0:
 				return &v.state
 			case 1:
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[49].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*VerifiableReferenceRequest); i {
+			switch v := v.(*ReferenceRequest); i {
 			case 0:
 				return &v.state
 			case 1:
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[50].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*ZAddRequest); i {
+			switch v := v.(*VerifiableReferenceRequest); i {
 			case 0:
 				return &v.state
 			case 1:
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[51].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*Score); i {
+			switch v := v.(*ZAddRequest); i {
 			case 0:
 				return &v.state
 			case 1:
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[52].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*ZScanRequest); i {
+			switch v := v.(*Score); i {
 			case 0:
 				return &v.state
 			case 1:
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[53].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*HistoryRequest); i {
+			switch v := v.(*ZScanRequest); i {
 			case 0:
 				return &v.state
 			case 1:
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[54].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*VerifiableZAddRequest); i {
+			switch v := v.(*HistoryRequest); i {
 			case 0:
 				return &v.state
 			case 1:
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[55].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*TxRequest); i {
+			switch v := v.(*VerifiableZAddRequest); i {
 			case 0:
 				return &v.state
 			case 1:
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[56].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*EntriesSpec); i {
+			switch v := v.(*TxRequest); i {
 			case 0:
 				return &v.state
 			case 1:
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[57].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*EntryTypeSpec); i {
+			switch v := v.(*EntriesSpec); i {
 			case 0:
 				return &v.state
 			case 1:
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[58].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*VerifiableTxRequest); i {
+			switch v := v.(*EntryTypeSpec); i {
 			case 0:
 				return &v.state
 			case 1:
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[59].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*TxScanRequest); i {
+			switch v := v.(*VerifiableTxRequest); i {
 			case 0:
 				return &v.state
 			case 1:
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[60].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*TxList); i {
+			switch v := v.(*TxScanRequest); i {
 			case 0:
 				return &v.state
 			case 1:
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[61].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*ExportTxRequest); i {
+			switch v := v.(*TxList); i {
 			case 0:
 				return &v.state
 			case 1:
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[62].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*ReplicaState); i {
+			switch v := v.(*ExportTxRequest); i {
 			case 0:
 				return &v.state
 			case 1:
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[63].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*Database); i {
+			switch v := v.(*ReplicaState); i {
 			case 0:
 				return &v.state
 			case 1:
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[64].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*DatabaseSettings); i {
+			switch v := v.(*Database); i {
 			case 0:
 				return &v.state
 			case 1:
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[65].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*CreateDatabaseRequest); i {
+			switch v := v.(*DatabaseSettings); i {
 			case 0:
 				return &v.state
 			case 1:
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[66].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*CreateDatabaseResponse); i {
+			switch v := v.(*CreateDatabaseRequest); i {
 			case 0:
 				return &v.state
 			case 1:
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[67].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*UpdateDatabaseRequest); i {
+			switch v := v.(*CreateDatabaseResponse); i {
 			case 0:
 				return &v.state
 			case 1:
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[68].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*UpdateDatabaseResponse); i {
+			switch v := v.(*UpdateDatabaseRequest); i {
 			case 0:
 				return &v.state
 			case 1:
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[69].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*DatabaseSettingsRequest); i {
+			switch v := v.(*UpdateDatabaseResponse); i {
 			case 0:
 				return &v.state
 			case 1:
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[70].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*DatabaseSettingsResponse); i {
+			switch v := v.(*DatabaseSettingsRequest); i {
 			case 0:
 				return &v.state
 			case 1:
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[71].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*NullableUint32); i {
+			switch v := v.(*DatabaseSettingsResponse); i {
 			case 0:
 				return &v.state
 			case 1:
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[72].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*NullableUint64); i {
+			switch v := v.(*NullableUint32); i {
 			case 0:
 				return &v.state
 			case 1:
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[73].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*NullableFloat); i {
+			switch v := v.(*NullableUint64); i {
 			case 0:
 				return &v.state
 			case 1:
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[74].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*NullableBool); i {
+			switch v := v.(*NullableFloat); i {
 			case 0:
 				return &v.state
 			case 1:
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[75].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*NullableString); i {
+			switch v := v.(*NullableBool); i {
 			case 0:
 				return &v.state
 			case 1:
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[76].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*NullableMilliseconds); i {
+			switch v := v.(*NullableString); i {
 			case 0:
 				return &v.state
 			case 1:
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[77].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*DatabaseNullableSettings); i {
+			switch v := v.(*NullableMilliseconds); i {
 			case 0:
 				return &v.state
 			case 1:
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[78].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*ReplicationNullableSettings); i {
+			switch v := v.(*DatabaseNullableSettings); i {
 			case 0:
 				return &v.state
 			case 1:
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[79].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*IndexNullableSettings); i {
+			switch v := v.(*ReplicationNullableSettings); i {
 			case 0:
 				return &v.state
 			case 1:
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[80].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*AHTNullableSettings); i {
+			switch v := v.(*IndexNullableSettings); i {
 			case 0:
 				return &v.state
 			case 1:
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[81].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*LoadDatabaseRequest); i {
+			switch v := v.(*AHTNullableSettings); i {
 			case 0:
 				return &v.state
 			case 1:
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[82].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*LoadDatabaseResponse); i {
+			switch v := v.(*LoadDatabaseRequest); i {
 			case 0:
 				return &v.state
 			case 1:
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[83].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*UnloadDatabaseRequest); i {
+			switch v := v.(*LoadDatabaseResponse); i {
 			case 0:
 				return &v.state
 			case 1:
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[84].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*UnloadDatabaseResponse); i {
+			switch v := v.(*UnloadDatabaseRequest); i {
 			case 0:
 				return &v.state
 			case 1:
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[85].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*DeleteDatabaseRequest); i {
+			switch v := v.(*UnloadDatabaseResponse); i {
 			case 0:
 				return &v.state
 			case 1:
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[86].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*DeleteDatabaseResponse); i {
+			switch v := v.(*DeleteDatabaseRequest); i {
 			case 0:
 				return &v.state
 			case 1:
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[87].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*FlushIndexRequest); i {
+			switch v := v.(*DeleteDatabaseResponse); i {
 			case 0:
 				return &v.state
 			case 1:
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[88].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*FlushIndexResponse); i {
+			switch v := v.(*FlushIndexRequest); i {
 			case 0:
 				return &v.state
 			case 1:
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[89].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*Table); i {
+			switch v := v.(*FlushIndexResponse); i {
 			case 0:
 				return &v.state
 			case 1:
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[90].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*SQLGetRequest); i {
+			switch v := v.(*Table); i {
 			case 0:
 				return &v.state
 			case 1:
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[91].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*VerifiableSQLGetRequest); i {
+			switch v := v.(*SQLGetRequest); i {
 			case 0:
 				return &v.state
 			case 1:
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[92].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*SQLEntry); i {
+			switch v := v.(*VerifiableSQLGetRequest); i {
 			case 0:
 				return &v.state
 			case 1:
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[93].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*VerifiableSQLEntry); i {
+			switch v := v.(*SQLEntry); i {
 			case 0:
 				return &v.state
 			case 1:
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[94].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*UseDatabaseReply); i {
+			switch v := v.(*VerifiableSQLEntry); i {
 			case 0:
 				return &v.state
 			case 1:
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[95].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*ChangePermissionRequest); i {
+			switch v := v.(*UseDatabaseReply); i {
 			case 0:
 				return &v.state
 			case 1:
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[96].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*SetActiveUserRequest); i {
+			switch v := v.(*ChangePermissionRequest); i {
 			case 0:
 				return &v.state
 			case 1:
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[97].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*DatabaseListResponse); i {
+			switch v := v.(*SetActiveUserRequest); i {
 			case 0:
 				return &v.state
 			case 1:
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[98].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*DatabaseListRequestV2); i {
+			switch v := v.(*DatabaseListResponse); i {
 			case 0:
 				return &v.state
 			case 1:
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[99].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*DatabaseListResponseV2); i {
+			switch v := v.(*DatabaseListRequestV2); i {
 			case 0:
 				return &v.state
 			case 1:
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[100].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*DatabaseWithSettings); i {
+			switch v := v.(*DatabaseListResponseV2); i {
 			case 0:
 				return &v.state
 			case 1:
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[101].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*Chunk); i {
+			switch v := v.(*DatabaseWithSettings); i {
 			case 0:
 				return &v.state
 			case 1:
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[102].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*UseSnapshotRequest); i {
+			switch v := v.(*Chunk); i {
 			case 0:
 				return &v.state
 			case 1:
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[103].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*SQLExecRequest); i {
+			switch v := v.(*UseSnapshotRequest); i {
 			case 0:
 				return &v.state
 			case 1:
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[104].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*SQLQueryRequest); i {
+			switch v := v.(*SQLExecRequest); i {
 			case 0:
 				return &v.state
 			case 1:
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[105].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*NamedParam); i {
+			switch v := v.(*SQLQueryRequest); i {
 			case 0:
 				return &v.state
 			case 1:
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[106].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*SQLExecResult); i {
+			switch v := v.(*NamedParam); i {
 			case 0:
 				return &v.state
 			case 1:
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[107].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*CommittedSQLTx); i {
+			switch v := v.(*SQLExecResult); i {
 			case 0:
 				return &v.state
 			case 1:
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[108].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*SQLQueryResult); i {
+			switch v := v.(*CommittedSQLTx); i {
 			case 0:
 				return &v.state
 			case 1:
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[109].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*Column); i {
+			switch v := v.(*SQLQueryResult); i {
 			case 0:
 				return &v.state
 			case 1:
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[110].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*Row); i {
+			switch v := v.(*Column); i {
 			case 0:
 				return &v.state
 			case 1:
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[111].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*SQLValue); i {
+			switch v := v.(*Row); i {
 			case 0:
 				return &v.state
 			case 1:
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[112].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*NewTxRequest); i {
+			switch v := v.(*SQLValue); i {
 			case 0:
 				return &v.state
 			case 1:
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[113].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*NewTxResponse); i {
+			switch v := v.(*NewTxRequest); i {
 			case 0:
 				return &v.state
 			case 1:
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[114].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*ErrorInfo); i {
+			switch v := v.(*NewTxResponse); i {
 			case 0:
 				return &v.state
 			case 1:
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[115].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*DebugInfo); i {
+			switch v := v.(*ErrorInfo); i {
 			case 0:
 				return &v.state
 			case 1:
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[116].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*RetryInfo); i {
+			switch v := v.(*DebugInfo); i {
 			case 0:
 				return &v.state
 			case 1:
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[117].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*Precondition_KeyMustExistPrecondition); i {
+			switch v := v.(*RetryInfo); i {
 			case 0:
 				return &v.state
 			case 1:
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[118].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*Precondition_KeyMustNotExistPrecondition); i {
+			switch v := v.(*Precondition_KeyMustExistPrecondition); i {
 			case 0:
 				return &v.state
 			case 1:
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[119].Exporter = func(v interface{}, i int) interface{} {
+			switch v := v.(*Precondition_KeyMustNotExistPrecondition); i {
+			case 0:
+				return &v.state
+			case 1:
+				return &v.sizeCache
+			case 2:
+				return &v.unknownFields
+			default:
+				return nil
+			}
+		}
+		file_schema_proto_msgTypes[120].Exporter = func(v interface{}, i int) interface{} {
 			switch v := v.(*Precondition_KeyNotModifiedAfterTXPrecondition); i {
 			case 0:
 				return &v.state
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 		(*Op_ZAdd)(nil),
 		(*Op_Ref)(nil),
 	}
-	file_schema_proto_msgTypes[111].OneofWrappers = []interface{}{
+	file_schema_proto_msgTypes[112].OneofWrappers = []interface{}{
 		(*SQLValue_Null)(nil),
 		(*SQLValue_N)(nil),
 		(*SQLValue_S)(nil),
",[False]
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
 			RawDescriptor: file_schema_proto_rawDesc,
 			NumEnums:      3,
-			NumMessages:   126,
+			NumMessages:   127,
 			NumExtensions: 0,
 			NumServices:   1,
 		},
",[False]
GO-2022-1117,codenotary,immudb,7267d67e28be8f0257b71d734611a051593e8a81," func (a *defaultAuditor) audit() error {
 			return noErr
 		}
 
+		dualProof := schema.DualProofFromProto(vtx.DualProof)
+		err = schema.FillMissingLinearAdvanceProof(
+			ctx, dualProof, prevState.TxId, state.TxId, a.serviceClient,
+		)
+		if err != nil {
+			a.logger.Errorf(
+				""error fetching consistency proof for previous state %d: %v"",
+				prevState.TxId, err)
+			withError = true
+			return noErr
+		}
+
 		verified = store.VerifyDualProof(
-			schema.DualProofFromProto(vtx.DualProof),
+			dualProof,
 			prevState.TxId,
 			state.TxId,
 			schema.DigestFromProto(prevState.TxHash),
",[True]
GO-2022-1117,codenotary,immudb,7267d67e28be8f0257b71d734611a051593e8a81," func (c *immuClient) verifiedGet(ctx context.Context, kReq *schema.KeyRequest) (
 	}
 
 	if state.TxId > 0 {
-		verifies = store.VerifyDualProof(
+		err := c.verifyDualProof(
+			ctx,
 			dualProof,
 			sourceID,
 			targetID,
 			sourceAlh,
 			targetAlh,
 		)
-		if !verifies {
-			return nil, store.ErrCorruptedData
+		if err != nil {
+			return nil, err
 		}
 	}
 
",[True]
GO-2022-1117,codenotary,immudb,7267d67e28be8f0257b71d734611a051593e8a81," func (c *immuClient) VerifiedSet(ctx context.Context, key []byte, value []byte)
 	targetAlh = tx.Header().Alh()
 
 	if state.TxId > 0 {
-		verifies = store.VerifyDualProof(
-			schema.DualProofFromProto(verifiableTx.DualProof),
+		dualProof := schema.DualProofFromProto(verifiableTx.DualProof)
+		err := c.verifyDualProof(
+			ctx,
+			dualProof,
 			sourceID,
 			targetID,
 			sourceAlh,
 			targetAlh,
 		)
-
-		if !verifies {
-			return nil, store.ErrCorruptedData
+		if err != nil {
+			return nil, err
 		}
 	}
 
",[True]
GO-2022-1117,codenotary,immudb,7267d67e28be8f0257b71d734611a051593e8a81," func (c *immuClient) VerifiedTxByID(ctx context.Context, tx uint64) (*schema.Tx,
 	}
 
 	if state.TxId > 0 {
-		verifies := store.VerifyDualProof(
+		err := c.verifyDualProof(
+			ctx,
 			dualProof,
 			sourceID,
 			targetID,
 			sourceAlh,
 			targetAlh,
 		)
-		if !verifies {
-			return nil, store.ErrCorruptedData
+		if err != nil {
+			return nil, err
 		}
 	}
 
",[True]
GO-2022-1117,codenotary,immudb,7267d67e28be8f0257b71d734611a051593e8a81," func (c *immuClient) VerifiedSetReferenceAt(ctx context.Context, key []byte, ref
 	targetAlh = tx.Header().Alh()
 
 	if state.TxId > 0 {
-		verifies = store.VerifyDualProof(
-			schema.DualProofFromProto(verifiableTx.DualProof),
+		dualProof := schema.DualProofFromProto(verifiableTx.DualProof)
+		err := c.verifyDualProof(
+			ctx,
+			dualProof,
 			sourceID,
 			targetID,
 			sourceAlh,
 			targetAlh,
 		)
-		if !verifies {
-			return nil, store.ErrCorruptedData
+		if err != nil {
+			return nil, err
 		}
 	}
 
",[True]
GO-2022-1117,codenotary,immudb,7267d67e28be8f0257b71d734611a051593e8a81," func (c *immuClient) VerifiedZAddAt(ctx context.Context, set []byte, score float
 	targetAlh = tx.Header().Alh()
 
 	if state.TxId > 0 {
-		verifies = store.VerifyDualProof(
-			schema.DualProofFromProto(vtx.DualProof),
+		dualProof := schema.DualProofFromProto(vtx.DualProof)
+		err := c.verifyDualProof(
+			ctx,
+			dualProof,
 			sourceID,
 			targetID,
 			sourceAlh,
 			targetAlh,
 		)
-		if !verifies {
-			return nil, store.ErrCorruptedData
+		if err != nil {
+			return nil, err
 		}
 	}
 
",[True]
GO-2022-1117,codenotary,immudb,7267d67e28be8f0257b71d734611a051593e8a81," func (c *immuClient) VerifyRow(ctx context.Context, row *schema.Row, table strin
 	}
 
 	if state.TxId > 0 {
-		verifies = store.VerifyDualProof(
+		err := c.verifyDualProof(
+			ctx,
 			dualProof,
 			sourceID,
 			targetID,
 			sourceAlh,
 			targetAlh,
 		)
-		if !verifies {
-			return store.ErrCorruptedData
+		if err != nil {
+			return err
 		}
 	}
 
",[True]
GO-2022-1117,codenotary,immudb,7267d67e28be8f0257b71d734611a051593e8a81," func (c *immuClient) _streamVerifiedSet(ctx context.Context, kvs []*stream.KeyVa
 	targetAlh = tx.Header().Alh()
 
 	if state.TxId > 0 {
-		verifies = store.VerifyDualProof(
-			schema.DualProofFromProto(verifiableTx.DualProof),
+		dualProof := schema.DualProofFromProto(verifiableTx.DualProof)
+		err := c.verifyDualProof(
+			ctx,
+			dualProof,
 			sourceID,
 			targetID,
 			sourceAlh,
 			targetAlh,
 		)
-
-		if !verifies {
-			return nil, store.ErrCorruptedData
+		if err != nil {
+			return nil, err
 		}
 	}
 
",[True]
GO-2022-1117,codenotary,immudb,7267d67e28be8f0257b71d734611a051593e8a81," func (c *immuClient) _streamVerifiedGet(ctx context.Context, req *schema.Verifia
 	}
 
 	if state.TxId > 0 {
-		verifies = store.VerifyDualProof(
+		err := c.verifyDualProof(
+			ctx,
 			dualProof,
 			sourceID,
 			targetID,
 			sourceAlh,
 			targetAlh,
 		)
-		if !verifies {
-			return nil, store.ErrCorruptedData
+		if err != nil {
+			return nil, err
 		}
 	}
 
",[True]
GO-2023-1681,containers,podman,6ca857feb07a5fdc96fd947afef03916291673d8," func (c *Container) export(out io.Writer) error {
 		}()
 	}
 
-	input, err := archive.Tar(mountPoint, archive.Uncompressed)
+	input, err := chrootarchive.Tar(mountPoint, nil, mountPoint)
 	if err != nil {
 		return fmt.Errorf(""reading container directory %q: %w"", c.ID(), err)
 	}
",[False]
GO-2023-1681,containers,podman,6ca857feb07a5fdc96fd947afef03916291673d8," func CreateTarFromSrc(source string, dest string) error {
 		return fmt.Errorf(""could not create tarball file '%s': %w"", dest, err)
 	}
 	defer file.Close()
-	return TarToFilesystem(source, file)
+	return TarChrootToFilesystem(source, file)
 }
 
 // TarToFilesystem creates a tarball from source and writes to an os.file
",[True]
GO-2021-0099,deislabs,oras,96cd90423303f1bb42bd043cb4c36085e6e91e8e," func extractTarDirectory(root, prefix string, r io.Reader) error {
 
 		// Name check
 		name := header.Name
-		path, err := filepath.Rel(prefix, name)
+		path, err := ensureBasePath(root, prefix, name)
 		if err != nil {
 			return err
 		}
-		if strings.HasPrefix(path, ""../"") {
-			return fmt.Errorf(""%q does not have prefix %q"", name, prefix)
-		}
 		path = filepath.Join(root, path)
 
+		// Link check
+		switch header.Typeflag {
+		case tar.TypeLink, tar.TypeSymlink:
+			link := header.Linkname
+			if !filepath.IsAbs(link) {
+				link = filepath.Join(filepath.Dir(name), link)
+			}
+			if _, err := ensureBasePath(root, prefix, link); err != nil {
+				return err
+			}
+		}
+
 		// Create content
 		switch header.Typeflag {
 		case tar.TypeReg:
",[True]
GO-2023-1547,helm,helm,293b50c65d4d56187cd4e2f390f0ada46b4c4737," func addInstallFlags(cmd *cobra.Command, f *pflag.FlagSet, client *action.Instal
 	f.BoolVar(&client.Atomic, ""atomic"", false, ""if set, the installation process deletes the installation on failure. The --wait flag will be set automatically if --atomic is used"")
 	f.BoolVar(&client.SkipCRDs, ""skip-crds"", false, ""if set, no CRDs will be installed. By default, CRDs are installed if not already present"")
 	f.BoolVar(&client.SubNotes, ""render-subchart-notes"", false, ""if set, render subchart notes along with the parent"")
+	f.BoolVar(&client.EnableDNS, ""enable-dns"", false, ""enable DNS lookups when rendering templates"")
 	addValueOptionsFlags(f, valueOpts)
 	addChartPathOptionsFlags(f, &client.ChartPathOptions)
 
",[True]
GO-2023-1547,helm,helm,293b50c65d4d56187cd4e2f390f0ada46b4c4737," func newUpgradeCmd(cfg *action.Configuration, out io.Writer) *cobra.Command {
 					instClient.SubNotes = client.SubNotes
 					instClient.Description = client.Description
 					instClient.DependencyUpdate = client.DependencyUpdate
+					instClient.EnableDNS = client.EnableDNS
 
 					rel, err := runInstall(args, instClient, valueOpts, out)
 					if err != nil {
",[True]
GO-2023-1547,helm,helm,293b50c65d4d56187cd4e2f390f0ada46b4c4737," func newUpgradeCmd(cfg *action.Configuration, out io.Writer) *cobra.Command {
 	f.BoolVar(&client.SubNotes, ""render-subchart-notes"", false, ""if set, render subchart notes along with the parent"")
 	f.StringVar(&client.Description, ""description"", """", ""add a custom description"")
 	f.BoolVar(&client.DependencyUpdate, ""dependency-update"", false, ""update dependencies if they are missing before installing the chart"")
+	f.BoolVar(&client.EnableDNS, ""enable-dns"", false, ""enable DNS lookups when rendering templates"")
 	addChartPathOptionsFlags(f, &client.ChartPathOptions)
 	addValueOptionsFlags(f, valueOpts)
 	bindOutputFlag(cmd, &outfmt)
",[True]
GO-2023-1547,helm,helm,293b50c65d4d56187cd4e2f390f0ada46b4c4737," type Configuration struct {
 //
 // TODO: This function is badly in need of a refactor.
 // TODO: As part of the refactor the duplicate code in cmd/helm/template.go should be removed
-//       This code has to do with writing files to disk.
-func (cfg *Configuration) renderResources(ch *chart.Chart, values chartutil.Values, releaseName, outputDir string, subNotes, useReleaseName, includeCrds bool, pr postrender.PostRenderer, dryRun bool) ([]*release.Hook, *bytes.Buffer, string, error) {
+//
+//	This code has to do with writing files to disk.
+func (cfg *Configuration) renderResources(ch *chart.Chart, values chartutil.Values, releaseName, outputDir string, subNotes, useReleaseName, includeCrds bool, pr postrender.PostRenderer, dryRun, enableDNS bool) ([]*release.Hook, *bytes.Buffer, string, error) {
 	hs := []*release.Hook{}
 	b := bytes.NewBuffer(nil)
 
",[True]
GO-2023-1547,helm,helm,293b50c65d4d56187cd4e2f390f0ada46b4c4737," func (cfg *Configuration) renderResources(ch *chart.Chart, values chartutil.Valu
 		if err != nil {
 			return hs, b, """", err
 		}
-		files, err2 = engine.RenderWithClient(ch, values, restConfig)
+		e := engine.New(restConfig)
+		e.EnableDNS = enableDNS
+		files, err2 = e.Render(ch, values)
 	} else {
-		files, err2 = engine.Render(ch, values)
+		var e engine.Engine
+		e.EnableDNS = enableDNS
+		files, err2 = e.Render(ch, values)
 	}
 
 	if err2 != nil {
",[True]
GO-2023-1547,helm,helm,293b50c65d4d56187cd4e2f390f0ada46b4c4737," func (i *Install) RunWithContext(ctx context.Context, chrt *chart.Chart, vals ma
 	rel := i.createRelease(chrt, vals)
 
 	var manifestDoc *bytes.Buffer
-	rel.Hooks, manifestDoc, rel.Info.Notes, err = i.cfg.renderResources(chrt, valuesToRender, i.ReleaseName, i.OutputDir, i.SubNotes, i.UseReleaseName, i.IncludeCRDs, i.PostRenderer, i.DryRun)
+	rel.Hooks, manifestDoc, rel.Info.Notes, err = i.cfg.renderResources(chrt, valuesToRender, i.ReleaseName, i.OutputDir, i.SubNotes, i.UseReleaseName, i.IncludeCRDs, i.PostRenderer, i.DryRun, i.EnableDNS)
 	// Even for errors, attach this if available
 	if manifestDoc != nil {
 		rel.Manifest = manifestDoc.String()
",[True]
GO-2023-1547,helm,helm,293b50c65d4d56187cd4e2f390f0ada46b4c4737," func (i *Install) failRelease(rel *release.Release, err error) (*release.Release
 //
 // Roughly, this will return an error if name is
 //
-//	- empty
-//	- too long
-//	- already in use, and not deleted
-//	- used by a deleted release, and i.Replace is false
+//   - empty
+//   - too long
+//   - already in use, and not deleted
+//   - used by a deleted release, and i.Replace is false
 func (i *Install) availableName() error {
 	start := i.ReleaseName
 
",[False]
GO-2023-1547,helm,helm,293b50c65d4d56187cd4e2f390f0ada46b4c4737," func (u *Upgrade) prepareUpgrade(name string, chart *chart.Chart, vals map[strin
 		return nil, nil, err
 	}
 
-	hooks, manifestDoc, notesTxt, err := u.cfg.renderResources(chart, valuesToRender, """", """", u.SubNotes, false, false, u.PostRenderer, u.DryRun)
+	hooks, manifestDoc, notesTxt, err := u.cfg.renderResources(chart, valuesToRender, """", """", u.SubNotes, false, false, u.PostRenderer, u.DryRun, u.EnableDNS)
 	if err != nil {
 		return nil, nil, err
 	}
",[True]
GO-2023-1547,helm,helm,293b50c65d4d56187cd4e2f390f0ada46b4c4737," type Engine struct {
 	LintMode bool
 	// the rest config to connect to the kubernetes api
 	config *rest.Config
+	// EnableDNS tells the engine to allow DNS lookups when rendering templates
+	EnableDNS bool
+}
+
+// New creates a new instance of Engine using the passed in rest config.
+func New(config *rest.Config) Engine {
+	return Engine{
+		config: config,
+	}
 }
 
 // Render takes a chart, optional values, and value overrides, and attempts to render the Go templates.
",[False]
GO-2023-1547,helm,helm,293b50c65d4d56187cd4e2f390f0ada46b4c4737," func (e Engine) initFunMap(t *template.Template, referenceTpls map[string]render
 		funcMap[""lookup""] = NewLookupFunction(e.config)
 	}
 
+	// When DNS lookups are not enabled override the sprig function and return
+	// an empty string.
+	if !e.EnableDNS {
+		funcMap[""getHostByName""] = func(name string) string {
+			return """"
+		}
+	}
+
 	t.Funcs(funcMap)
 }
 
",[True]
GO-2021-0077,etcd-io,etcd,bf9d0d8291dc71ecbfb2690612954e1a298154b2," func (as *authStore) AuthInfoFromTLS(ctx context.Context) (ai *AuthInfo) {
 			Username: chains[0].Subject.CommonName,
 			Revision: as.Revision(),
 		}
+		md, ok := metadata.FromIncomingContext(ctx)
+		if !ok {
+			return nil
+		}
+
+		// gRPC-gateway proxy request to etcd server includes Grpcgateway-Accept
+		// header. The proxy uses etcd client server certificate. If the certificate
+		// has a CommonName we should never use this for authentication.
+		if gw := md[""grpcgateway-accept""]; len(gw) > 0 {
+			if as.lg != nil {
+				as.lg.Warn(
+					""ignoring common name in gRPC-gateway proxy request"",
+					zap.String(""common-name"", ai.Username),
+					zap.String(""user-name"", ai.Username),
+					zap.Uint64(""revision"", ai.Revision),
+				)
+			} else {
+				plog.Warningf(""ignoring common name in gRPC-gateway proxy request %s"", ai.Username)
+			}
+			return nil
+		}
 		if as.lg != nil {
 			as.lg.Debug(
 				""found command name"",
",[True]
GO-2020-0036,go-yaml,yaml,53403b58ad1b561927d19068c655246f2db79d48," func trace(args ...interface{}) func() {
 func yaml_parser_fetch_more_tokens(parser *yaml_parser_t) bool {
 	// While we need more tokens to fetch, do it.
 	for {
-		// Check if we really need to fetch more tokens.
-		need_more_tokens := false
-
-		if parser.tokens_head == len(parser.tokens) {
-			// Queue is empty.
-			need_more_tokens = true
-		} else {
-			// Check if any potential simple key may occupy the head position.
-			for i := len(parser.simple_keys) - 1; i >= 0; i-- {
-				simple_key := &parser.simple_keys[i]
-				if simple_key.token_number < parser.tokens_parsed {
-					break
-				}
-				if valid, ok := yaml_simple_key_is_valid(parser, simple_key); !ok {
-					return false
-				} else if valid && simple_key.token_number == parser.tokens_parsed {
-					need_more_tokens = true
-					break
-				}
+		if parser.tokens_head != len(parser.tokens) {
+			// If queue is non-empty, check if any potential simple key may
+			// occupy the head position.
+			head_tok_idx, ok := parser.simple_keys_by_tok[parser.tokens_parsed]
+			if !ok {
+				break
+			} else if valid, ok := yaml_simple_key_is_valid(parser, &parser.simple_keys[head_tok_idx]); !ok {
+				return false
+			} else if !valid {
+				break
 			}
 		}
-
-		// We are finished.
-		if !need_more_tokens {
-			break
-		}
 		// Fetch the next token.
 		if !yaml_parser_fetch_next_token(parser) {
 			return false
",[True]
GO-2020-0036,go-yaml,yaml,53403b58ad1b561927d19068c655246f2db79d48," func yaml_parser_save_simple_key(parser *yaml_parser_t) bool {
 			return false
 		}
 		parser.simple_keys[len(parser.simple_keys)-1] = simple_key
+		parser.simple_keys_by_tok[simple_key.token_number] = len(parser.simple_keys) - 1
 	}
 	return true
 }
",[True]
GO-2020-0036,go-yaml,yaml,53403b58ad1b561927d19068c655246f2db79d48," func yaml_parser_remove_simple_key(parser *yaml_parser_t) bool {
 				""while scanning a simple key"", parser.simple_keys[i].mark,
 				""could not find expected ':'"")
 		}
+		// Remove the key from the stack.
+		parser.simple_keys[i].possible = false
+		delete(parser.simple_keys_by_tok, parser.simple_keys[i].token_number)
 	}
-	// Remove the key from the stack.
-	parser.simple_keys[i].possible = false
 	return true
 }
 
",[True]
GO-2020-0036,go-yaml,yaml,53403b58ad1b561927d19068c655246f2db79d48," func yaml_parser_increase_flow_level(parser *yaml_parser_t) bool {
 func yaml_parser_decrease_flow_level(parser *yaml_parser_t) bool {
 	if parser.flow_level > 0 {
 		parser.flow_level--
-		parser.simple_keys = parser.simple_keys[:len(parser.simple_keys)-1]
+		last := len(parser.simple_keys) - 1
+		delete(parser.simple_keys_by_tok, parser.simple_keys[last].token_number)
+		parser.simple_keys = parser.simple_keys[:last]
 	}
 	return true
 }
",[True]
GO-2020-0036,go-yaml,yaml,53403b58ad1b561927d19068c655246f2db79d48," func yaml_parser_fetch_stream_start(parser *yaml_parser_t) bool {
 	// Initialize the simple key stack.
 	parser.simple_keys = append(parser.simple_keys, yaml_simple_key_t{})
 
+	parser.simple_keys_by_tok = make(map[int]int)
+
 	// A simple key is allowed at the beginning of the stream.
 	parser.simple_key_allowed = true
 
",[True]
GO-2020-0036,go-yaml,yaml,53403b58ad1b561927d19068c655246f2db79d48," func yaml_parser_fetch_value(parser *yaml_parser_t) bool {
 
 		// Remove the simple key.
 		simple_key.possible = false
+		delete(parser.simple_keys_by_tok, simple_key.token_number)
 
 		// A simple key cannot follow another simple key.
 		parser.simple_key_allowed = false
",[True]
GO-2023-1600,kitabisa,teler-waf,6e1b0e19b8adc1bbc3513a986025d4adf88d59f8," func (t *Teler) checkCustomRules(r *http.Request) error {
 // If a match is found, it returns an error indicating a common web attack has been detected.
 // If no match is found, it returns nil.
 func (t *Teler) checkCommonWebAttack(r *http.Request) error {
-	// Decode the URL-encoded and unescape HTML entities request URI of the URL
-	uri := stringDeUnescape(r.URL.RequestURI())
+	// Decode the URL-encoded and unescape HTML entities in the
+	// request URI of the URL then remove all special characters
+	uri := removeSpecialChars(stringDeUnescape(r.URL.RequestURI()))
 
 	// Declare byte slice for request body.
 	var body string
",[True]
GO-2023-1600,kitabisa,teler-waf,6e1b0e19b8adc1bbc3513a986025d4adf88d59f8," func (t *Teler) checkCommonWebAttack(r *http.Request) error {
 		body = buf.String()
 	}
 
-	// Decode the URL-encoded and unescape HTML entities of body
-	body = stringDeUnescape(body)
+	// Decode the URL-encoded and unescape HTML entities in the
+	// body of request then remove all special characters
+	body = removeSpecialChars(stringDeUnescape(body))
 
 	// Iterate over the filters in the CommonWebAttack data stored in the t.threat.cwa.Filters field
 	for _, filter := range t.threat.cwa.Filters {
",[True]
GO-2021-0086,documize,community,a4384210d4d0d6b18e6fdb7e155de96d4a1cf9f3," func (*Provider) Command(ctx *provider.Context, w http.ResponseWriter, r *http.R
 
 // Render converts markdown data into HTML suitable for browser rendering.
 func (*Provider) Render(ctx *provider.Context, config, data string) string {
-	result := blackfriday.Run([]byte(data))
+	unsafe := blackfriday.Run([]byte(data))
 
-	return string(result)
+	safe := bluemonday.UGCPolicy().SanitizeBytes(unsafe)
+
+	return string(safe)
 }
 
 // Refresh just sends back data as-is.
",[True]
GO-2023-1567,caddyserver,caddy,78b5356f2b1945a90de1ef7f2c7669d82098edbd," func (fsrv *FileServer) directoryListing(files []os.FileInfo, canGoUp bool, root
 
 		isDir := f.IsDir() || isSymlinkTargetDir(f, root, urlPath)
 
-		u := url.URL{Path: url.PathEscape(name)}
-
 		// add the slash after the escape of path to avoid escaping the slash as well
 		if isDir {
-			u.Path += ""/""
+			name += ""/""
 			dirCount++
 		} else {
 			fileCount++
",[True]
GO-2023-1567,caddyserver,caddy,78b5356f2b1945a90de1ef7f2c7669d82098edbd," func (fsrv *FileServer) directoryListing(files []os.FileInfo, canGoUp bool, root
 			// was already set above.
 		}
 
+		u := url.URL{Path: ""./"" + name} // prepend with ""./"" to fix paths with ':' in the name
+
 		fileInfos = append(fileInfos, fileInfo{
 			IsDir:     isDir,
 			IsSymlink: fileIsSymlink,
",[True]
GO-2023-1567,caddyserver,caddy,78b5356f2b1945a90de1ef7f2c7669d82098edbd," func StatusCodeMatches(actual, configured int) bool {
 // never be outside of root. The resulting path can be used
 // with the local file system.
 func SanitizedPathJoin(root, reqPath string) string {
-	reqPath, _ = url.PathUnescape(reqPath)
 	if root == """" {
 		root = "".""
 	}
",[True]
GO-2023-1526,hakobe,paranoidhttp,07f671da14ce63a80f4e52432b32e8d178d75fd3," func safeAddr(ctx context.Context, resolver *net.Resolver, hostport string, opts
 
 	ip := net.ParseIP(host)
 	if ip != nil {
-		if ip.To4() != nil && c.isIPForbidden(ip) {
+		if ip.IsUnspecified() || (ip.To4() != nil && c.isIPForbidden(ip)) {
 			return """", fmt.Errorf(""bad ip is detected: %v"", ip)
 		}
 		return net.JoinHostPort(ip.String(), port), nil
",[True]
GO-2023-2024,libp2p,go-libp2p,45d3c6fff662ddd6938982e7e9309ad5fa2ad8dd," func ConsumeEnvelope(data []byte, domain string) (envelope *Envelope, rec Record
 
 	err = e.validate(domain)
 	if err != nil {
-		return e, nil, fmt.Errorf(""failed to validate envelope: %w"", err)
+		return nil, nil, fmt.Errorf(""failed to validate envelope: %w"", err)
 	}
 
 	rec, err = e.Record()
 	if err != nil {
-		return e, nil, fmt.Errorf(""failed to unmarshal envelope payload: %w"", err)
+		return nil, nil, fmt.Errorf(""failed to unmarshal envelope payload: %w"", err)
 	}
 	return e, rec, nil
 }
",[True]
GO-2023-2024,libp2p,go-libp2p,45d3c6fff662ddd6938982e7e9309ad5fa2ad8dd," func (ids *idService) consumeMessage(mes *pb.Identify, c network.Conn, isPush bo
 
 	// add signed addrs if we have them and the peerstore supports them
 	cab, ok := peerstore.GetCertifiedAddrBook(ids.Host.Peerstore())
-	if ok && signedPeerRecord != nil {
-		_, addErr := cab.ConsumePeerRecord(signedPeerRecord, ttl)
-		if addErr != nil {
-			log.Debugf(""error adding signed addrs to peerstore: %v"", addErr)
+	if ok && signedPeerRecord != nil && signedPeerRecord.PublicKey != nil {
+		id, err := peer.IDFromPublicKey(signedPeerRecord.PublicKey)
+		if err != nil {
+			log.Debugf(""failed to derive peer ID from peer record: %s"", err)
+		} else if id != c.RemotePeer() {
+			log.Debugf(""received signed peer record for unexpected peer ID. expected %s, got %s"", c.RemotePeer(), id)
+		} else if _, err := cab.ConsumePeerRecord(signedPeerRecord, ttl); err != nil {
+			log.Debugf(""error adding signed addrs to peerstore: %v"", err)
 		}
 	} else {
 		ids.Host.Peerstore().AddAddrs(p, lmaddrs, ttl)
",[True]
GO-2022-0956,go-yaml,yaml,f221b8435cfb71e54062f6c6e99e9ade30b124d5," func yaml_parser_increase_flow_level(parser *yaml_parser_t) bool {
 
 	// Increase the flow level.
 	parser.flow_level++
+	if parser.flow_level > max_flow_level {
+		return yaml_parser_set_scanner_error(parser,
+			""while increasing flow level"", parser.simple_keys[len(parser.simple_keys)-1].mark,
+			fmt.Sprintf(""exceeded max depth of %d"", max_flow_level))
+	}
 	return true
 }
 
",[True]
GO-2022-0956,go-yaml,yaml,f221b8435cfb71e54062f6c6e99e9ade30b124d5," func yaml_parser_roll_indent(parser *yaml_parser_t, column, number int, typ yaml
 		// indentation level.
 		parser.indents = append(parser.indents, parser.indent)
 		parser.indent = column
+		if len(parser.indents) > max_indents {
+			return yaml_parser_set_scanner_error(parser,
+				""while increasing indent level"", parser.simple_keys[len(parser.simple_keys)-1].mark,
+				fmt.Sprintf(""exceeded max depth of %d"", max_indents))
+		}
 
 		// Create a token and insert it into the queue.
 		token := yaml_token_t{
",[True]
GO-2023-1772,distribution,distribution,f55a6552b006a381d9167e328808565dd2bf77dc," func Parse(rd io.Reader) (*Configuration, error) {
 					if v0_1.Loglevel != Loglevel("""") {
 						v0_1.Loglevel = Loglevel("""")
 					}
+
+					if v0_1.Catalog.MaxEntries <= 0 {
+						v0_1.Catalog.MaxEntries = 1000
+					}
+
 					if v0_1.Storage.Type() == """" {
 						return nil, errors.New(""no storage configuration provided"")
 					}
",[False]
GO-2023-1772,distribution,distribution,f55a6552b006a381d9167e328808565dd2bf77dc," func (ch *catalogHandler) GetCatalog(w http.ResponseWriter, r *http.Request) {
 
 	q := r.URL.Query()
 	lastEntry := q.Get(""last"")
-	maxEntries, err := strconv.Atoi(q.Get(""n""))
-	if err != nil || maxEntries < 0 {
-		maxEntries = maximumReturnedEntries
+
+	entries := defaultReturnedEntries
+	maximumConfiguredEntries := ch.App.Config.Catalog.MaxEntries
+
+	// parse n, if n is negative abort with an error
+	if n := q.Get(""n""); n != """" {
+		parsedMax, err := strconv.Atoi(n)
+		if err != nil || parsedMax < 0 {
+			ch.Errors = append(ch.Errors, v2.ErrorCodePaginationNumberInvalid.WithDetail(map[string]string{""n"": n}))
+			return
+		}
+
+		// if a client requests more than it's allowed to receive
+		if parsedMax > maximumConfiguredEntries {
+			ch.Errors = append(ch.Errors, v2.ErrorCodePaginationNumberInvalid.WithDetail(map[string]int{""n"": parsedMax}))
+			return
+		}
+		entries = parsedMax
 	}
 
-	repos := make([]string, maxEntries)
+	// then enforce entries to be between 0 & maximumConfiguredEntries
+	// max(0, min(entries, maximumConfiguredEntries))
+	if entries < 0 || entries > maximumConfiguredEntries {
+		entries = maximumConfiguredEntries
+	}
 
-	filled, err := ch.App.registry.Repositories(ch.Context, repos, lastEntry)
-	_, pathNotFound := err.(driver.PathNotFoundError)
+	repos := make([]string, entries)
+	filled := 0
 
-	if err == io.EOF || pathNotFound {
+	// entries is guaranteed to be >= 0 and < maximumConfiguredEntries
+	if entries == 0 {
 		moreEntries = false
-	} else if err != nil {
-		ch.Errors = append(ch.Errors, errcode.ErrorCodeUnknown.WithDetail(err))
-		return
+	} else {
+		returnedRepositories, err := ch.App.registry.Repositories(ch.Context, repos, lastEntry)
+		if err != nil {
+			_, pathNotFound := err.(driver.PathNotFoundError)
+			if err != io.EOF && !pathNotFound {
+				ch.Errors = append(ch.Errors, errcode.ErrorCodeUnknown.WithDetail(err))
+				return
+			}
+			// err is either io.EOF or not PathNotFoundError
+			moreEntries = false
+		}
+		filled = returnedRepositories
 	}
 
 	w.Header().Set(""Content-Type"", ""application/json"")
 
 	// Add a link header if there are more entries to retrieve
 	if moreEntries {
-		lastEntry = repos[len(repos)-1]
-		urlStr, err := createLinkEntry(r.URL.String(), maxEntries, lastEntry)
+		lastEntry = repos[filled-1]
+		urlStr, err := createLinkEntry(r.URL.String(), entries, lastEntry)
 		if err != nil {
 			ch.Errors = append(ch.Errors, errcode.ErrorCodeUnknown.WithDetail(err))
 			return
",[True]
GO-2021-0053,gogo,protobuf,b03c65ea87cdc3521ede29f62fe3ce239267c1bc," func (p *unmarshal) field(file *generator.FileDescriptor, msg *generator.Descrip
 			p.P(`return err`)
 			p.Out()
 			p.P(`}`)
-			p.P(`if skippy < 0 {`)
+			p.P(`if (skippy < 0) || (iNdEx + skippy) < 0 {`)
 			p.In()
 			p.P(`return ErrInvalidLength`, p.localName)
 			p.Out()
",[True]
GO-2021-0053,gogo,protobuf,b03c65ea87cdc3521ede29f62fe3ce239267c1bc," func (p *unmarshal) Generate(file *generator.FileDescriptor) {
 			p.P(`return err`)
 			p.Out()
 			p.P(`}`)
-			p.P(`if skippy < 0 {`)
-			p.In()
-			p.P(`return ErrInvalidLength`, p.localName)
-			p.Out()
-			p.P(`}`)
-			p.P(`if (iNdEx + skippy) < 0 {`)
+			p.P(`if (skippy < 0) || (iNdEx + skippy) < 0 {`)
 			p.In()
 			p.P(`return ErrInvalidLength`, p.localName)
 			p.Out()
",[True]
GO-2021-0053,gogo,protobuf,b03c65ea87cdc3521ede29f62fe3ce239267c1bc," func (p *unmarshal) Generate(file *generator.FileDescriptor) {
 		p.P(`return err`)
 		p.Out()
 		p.P(`}`)
-		p.P(`if skippy < 0 {`)
-		p.In()
-		p.P(`return ErrInvalidLength`, p.localName)
-		p.Out()
-		p.P(`}`)
-		p.P(`if (iNdEx + skippy) < 0 {`)
+		p.P(`if (skippy < 0) || (iNdEx + skippy) < 0 {`)
 		p.In()
 		p.P(`return ErrInvalidLength`, p.localName)
 		p.Out()
",[True]
GO-2021-0053,gogo,protobuf,b03c65ea87cdc3521ede29f62fe3ce239267c1bc," func (m *Any) Unmarshal(dAtA []byte) error {
 			if err != nil {
 				return err
 			}
-			if skippy < 0 {
-				return ErrInvalidLengthAny
-			}
-			if (iNdEx + skippy) < 0 {
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
 				return ErrInvalidLengthAny
 			}
 			if (iNdEx + skippy) > l {
",[False]
GO-2021-0053,gogo,protobuf,b03c65ea87cdc3521ede29f62fe3ce239267c1bc," func (m *Api) Unmarshal(dAtA []byte) error {
 			if err != nil {
 				return err
 			}
-			if skippy < 0 {
-				return ErrInvalidLengthApi
-			}
-			if (iNdEx + skippy) < 0 {
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
 				return ErrInvalidLengthApi
 			}
 			if (iNdEx + skippy) > l {
",[False]
GO-2021-0053,gogo,protobuf,b03c65ea87cdc3521ede29f62fe3ce239267c1bc," func (m *Method) Unmarshal(dAtA []byte) error {
 			if err != nil {
 				return err
 			}
-			if skippy < 0 {
-				return ErrInvalidLengthApi
-			}
-			if (iNdEx + skippy) < 0 {
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
 				return ErrInvalidLengthApi
 			}
 			if (iNdEx + skippy) > l {
",[False]
GO-2021-0053,gogo,protobuf,b03c65ea87cdc3521ede29f62fe3ce239267c1bc," func (m *Mixin) Unmarshal(dAtA []byte) error {
 			if err != nil {
 				return err
 			}
-			if skippy < 0 {
-				return ErrInvalidLengthApi
-			}
-			if (iNdEx + skippy) < 0 {
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
 				return ErrInvalidLengthApi
 			}
 			if (iNdEx + skippy) > l {
",[False]
GO-2021-0053,gogo,protobuf,b03c65ea87cdc3521ede29f62fe3ce239267c1bc," func (m *Duration) Unmarshal(dAtA []byte) error {
 			if err != nil {
 				return err
 			}
-			if skippy < 0 {
-				return ErrInvalidLengthDuration
-			}
-			if (iNdEx + skippy) < 0 {
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
 				return ErrInvalidLengthDuration
 			}
 			if (iNdEx + skippy) > l {
",[False]
GO-2021-0053,gogo,protobuf,b03c65ea87cdc3521ede29f62fe3ce239267c1bc," func (m *Empty) Unmarshal(dAtA []byte) error {
 			if err != nil {
 				return err
 			}
-			if skippy < 0 {
-				return ErrInvalidLengthEmpty
-			}
-			if (iNdEx + skippy) < 0 {
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
 				return ErrInvalidLengthEmpty
 			}
 			if (iNdEx + skippy) > l {
",[False]
GO-2021-0053,gogo,protobuf,b03c65ea87cdc3521ede29f62fe3ce239267c1bc," func (m *FieldMask) Unmarshal(dAtA []byte) error {
 			if err != nil {
 				return err
 			}
-			if skippy < 0 {
-				return ErrInvalidLengthFieldMask
-			}
-			if (iNdEx + skippy) < 0 {
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
 				return ErrInvalidLengthFieldMask
 			}
 			if (iNdEx + skippy) > l {
",[False]
GO-2021-0053,gogo,protobuf,b03c65ea87cdc3521ede29f62fe3ce239267c1bc," func (m *SourceContext) Unmarshal(dAtA []byte) error {
 			if err != nil {
 				return err
 			}
-			if skippy < 0 {
-				return ErrInvalidLengthSourceContext
-			}
-			if (iNdEx + skippy) < 0 {
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
 				return ErrInvalidLengthSourceContext
 			}
 			if (iNdEx + skippy) > l {
",[False]
GO-2021-0053,gogo,protobuf,b03c65ea87cdc3521ede29f62fe3ce239267c1bc," func (m *Struct) Unmarshal(dAtA []byte) error {
 					if err != nil {
 						return err
 					}
-					if skippy < 0 {
+					if (skippy < 0) || (iNdEx+skippy) < 0 {
 						return ErrInvalidLengthStruct
 					}
 					if (iNdEx + skippy) > postIndex {
",[False]
GO-2021-0053,gogo,protobuf,b03c65ea87cdc3521ede29f62fe3ce239267c1bc," func (m *Struct) Unmarshal(dAtA []byte) error {
 			if err != nil {
 				return err
 			}
-			if skippy < 0 {
-				return ErrInvalidLengthStruct
-			}
-			if (iNdEx + skippy) < 0 {
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
 				return ErrInvalidLengthStruct
 			}
 			if (iNdEx + skippy) > l {
",[False]
GO-2021-0053,gogo,protobuf,b03c65ea87cdc3521ede29f62fe3ce239267c1bc," func (m *Value) Unmarshal(dAtA []byte) error {
 			if err != nil {
 				return err
 			}
-			if skippy < 0 {
-				return ErrInvalidLengthStruct
-			}
-			if (iNdEx + skippy) < 0 {
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
 				return ErrInvalidLengthStruct
 			}
 			if (iNdEx + skippy) > l {
",[False]
GO-2021-0053,gogo,protobuf,b03c65ea87cdc3521ede29f62fe3ce239267c1bc," func (m *ListValue) Unmarshal(dAtA []byte) error {
 			if err != nil {
 				return err
 			}
-			if skippy < 0 {
-				return ErrInvalidLengthStruct
-			}
-			if (iNdEx + skippy) < 0 {
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
 				return ErrInvalidLengthStruct
 			}
 			if (iNdEx + skippy) > l {
",[False]
GO-2021-0053,gogo,protobuf,b03c65ea87cdc3521ede29f62fe3ce239267c1bc," func (m *Timestamp) Unmarshal(dAtA []byte) error {
 			if err != nil {
 				return err
 			}
-			if skippy < 0 {
-				return ErrInvalidLengthTimestamp
-			}
-			if (iNdEx + skippy) < 0 {
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
 				return ErrInvalidLengthTimestamp
 			}
 			if (iNdEx + skippy) > l {
",[False]
GO-2021-0053,gogo,protobuf,b03c65ea87cdc3521ede29f62fe3ce239267c1bc," func (m *Type) Unmarshal(dAtA []byte) error {
 			if err != nil {
 				return err
 			}
-			if skippy < 0 {
-				return ErrInvalidLengthType
-			}
-			if (iNdEx + skippy) < 0 {
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
 				return ErrInvalidLengthType
 			}
 			if (iNdEx + skippy) > l {
",[False]
GO-2021-0053,gogo,protobuf,b03c65ea87cdc3521ede29f62fe3ce239267c1bc," func (m *Field) Unmarshal(dAtA []byte) error {
 			if err != nil {
 				return err
 			}
-			if skippy < 0 {
-				return ErrInvalidLengthType
-			}
-			if (iNdEx + skippy) < 0 {
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
 				return ErrInvalidLengthType
 			}
 			if (iNdEx + skippy) > l {
",[False]
GO-2021-0053,gogo,protobuf,b03c65ea87cdc3521ede29f62fe3ce239267c1bc," func (m *Enum) Unmarshal(dAtA []byte) error {
 			if err != nil {
 				return err
 			}
-			if skippy < 0 {
-				return ErrInvalidLengthType
-			}
-			if (iNdEx + skippy) < 0 {
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
 				return ErrInvalidLengthType
 			}
 			if (iNdEx + skippy) > l {
",[False]
GO-2021-0053,gogo,protobuf,b03c65ea87cdc3521ede29f62fe3ce239267c1bc," func (m *EnumValue) Unmarshal(dAtA []byte) error {
 			if err != nil {
 				return err
 			}
-			if skippy < 0 {
-				return ErrInvalidLengthType
-			}
-			if (iNdEx + skippy) < 0 {
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
 				return ErrInvalidLengthType
 			}
 			if (iNdEx + skippy) > l {
",[False]
GO-2021-0053,gogo,protobuf,b03c65ea87cdc3521ede29f62fe3ce239267c1bc," func (m *Option) Unmarshal(dAtA []byte) error {
 			if err != nil {
 				return err
 			}
-			if skippy < 0 {
-				return ErrInvalidLengthType
-			}
-			if (iNdEx + skippy) < 0 {
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
 				return ErrInvalidLengthType
 			}
 			if (iNdEx + skippy) > l {
",[False]
GO-2021-0053,gogo,protobuf,b03c65ea87cdc3521ede29f62fe3ce239267c1bc," func (m *DoubleValue) Unmarshal(dAtA []byte) error {
 			if err != nil {
 				return err
 			}
-			if skippy < 0 {
-				return ErrInvalidLengthWrappers
-			}
-			if (iNdEx + skippy) < 0 {
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
 				return ErrInvalidLengthWrappers
 			}
 			if (iNdEx + skippy) > l {
",[False]
GO-2021-0053,gogo,protobuf,b03c65ea87cdc3521ede29f62fe3ce239267c1bc," func (m *FloatValue) Unmarshal(dAtA []byte) error {
 			if err != nil {
 				return err
 			}
-			if skippy < 0 {
-				return ErrInvalidLengthWrappers
-			}
-			if (iNdEx + skippy) < 0 {
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
 				return ErrInvalidLengthWrappers
 			}
 			if (iNdEx + skippy) > l {
",[False]
GO-2021-0053,gogo,protobuf,b03c65ea87cdc3521ede29f62fe3ce239267c1bc," func (m *Int64Value) Unmarshal(dAtA []byte) error {
 			if err != nil {
 				return err
 			}
-			if skippy < 0 {
-				return ErrInvalidLengthWrappers
-			}
-			if (iNdEx + skippy) < 0 {
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
 				return ErrInvalidLengthWrappers
 			}
 			if (iNdEx + skippy) > l {
",[False]
GO-2021-0053,gogo,protobuf,b03c65ea87cdc3521ede29f62fe3ce239267c1bc," func (m *UInt64Value) Unmarshal(dAtA []byte) error {
 			if err != nil {
 				return err
 			}
-			if skippy < 0 {
-				return ErrInvalidLengthWrappers
-			}
-			if (iNdEx + skippy) < 0 {
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
 				return ErrInvalidLengthWrappers
 			}
 			if (iNdEx + skippy) > l {
",[False]
GO-2021-0053,gogo,protobuf,b03c65ea87cdc3521ede29f62fe3ce239267c1bc," func (m *Int32Value) Unmarshal(dAtA []byte) error {
 			if err != nil {
 				return err
 			}
-			if skippy < 0 {
-				return ErrInvalidLengthWrappers
-			}
-			if (iNdEx + skippy) < 0 {
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
 				return ErrInvalidLengthWrappers
 			}
 			if (iNdEx + skippy) > l {
",[False]
GO-2021-0053,gogo,protobuf,b03c65ea87cdc3521ede29f62fe3ce239267c1bc," func (m *UInt32Value) Unmarshal(dAtA []byte) error {
 			if err != nil {
 				return err
 			}
-			if skippy < 0 {
-				return ErrInvalidLengthWrappers
-			}
-			if (iNdEx + skippy) < 0 {
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
 				return ErrInvalidLengthWrappers
 			}
 			if (iNdEx + skippy) > l {
",[False]
GO-2021-0053,gogo,protobuf,b03c65ea87cdc3521ede29f62fe3ce239267c1bc," func (m *BoolValue) Unmarshal(dAtA []byte) error {
 			if err != nil {
 				return err
 			}
-			if skippy < 0 {
-				return ErrInvalidLengthWrappers
-			}
-			if (iNdEx + skippy) < 0 {
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
 				return ErrInvalidLengthWrappers
 			}
 			if (iNdEx + skippy) > l {
",[False]
GO-2021-0053,gogo,protobuf,b03c65ea87cdc3521ede29f62fe3ce239267c1bc," func (m *StringValue) Unmarshal(dAtA []byte) error {
 			if err != nil {
 				return err
 			}
-			if skippy < 0 {
-				return ErrInvalidLengthWrappers
-			}
-			if (iNdEx + skippy) < 0 {
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
 				return ErrInvalidLengthWrappers
 			}
 			if (iNdEx + skippy) > l {
",[False]
GO-2021-0053,gogo,protobuf,b03c65ea87cdc3521ede29f62fe3ce239267c1bc," func (m *BytesValue) Unmarshal(dAtA []byte) error {
 			if err != nil {
 				return err
 			}
-			if skippy < 0 {
-				return ErrInvalidLengthWrappers
-			}
-			if (iNdEx + skippy) < 0 {
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
 				return ErrInvalidLengthWrappers
 			}
 			if (iNdEx + skippy) > l {
",[False]
GO-2021-0089,buger,jsonparser,91ac96899e492584984ded0c8f9a08f10b473717," func findKeyStart(data []byte, key string) (int, error) {
 			}
 
 		case '[':
-			i = blockEnd(data[i:], data[i], ']') + i
+			end := blockEnd(data[i:], data[i], ']')
+			if end != -1 {
+				i = i + end
+			}
 		case '{':
-			i = blockEnd(data[i:], data[i], '}') + i
+			end := blockEnd(data[i:], data[i], '}')
+			if end != -1 {
+				i = i + end
+			}
 		}
 		i++
 	}
",[True]
GO-2022-0272,kataras,iris,e213dba0d32ff66653e0ef124bc5088817264b08," func (ctx *Context) FormFiles(key string, before ...func(*Context, *multipart.Fi
 
 		innerLoop:
 			for _, header := range fhs[key] {
-				// Fix an issue that net/http has,
-				// an attacker can push a filename
-				// which could lead to override existing system files
-				// by ../../$header.
-				// Reported by Frank through security reports.
-				header.Filename = strings.ReplaceAll(header.Filename, ""../"", """")
-				header.Filename = strings.ReplaceAll(header.Filename, ""..\\"", """")
+				header.Filename = filepath.Base(header.Filename)
 
 				for _, b := range before {
 					if !b(ctx, header) {
",[False]
GO-2022-0272,kataras,iris,e213dba0d32ff66653e0ef124bc5088817264b08," func (ctx *Context) UploadFormFiles(destDirectory string, before ...func(*Contex
 			for _, files := range fhs {
 			innerLoop:
 				for _, file := range files {
-					// Fix an issue that net/http has,
-					// an attacker can push a filename
-					// which could lead to override existing system files
-					// by ../../$file.
-					// Reported by Frank through security reports.
-					file.Filename = strings.ReplaceAll(file.Filename, ""../"", """")
-					file.Filename = strings.ReplaceAll(file.Filename, ""..\\"", """")
+					// Security fix for go < 1.17.5:
+					// Reported by Kirill Efimov (snyk.io) through security reports.
+					file.Filename = filepath.Base(file.Filename)
 
 					for _, b := range before {
 						if !b(ctx, file) {
",[True]
GO-2022-0316,open-policy-agent,opa,932e4ffc37a590ace79e9b75ca4340288c220239," func squashTrailingNewlines(bs []byte) []byte {
 }
 
 func defaultLocation(x ast.Node) *ast.Location {
-	return ast.NewLocation([]byte(x.String()), """", 1, 1)
+	return ast.NewLocation([]byte(x.String()), defaultLocationFile, 1, 1)
 }
 
 type writer struct {
",[False]
GO-2022-0316,open-policy-agent,opa,932e4ffc37a590ace79e9b75ca4340288c220239," func (w *writer) listWriter() entryWriter {
 // location: anything on the same line will be put into a slice.
 func groupIterable(elements []interface{}, last *ast.Location) [][]interface{} {
 	// Generated vars occur in the AST when we're rendering the result of
-	// partial evaluation in a bundle build with optimization. For those vars,
-	// there is no location, and the grouping based on source location will
-	// yield a bad result. So if there's a generated variable among elements,
-	// we'll render the elements all in one line.
-	vis := ast.NewVarVisitor()
+	// partial evaluation in a bundle build with optimization.
+	// Those variables, and wildcard variables have the ""default location"",
+	// set in `Ast()`). That is no proper file location, and the grouping
+	// based on source location will yield a bad result.
+	def := false // default location found?
 	for _, elem := range elements {
-		vis.Walk(elem)
-	}
-	for v := range vis.Vars() {
-		if v.IsGenerated() {
+		ast.WalkTerms(elem, func(t *ast.Term) bool {
+			if t.Location.File == defaultLocationFile {
+				def = true
+				return true
+			}
+			return false
+		})
+		if def { // return as-is
 			return [][]interface{}{elements}
 		}
 	}
 	sort.Slice(elements, func(i, j int) bool {
 		return locLess(elements[i], elements[j])
 	})
+
 	var lines [][]interface{}
 	var cur []interface{}
 	for i, t := range elements {
",[True]
GO-2022-0316,open-policy-agent,opa,2bd8edab9e10e2dc9cf76ae8335ced0c224f3055," func groupIterable(elements []interface{}, last *ast.Location) [][]interface{} {
 	// Those variables, and wildcard variables have the ""default location"",
 	// set in `Ast()`). That is no proper file location, and the grouping
 	// based on source location will yield a bad result.
+	// Another case is generated variables: they do have proper file locations,
+	// but their row/col information may no longer match their AST location.
+	// So, for generated variables, we also don't trust the location, but
+	// keep them ungrouped.
 	def := false // default location found?
 	for _, elem := range elements {
 		ast.WalkTerms(elem, func(t *ast.Term) bool {
",[True]
GO-2022-0316,open-policy-agent,opa,2bd8edab9e10e2dc9cf76ae8335ced0c224f3055," func groupIterable(elements []interface{}, last *ast.Location) [][]interface{} {
 			}
 			return false
 		})
+		ast.WalkVars(elem, func(v ast.Var) bool {
+			if v.IsGenerated() {
+				def = true
+				return true
+			}
+			return false
+		})
 		if def { // return as-is
 			return [][]interface{}{elements}
 		}
",[True]
GO-2020-0034,artdarek,go-unzip,4975cbe0a719dc50b12da8585f1f207c82f7dfe0," func (uz Unzip) Extract() error {
 		}()
 
 		path := filepath.Join(uz.Dest, f.Name)
+		if !strings.HasPrefix(path, filepath.Clean(uz.Dest)+string(os.PathSeparator)) {
+            return fmt.Errorf(""%s: Illegal file path"", path)
+        }
 
 		if f.FileInfo().IsDir() {
 			os.MkdirAll(path, f.Mode())
",[True]
GO-2022-0411,Masterminds,goutils,869801f20f9f1e7ecdbdb6422049d8241270d5e1," func CryptoRandomAlphaNumeric(count int) (string, error) {
 	if count == 0 {
 		return """", nil
 	}
-	RandomString, err := CryptoRandom(count, 0, 0, true, true)
-	if err != nil {
-		return """", fmt.Errorf(""Error: %s"", err)
-	}
-	match, err := regexp.MatchString(""([0-9]+)"", RandomString)
-	if err != nil {
-		panic(err)
-	}
-
-	if !match {
-		//Get the position between 0 and the length of the string-1  to insert a random number
-		position := getCryptoRandomInt(count)
-		//Insert a random number between [0-9] in the position
-		RandomString = RandomString[:position] + string('0' + getCryptoRandomInt(10)) + RandomString[position + 1:]
-		return RandomString, err
-	}
-	return RandomString, err
 
+	return CryptoRandom(count, 0, 0, true, true)
 }
 
 /*
",[True]
GO-2022-0411,Masterminds,goutils,869801f20f9f1e7ecdbdb6422049d8241270d5e1," func CryptoRandom(count int, start int, end int, letters bool, numbers bool, cha
 		if chars == nil {
 			ch = rune(getCryptoRandomInt(gap) + int64(start))
 		} else {
-			ch = chars[getCryptoRandomInt(gap) + int64(start)]
+			ch = chars[getCryptoRandomInt(gap)+int64(start)]
 		}
 
 		if letters && unicode.IsLetter(ch) || numbers && unicode.IsDigit(ch) || !letters && !numbers {
",[False]
GO-2022-0528,containrrr,shoutrrr,6a27056f9d7522a8b493216195cb7634bf4b5c42," const (
 )
 
 // Send a notification message to discord
-func (service *Service) Send(message string, params *types.Params) error {
-
+func (service *Service) Send(message string, params *types.Params) (err error) {
 	if service.config.JSON {
 		postURL := CreateAPIURLFromConfig(service.config)
-		return doSend([]byte(message), postURL)
+		err = doSend([]byte(message), postURL)
+	} else {
+		items, omitted := CreateItemsFromPlain(message, service.config.SplitLines)
+		err = service.sendItems(items, params, omitted)
 	}
 
-	items, omitted := CreateItemsFromPlain(message, service.config.SplitLines)
-	return service.sendItems(items, params, omitted)
+	if err != nil {
+		err = fmt.Errorf(""failed to send discord notification: %v"", err)
+	}
+
+	return
 }
 
 // SendItems sends items with additional meta data and richer appearance
",[False]
GO-2022-0528,containrrr,shoutrrr,6a27056f9d7522a8b493216195cb7634bf4b5c42," func doSend(payload []byte, postURL string) error {
 		err = fmt.Errorf(""response status code %s"", res.Status)
 	}
 
-	if err != nil {
-		return fmt.Errorf(""failed to send discord notification: %v"", err)
-	}
-
-	return nil
+	return err
 }
",[False]
GO-2022-0528,containrrr,shoutrrr,6a27056f9d7522a8b493216195cb7634bf4b5c42," type embedFooter struct {
 // CreatePayloadFromItems creates a JSON payload to be sent to the discord webhook API
 func CreatePayloadFromItems(items []types.MessageItem, title string, colors [types.MessageLevelCount]uint, omitted int) (WebhookPayload, error) {
 
+	if len(items) < 1 {
+		return WebhookPayload{}, fmt.Errorf(""message is empty"")
+	}
+
 	metaCount := 1
 	if omitted < 1 && len(title) < 1 {
 		metaCount = 0
",[False]
GO-2022-0528,containrrr,shoutrrr,6a27056f9d7522a8b493216195cb7634bf4b5c42," func CreatePayloadFromItems(items []types.MessageItem, title string, colors [typ
 		embeds = append(embeds, ei)
 	}
 
-	embeds[0].Title = title
-	if omitted > 0 {
-		embeds[0].Footer = &embedFooter{
-			Text: fmt.Sprintf(""... (%v character(s) where omitted)"", omitted),
+	// This should not happen, but it's better to leave the index check before dereferencing the array
+	if len(embeds) > 0 {
+		embeds[0].Title = title
+
+		if omitted > 0 {
+			embeds[0].Footer = &embedFooter{
+				Text: fmt.Sprintf(""... (%v character(s) were omitted)"", omitted),
+			}
 		}
 	}
 
",[False]
GO-2022-0528,containrrr,shoutrrr,6a27056f9d7522a8b493216195cb7634bf4b5c42," func PartitionMessage(input string, limits t.MessageLimit, distance int) (items
 	maxTotal := Min(len(runes), limits.TotalChunkSize)
 	maxCount := limits.ChunkCount - 1
 
+	if len(input) == 0 {
+		// If the message is empty, return an empty array
+		omitted = 0
+		return
+	}
+
 	for i := 0; i < maxCount; i++ {
-		// If no suitable split point is found, use the chunkSize
-		chunkEnd := chunkOffset + limits.ChunkSize
-		// ... and start next chunk directly after this one
-		nextChunkStart := chunkEnd
+		// If no suitable split point is found, start next chunk at chunkSize from chunk start
+		nextChunkStart := chunkOffset + limits.ChunkSize
+		// ... and set the chunk end to the rune before the next chunk
+		chunkEnd := nextChunkStart - 1
 		if chunkEnd > maxTotal {
 			// The chunk is smaller than the limit, no need to search
 			chunkEnd = maxTotal
",[True]
GO-2023-1557,ipfs,go-unixfs,467d139a640ecee4f2e74643dafcc58bb3b54175," func makeShard(ds ipld.DAGService, size int, key string, val *ipld.Link) (*Shard
 	if err != nil {
 		return nil, err
 	}
+	childer, err := newChilder(ds, size)
+	if err != nil {
+		return nil, err
+	}
 	maxpadding := fmt.Sprintf(""%X"", size-1)
 	s := &Shard{
 		tableSizeLg2: lg2s,
 		prefixPadStr: fmt.Sprintf(""%%0%dX"", len(maxpadding)),
 		maxpadlen:    len(maxpadding),
-		childer:      newChilder(ds, size),
+		childer:      childer,
 		tableSize:    size,
 		dserv:        ds,
 
",[True]
GO-2023-1557,ipfs,go-unixfs,467d139a640ecee4f2e74643dafcc58bb3b54175," type childer struct {
 	children []*Shard
 }
 
-func newChilder(ds ipld.DAGService, size int) *childer {
+const maximumHamtWidth = 1 << 10 // FIXME: Spec this and decide of a correct value
+
+func newChilder(ds ipld.DAGService, size int) (*childer, error) {
+	if size > maximumHamtWidth {
+		return nil, fmt.Errorf(""hamt witdh (%d) exceed maximum allowed (%d)"", size, maximumHamtWidth)
+	}
+	bf, err := bitfield.NewBitfield(size)
+	if err != nil {
+		return nil, err
+	}
+
 	return &childer{
 		dserv:    ds,
-		bitfield: bitfield.NewBitfield(size),
-	}
+		bitfield: bf,
+	}, nil
 }
 
 func (s *childer) makeChilder(data []byte, links []*ipld.Link) *childer {
",[True]
GO-2022-1118,codenotary,immudb,cade04756ff3f0a3b9e8d24149062744574adf5d," func NewImmuClient(options *Options) (*immuClient, error) {
 	}
 
 	stateProvider := state.NewStateProvider(serviceClient)
-	uuidProvider := state.NewUUIDProvider(serviceClient)
+	serverUUID, err := state.NewUUIDProvider(serviceClient).CurrentUUID(context.Background())
+	if err != nil {
+		return nil, logErr(l, ""Unable to get server uuid: %s"", err)
+	}
+
+	stateCache := cache.NewFileCache(c.Options.Dir)
+	if !c.Options.DisableIdentityCheck {
+		err = stateCache.ServerIdentityCheck(
+			fmt.Sprintf(""%s:%d"", c.Options.Address, c.Options.Port),
+			serverUUID,
+		)
+		if err != nil {
+			return nil, logErr(l, ""Unable to validate server identity: %s"", err)
+		}
+	}
 
-	stateService, err := state.NewStateService(cache.NewFileCache(options.Dir), l, stateProvider, uuidProvider)
+	stateService, err := state.NewStateServiceWithUUID(
+		stateCache,
+		l,
+		stateProvider,
+		serverUUID,
+	)
 	if err != nil {
 		return nil, logErr(l, ""Unable to create state service: %s"", err)
 	}
",[True]
GO-2022-1118,codenotary,immudb,cade04756ff3f0a3b9e8d24149062744574adf5d," type Options struct {
 	StreamChunkSize     int    // Maximum size of a data chunk in bytes for streaming operations (directly affects maximum GRPC packet size)
 
 	HeartBeatFrequency time.Duration // Duration between two consecutive heartbeat calls to the server for session heartbeats
+
+	DisableIdentityCheck bool // Do not validate server's identity
 }
 
 // DefaultOptions ...
 func DefaultOptions() *Options {
 	return &Options{
-		Dir:                 ""."",
-		Address:             ""127.0.0.1"",
-		Port:                3322,
-		HealthCheckRetries:  5,
-		MTLs:                false,
-		Auth:                true,
-		MaxRecvMsgSize:      4 * 1024 * 1024, //4Mb
-		Config:              ""configs/immuclient.toml"",
-		DialOptions:         []grpc.DialOption{grpc.WithInsecure()},
-		PasswordReader:      c.DefaultPasswordReader,
-		Metrics:             true,
-		PidPath:             """",
-		LogFileName:         """",
-		ServerSigningPubKey: """",
-		StreamChunkSize:     stream.DefaultChunkSize,
-		HeartBeatFrequency:  time.Minute * 1,
+		Dir:                  ""."",
+		Address:              ""127.0.0.1"",
+		Port:                 3322,
+		HealthCheckRetries:   5,
+		MTLs:                 false,
+		Auth:                 true,
+		MaxRecvMsgSize:       4 * 1024 * 1024, //4Mb
+		Config:               ""configs/immuclient.toml"",
+		DialOptions:          []grpc.DialOption{grpc.WithInsecure()},
+		PasswordReader:       c.DefaultPasswordReader,
+		Metrics:              true,
+		PidPath:              """",
+		LogFileName:          """",
+		ServerSigningPubKey:  """",
+		StreamChunkSize:      stream.DefaultChunkSize,
+		HeartBeatFrequency:   time.Minute * 1,
+		DisableIdentityCheck: false,
 	}
 }
 
",[True]
GO-2022-1118,codenotary,immudb,cade04756ff3f0a3b9e8d24149062744574adf5d," func (o *Options) WithHeartBeatFrequency(heartBeatFrequency time.Duration) *Opti
 	return o
 }
 
+func (o *Options) WithDisableIdentityCheck(disableIdentityCheck bool) *Options {
+	o.DisableIdentityCheck = disableIdentityCheck
+	return o
+}
+
 // String converts options object to a json string
 func (o *Options) String() string {
 	optionsJSON, err := json.Marshal(o)
",[False]
GO-2022-1118,codenotary,immudb,cade04756ff3f0a3b9e8d24149062744574adf5d," func (c *immuClient) OpenSession(ctx context.Context, user []byte, pass []byte,
 		}
 	}()
 
+	stateCache := cache.NewFileCache(c.Options.Dir)
+	if !c.Options.DisableIdentityCheck {
+		err = stateCache.ServerIdentityCheck(
+			fmt.Sprintf(""%s:%d"", c.Options.Address, c.Options.Port),
+			resp.GetServerUUID(),
+		)
+		if err != nil {
+			return err
+		}
+	}
+
 	stateProvider := state.NewStateProvider(serviceClient)
 
-	stateService, err := state.NewStateServiceWithUUID(cache.NewFileCache(c.Options.Dir), c.Logger, stateProvider, resp.GetServerUUID())
+	stateService, err := state.NewStateServiceWithUUID(stateCache, c.Logger, stateProvider, resp.GetServerUUID())
 	if err != nil {
 		return errors.FromError(fmt.Errorf(""unable to create state service: %v"", err))
 	}
",[True]
GO-2022-0462,pion,dtls,d2f797183a9f044ce976e6df6f362662ca722412," func flight4Parse(ctx context.Context, c flightConn, state *State, cache *handsh
 			}
 		}
 		state.peerCertificatesVerified = verified
+	} else if state.PeerCertificates != nil {
+		// A certificate was received, but we haven't seen a CertificateVerify
+		// keep reading until we receieve one
+		return 0, nil, nil
 	}
 
 	if !state.cipherSuite.IsInitialized() {
",[True]
GO-2022-0384,helm,helm,61d8e8c4a6f95540c15c6a65f36a6dd0a45e7a2f," func addChartPathOptionsFlags(f *pflag.FlagSet, c *action.ChartPathOptions) {
 	f.StringVar(&c.KeyFile, ""key-file"", """", ""identify HTTPS client using this SSL key file"")
 	f.BoolVar(&c.InsecureSkipTLSverify, ""insecure-skip-tls-verify"", false, ""skip tls certificate checks for the chart download"")
 	f.StringVar(&c.CaFile, ""ca-file"", """", ""verify certificates of HTTPS-enabled servers using this CA bundle"")
+	f.BoolVar(&c.PassCredentialsAll, ""pass-credentials"", false, ""pass credentials to all domains"")
 }
 
 // bindOutputFlag will add the output flag to the given command and bind the
",[False]
GO-2022-0384,helm,helm,61d8e8c4a6f95540c15c6a65f36a6dd0a45e7a2f," func newRepoAddCmd(out io.Writer) *cobra.Command {
 	f.StringVar(&o.caFile, ""ca-file"", """", ""verify certificates of HTTPS-enabled servers using this CA bundle"")
 	f.BoolVar(&o.insecureSkipTLSverify, ""insecure-skip-tls-verify"", false, ""skip tls certificate checks for the repository"")
 	f.BoolVar(&o.allowDeprecatedRepos, ""allow-deprecated-repos"", false, ""by default, this command will not allow adding official repos that have been permanently deleted. This disables that behavior"")
+	f.BoolVar(&o.passCredentialsAll, ""pass-credentials"", false, ""pass credentials to all domains"")
 
 	return cmd
 }
",[False]
GO-2022-0384,helm,helm,61d8e8c4a6f95540c15c6a65f36a6dd0a45e7a2f," func (o *repoAddOptions) run(out io.Writer) error {
 		URL:                   o.url,
 		Username:              o.username,
 		Password:              o.password,
+		PassCredentialsAll:    o.passCredentialsAll,
 		CertFile:              o.certFile,
 		KeyFile:               o.keyFile,
 		CAFile:                o.caFile,
",[False]
GO-2022-0384,helm,helm,61d8e8c4a6f95540c15c6a65f36a6dd0a45e7a2f," func (c *ChartPathOptions) LocateChart(name string, settings *cli.EnvSettings) (
 		Keyring: c.Keyring,
 		Getters: getter.All(settings),
 		Options: []getter.Option{
-			getter.WithBasicAuth(c.Username, c.Password),
+			getter.WithPassCredentialsAll(c.PassCredentialsAll),
 			getter.WithTLSClientConfig(c.CertFile, c.KeyFile, c.CaFile),
 			getter.WithInsecureSkipVerifyTLS(c.InsecureSkipTLSverify),
 		},
",[False]
GO-2022-0384,helm,helm,61d8e8c4a6f95540c15c6a65f36a6dd0a45e7a2f," func (c *ChartPathOptions) LocateChart(name string, settings *cli.EnvSettings) (
 		dl.Verify = downloader.VerifyAlways
 	}
 	if c.RepoURL != """" {
-		chartURL, err := repo.FindChartInAuthAndTLSRepoURL(c.RepoURL, c.Username, c.Password, name, version,
-			c.CertFile, c.KeyFile, c.CaFile, c.InsecureSkipTLSverify, getter.All(settings))
+		chartURL, err := repo.FindChartInAuthAndTLSAndPassRepoURL(c.RepoURL, c.Username, c.Password, name, version,
+			c.CertFile, c.KeyFile, c.CaFile, c.InsecureSkipTLSverify, c.PassCredentialsAll, getter.All(settings))
 		if err != nil {
 			return """", err
 		}
 		name = chartURL
+
+		// Only pass the user/pass on when the user has said to or when the
+		// location of the chart repo and the chart are the same domain.
+		u1, err := url.Parse(c.RepoURL)
+		if err != nil {
+			return """", err
+		}
+		u2, err := url.Parse(chartURL)
+		if err != nil {
+			return """", err
+		}
+
+		// Host on URL (returned from url.Parse) contains the port if present.
+		// This check ensures credentials are not passed between different
+		// services on different ports.
+		if c.PassCredentialsAll || (u1.Scheme == u2.Scheme && u1.Host == u2.Host) {
+			dl.Options = append(dl.Options, getter.WithBasicAuth(c.Username, c.Password))
+		} else {
+			dl.Options = append(dl.Options, getter.WithBasicAuth("""", """"))
+		}
+	} else {
+		dl.Options = append(dl.Options, getter.WithBasicAuth(c.Username, c.Password))
 	}
 
 	if err := os.MkdirAll(settings.RepositoryCache, 0755); err != nil {
",[False]
GO-2022-0384,helm,helm,61d8e8c4a6f95540c15c6a65f36a6dd0a45e7a2f," func (p *Pull) Run(chartRef string) (string, error) {
 		Getters: getter.All(p.Settings),
 		Options: []getter.Option{
 			getter.WithBasicAuth(p.Username, p.Password),
+			getter.WithPassCredentialsAll(p.PassCredentialsAll),
 			getter.WithTLSClientConfig(p.CertFile, p.KeyFile, p.CaFile),
 			getter.WithInsecureSkipVerifyTLS(p.InsecureSkipTLSverify),
 		},
",[False]
GO-2022-0384,helm,helm,61d8e8c4a6f95540c15c6a65f36a6dd0a45e7a2f," func (p *Pull) Run(chartRef string) (string, error) {
 	}
 
 	if p.RepoURL != """" {
-		chartURL, err := repo.FindChartInAuthAndTLSRepoURL(p.RepoURL, p.Username, p.Password, chartRef, p.Version, p.CertFile, p.KeyFile, p.CaFile, p.InsecureSkipTLSverify, getter.All(p.Settings))
+		chartURL, err := repo.FindChartInAuthAndTLSAndPassRepoURL(p.RepoURL, p.Username, p.Password, chartRef, p.Version, p.CertFile, p.KeyFile, p.CaFile, p.InsecureSkipTLSverify, p.PassCredentialsAll, getter.All(p.Settings))
 		if err != nil {
 			return out.String(), err
 		}
",[False]
GO-2022-0384,helm,helm,61d8e8c4a6f95540c15c6a65f36a6dd0a45e7a2f," func (c *ChartDownloader) ResolveChartVersion(ref, version string) (*url.URL, er
 			c.Options = append(
 				c.Options,
 				getter.WithBasicAuth(rc.Username, rc.Password),
+				getter.WithPassCredentialsAll(rc.PassCredentialsAll),
 			)
 		}
 		return u, nil
",[True]
GO-2022-0384,helm,helm,61d8e8c4a6f95540c15c6a65f36a6dd0a45e7a2f," func (c *ChartDownloader) ResolveChartVersion(ref, version string) (*url.URL, er
 			c.Options = append(c.Options, getter.WithTLSClientConfig(r.Config.CertFile, r.Config.KeyFile, r.Config.CAFile))
 		}
 		if r.Config.Username != """" && r.Config.Password != """" {
-			c.Options = append(c.Options, getter.WithBasicAuth(r.Config.Username, r.Config.Password))
+			c.Options = append(c.Options,
+				getter.WithBasicAuth(r.Config.Username, r.Config.Password),
+				getter.WithPassCredentialsAll(r.Config.PassCredentialsAll),
+			)
 		}
 	}
 
",[True]
GO-2022-0384,helm,helm,61d8e8c4a6f95540c15c6a65f36a6dd0a45e7a2f," func (m *Manager) downloadAll(deps []*chart.Dependency) error {
 
 		// Any failure to resolve/download a chart should fail:
 		// https://github.com/helm/helm/issues/1439
-		churl, username, password, err := m.findChartURL(dep.Name, dep.Version, dep.Repository, repos)
+		churl, username, password, passcredentialsall, err := m.findChartURL(dep.Name, dep.Version, dep.Repository, repos)
 		if err != nil {
 			saveError = errors.Wrapf(err, ""could not find %s"", churl)
 			break
",[False]
GO-2022-0384,helm,helm,61d8e8c4a6f95540c15c6a65f36a6dd0a45e7a2f," func (m *Manager) downloadAll(deps []*chart.Dependency) error {
 			Getters:          m.Getters,
 			Options: []getter.Option{
 				getter.WithBasicAuth(username, password),
+				getter.WithPassCredentialsAll(passcredentialsall),
 			},
 		}
 
",[False]
GO-2022-0384,helm,helm,61d8e8c4a6f95540c15c6a65f36a6dd0a45e7a2f," func (m *Manager) parallelRepoUpdate(repos []*repo.Entry) error {
 // repoURL is the repository to search
 //
 // If it finds a URL that is ""relative"", it will prepend the repoURL.
-func (m *Manager) findChartURL(name, version, repoURL string, repos map[string]*repo.ChartRepository) (url, username, password string, err error) {
+func (m *Manager) findChartURL(name, version, repoURL string, repos map[string]*repo.ChartRepository) (url, username, password string, passcredentialsall bool, err error) {
 	if strings.HasPrefix(repoURL, ""oci://"") {
-		return fmt.Sprintf(""%s/%s:%s"", repoURL, name, version), """", """", nil
+		return fmt.Sprintf(""%s/%s:%s"", repoURL, name, version), """", """", false, nil
 	}
 
 	for _, cr := range repos {
",[False]
GO-2022-0384,helm,helm,61d8e8c4a6f95540c15c6a65f36a6dd0a45e7a2f," func (m *Manager) findChartURL(name, version, repoURL string, repos map[string]*
 			}
 			username = cr.Config.Username
 			password = cr.Config.Password
+			passcredentialsall = cr.Config.PassCredentialsAll
 			return
 		}
 	}
 	url, err = repo.FindChartInRepoURL(repoURL, name, version, """", """", """", m.Getters)
 	if err == nil {
-		return url, username, password, err
+		return url, username, password, false, err
 	}
 	err = errors.Errorf(""chart %s not found in %s: %s"", name, repoURL, err)
-	return url, username, password, err
+	return url, username, password, false, err
 }
 
 // findEntryByName finds an entry in the chart repository whose name matches the given name.
",[False]
GO-2022-0384,helm,helm,61d8e8c4a6f95540c15c6a65f36a6dd0a45e7a2f," func WithBasicAuth(username, password string) Option {
 	}
 }
 
+func WithPassCredentialsAll(pass bool) Option {
+	return func(opts *options) {
+		opts.passCredentialsAll = pass
+	}
+}
+
 // WithUserAgent sets the request's User-Agent header to use the provided agent name.
 func WithUserAgent(userAgent string) Option {
 	return func(opts *options) {
",[False]
GO-2022-0384,helm,helm,61d8e8c4a6f95540c15c6a65f36a6dd0a45e7a2f," func (g *HTTPGetter) get(href string) (*bytes.Buffer, error) {
 		req.Header.Set(""User-Agent"", g.opts.userAgent)
 	}
 
-	if g.opts.username != """" && g.opts.password != """" {
-		req.SetBasicAuth(g.opts.username, g.opts.password)
+	// Before setting the basic auth credentials, make sure the URL associated
+	// with the basic auth is the one being fetched.
+	u1, err := url.Parse(g.opts.url)
+	if err != nil {
+		return buf, errors.Wrap(err, ""Unable to parse getter URL"")
+	}
+	u2, err := url.Parse(href)
+	if err != nil {
+		return buf, errors.Wrap(err, ""Unable to parse URL getting from"")
+	}
+
+	// Host on URL (returned from url.Parse) contains the port if present.
+	// This check ensures credentials are not passed between different
+	// services on different ports.
+	if g.opts.passCredentialsAll || (u1.Scheme == u2.Scheme && u1.Host == u2.Host) {
+		if g.opts.username != """" && g.opts.password != """" {
+			req.SetBasicAuth(g.opts.username, g.opts.password)
+		}
 	}
 
 	client, err := g.httpClient()
",[False]
GO-2022-0384,helm,helm,61d8e8c4a6f95540c15c6a65f36a6dd0a45e7a2f," func (r *ChartRepository) DownloadIndexFile() (string, error) {
 		getter.WithInsecureSkipVerifyTLS(r.Config.InsecureSkipTLSverify),
 		getter.WithTLSClientConfig(r.Config.CertFile, r.Config.KeyFile, r.Config.CAFile),
 		getter.WithBasicAuth(r.Config.Username, r.Config.Password),
+		getter.WithPassCredentialsAll(r.Config.PassCredentialsAll),
 	)
 	if err != nil {
 		return """", err
",[False]
GO-2022-0384,helm,helm,61d8e8c4a6f95540c15c6a65f36a6dd0a45e7a2f," func FindChartInAuthAndTLSRepoURL(repoURL, username, password, chartName, chartV
 		URL:                   repoURL,
 		Username:              username,
 		Password:              password,
+		PassCredentialsAll:    passCredentialsAll,
 		CertFile:              certFile,
 		KeyFile:               keyFile,
 		CAFile:                caFile,
",[False]
GO-2022-0519,flyteorg,flyteadmin,a1ec282d02706e074bc4986fd0412e5da3b9d00a," type ResourceServer struct {
 }
 
 func (r ResourceServer) ValidateAccessToken(ctx context.Context, expectedAudience, tokenStr string) (interfaces.IdentityContext, error) {
-	raw, err := r.signatureVerifier.VerifySignature(ctx, tokenStr)
+	_, err := r.signatureVerifier.VerifySignature(ctx, tokenStr)
 	if err != nil {
 		return nil, err
 	}
 
-	claimsRaw := map[string]interface{}{}
-	if err = json.Unmarshal(raw, &claimsRaw); err != nil {
-		return nil, fmt.Errorf(""failed to unmarshal user info claim into UserInfo type. Error: %w"", err)
+	t, _, err := jwtgo.NewParser().ParseUnverified(tokenStr, jwtgo.MapClaims{})
+	if err != nil {
+		return nil, fmt.Errorf(""failed to parse token: %v"", err)
+	}
+
+	if err = t.Claims.Valid(); err != nil {
+		return nil, fmt.Errorf(""failed to validate token: %v"", err)
 	}
 
-	return verifyClaims(sets.NewString(append(r.allowedAudience, expectedAudience)...), claimsRaw)
+	return verifyClaims(sets.NewString(append(r.allowedAudience, expectedAudience)...), t.Claims.(jwtgo.MapClaims))
 }
 
 func doRequest(ctx context.Context, req *http.Request) (*http.Response, error) {
",[True]
GO-2020-0032,goadesign,goa,70b5a199d0f813d74423993832c424e1fc73fb39," func (ctrl *Controller) FileHandler(path, filename string) Handler {
 		}
 	}
 	return func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
+		// prevent path traversal
+		if attemptsPathTraversal(req.URL.Path, path) {
+			return ErrNotFound(req.URL.Path)
+		}
 		fname := filename
 		if len(wc) > 0 {
 			if m, ok := ContextRequest(ctx).Params[wc]; ok {
",[True]
GO-2022-1187,go-macaron,i18n,329b0c4844cc16a5a253c011b55180598e707735," func initLocales(opt Options) language.Matcher {
 		// Append custom locale file.
 		custom := []interface{}{}
 		customPath := path.Join(opt.CustomDirectory, fname)
-		if com.IsFile(customPath) {
+		if isFile(customPath) {
 			custom = append(custom, customPath)
 		}
 
",[False]
GO-2022-1187,go-macaron,i18n,329b0c4844cc16a5a253c011b55180598e707735," func I18n(options ...Options) macaron.Handler {
 		ctx.Data[""RestLangs""] = restLangs
 
 		if opt.Redirect && isNeedRedir {
-			ctx.Redirect(opt.SubURL + ctx.Req.RequestURI[:strings.Index(ctx.Req.RequestURI, ""?"")])
+			ctx.Redirect(opt.SubURL + path.Clean(ctx.Req.RequestURI[:strings.Index(ctx.Req.RequestURI, ""?"")]))
 		}
 	}
 }
",[True]
GO-2022-0391,aws,aws-sdk-go,35fa6ddf45c061e0f08d3a3b5119f8f4da38f6d1," type gcmContentCipherBuilder struct {
 	generator CipherDataGenerator
 }
 
+func (builder gcmContentCipherBuilder) isUsingDeprecatedFeatures() error {
+	if feature, ok := builder.generator.(deprecatedFeatures); ok {
+		return feature.isUsingDeprecatedFeatures()
+	}
+	return nil
+}
+
 // AESGCMContentCipherBuilder returns a new encryption only mode structure with a specific cipher
 // for the master key
 func AESGCMContentCipherBuilder(generator CipherDataGenerator) ContentCipherBuilder {
",[False]
GO-2022-0391,aws,aws-sdk-go,35fa6ddf45c061e0f08d3a3b5119f8f4da38f6d1," func (builder gcmContentCipherBuilder) ContentCipherWithContext(ctx aws.Context)
 	var cd CipherData
 	var err error
 
-	if v, ok := builder.generator.(CipherDataGeneratorWithContext); ok {
+	switch v := builder.generator.(type) {
+	case CipherDataGeneratorWithCEKAlgWithContext:
+		cd, err = v.GenerateCipherDataWithCEKAlgWithContext(ctx, gcmKeySize, gcmNonceSize, AESGCMNoPadding)
+	case CipherDataGeneratorWithCEKAlg:
+		cd, err = v.GenerateCipherDataWithCEKAlg(gcmKeySize, gcmNonceSize, AESGCMNoPadding)
+	case CipherDataGeneratorWithContext:
 		cd, err = v.GenerateCipherDataWithContext(ctx, gcmKeySize, gcmNonceSize)
-	} else {
+	default:
 		cd, err = builder.generator.GenerateCipherData(gcmKeySize, gcmNonceSize)
 	}
 	if err != nil {
",[False]
GO-2022-0391,aws,aws-sdk-go,35fa6ddf45c061e0f08d3a3b5119f8f4da38f6d1," type DecryptionClient struct {
 //	svc := s3crypto.NewDecryptionClient(sess, func(svc *s3crypto.DecryptionClient{
 //		// Custom client options here
 //	}))
+//
+// deprecated: see NewDecryptionClientV2
 func NewDecryptionClient(prov client.ConfigProvider, options ...func(*DecryptionClient)) *DecryptionClient {
 	s3client := s3.New(prov)
 
",[False]
GO-2022-0391,aws,aws-sdk-go,35fa6ddf45c061e0f08d3a3b5119f8f4da38f6d1," type EncryptionClient struct {
 //
 // Example:
 //	cmkID := ""arn:aws:kms:region:000000000000:key/00000000-0000-0000-0000-000000000000""
-//	sess := session.New()
+//  sess := session.Must(session.NewSession())
 //	handler := s3crypto.NewKMSKeyGenerator(kms.New(sess), cmkID)
-//	svc := s3crypto.New(sess, s3crypto.AESGCMContentCipherBuilder(handler))
+//	svc := s3crypto.NewEncryptionClient(sess, s3crypto.AESGCMContentCipherBuilder(handler))
+//
+// deprecated: See NewEncryptionClientV2
 func NewEncryptionClient(prov client.ConfigProvider, builder ContentCipherBuilder, options ...func(*EncryptionClient)) *EncryptionClient {
 	s3client := s3.New(prov)
 
",[False]
GO-2022-0391,aws,aws-sdk-go,35fa6ddf45c061e0f08d3a3b5119f8f4da38f6d1," type CipherDataDecrypterWithContext interface {
 	DecryptKeyWithContext(aws.Context, []byte) ([]byte, error)
 }
 
-func generateBytes(n int) []byte {
+func generateBytes(n int) ([]byte, error) {
 	b := make([]byte, n)
-	rand.Read(b)
-	return b
+	_, err := rand.Read(b)
+	if err != nil {
+		return nil, err
+	}
+	return b, nil
 }
",[False]
GO-2022-0391,aws,aws-sdk-go,35fa6ddf45c061e0f08d3a3b5119f8f4da38f6d1," func NewKMSKeyGeneratorWithMatDesc(kmsClient kmsiface.KMSAPI, cmkID string, matd
 //	svc := s3crypto.NewDecryptionClient(sess, func(svc *s3crypto.DecryptionClient) {
 //		svc.WrapRegistry[s3crypto.KMSWrap] = decryptHandler
 //	}))
+//
+// deprecated: See NewKMSContextWrapEntry
 func NewKMSWrapEntry(kmsClient kmsiface.KMSAPI) WrapEntry {
 	// These values are read only making them thread safe
 	kp := &kmsKeyHandler{
",[False]
GO-2022-0391,aws,aws-sdk-go,35fa6ddf45c061e0f08d3a3b5119f8f4da38f6d1," func NewKMSWrapEntry(kmsClient kmsiface.KMSAPI) WrapEntry {
 	return kp.decryptHandler
 }
 
+// NewKMSContextWrapEntry builds returns a new KMS key provider and its decrypt handler.
+//
+// Example:
+//	sess := session.New(&aws.Config{})
+//	customKMSClient := kms.New(sess)
+//	decryptHandler := s3crypto.NewKMSContextWrapEntry(customKMSClient)
+//
+//	svc := s3crypto.NewDecryptionClient(sess, func(svc *s3crypto.DecryptionClient) {
+//		svc.WrapRegistry[s3crypto.KMSContextWrap] = decryptHandler
+//	}))
+func NewKMSContextWrapEntry(kmsClient kmsiface.KMSAPI) WrapEntry {
+	// These values are read only making them thread safe
+	kp := &kmsKeyHandler{
+		kms:         kmsClient,
+		withContext: true,
+	}
+
+	return kp.decryptHandler
+}
+
 // decryptHandler initializes a KMS keyprovider with a material description. This
 // is used with Decrypting kms content, due to the cmkID being in the material description.
 func (kp kmsKeyHandler) decryptHandler(env Envelope) (CipherDataDecrypter, error) {
",[False]
GO-2022-0391,aws,aws-sdk-go,35fa6ddf45c061e0f08d3a3b5119f8f4da38f6d1," func (kp kmsKeyHandler) decryptHandler(env Envelope) (CipherDataDecrypter, error
 	}
 
 	cmkID, ok := m[""kms_cmk_id""]
-	if !ok {
+	if !kp.withContext && !ok {
 		return nil, awserr.New(""MissingCMKIDError"", ""Material description is missing CMK ID"", nil)
 	}
 
 	kp.CipherData.MaterialDescription = m
 	kp.cmkID = cmkID
 	kp.WrapAlgorithm = KMSWrap
+	if kp.withContext {
+		kp.WrapAlgorithm = KMSContextWrap
+	}
 	return &kp, nil
 }
 
",[False]
GO-2022-0391,aws,aws-sdk-go,35fa6ddf45c061e0f08d3a3b5119f8f4da38f6d1," func (strat HeaderV2SaveStrategy) Save(env Envelope, req *request.Request) error
 	input.Metadata[http.CanonicalHeaderKey(matDescHeader)] = &env.MatDesc
 	input.Metadata[http.CanonicalHeaderKey(wrapAlgorithmHeader)] = &env.WrapAlg
 	input.Metadata[http.CanonicalHeaderKey(cekAlgorithmHeader)] = &env.CEKAlg
-	input.Metadata[http.CanonicalHeaderKey(unencryptedMD5Header)] = &env.UnencryptedMD5
 	input.Metadata[http.CanonicalHeaderKey(unencryptedContentLengthHeader)] = &env.UnencryptedContentLen
 
 	if len(env.TagLen) > 0 {
",[False]
GO-2022-0629,kubernetes-sigs,secrets-store-csi-driver,c2cbb19e2eef16638fa0523383788a4bc22231fd," func (r *SecretProviderClassPodStatusReconciler) Reconcile(req ctrl.Request) (ct
 		return ctrl.Result{}, nil
 	}
 
-	// podObjectReference is an object reference to the pod that spc pod status
-	// is created for. The object reference is created with minimal required fields
-	// name, namespace and UID. By doing this we can skip an additional client call
-	// to fetch the pod object
-	podObjectReference, err := getPodObjectReference(spcPodStatus)
-	if err != nil {
-		logger.Errorf(""failed to get pod object reference, error: %+v"", err)
+	// Obtain the full pod metadata. An object reference is needed for sending
+	// events and the UID is helpful for validating the SPCPS TargetPath.
+	pod := &v1.Pod{}
+	if err := r.reader.Get(ctx, client.ObjectKey{Namespace: req.Namespace, Name: spcPodStatus.Status.PodName}, pod); err != nil {
+		logger.Errorf(""failed to get pod %s/%s, err: %+v"", req.Namespace, spcPodStatus.Status.PodName, err)
+		if apierrors.IsNotFound(err) {
+			return ctrl.Result{RequeueAfter: 5 * time.Second}, nil
+		}
+		return ctrl.Result{}, err
+	}
+
+	// determine which pod volume this is associated with
+	podVol := k8sutil.SPCVolume(pod, spc.Name)
+	if podVol == nil {
+		return ctrl.Result{}, fmt.Errorf(""failed to find secret provider class pod status volume for pod %s/%s"", req.Namespace, spcPodStatus.Status.PodName)
+	}
+
+	// validate TargetPath
+	if fileutil.GetPodUIDFromTargetPath(spcPodStatus.Status.TargetPath) != string(pod.UID) {
+		return ctrl.Result{}, fmt.Errorf(""secret provider class pod status targetPath did not match pod UID for pod %s/%s"", req.Namespace, spcPodStatus.Status.PodName)
+	}
+	if fileutil.GetVolumeNameFromTargetPath(spcPodStatus.Status.TargetPath) != podVol.Name {
+		return ctrl.Result{}, fmt.Errorf(""secret provider class pod status volume name did not match pod Volume for pod %s/%s"", req.Namespace, spcPodStatus.Status.PodName)
 	}
 
 	files, err := fileutil.GetMountedFiles(spcPodStatus.Status.TargetPath)
 	if err != nil {
-		r.generateEvent(podObjectReference, corev1.EventTypeWarning, secretCreationFailedReason, fmt.Sprintf(""failed to get mounted files, err: %+v"", err))
+		r.generateEvent(pod, corev1.EventTypeWarning, secretCreationFailedReason, fmt.Sprintf(""failed to get mounted files, err: %+v"", err))
 		logger.Errorf(""failed to get mounted files, err: %+v"", err)
 		return ctrl.Result{RequeueAfter: 10 * time.Second}, err
 	}
",[True]
GO-2022-0629,kubernetes-sigs,secrets-store-csi-driver,c2cbb19e2eef16638fa0523383788a4bc22231fd," func (r *SecretProviderClassPodStatusReconciler) Reconcile(req ctrl.Request) (ct
 
 			datamap := make(map[string][]byte)
 			if datamap, err = secretutil.GetSecretData(secretObj.Data, secretType, files); err != nil {
-				r.generateEvent(podObjectReference, corev1.EventTypeWarning, secretCreationFailedReason, fmt.Sprintf(""failed to get data in spc %s/%s for secret %s, err: %+v"", req.Namespace, spcName, secretName, err))
+				r.generateEvent(pod, corev1.EventTypeWarning, secretCreationFailedReason, fmt.Sprintf(""failed to get data in spc %s/%s for secret %s, err: %+v"", req.Namespace, spcName, secretName, err))
 				log.Errorf(""failed to get data in spc %s/%s for secret %s, err: %+v"", req.Namespace, spcName, secretName, err)
 				errs = append(errs, fmt.Errorf(""failed to get data in spc %s/%s for secret %s, err: %+v"", req.Namespace, spcName, secretName, err))
 				continue
",[True]
GO-2022-0629,kubernetes-sigs,secrets-store-csi-driver,c2cbb19e2eef16638fa0523383788a4bc22231fd," func (r *SecretProviderClassPodStatusReconciler) Reconcile(req ctrl.Request) (ct
 				Factor:   1.0,
 				Jitter:   0.1,
 			}, f); err != nil {
-				r.generateEvent(podObjectReference, corev1.EventTypeWarning, secretCreationFailedReason, err.Error())
+				r.generateEvent(pod, corev1.EventTypeWarning, secretCreationFailedReason, err.Error())
 				return ctrl.Result{RequeueAfter: 5 * time.Second}, err
 			}
 		}
",[True]
GO-2022-0629,kubernetes-sigs,secrets-store-csi-driver,c2cbb19e2eef16638fa0523383788a4bc22231fd," func (r *Reconciler) reconcile(ctx context.Context, spcps *v1alpha1.SecretProvid
 		return fmt.Errorf(""failed to get pod %s/%s, err: %+v"", podNamespace, podName, err)
 	}
 
+	// determine which pod volume this is associated with
+	podVol := k8sutil.SPCVolume(pod, spc.Name)
+	if podVol == nil {
+		errorReason = internalerrors.PodVolumeNotFound
+		return fmt.Errorf(""could not find secret provider class pod status volume for pod %s/%s"", podNamespace, podName)
+	}
+
+	// validate TargetPath
+	if fileutil.GetPodUIDFromTargetPath(spcps.Status.TargetPath) != string(pod.UID) {
+		errorReason = internalerrors.UnexpectedTargetPath
+		return fmt.Errorf(""secret provider class pod status targetPath did not match pod UID for pod %s/%s"", podNamespace, podName)
+	}
+	if fileutil.GetVolumeNameFromTargetPath(spcps.Status.TargetPath) != podVol.Name {
+		errorReason = internalerrors.UnexpectedTargetPath
+		return fmt.Errorf(""secret provider class pod status volume name did not match pod Volume for pod %s/%s"", podNamespace, podName)
+	}
+
 	parameters := make(map[string]string)
 	if spc.Spec.Parameters != nil {
 		parameters = spc.Spec.Parameters
",[True]
GO-2022-0629,kubernetes-sigs,secrets-store-csi-driver,c2cbb19e2eef16638fa0523383788a4bc22231fd," func (r *Reconciler) reconcile(ctx context.Context, spcps *v1alpha1.SecretProvid
 
 	// check if the volume pertaining to the current spc is using nodePublishSecretRef for
 	// accessing external secrets store
-	var nodePublishSecretRef *v1.LocalObjectReference
-	for _, vol := range pod.Spec.Volumes {
-		if vol.CSI == nil {
-			continue
-		}
-		if vol.CSI.Driver != ""secrets-store.csi.k8s.io"" {
-			continue
-		}
-		if vol.CSI.VolumeAttributes[""secretProviderClass""] != spc.Name {
-			continue
-		}
-		nodePublishSecretRef = vol.CSI.NodePublishSecretRef
-		break
-	}
+	nodePublishSecretRef := podVol.CSI.NodePublishSecretRef
 
 	var secretsJSON []byte
 	nodePublishSecretData := make(map[string]string)
",[True]
GO-2022-0629,kubernetes-sigs,secrets-store-csi-driver,c2cbb19e2eef16638fa0523383788a4bc22231fd," func (ns *nodeServer) NodeUnpublishVolume(ctx context.Context, req *csi.NodeUnpu
 	}
 	targetPath := req.GetTargetPath()
 	volumeID := req.GetVolumeId()
-	files, err := getMountedFiles(targetPath)
+	// Assume no mounted files if GetMountedFiles fails.
+	files, _ := fileutil.GetMountedFiles(targetPath)
 
 	if isMockTargetPath(targetPath) {
 		return &csi.NodeUnpublishVolumeResponse{}, nil
 	}
 
-	podUID = getPodUIDFromTargetPath(targetPath)
+	podUID = fileutil.GetPodUIDFromTargetPath(targetPath)
 	if len(podUID) == 0 {
 		return nil, status.Error(codes.InvalidArgument, ""Cannot get podUID from Target path"")
 	}
",[True]
GO-2022-0629,kubernetes-sigs,secrets-store-csi-driver,c2cbb19e2eef16638fa0523383788a4bc22231fd,"
+/*
+Copyright 2020 The Kubernetes Authors.
+
+Licensed under the Apache License, Version 2.0 (the ""License"");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an ""AS IS"" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+// Package k8sutil holds Secrets CSI Driver utilities for dealing with k8s
+// types.
+package k8sutil
+
+import (
+	v1 ""k8s.io/api/core/v1""
+)
+
+// SPCVolume finds the Secret Provider Class volume from a Pod, or returns nil
+// if a volume could not be found.
+func SPCVolume(pod *v1.Pod, spcName string) *v1.Volume {
+	for i, vol := range pod.Spec.Volumes {
+		if vol.CSI == nil {
+			continue
+		}
+		if vol.CSI.Driver != ""secrets-store.csi.k8s.io"" {
+			continue
+		}
+		if vol.CSI.VolumeAttributes[""secretProviderClass""] != spcName {
+			continue
+		}
+		return &pod.Spec.Volumes[i]
+	}
+	return nil
+}
",[False]
GO-2021-0088,facebook,fbthrift,c461c1bd1a3e130b181aa9c854da3030cd4b5156," func Skip(self Protocol, fieldType Type, maxDepth int) (err error) {
 			}
 		}
 		return self.ReadListEnd()
+	default:
+		return fmt.Errorf(""unable to skip over unknown type id %d"", fieldType)
 	}
-	return nil
 }
",[True]
GO-2021-0088,facebook,fbthrift,c461c1bd1a3e130b181aa9c854da3030cd4b5156," func Skip(self Protocol, fieldType Type, maxDepth int) (err error) {
 	}
 
 	switch fieldType {
-	case STOP:
-		return
 	case BOOL:
 		_, err = self.ReadBool()
 		return
",[True]
GO-2022-1148,libp2p,go-libp2p,15d7dfbf54264ead8e6f49ca658d79c90635e2de," func (cfg *Config) makeSwarm() (*swarm.Swarm, error) {
 	if cfg.DialTimeout != 0 {
 		opts = append(opts, swarm.WithDialTimeout(cfg.DialTimeout))
 	}
+	if cfg.ResourceManager != nil {
+		opts = append(opts, swarm.WithResourceManager(cfg.ResourceManager))
+	}
 	// TODO: Make the swarm implementation configurable.
 	return swarm.NewSwarm(pid, cfg.Peerstore, opts...)
 }
",[False]
GO-2022-1148,libp2p,go-libp2p,15d7dfbf54264ead8e6f49ca658d79c90635e2de," func (cfg *Config) addTransports(h host.Host) error {
 	if cfg.ConnectionGater != nil {
 		opts = append(opts, tptu.WithConnectionGater(cfg.ConnectionGater))
 	}
+	if cfg.ResourceManager != nil {
+		opts = append(opts, tptu.WithResourceManager(cfg.ResourceManager))
+	}
 	upgrader, err := tptu.New(secure, muxer, opts...)
 	if err != nil {
 		return err
 	}
-	tpts, err := makeTransports(h, upgrader, cfg.ConnectionGater, cfg.PSK, cfg.Transports)
+	tpts, err := makeTransports(h, upgrader, cfg.ConnectionGater, cfg.PSK, cfg.ResourceManager, cfg.Transports)
 	if err != nil {
 		return err
 	}
",[False]
GO-2022-1148,libp2p,go-libp2p,15d7dfbf54264ead8e6f49ca658d79c90635e2de," var muxArgTypes = newArgTypeSet(hostType, networkType, peerIDType, pstoreType)
 // using reflection.
 func MuxerConstructor(m interface{}) (MuxC, error) {
 	// Already constructed?
-	if t, ok := m.(mux.Multiplexer); ok {
-		return func(_ host.Host) (mux.Multiplexer, error) {
+	if t, ok := m.(network.Multiplexer); ok {
+		return func(_ host.Host) (network.Multiplexer, error) {
 			return t, nil
 		}, nil
 	}
",[True]
GO-2022-1148,libp2p,go-libp2p,15d7dfbf54264ead8e6f49ca658d79c90635e2de," func makeConstructor(
 	tptType reflect.Type,
 	argTypes map[reflect.Type]constructor,
 	opts ...interface{},
-) (func(host.Host, transport.Upgrader, pnet.PSK, connmgr.ConnectionGater) (interface{}, error), error) {
+) (func(host.Host, transport.Upgrader, pnet.PSK, connmgr.ConnectionGater, network.ResourceManager) (interface{}, error), error) {
 	v := reflect.ValueOf(tpt)
 	// avoid panicing on nil/zero value.
 	if v == (reflect.Value{}) {
",[True]
GO-2022-1148,libp2p,go-libp2p,15d7dfbf54264ead8e6f49ca658d79c90635e2de," func makeConstructor(
 		return nil, err
 	}
 
-	return func(h host.Host, u transport.Upgrader, psk pnet.PSK, cg connmgr.ConnectionGater) (interface{}, error) {
+	return func(h host.Host, u transport.Upgrader, psk pnet.PSK, cg connmgr.ConnectionGater, rcmgr network.ResourceManager) (interface{}, error) {
 		arguments := make([]reflect.Value, 0, len(argConstructors)+len(opts))
 		for i, makeArg := range argConstructors {
-			if arg := makeArg(h, u, psk, cg); arg != nil {
+			if arg := makeArg(h, u, psk, cg, rcmgr); arg != nil {
 				arguments = append(arguments, reflect.ValueOf(arg))
 			} else {
 				// ValueOf an un-typed nil yields a zero reflect
",[True]
GO-2022-1148,libp2p,go-libp2p,15d7dfbf54264ead8e6f49ca658d79c90635e2de," func SecurityConstructor(security interface{}) (SecC, error) {
 		return nil, err
 	}
 	return func(h host.Host) (sec.SecureTransport, error) {
-		t, err := ctor(h, nil, nil, nil)
+		t, err := ctor(h, nil, nil, nil, nil)
 		if err != nil {
 			return nil, err
 		}
",[True]
GO-2022-1148,libp2p,go-libp2p,15d7dfbf54264ead8e6f49ca658d79c90635e2de," var transportArgTypes = argTypes
 func TransportConstructor(tpt interface{}, opts ...interface{}) (TptC, error) {
 	// Already constructed?
 	if t, ok := tpt.(transport.Transport); ok {
-		return func(_ host.Host, _ transport.Upgrader, _ pnet.PSK, _ connmgr.ConnectionGater) (transport.Transport, error) {
+		return func(_ host.Host, _ transport.Upgrader, _ pnet.PSK, _ connmgr.ConnectionGater, _ network.ResourceManager) (transport.Transport, error) {
 			return t, nil
 		}, nil
 	}
",[True]
GO-2022-1148,libp2p,go-libp2p,15d7dfbf54264ead8e6f49ca658d79c90635e2de," func TransportConstructor(tpt interface{}, opts ...interface{}) (TptC, error) {
 	if err != nil {
 		return nil, err
 	}
-	return func(h host.Host, u transport.Upgrader, psk pnet.PSK, cg connmgr.ConnectionGater) (transport.Transport, error) {
-		t, err := ctor(h, u, psk, cg)
+	return func(h host.Host, u transport.Upgrader, psk pnet.PSK, cg connmgr.ConnectionGater, rcmgr network.ResourceManager) (transport.Transport, error) {
+		t, err := ctor(h, u, psk, cg, rcmgr)
 		if err != nil {
 			return nil, err
 		}
",[True]
GO-2022-1148,libp2p,go-libp2p,15d7dfbf54264ead8e6f49ca658d79c90635e2de," func TransportConstructor(tpt interface{}, opts ...interface{}) (TptC, error) {
 	}, nil
 }
 
-func makeTransports(h host.Host, u transport.Upgrader, cg connmgr.ConnectionGater, psk pnet.PSK, tpts []TptC) ([]transport.Transport, error) {
+func makeTransports(h host.Host, u transport.Upgrader, cg connmgr.ConnectionGater, psk pnet.PSK, rcmgr network.ResourceManager, tpts []TptC) ([]transport.Transport, error) {
 	transports := make([]transport.Transport, len(tpts))
 	for i, tC := range tpts {
-		t, err := tC(h, u, psk, cg)
+		t, err := tC(h, u, psk, cg, rcmgr)
 		if err != nil {
 			return nil, err
 		}
",[True]
GO-2022-1148,libp2p,go-libp2p,15d7dfbf54264ead8e6f49ca658d79c90635e2de," func ConnectionGater(cg connmgr.ConnectionGater) Option {
 	}
 }
 
+// ResourceManager configures libp2p to use the given ResourceManager.
+func ResourceManager(rcmgr network.ResourceManager) Option {
+	return func(cfg *Config) error {
+		if cfg.ResourceManager != nil {
+			return errors.New(""cannot configure multiple resource managers"")
+		}
+		cfg.ResourceManager = rcmgr
+		return nil
+	}
+}
+
 // NATPortMap configures libp2p to use the default NATManager. The default
 // NATManager will attempt to open a port in your network's firewall using UPnP.
 func NATPortMap() Option {
",[False]
GO-2022-1148,libp2p,go-libp2p,15d7dfbf54264ead8e6f49ca658d79c90635e2de," func (c *client) DialBack(ctx context.Context, p peer.ID) (ma.Multiaddr, error)
 	if err != nil {
 		return nil, err
 	}
+
+	if err := s.Scope().SetService(ServiceName); err != nil {
+		log.Debugf(""error attaching stream to autonat service: %s"", err)
+		s.Reset()
+		return nil, err
+	}
+
+	if err := s.Scope().ReserveMemory(maxMsgSize, network.ReservationPriorityAlways); err != nil {
+		log.Debugf(""error reserving memory for autonat stream: %s"", err)
+		s.Reset()
+		return nil, err
+	}
+	defer s.Scope().ReleaseMemory(maxMsgSize)
+
 	s.SetDeadline(time.Now().Add(streamTimeout))
 	// Might as well just reset the stream. Once we get to this point, we
 	// don't care about being nice.
 	defer s.Close()
 
-	r := protoio.NewDelimitedReader(s, network.MessageSizeMax)
+	r := protoio.NewDelimitedReader(s, maxMsgSize)
 	w := protoio.NewDelimitedWriter(s)
 
 	req := newDialMessage(peer.AddrInfo{ID: c.h.ID(), Addrs: c.addrFunc()})
",[True]
GO-2022-1148,libp2p,go-libp2p,15d7dfbf54264ead8e6f49ca658d79c90635e2de," func newAutoNATService(c *config) (*autoNATService, error) {
 }
 
 func (as *autoNATService) handleStream(s network.Stream) {
+	if err := s.Scope().SetService(ServiceName); err != nil {
+		log.Debugf(""error attaching stream to autonat service: %s"", err)
+		s.Reset()
+		return
+	}
+
+	if err := s.Scope().ReserveMemory(maxMsgSize, network.ReservationPriorityAlways); err != nil {
+		log.Debugf(""error reserving memory for autonat stream: %s"", err)
+		s.Reset()
+		return
+	}
+	defer s.Scope().ReleaseMemory(maxMsgSize)
+
 	s.SetDeadline(time.Now().Add(streamTimeout))
 	defer s.Close()
 
 	pid := s.Conn().RemotePeer()
 	log.Debugf(""New stream from %s"", pid.Pretty())
 
-	r := protoio.NewDelimitedReader(s, network.MessageSizeMax)
+	r := protoio.NewDelimitedReader(s, maxMsgSize)
 	w := protoio.NewDelimitedWriter(s)
 
 	var req pb.Message
",[True]
GO-2022-1148,libp2p,go-libp2p,15d7dfbf54264ead8e6f49ca658d79c90635e2de," func (h *BasicHost) newStreamHandler(s network.Stream) {
 		}
 	}
 
-	s.SetProtocol(protocol.ID(protoID))
+	if err := s.SetProtocol(protocol.ID(protoID)); err != nil {
+		log.Debugf(""error setting stream protocol: %s"", err)
+		s.Reset()
+		return
+	}
+
 	log.Debugf(""protocol negotiation took %s"", took)
 
 	go handle(protoID, s)
",[True]
GO-2022-1148,libp2p,go-libp2p,15d7dfbf54264ead8e6f49ca658d79c90635e2de," func (h *BasicHost) SetAutoNat(a autonat.AutoNAT) {
 	}
 }
 
-// Return the host's AutoNAT service, if AutoNAT is enabled.
+// GetAutoNat returns the host's AutoNAT service, if AutoNAT is enabled.
 func (h *BasicHost) GetAutoNat() autonat.AutoNAT {
 	h.addrMu.Lock()
 	defer h.addrMu.Unlock()
",[False]
GO-2022-1148,libp2p,go-libp2p,15d7dfbf54264ead8e6f49ca658d79c90635e2de," func (c *conn) RemotePublicKey() ic.PubKey {
 func (c *conn) Stat() network.ConnStats {
 	return c.stat
 }
+
+func (c *conn) Scope() network.ConnScope {
+	return network.NullScope
+}
",[False]
GO-2022-1148,libp2p,go-libp2p,15d7dfbf54264ead8e6f49ca658d79c90635e2de," func (pn *peernet) notifyAll(notification func(f network.Notifiee)) {
 	pn.notifmu.Unlock()
 	wg.Wait()
 }
+
+func (pn *peernet) ResourceManager() network.ResourceManager {
+	return network.NullResourceManager
+}
",[False]
GO-2022-1148,libp2p,go-libp2p,15d7dfbf54264ead8e6f49ca658d79c90635e2de," func (s *stream) Stat() network.Stats {
 	return s.stat
 }
 
-func (s *stream) SetProtocol(proto protocol.ID) {
+func (s *stream) SetProtocol(proto protocol.ID) error {
 	s.protocol.Store(proto)
+	return nil
 }
 
 func (s *stream) CloseWrite() error {
",[False]
GO-2022-1148,libp2p,go-libp2p,15d7dfbf54264ead8e6f49ca658d79c90635e2de," func (s *stream) Close() error {
 
 func (s *stream) Reset() error {
 	// Cancel any pending reads/writes with an error.
-	s.write.CloseWithError(mux.ErrReset)
-	s.read.CloseWithError(mux.ErrReset)
+	s.write.CloseWithError(network.ErrReset)
+	s.read.CloseWithError(network.ErrReset)
 
 	select {
 	case s.reset <- struct{}{}:
",[False]
GO-2022-1148,libp2p,go-libp2p,15d7dfbf54264ead8e6f49ca658d79c90635e2de," func (s *stream) transport() {
 				case s.reset <- struct{}{}:
 				default:
 				}
-				return mux.ErrReset
+				return network.ErrReset
 			}
 			if err := drainBuf(); err != nil {
 				return err
",[False]
GO-2022-1148,libp2p,go-libp2p,15d7dfbf54264ead8e6f49ca658d79c90635e2de," func (s *stream) transport() {
 		// Reset takes precedent.
 		select {
 		case <-s.reset:
-			s.writeErr = mux.ErrReset
+			s.writeErr = network.ErrReset
 			return
 		default:
 		}
 
 		select {
 		case <-s.reset:
-			s.writeErr = mux.ErrReset
+			s.writeErr = network.ErrReset
 			return
 		case <-s.close:
 			if err := drainBuf(); err != nil {
",[False]
GO-2022-1148,libp2p,go-libp2p,15d7dfbf54264ead8e6f49ca658d79c90635e2de," func NewRelay(h host.Host, opts ...Option) (*Relay, error) {
 		}
 	}
 
+	// get a scope for memory reservations at service level
+	err := h.Network().ResourceManager().ViewService(ServiceName,
+		func(s network.ServiceScope) error {
+			var err error
+			r.scope, err = s.BeginSpan()
+			return err
+		})
+	if err != nil {
+		return nil, err
+	}
+
 	h.SetStreamHandler(ProtoID, r.handleStream)
 
 	return r, nil
",[True]
GO-2022-1148,libp2p,go-libp2p,15d7dfbf54264ead8e6f49ca658d79c90635e2de," func (r *Relay) handleStream(s network.Stream) {
 }
 
 func (r *Relay) handleHopStream(s network.Stream, msg *pb.CircuitRelay) {
+	span, err := r.scope.BeginSpan()
+	if err != nil {
+		log.Debugf(""failed to begin relay transaction: %s"", err)
+		r.handleError(s, pb.CircuitRelay_HOP_CANT_SPEAK_RELAY)
+		return
+	}
+
+	fail := func(code pb.CircuitRelay_Status) {
+		span.Done()
+		r.handleError(s, code)
+	}
+
+	// reserve buffers for the relay
+	if err := span.ReserveMemory(2*r.rc.BufferSize, network.ReservationPriorityHigh); err != nil {
+		log.Debugf(""error reserving memory for relay: %s"", err)
+		fail(pb.CircuitRelay_HOP_CANT_SPEAK_RELAY)
+		return
+	}
+
 	src, err := peerToPeerInfo(msg.GetSrcPeer())
 	if err != nil {
-		r.handleError(s, pb.CircuitRelay_HOP_SRC_MULTIADDR_INVALID)
+		fail(pb.CircuitRelay_HOP_SRC_MULTIADDR_INVALID)
 		return
 	}
 
 	if src.ID != s.Conn().RemotePeer() {
-		r.handleError(s, pb.CircuitRelay_HOP_SRC_MULTIADDR_INVALID)
+		fail(pb.CircuitRelay_HOP_SRC_MULTIADDR_INVALID)
 		return
 	}
 
 	dest, err := peerToPeerInfo(msg.GetDstPeer())
 	if err != nil {
-		r.handleError(s, pb.CircuitRelay_HOP_DST_MULTIADDR_INVALID)
+		fail(pb.CircuitRelay_HOP_DST_MULTIADDR_INVALID)
 		return
 	}
 
 	if dest.ID == r.host.ID() {
-		r.handleError(s, pb.CircuitRelay_HOP_CANT_RELAY_TO_SELF)
+		fail(pb.CircuitRelay_HOP_CANT_RELAY_TO_SELF)
 		return
 	}
 
 	if r.acl != nil && !r.acl.AllowHop(src.ID, dest.ID) {
 		log.Debugf(""refusing hop from %s to %s; ACL refused"", src.ID, dest.ID)
-		r.handleError(s, pb.CircuitRelay_HOP_CANT_SPEAK_RELAY)
+		fail(pb.CircuitRelay_HOP_CANT_SPEAK_RELAY)
 		return
 	}
 
",[False]
GO-2022-1148,libp2p,go-libp2p,15d7dfbf54264ead8e6f49ca658d79c90635e2de," func (r *Relay) handleHopStream(s network.Stream, msg *pb.CircuitRelay) {
 	if r.active >= r.rc.MaxCircuits {
 		r.mx.Unlock()
 		log.Debugf(""refusing connection from %s to %s; too many active circuits"", src.ID, dest.ID)
-		r.handleError(s, pb.CircuitRelay_HOP_CANT_SPEAK_RELAY)
+		fail(pb.CircuitRelay_HOP_CANT_SPEAK_RELAY)
 		return
 	}
 
",[False]
GO-2022-1148,libp2p,go-libp2p,15d7dfbf54264ead8e6f49ca658d79c90635e2de," func (r *Relay) handleHopStream(s network.Stream, msg *pb.CircuitRelay) {
 	if srcConns >= r.rc.MaxCircuitsPerPeer {
 		r.mx.Unlock()
 		log.Debugf(""refusing connection from %s to %s; too many connections from %s"", src.ID, dest.ID, src)
-		r.handleError(s, pb.CircuitRelay_HOP_CANT_SPEAK_RELAY)
+		fail(pb.CircuitRelay_HOP_CANT_SPEAK_RELAY)
 		return
 	}
 
",[False]
GO-2022-1148,libp2p,go-libp2p,15d7dfbf54264ead8e6f49ca658d79c90635e2de," func (r *Relay) handleHopStream(s network.Stream, msg *pb.CircuitRelay) {
 	if destConns >= r.rc.MaxCircuitsPerPeer {
 		r.mx.Unlock()
 		log.Debugf(""refusing connection from %s to %s; too many connecitons to %s"", src.ID, dest.ID, dest.ID)
-		r.handleError(s, pb.CircuitRelay_HOP_CANT_SPEAK_RELAY)
+		fail(pb.CircuitRelay_HOP_CANT_SPEAK_RELAY)
 		return
 	}
 
",[False]
GO-2022-1148,libp2p,go-libp2p,15d7dfbf54264ead8e6f49ca658d79c90635e2de," func (r *Relay) handleHopStream(s network.Stream, msg *pb.CircuitRelay) {
 	r.mx.Unlock()
 
 	cleanup := func() {
+		span.Done()
 		r.mx.Lock()
 		r.active--
 		r.rmConn(src.ID)
",[False]
GO-2022-1148,libp2p,go-libp2p,15d7dfbf54264ead8e6f49ca658d79c90635e2de," func (r *Relay) handleHopStream(s network.Stream, msg *pb.CircuitRelay) {
 		return
 	}
 
+	fail = func(code pb.CircuitRelay_Status) {
+		bs.Reset()
+		cleanup()
+		r.handleError(s, code)
+	}
+
+	if err := bs.Scope().SetService(ServiceName); err != nil {
+		log.Debugf(""error attaching stream to relay service: %s"", err)
+		fail(pb.CircuitRelay_HOP_CANT_SPEAK_RELAY)
+		return
+	}
+
 	// stop handshake
+	if err := bs.Scope().ReserveMemory(maxMessageSize, network.ReservationPriorityAlways); err != nil {
+		log.Debugf(""failed to reserve memory for stream: %s"", err)
+		fail(pb.CircuitRelay_HOP_CANT_SPEAK_RELAY)
+		return
+	}
+	defer bs.Scope().ReleaseMemory(maxMessageSize)
+
 	rd := util.NewDelimitedReader(bs, maxMessageSize)
 	wr := util.NewDelimitedWriter(bs)
 	defer rd.Close()
",[False]
GO-2022-1148,libp2p,go-libp2p,15d7dfbf54264ead8e6f49ca658d79c90635e2de," func (r *Relay) handleHopStream(s network.Stream, msg *pb.CircuitRelay) {
 	err = wr.WriteMsg(msg)
 	if err != nil {
 		log.Debugf(""error writing stop handshake: %s"", err.Error())
-		bs.Reset()
-		r.handleError(s, pb.CircuitRelay_HOP_CANT_OPEN_DST_STREAM)
-		cleanup()
+		fail(pb.CircuitRelay_HOP_CANT_OPEN_DST_STREAM)
 		return
 	}
 
",[False]
GO-2022-1148,libp2p,go-libp2p,15d7dfbf54264ead8e6f49ca658d79c90635e2de," func (r *Relay) handleHopStream(s network.Stream, msg *pb.CircuitRelay) {
 	err = rd.ReadMsg(msg)
 	if err != nil {
 		log.Debugf(""error reading stop response: %s"", err.Error())
-		bs.Reset()
-		r.handleError(s, pb.CircuitRelay_HOP_CANT_OPEN_DST_STREAM)
-		cleanup()
+		fail(pb.CircuitRelay_HOP_CANT_OPEN_DST_STREAM)
 		return
 	}
 
 	if msg.GetType() != pb.CircuitRelay_STATUS {
 		log.Debugf(""unexpected relay stop response: not a status message (%d)"", msg.GetType())
-		bs.Reset()
-		r.handleError(s, pb.CircuitRelay_HOP_CANT_OPEN_DST_STREAM)
-		cleanup()
+		fail(pb.CircuitRelay_HOP_CANT_OPEN_DST_STREAM)
 		return
 	}
 
 	if msg.GetCode() != pb.CircuitRelay_SUCCESS {
 		log.Debugf(""relay stop failure: %d"", msg.GetCode())
-		bs.Reset()
-		r.handleError(s, msg.GetCode())
-		cleanup()
+		fail(msg.GetCode())
 		return
 	}
 
",[False]
GO-2022-1148,libp2p,go-libp2p,15d7dfbf54264ead8e6f49ca658d79c90635e2de," func (c *Client) dialPeer(ctx context.Context, relay, dest peer.AddrInfo) (*Conn
 }
 
 func (c *Client) connectV2(s network.Stream, dest peer.AddrInfo) (*Conn, error) {
+	if err := s.Scope().ReserveMemory(maxMessageSize, network.ReservationPriorityAlways); err != nil {
+		s.Reset()
+		return nil, err
+	}
+	defer s.Scope().ReleaseMemory(maxMessageSize)
+
 	rd := util.NewDelimitedReader(s, maxMessageSize)
 	wr := util.NewDelimitedWriter(s)
 	defer rd.Close()
",[True]
GO-2022-1148,libp2p,go-libp2p,15d7dfbf54264ead8e6f49ca658d79c90635e2de," func (c *Client) connectV2(s network.Stream, dest peer.AddrInfo) (*Conn, error)
 }
 
 func (c *Client) connectV1(s network.Stream, dest peer.AddrInfo) (*Conn, error) {
+	if err := s.Scope().ReserveMemory(maxMessageSize, network.ReservationPriorityAlways); err != nil {
+		s.Reset()
+		return nil, err
+	}
+	defer s.Scope().ReleaseMemory(maxMessageSize)
+
 	rd := util.NewDelimitedReader(s, maxMessageSize)
 	wr := util.NewDelimitedWriter(s)
 	defer rd.Close()
",[True]
GO-2022-1148,libp2p,go-libp2p,15d7dfbf54264ead8e6f49ca658d79c90635e2de," var _ transport.Transport = (*Client)(nil)
 var _ io.Closer = (*Client)(nil)
 
 func (c *Client) Dial(ctx context.Context, a ma.Multiaddr, p peer.ID) (transport.CapableConn, error) {
+	connScope, err := c.host.Network().ResourceManager().OpenConnection(network.DirOutbound, false)
+	if err != nil {
+		return nil, err
+	}
+	if err := connScope.SetPeer(p); err != nil {
+		connScope.Done()
+		return nil, err
+	}
 	conn, err := c.dial(ctx, a, p)
 	if err != nil {
+		connScope.Done()
 		return nil, err
 	}
-
 	conn.tagHop()
-
-	return c.upgrader.Upgrade(ctx, c, conn, network.DirOutbound, p)
+	return c.upgrader.Upgrade(ctx, c, conn, network.DirOutbound, p, connScope)
 }
 
 func (c *Client) CanDial(addr ma.Multiaddr) bool {
",[True]
GO-2022-1148,libp2p,go-libp2p,15d7dfbf54264ead8e6f49ca658d79c90635e2de," func New(h host.Host, opts ...Option) (*Relay, error) {
 		}
 	}
 
+	// get a scope for memory reservations at service level
+	err := h.Network().ResourceManager().ViewService(ServiceName,
+		func(s network.ServiceScope) error {
+			var err error
+			r.scope, err = s.BeginSpan()
+			return err
+		})
+	if err != nil {
+		return nil, err
+	}
+
 	r.constraints = newConstraints(&r.rc)
 	r.selfAddr = ma.StringCast(fmt.Sprintf(""/p2p/%s"", h.ID()))
 
",[True]
GO-2022-1148,libp2p,go-libp2p,15d7dfbf54264ead8e6f49ca658d79c90635e2de," func New(h host.Host, opts ...Option) (*Relay, error) {
 func (r *Relay) Close() error {
 	if atomic.CompareAndSwapUint32(&r.closed, 0, 1) {
 		r.host.RemoveStreamHandler(proto.ProtoIDv2Hop)
+		r.scope.Done()
 		r.cancel()
 		r.mx.Lock()
 		for p := range r.rsvp {
",[True]
GO-2022-1148,libp2p,go-libp2p,15d7dfbf54264ead8e6f49ca658d79c90635e2de," func (r *Relay) Close() error {
 }
 
 func (r *Relay) handleStream(s network.Stream) {
-	s.SetReadDeadline(time.Now().Add(StreamTimeout))
-
 	log.Infof(""new relay stream from: %s"", s.Conn().RemotePeer())
 
+	if err := s.Scope().SetService(ServiceName); err != nil {
+		log.Debugf(""error attaching stream to relay service: %s"", err)
+		s.Reset()
+		return
+	}
+
+	if err := s.Scope().ReserveMemory(maxMessageSize, network.ReservationPriorityAlways); err != nil {
+		log.Debugf(""error reserving memory for stream: %s"", err)
+		s.Reset()
+		return
+	}
+	defer s.Scope().ReleaseMemory(maxMessageSize)
+
 	rd := util.NewDelimitedReader(s, maxMessageSize)
 	defer rd.Close()
 
+	s.SetReadDeadline(time.Now().Add(StreamTimeout))
+
 	var msg pbv2.HopMessage
 
 	err := rd.ReadMsg(&msg)
",[True]
GO-2022-1148,libp2p,go-libp2p,15d7dfbf54264ead8e6f49ca658d79c90635e2de," func (r *Relay) handleConnect(s network.Stream, msg *pbv2.HopMessage) {
 	src := s.Conn().RemotePeer()
 	a := s.Conn().RemoteMultiaddr()
 
+	span, err := r.scope.BeginSpan()
+	if err != nil {
+		log.Debugf(""failed to begin relay transaction: %s"", err)
+		r.handleError(s, pbv2.Status_RESOURCE_LIMIT_EXCEEDED)
+		return
+	}
+
+	fail := func(status pbv2.Status) {
+		span.Done()
+		r.handleError(s, status)
+	}
+
+	// reserve buffers for the relay
+	if err := span.ReserveMemory(2*r.rc.BufferSize, network.ReservationPriorityHigh); err != nil {
+		log.Debugf(""error reserving memory for relay: %s"", err)
+		fail(pbv2.Status_RESOURCE_LIMIT_EXCEEDED)
+		return
+	}
+
 	if isRelayAddr(a) {
 		log.Debugf(""refusing connection from %s; connection attempt over relay connection"")
-		r.handleError(s, pbv2.Status_PERMISSION_DENIED)
+		fail(pbv2.Status_PERMISSION_DENIED)
 		return
 	}
 
 	dest, err := util.PeerToPeerInfoV2(msg.GetPeer())
 	if err != nil {
-		r.handleError(s, pbv2.Status_MALFORMED_MESSAGE)
+		fail(pbv2.Status_MALFORMED_MESSAGE)
 		return
 	}
 
 	if r.acl != nil && !r.acl.AllowConnect(src, s.Conn().RemoteMultiaddr(), dest.ID) {
 		log.Debugf(""refusing connection from %s to %s; permission denied"", src, dest.ID)
-		r.handleError(s, pbv2.Status_PERMISSION_DENIED)
+		fail(pbv2.Status_PERMISSION_DENIED)
 		return
 	}
 
",[True]
GO-2022-1148,libp2p,go-libp2p,15d7dfbf54264ead8e6f49ca658d79c90635e2de," func (r *Relay) handleConnect(s network.Stream, msg *pbv2.HopMessage) {
 	if !rsvp {
 		r.mx.Unlock()
 		log.Debugf(""refusing connection from %s to %s; no reservation"", src, dest.ID)
-		r.handleError(s, pbv2.Status_NO_RESERVATION)
+		fail(pbv2.Status_NO_RESERVATION)
 		return
 	}
 
",[True]
GO-2022-1148,libp2p,go-libp2p,15d7dfbf54264ead8e6f49ca658d79c90635e2de," func (r *Relay) handleConnect(s network.Stream, msg *pbv2.HopMessage) {
 	if srcConns >= r.rc.MaxCircuits {
 		r.mx.Unlock()
 		log.Debugf(""refusing connection from %s to %s; too many connections from %s"", src, dest.ID, src)
-		r.handleError(s, pbv2.Status_RESOURCE_LIMIT_EXCEEDED)
+		fail(pbv2.Status_RESOURCE_LIMIT_EXCEEDED)
 		return
 	}
 
",[True]
GO-2022-1148,libp2p,go-libp2p,15d7dfbf54264ead8e6f49ca658d79c90635e2de," func (r *Relay) handleConnect(s network.Stream, msg *pbv2.HopMessage) {
 	if destConns >= r.rc.MaxCircuits {
 		r.mx.Unlock()
 		log.Debugf(""refusing connection from %s to %s; too many connecitons to %s"", src, dest.ID, dest.ID)
-		r.handleError(s, pbv2.Status_RESOURCE_LIMIT_EXCEEDED)
+		fail(pbv2.Status_RESOURCE_LIMIT_EXCEEDED)
 		return
 	}
 
",[True]
GO-2022-1148,libp2p,go-libp2p,15d7dfbf54264ead8e6f49ca658d79c90635e2de," func (r *Relay) handleConnect(s network.Stream, msg *pbv2.HopMessage) {
 	r.mx.Unlock()
 
 	cleanup := func() {
+		span.Done()
 		r.mx.Lock()
 		r.rmConn(src)
 		r.rmConn(dest.ID)
",[True]
GO-2022-1148,libp2p,go-libp2p,15d7dfbf54264ead8e6f49ca658d79c90635e2de," func (r *Relay) handleConnect(s network.Stream, msg *pbv2.HopMessage) {
 		return
 	}
 
+	fail = func(status pbv2.Status) {
+		bs.Reset()
+		cleanup()
+		r.handleError(s, status)
+	}
+
+	if err := bs.Scope().SetService(ServiceName); err != nil {
+		log.Debugf(""error attaching stream to relay service: %s"", err)
+		fail(pbv2.Status_RESOURCE_LIMIT_EXCEEDED)
+		return
+	}
+
 	// handshake
+	if err := bs.Scope().ReserveMemory(maxMessageSize, network.ReservationPriorityAlways); err != nil {
+		log.Debugf(""erro reserving memory for stream: %s"", err)
+		fail(pbv2.Status_RESOURCE_LIMIT_EXCEEDED)
+		return
+	}
+	defer bs.Scope().ReleaseMemory(maxMessageSize)
+
 	rd := util.NewDelimitedReader(bs, maxMessageSize)
 	wr := util.NewDelimitedWriter(bs)
 	defer rd.Close()
",[True]
GO-2022-1148,libp2p,go-libp2p,15d7dfbf54264ead8e6f49ca658d79c90635e2de," func (r *Relay) handleConnect(s network.Stream, msg *pbv2.HopMessage) {
 	err = wr.WriteMsg(&stopmsg)
 	if err != nil {
 		log.Debugf(""error writing stop handshake"")
-		bs.Reset()
-		cleanup()
-		r.handleError(s, pbv2.Status_CONNECTION_FAILED)
+		fail(pbv2.Status_CONNECTION_FAILED)
 		return
 	}
 
",[True]
GO-2022-1148,libp2p,go-libp2p,15d7dfbf54264ead8e6f49ca658d79c90635e2de," func (r *Relay) handleConnect(s network.Stream, msg *pbv2.HopMessage) {
 	err = rd.ReadMsg(&stopmsg)
 	if err != nil {
 		log.Debugf(""error reading stop response: %s"", err.Error())
-		bs.Reset()
-		cleanup()
-		r.handleError(s, pbv2.Status_CONNECTION_FAILED)
+		fail(pbv2.Status_CONNECTION_FAILED)
 		return
 	}
 
 	if t := stopmsg.GetType(); t != pbv2.StopMessage_STATUS {
 		log.Debugf(""unexpected stop response; not a status message (%d)"", t)
-		bs.Reset()
-		cleanup()
-		r.handleError(s, pbv2.Status_CONNECTION_FAILED)
+		fail(pbv2.Status_CONNECTION_FAILED)
 		return
 	}
 
 	if status := stopmsg.GetStatus(); status != pbv2.Status_OK {
 		log.Debugf(""relay stop failure: %d"", status)
-		bs.Reset()
-		cleanup()
-		r.handleError(s, pbv2.Status_CONNECTION_FAILED)
+		fail(pbv2.Status_CONNECTION_FAILED)
 		return
 	}
 
",[True]
GO-2022-1148,libp2p,go-libp2p,15d7dfbf54264ead8e6f49ca658d79c90635e2de," func (hs *Service) Close() error {
 func (hs *Service) initiateHolePunch(rp peer.ID) ([]ma.Multiaddr, time.Duration, error) {
 	hpCtx := network.WithUseTransient(hs.ctx, ""hole-punch"")
 	sCtx := network.WithNoDial(hpCtx, ""hole-punch"")
+
 	str, err := hs.host.NewStream(sCtx, rp, Protocol)
 	if err != nil {
 		return nil, 0, fmt.Errorf(""failed to open hole-punching stream: %w"", err)
 	}
 	defer str.Close()
-	str.SetDeadline(time.Now().Add(StreamTimeout))
+
+	if err := str.Scope().SetService(ServiceName); err != nil {
+		log.Debugf(""error attaching stream to holepunch service: %s"", err)
+		str.Reset()
+		return nil, 0, err
+	}
+
+	if err := str.Scope().ReserveMemory(maxMsgSize, network.ReservationPriorityAlways); err != nil {
+		log.Debugf(""error reserving memory for stream: %s, err"")
+		str.Reset()
+		return nil, 0, err
+	}
+	defer str.Scope().ReleaseMemory(maxMsgSize)
 
 	w := protoio.NewDelimitedWriter(str)
+	rd := protoio.NewDelimitedReader(str, maxMsgSize)
 
+	str.SetDeadline(time.Now().Add(StreamTimeout))
 	// send a CONNECT and start RTT measurement.
 	msg := &pb.HolePunch{
 		Type:     pb.HolePunch_CONNECT.Enum(),
",[True]
GO-2022-1148,libp2p,go-libp2p,15d7dfbf54264ead8e6f49ca658d79c90635e2de," func (hs *Service) incomingHolePunch(s network.Stream) (rtt time.Duration, addrs
 		return 0, nil, errors.New(""rejecting hole punch request, as we don't have any public addresses"")
 	}
 
-	s.SetDeadline(time.Now().Add(StreamTimeout))
+	if err := s.Scope().ReserveMemory(maxMsgSize, network.ReservationPriorityAlways); err != nil {
+		log.Debugf(""error reserving memory for stream: %s, err"")
+		return 0, nil, err
+	}
+	defer s.Scope().ReleaseMemory(maxMsgSize)
+
 	wr := protoio.NewDelimitedWriter(s)
 	rd := protoio.NewDelimitedReader(s, maxMsgSize)
 
 	// Read Connect message
 	msg := new(pb.HolePunch)
+
+	s.SetDeadline(time.Now().Add(StreamTimeout))
+
 	if err := rd.ReadMsg(msg); err != nil {
 		return 0, nil, fmt.Errorf(""failed to read message from initator: %w"", err)
 	}
",[True]
GO-2022-1148,libp2p,go-libp2p,15d7dfbf54264ead8e6f49ca658d79c90635e2de," func (hs *Service) handleNewStream(s network.Stream) {
 		s.Reset()
 		return
 	}
+
+	if err := s.Scope().SetService(ServiceName); err != nil {
+		log.Debugf(""error attaching stream to holepunch service: %s"", err)
+		s.Reset()
+		return
+	}
+
 	rp := s.Conn().RemotePeer()
 	rtt, addrs, err := hs.incomingHolePunch(s)
 	if err != nil {
",[True]
GO-2022-1148,libp2p,go-libp2p,15d7dfbf54264ead8e6f49ca658d79c90635e2de," func (ids *idService) identifyConn(c network.Conn) error {
 		ids.removeConn(c)
 		return err
 	}
-	s.SetProtocol(ID)
+
+	if err := s.SetProtocol(ID); err != nil {
+		log.Warnf(""error setting identify protocol for stream: %s"", err)
+		s.Reset()
+	}
 
 	// ok give the response to our handler.
 	if err := msmux.SelectProtoOrFail(ID, s); err != nil {
",[False]
GO-2022-1148,libp2p,go-libp2p,15d7dfbf54264ead8e6f49ca658d79c90635e2de," func (ids *idService) identifyConn(c network.Conn) error {
 }
 
 func (ids *idService) sendIdentifyResp(s network.Stream) {
+	if err := s.Scope().SetService(ServiceName); err != nil {
+		log.Warnf(""error attaching stream to identify service: %s"", err)
+		s.Reset()
+		return
+	}
+
 	defer s.Close()
 
 	c := s.Conn()
",[False]
GO-2022-1148,libp2p,go-libp2p,15d7dfbf54264ead8e6f49ca658d79c90635e2de," func (ids *idService) sendIdentifyResp(s network.Stream) {
 }
 
 func (ids *idService) handleIdentifyResponse(s network.Stream) error {
+	if err := s.Scope().SetService(ServiceName); err != nil {
+		log.Warnf(""error attaching stream to identify service: %s"", err)
+		s.Reset()
+		return err
+	}
+
+	if err := s.Scope().ReserveMemory(signedIDSize, network.ReservationPriorityAlways); err != nil {
+		log.Warnf(""error reserving memory for identify stream: %s"", err)
+		s.Reset()
+		return err
+	}
+	defer s.Scope().ReleaseMemory(signedIDSize)
+
 	_ = s.SetReadDeadline(time.Now().Add(StreamReadTimeout))
 
 	c := s.Conn()
",[False]
GO-2022-1148,libp2p,go-libp2p,15d7dfbf54264ead8e6f49ca658d79c90635e2de," import (
 
 const IDDelta = ""/p2p/id/delta/1.0.0""
 
+const deltaMsgSize = 2048
+
 // deltaHandler handles incoming delta updates from peers.
 func (ids *idService) deltaHandler(s network.Stream) {
+	if err := s.Scope().SetService(ServiceName); err != nil {
+		log.Warnf(""error attaching stream to identify service: %s"", err)
+		s.Reset()
+		return
+	}
+
+	if err := s.Scope().ReserveMemory(deltaMsgSize, network.ReservationPriorityAlways); err != nil {
+		log.Warnf(""error reserving memory for identify stream: %s"", err)
+		s.Reset()
+		return
+	}
+	defer s.Scope().ReleaseMemory(deltaMsgSize)
+
 	_ = s.SetReadDeadline(time.Now().Add(StreamReadTimeout))
 
 	c := s.Conn()
 
-	r := protoio.NewDelimitedReader(s, 2048)
+	r := protoio.NewDelimitedReader(s, deltaMsgSize)
 	mes := pb.Identify{}
 	if err := r.ReadMsg(&mes); err != nil {
 		log.Warn(""error reading identify message: "", err)
",[False]
GO-2022-1148,libp2p,go-libp2p,15d7dfbf54264ead8e6f49ca658d79c90635e2de," func NewPingService(h host.Host) *PingService {
 }
 
 func (p *PingService) PingHandler(s network.Stream) {
-	buf := make([]byte, PingSize)
+	if err := s.Scope().SetService(ServiceName); err != nil {
+		log.Debugf(""error attaching stream to ping service: %s"", err)
+		s.Reset()
+		return
+	}
+
+	if err := s.Scope().ReserveMemory(PingSize, network.ReservationPriorityAlways); err != nil {
+		log.Debugf(""error reserving memory for ping stream: %s"", err)
+		s.Reset()
+		return
+	}
+	defer s.Scope().ReleaseMemory(PingSize)
+
+	buf := pool.Get(PingSize)
+	defer pool.Put(buf)
 
 	errCh := make(chan error, 1)
 	defer close(errCh)
",[False]
GO-2022-1148,libp2p,go-libp2p,15d7dfbf54264ead8e6f49ca658d79c90635e2de," func Ping(ctx context.Context, h host.Host, p peer.ID) <-chan Result {
 }
 
 func ping(s network.Stream) (time.Duration, error) {
-	buf := make([]byte, PingSize)
+	if err := s.Scope().ReserveMemory(2*PingSize, network.ReservationPriorityAlways); err != nil {
+		log.Debugf(""error reserving memory for ping stream: %s"", err)
+		s.Reset()
+		return 0, err
+	}
+	defer s.Scope().ReleaseMemory(2 * PingSize)
+
+	buf := pool.Get(PingSize)
+	defer pool.Put(buf)
+
 	u.NewTimeSeededRand().Read(buf)
 
 	before := time.Now()
",[False]
GO-2022-1148,libp2p,go-libp2p,15d7dfbf54264ead8e6f49ca658d79c90635e2de," func ping(s network.Stream) (time.Duration, error) {
 		return 0, err
 	}
 
-	rbuf := make([]byte, PingSize)
+	rbuf := pool.Get(PingSize)
+	defer pool.Put(rbuf)
+
 	_, err = io.ReadFull(s, rbuf)
 	if err != nil {
 		return 0, err
",[False]
GO-2022-1148,libp2p,go-libp2p,15d7dfbf54264ead8e6f49ca658d79c90635e2de," func (hs *Service) initiateHolePunch(rp peer.ID) ([]ma.Multiaddr, time.Duration,
 	}
 
 	// wait for a CONNECT message from the remote peer
-	rd := protoio.NewDelimitedReader(str, maxMsgSize)
 	msg.Reset()
 	if err := rd.ReadMsg(msg); err != nil {
 		str.Reset()
",[True]
GO-2023-2000,libp2p,go-libp2p,0cce607219f3710addc7e18672cffd1f1d912fbb," func GenerateRSAKeyPair(bits int, src io.Reader) (PrivKey, PubKey, error) {
 	if bits < MinRsaKeyBits {
 		return nil, nil, ErrRsaKeyTooSmall
 	}
+	if bits > maxRsaKeyBits {
+		return nil, nil, ErrRsaKeyTooBig
+	}
 	priv, err := rsa.GenerateKey(src, bits)
 	if err != nil {
 		return nil, nil, err
",[True]
GO-2023-2000,libp2p,go-libp2p,0cce607219f3710addc7e18672cffd1f1d912fbb," func UnmarshalRsaPrivateKey(b []byte) (key PrivKey, err error) {
 	if sk.N.BitLen() < MinRsaKeyBits {
 		return nil, ErrRsaKeyTooSmall
 	}
+	if sk.N.BitLen() > maxRsaKeyBits {
+		return nil, ErrRsaKeyTooBig
+	}
 	return &RsaPrivateKey{sk: *sk}, nil
 }
 
",[True]
GO-2023-2000,libp2p,go-libp2p,0cce607219f3710addc7e18672cffd1f1d912fbb," func UnmarshalRsaPublicKey(b []byte) (key PubKey, err error) {
 	if pk.N.BitLen() < MinRsaKeyBits {
 		return nil, ErrRsaKeyTooSmall
 	}
+	if pk.N.BitLen() > maxRsaKeyBits {
+		return nil, ErrRsaKeyTooBig
+	}
 
 	return &RsaPublicKey{k: *pk}, nil
 }
",[True]
GO-2022-1213,go-macaron,csrf,dadd1711a617000b70e5e408a76531b73187031c," func Generate(options ...Options) macaron.Handler {
 			// FIXME: actionId.
 			x.Token = GenerateToken(x.Secret, x.ID, ""POST"")
 			if opt.SetCookie {
-				ctx.SetCookie(opt.Cookie, x.Token, 0, opt.CookiePath, """", false, opt.CookieHttpOnly, time.Now().AddDate(0, 0, 1))
+				ctx.SetCookie(opt.Cookie, x.Token, 0, opt.CookiePath, """", opt.Secure, opt.CookieHttpOnly, time.Now().AddDate(0, 0, 1))
 			}
 		}
 
",[True]
GO-2022-0755,rancher,rancher,0ddffe484adccb9e37d9432e8e625d8ebbfb0088," func New(localConfig *rest.Config, lookup ClusterLookup, dialer dialer.Factory,
 func (r *Router) ServeHTTP(rw http.ResponseWriter, req *http.Request) {
 	c, handler, err := r.serverFactory.get(req)
 	if err != nil {
-		response(rw, httperror.ServerError, err.Error())
+		e, ok := err.(*httperror.APIError)
+		if ok {
+			response(rw, e.Code, e.Message)
+		} else {
+			response(rw, httperror.ServerError, err.Error())
+		}
 		return
 	}
 
",[True]
GO-2022-0755,rancher,rancher,0ddffe484adccb9e37d9432e8e625d8ebbfb0088," func Start(ctx context.Context, httpPort, httpsPort int, localClusterEnabled boo
 	if err != nil {
 		return err
 	}
+	websocketHandler := websocket.NewWebsocketHandler(authedHandler)
 
-	auditHandler := audit.NewAuditLogFilter(ctx, auditLogWriter, authedHandler)
+	auditHandler := audit.NewAuditLogFilter(ctx, auditLogWriter, websocketHandler)
 
 	webhookHandler := hooks.New(scaledContext)
 
",[True]
GO-2021-0054,tidwall,gjson,bf4efcb3c18d1825b2988603dea5909140a5302b," func execModifier(json, path string) (pathOut, res string, ok bool) {
 // unwrap removes the '[]' or '{}' characters around json
 func unwrap(json string) string {
 	json = trim(json)
-	if len(json) >= 2 && json[0] == '[' || json[0] == '{' {
+	if len(json) >= 2 && (json[0] == '[' || json[0] == '{') {
 		json = json[1 : len(json)-1]
 	}
 	return json
",[True]
GO-2023-2137,ydb-platform,ydb-go-sdk,a0d92057c4e1bbdc5e85ae8d649edb0232b8fd4c," func connect(ctx context.Context, c *Driver) error {
 		c.config = c.config.With(config.WithCredentials(
 			credentials.NewStaticCredentials(
 				c.userInfo.User, c.userInfo.Password,
-				c.config,
+				c.config.Endpoint(),
+				credentials.WithGrpcDialOptions(c.config.GrpcDialOptions()...),
 			),
 		))
 	}
",[True]
GO-2023-2137,ydb-platform,ydb-go-sdk,a0d92057c4e1bbdc5e85ae8d649edb0232b8fd4c," func (b *Balancer) clusterDiscovery(ctx context.Context) (err error) {
 	if err = retry.Retry(ctx, func(childCtx context.Context) (err error) {
 		if err = b.clusterDiscoveryAttempt(childCtx); err != nil {
 			if xerrors.IsTransportError(err, grpcCodes.Unauthenticated) {
-				return xerrors.WithStackTrace(
-					fmt.Errorf(
-						""cluster discovery failed: %w (endpoint: %q, database: %q, credentials: %q)"",
-						err,
-						b.driverConfig.Endpoint(),
-						b.driverConfig.Database(),
-						b.driverConfig.Credentials(),
-					),
+				return credentials.UnauthenticatedError(""cluster discovery failed"", err,
+					credentials.WithEndpoint(b.driverConfig.Endpoint()),
+					credentials.WithDatabase(b.driverConfig.Database()),
+					credentials.WithCredentials(b.driverConfig.Credentials()),
 				)
 			}
 			// if got err but parent context is not done - mark error as retryable
",[True]
GO-2023-2137,ydb-platform,ydb-go-sdk,a0d92057c4e1bbdc5e85ae8d649edb0232b8fd4c," func (b *Balancer) wrapCall(ctx context.Context, f func(ctx context.Context, cc
 
 	if err = f(ctx, cc); err != nil {
 		if conn.UseWrapping(ctx) {
+			if xerrors.IsTransportError(err, grpcCodes.Unauthenticated) {
+				err = credentials.UnauthenticatedError(""unauthenticated"", err,
+					credentials.WithAddress(cc.Endpoint().String()),
+					credentials.WithNodeID(cc.Endpoint().NodeID()),
+					credentials.WithCredentials(b.driverConfig.Credentials()),
+				)
+			}
 			return xerrors.WithStackTrace(err)
 		}
 		return err
",[True]
GO-2023-2137,ydb-platform,ydb-go-sdk,a0d92057c4e1bbdc5e85ae8d649edb0232b8fd4c," type AccessToken struct {
 	sourceInfo string
 }
 
-func NewAccessTokenCredentials(token string, opts ...Option) *AccessToken {
-	options := optionsHolder{
+func NewAccessTokenCredentials(token string, opts ...AccessTokenCredentialsOption) *AccessToken {
+	c := &AccessToken{
+		token:      token,
 		sourceInfo: stack.Record(1),
 	}
 	for _, opt := range opts {
-		opt(&options)
-	}
-	return &AccessToken{
-		token:      token,
-		sourceInfo: options.sourceInfo,
+		opt.ApplyAccessTokenCredentialsOption(c)
 	}
+	return c
 }
 
 // Token implements Credentials.
",[True]
GO-2023-2137,ydb-platform,ydb-go-sdk,a0d92057c4e1bbdc5e85ae8d649edb0232b8fd4c," func (c AccessToken) Token(_ context.Context) (string, error) {
 
 // Token implements Credentials.
 func (c AccessToken) String() string {
-	return fmt.Sprintf(""AccessToken(token:%q,from:%q)"", secret.Token(c.token), c.sourceInfo)
+	buffer := allocator.Buffers.Get()
+	defer allocator.Buffers.Put(buffer)
+	buffer.WriteString(""AccessToken(token:"")
+	fmt.Fprintf(buffer, ""%q"", secret.Token(c.token))
+	if c.sourceInfo != """" {
+		buffer.WriteString("",from:"")
+		fmt.Fprintf(buffer, ""%q"", c.sourceInfo)
+	}
+	buffer.WriteByte(')')
+	return buffer.String()
 }
",[True]
GO-2023-2137,ydb-platform,ydb-go-sdk,a0d92057c4e1bbdc5e85ae8d649edb0232b8fd4c," import (
 	""context""
 	""fmt""
 
+	""github.com/ydb-platform/ydb-go-sdk/v3/internal/allocator""
 	""github.com/ydb-platform/ydb-go-sdk/v3/internal/stack""
 )
 
 var (
-	_ Credentials  = (*Anonymous)(nil)
-	_ fmt.Stringer = (*Anonymous)(nil)
+	_ Credentials                = (*Anonymous)(nil)
+	_ fmt.Stringer               = (*Anonymous)(nil)
+	_ AnonymousCredentialsOption = SourceInfoOption("""")
 )
 
+type AnonymousCredentialsOption interface {
+	ApplyAnonymousCredentialsOption(c *Anonymous)
+}
+
 // Anonymous implements Credentials interface with Anonymous access
 type Anonymous struct {
 	sourceInfo string
 }
 
-func NewAnonymousCredentials(opts ...Option) *Anonymous {
-	options := optionsHolder{
+func NewAnonymousCredentials(opts ...AnonymousCredentialsOption) *Anonymous {
+	c := &Anonymous{
 		sourceInfo: stack.Record(1),
 	}
 	for _, opt := range opts {
-		opt(&options)
-	}
-	return &Anonymous{
-		sourceInfo: options.sourceInfo,
+		opt.ApplyAnonymousCredentialsOption(c)
 	}
+	return c
 }
 
 // Token implements Credentials.
",[True]
GO-2023-2137,ydb-platform,ydb-go-sdk,a0d92057c4e1bbdc5e85ae8d649edb0232b8fd4c," func (c Anonymous) Token(_ context.Context) (string, error) {
 
 // Token implements Credentials.
 func (c Anonymous) String() string {
-	return fmt.Sprintf(""Anonymous(from:%q)"", c.sourceInfo)
+	buffer := allocator.Buffers.Get()
+	defer allocator.Buffers.Put(buffer)
+	buffer.WriteString(""Anonymous("")
+	if c.sourceInfo != """" {
+		buffer.WriteString(""from:"")
+		fmt.Fprintf(buffer, ""%q"", c.sourceInfo)
+	}
+	buffer.WriteByte(')')
+	return buffer.String()
 }
",[True]
GO-2023-2137,ydb-platform,ydb-go-sdk,a0d92057c4e1bbdc5e85ae8d649edb0232b8fd4c," func parseExpiresAt(raw string) (expiresAt time.Time, err error) {
 }
 
 func (c *Static) String() string {
-	return fmt.Sprintf(
-		""Static(user:%q,password:%q,token:%q,from:%q)"",
-		c.user,
-		secret.Password(c.password),
-		secret.Token(c.token),
-		c.sourceInfo,
-	)
+	buffer := allocator.Buffers.Get()
+	defer allocator.Buffers.Put(buffer)
+	buffer.WriteString(""Static(user:"")
+	fmt.Fprintf(buffer, ""%q"", c.user)
+	buffer.WriteString("",password:"")
+	fmt.Fprintf(buffer, ""%q"", secret.Password(c.password))
+	buffer.WriteString("",token:"")
+	fmt.Fprintf(buffer, ""%q"", secret.Token(c.token))
+	if c.sourceInfo != """" {
+		buffer.WriteString("",from:"")
+		fmt.Fprintf(buffer, ""%q"", c.sourceInfo)
+	}
+	buffer.WriteByte(')')
+	return buffer.String()
 }
",[True]
GO-2023-2137,ydb-platform,ydb-go-sdk,a0d92057c4e1bbdc5e85ae8d649edb0232b8fd4c," func WithBeforeFunc(
 		},
 	}
 }
-
-func WithAfterFunc(
-	cc grpc.ClientConnInterface,
-	after func(),
-) grpc.ClientConnInterface {
-	return &middleware{
-		invoke: func(ctx context.Context, method string, args interface{}, reply interface{}, opts ...grpc.CallOption) error {
-			defer after()
-			return cc.Invoke(ctx, method, args, reply, opts...)
-		},
-		newStream: func(ctx context.Context, desc *grpc.StreamDesc, method string, opts ...grpc.CallOption) (
-			grpc.ClientStream, error,
-		) {
-			defer after()
-			return cc.NewStream(ctx, desc, method, opts...)
-		},
-	}
-}
",[True]
GO-2021-0073,git-lfs,git-lfs,f913f5f9c7c6d1301785fdf9884a2942d59cdf19," func (c *sshAuthClient) Resolve(e Endpoint, method string) (sshAuthResponse, err
 }
 
 func sshGetLFSExeAndArgs(osEnv Env, e Endpoint, method string) (string, []string) {
-	operation := endpointOperation(e, method)
-	tracerx.Printf(""ssh: %s git-lfs-authenticate %s %s"",
-		e.SshUserAndHost, e.SshPath, operation)
-
 	exe, args := sshGetExeAndArgs(osEnv, e)
-	return exe, append(args,
-		fmt.Sprintf(""git-lfs-authenticate %s %s"", e.SshPath, operation))
+	operation := endpointOperation(e, method)
+	args = append(args, fmt.Sprintf(""git-lfs-authenticate %s %s"", e.SshPath, operation))
+	tracerx.Printf(""run_command: %s %s"", exe, strings.Join(args, "" ""))
+	return exe, args
 }
 
 // Return the executable name for ssh on this machine and the base args
",[True]
GO-2021-0073,git-lfs,git-lfs,f913f5f9c7c6d1301785fdf9884a2942d59cdf19," func sshGetExeAndArgs(osEnv Env, e Endpoint) (exe string, baseargs []string) {
 	}
 
 	if ssh == """" {
-		ssh = ""ssh""
-	} else {
-		basessh := filepath.Base(ssh)
+		ssh = defaultSSHCmd
+	}
+
+	basessh := filepath.Base(ssh)
+
+	if basessh != defaultSSHCmd {
 		// Strip extension for easier comparison
 		if ext := filepath.Ext(basessh); len(ext) > 0 {
 			basessh = basessh[:len(basessh)-len(ext)]
",[False]
GO-2021-0073,git-lfs,git-lfs,f913f5f9c7c6d1301785fdf9884a2942d59cdf19," func sshGetExeAndArgs(osEnv Env, e Endpoint) (exe string, baseargs []string) {
 		isTortoise = strings.EqualFold(basessh, ""tortoiseplink"")
 	}
 
-	args := make([]string, 0, 4+len(cmdArgs))
+	args := make([]string, 0, 5+len(cmdArgs))
 	if len(cmdArgs) > 0 {
 		args = append(args, cmdArgs...)
 	}
",[False]
GO-2021-0073,git-lfs,git-lfs,f913f5f9c7c6d1301785fdf9884a2942d59cdf19," func sshGetExeAndArgs(osEnv Env, e Endpoint) (exe string, baseargs []string) {
 		}
 		args = append(args, e.SshPort)
 	}
-	args = append(args, e.SshUserAndHost)
+
+	if sep, ok := sshSeparators[basessh]; ok {
+		// inserts a separator between cli -options and host/cmd commands
+		// example: $ ssh -p 12345 -- user@host.com git-lfs-authenticate ...
+		args = append(args, sep, e.SshUserAndHost)
+	} else {
+		// no prefix supported, strip leading - off host to prevent cmd like:
+		// $ git config lfs.url ssh://-proxycmd=whatever
+		// $ plink -P 12345 -proxycmd=foo git-lfs-authenticate ...
+		//
+		// Instead, it'll attempt this, and eventually return an error
+		// $ plink -P 12345 proxycmd=foo git-lfs-authenticate ...
+		args = append(args, sshOptPrefixRE.ReplaceAllString(e.SshUserAndHost, """"))
+	}
 
 	return ssh, args
 }
+
+const defaultSSHCmd = ""ssh""
+
+var (
+	sshOptPrefixRE = regexp.MustCompile(`\A\-+`)
+	sshSeparators  = map[string]string{
+		""ssh"":          ""--"",
+		""lfs-ssh-echo"": ""--"", // used in lfs integration tests only
+	}
+)
",[False]
GO-2021-0084,beego,beego,bac2b31afecc65d9a89f9e473b8006c5edc0c8d1," func (fp *FileProvider) SessionRead(sid string) (Store, error) {
 	filepder.lock.Lock()
 	defer filepder.lock.Unlock()
 
-	err := os.MkdirAll(path.Join(fp.savePath, string(sid[0]), string(sid[1])), 0777)
+	err := os.MkdirAll(path.Join(fp.savePath, string(sid[0]), string(sid[1])), 0755)
 	if err != nil {
 		SLogger.Println(err.Error())
 	}
",[True]
GO-2021-0084,beego,beego,bac2b31afecc65d9a89f9e473b8006c5edc0c8d1," func (fp *FileProvider) SessionRegenerate(oldsid, sid string) (Store, error) {
 		return nil, fmt.Errorf(""newsid %s exist"", newSidFile)
 	}
 
-	err = os.MkdirAll(newPath, 0777)
+	err = os.MkdirAll(newPath, 0755)
 	if err != nil {
 		SLogger.Println(err.Error())
 	}
",[True]
GO-2021-0081,containers,image,634605d06e738aec8332bcfd69162e7509ac7aaf," func (c *dockerClient) getBearerToken(ctx context.Context, challenge challenge,
 		authReq.SetBasicAuth(c.username, c.password)
 	}
 	logrus.Debugf(""%s %s"", authReq.Method, authReq.URL.String())
-	tr := tlsclientconfig.NewTransport()
-	// TODO(runcom): insecure for now to contact the external token service
-	tr.TLSClientConfig = &tls.Config{InsecureSkipVerify: true}
-	client := &http.Client{Transport: tr}
-	res, err := client.Do(authReq)
+	res, err := c.client.Do(authReq)
 	if err != nil {
 		return nil, err
 	}
",[True]
GO-2023-1549,openshift,apiserver-library-go,30f75d79e424ca462c6de53ee8b93f91183763e6," func (s *strategy) validateProfile(fldPath *field.Path, profile string) *field.E
 		// This means that we now have to automatically allow `runtime/default`
 		// if a user specifies `docker/default` and vice versa in an SCC.
 		if s.runtimeDefaultAllowed &&
-			(p == v1.DeprecatedSeccompProfileDockerDefault ||
-				p == v1.SeccompProfileRuntimeDefault) {
+			(profile == v1.DeprecatedSeccompProfileDockerDefault ||
+				profile == v1.SeccompProfileRuntimeDefault) {
 			return nil
 		}
 	}
",[True]
GO-2021-0104,pion,webrtc,545613dcdeb5dedb01cce94175f40bcbe045df2e," func (api *API) NewDTLSTransport(transport *ICETransport, certificates []Certifi
 		state:        DTLSTransportStateNew,
 		dtlsMatcher:  mux.MatchDTLS,
 		srtpReady:    make(chan struct{}),
+		log:          api.settingEngine.LoggerFactory.NewLogger(""DTLSTransport""),
 	}
 
 	if len(certificates) > 0 {
",[False]
GO-2021-0104,pion,webrtc,545613dcdeb5dedb01cce94175f40bcbe045df2e," func (t *DTLSTransport) Start(remoteParameters DTLSParameters) error {
 		return ErrNoSRTPProtectionProfile
 	}
 
-	t.conn = dtlsConn
-	t.onStateChange(DTLSTransportStateConnected)
-
 	if t.api.settingEngine.disableCertificateFingerprintVerification {
 		return nil
 	}
 
 	// Check the fingerprint if a certificate was exchanged
-	remoteCerts := t.conn.ConnectionState().PeerCertificates
+	remoteCerts := dtlsConn.ConnectionState().PeerCertificates
 	if len(remoteCerts) == 0 {
 		t.onStateChange(DTLSTransportStateFailed)
 		return errNoRemoteCertificate
",[True]
GO-2021-0104,pion,webrtc,545613dcdeb5dedb01cce94175f40bcbe045df2e," func (t *DTLSTransport) Start(remoteParameters DTLSParameters) error {
 
 	parsedRemoteCert, err := x509.ParseCertificate(t.remoteCertificate)
 	if err != nil {
+		if closeErr := dtlsConn.Close(); closeErr != nil {
+			t.log.Error(err.Error())
+		}
+
 		t.onStateChange(DTLSTransportStateFailed)
 		return err
 	}
 
 	if err = t.validateFingerPrint(parsedRemoteCert); err != nil {
+		if closeErr := dtlsConn.Close(); closeErr != nil {
+			t.log.Error(err.Error())
+		}
+
 		t.onStateChange(DTLSTransportStateFailed)
 		return err
 	}
 
+	t.conn = dtlsConn
+	t.onStateChange(DTLSTransportStateConnected)
+
 	return t.startSRTP()
 }
 
",[True]
GO-2022-1167,helm,helm,3636f6824757ff734cb265b8770efe48c1fb3737," func newFileParser(sc *bytes.Buffer, data map[string]interface{}, reader RunesVa
 
 func (t *parser) parse() error {
 	for {
-		err := t.key(t.data)
+		err := t.key(t.data, 0)
 		if err == nil {
 			continue
 		}
",[False]
GO-2022-1167,helm,helm,3636f6824757ff734cb265b8770efe48c1fb3737," func runeSet(r []rune) map[rune]bool {
 	return s
 }
 
-func (t *parser) key(data map[string]interface{}) (reterr error) {
+func (t *parser) key(data map[string]interface{}, nestedNameLevel int) (reterr error) {
 	defer func() {
 		if r := recover(); r != nil {
 			reterr = fmt.Errorf(""unable to parse key: %s"", r)
",[True]
GO-2022-1167,helm,helm,3636f6824757ff734cb265b8770efe48c1fb3737," func (t *parser) key(data map[string]interface{}) (reterr error) {
 			}
 
 			// Now we need to get the value after the ].
-			list, err = t.listItem(list, i)
+			list, err = t.listItem(list, i, nestedNameLevel)
 			set(data, kk, list)
 			return err
 		case last == '=':
",[True]
GO-2022-1167,helm,helm,3636f6824757ff734cb265b8770efe48c1fb3737," func (t *parser) key(data map[string]interface{}) (reterr error) {
 			set(data, string(k), """")
 			return errors.Errorf(""key %q has no value (cannot end with ,)"", string(k))
 		case last == '.':
+			// Check value name is within the maximum nested name level
+			nestedNameLevel++
+			if nestedNameLevel > MaxNestedNameLevel {
+				return fmt.Errorf(""value name nested level is greater than maximum supported nested level of %d"", MaxNestedNameLevel)
+			}
+
 			// First, create or find the target map.
 			inner := map[string]interface{}{}
 			if _, ok := data[string(k)]; ok {
",[True]
GO-2022-1167,helm,helm,3636f6824757ff734cb265b8770efe48c1fb3737," func (t *parser) key(data map[string]interface{}) (reterr error) {
 			}
 
 			// Recurse
-			e := t.key(inner)
-			if len(inner) == 0 {
+			e := t.key(inner, nestedNameLevel)
+			if e == nil && len(inner) == 0 {
 				return errors.Errorf(""key map %q has no value"", string(k))
 			}
-			set(data, string(k), inner)
+			if len(inner) != 0 {
+				set(data, string(k), inner)
+			}
 			return e
 		}
 	}
",[True]
GO-2022-1167,helm,helm,3636f6824757ff734cb265b8770efe48c1fb3737," func (t *parser) keyIndex() (int, error) {
 	return strconv.Atoi(string(v))
 
 }
-func (t *parser) listItem(list []interface{}, i int) ([]interface{}, error) {
+func (t *parser) listItem(list []interface{}, i, nestedNameLevel int) ([]interface{}, error) {
 	if i < 0 {
 		return list, fmt.Errorf(""negative %d index not allowed"", i)
 	}
",[False]
GO-2022-1167,helm,helm,3636f6824757ff734cb265b8770efe48c1fb3737," func (t *parser) listItem(list []interface{}, i int) ([]interface{}, error) {
 			}
 		}
 		// Now we need to get the value after the ].
-		list2, err := t.listItem(crtList, nextI)
+		list2, err := t.listItem(crtList, nextI, nestedNameLevel)
 		if err != nil {
 			return list, err
 		}
",[False]
GO-2022-1167,helm,helm,3636f6824757ff734cb265b8770efe48c1fb3737," func (t *parser) listItem(list []interface{}, i int) ([]interface{}, error) {
 		}
 
 		// Recurse
-		e := t.key(inner)
+		e := t.key(inner, nestedNameLevel)
 		if e != nil {
 			return list, e
 		}
",[False]
GO-2021-0083,hybridgroup,gobot,c1aa4f867846da4669ecf3bc3318bd96b7ee6f3f," func (a *Adaptor) newTLSConfig() *tls.Config {
 		ClientCAs: nil,
 		// InsecureSkipVerify = verify that cert contents
 		// match server. IP matches what is in cert etc.
-		InsecureSkipVerify: true,
+		InsecureSkipVerify: false,
 		// Certificates = list of certs client sends to server.
 		Certificates: certs,
 	}
",[True]
GO-2022-0952,matrix-org,gomatrixserverlib,723fd495dde835d078b9f2074b6b62c06dea4575," func NewPowerLevelContentFromEvent(event *Event) (c PowerLevelContent, err error
 			UsersDefaultLevel  levelJSONValue            `json:""users_default""`
 			EventLevels        map[string]levelJSONValue `json:""events""`
 			StateDefaultLevel  levelJSONValue            `json:""state_default""`
-			EventDefaultLevel  levelJSONValue            `json:""event_default""`
+			EventDefaultLevel  levelJSONValue            `json:""events_default""`
 			NotificationLevels map[string]levelJSONValue `json:""notifications""`
 		}
 		if err = json.Unmarshal(event.Content(), &content); err != nil {
",[True]
GO-2021-0412,containerd,imgcrypt,6fdd9818a4d8142107b7ecd767d839c9707700d9," const (
 // LayerFilter allows to select Layers by certain criteria
 type LayerFilter func(desc ocispec.Descriptor) bool
 
+// isLocalPlatform determines whether the given platform matches the local one
+func isLocalPlatform(platform *ocispec.Platform) bool {
+	matcher := platforms.NewMatcher(*platform)
+
+	return matcher.Match(platforms.DefaultSpec())
+}
+
 // IsEncryptedDiff returns true if mediaType is a known encrypted media type.
 func IsEncryptedDiff(ctx context.Context, mediaType string) bool {
 	switch mediaType {
",[False]
GO-2021-0412,containerd,imgcrypt,6fdd9818a4d8142107b7ecd767d839c9707700d9," func cryptManifestList(ctx context.Context, cs content.Store, desc ocispec.Descr
 	var newManifests []ocispec.Descriptor
 	modified := false
 	for _, manifest := range index.Manifests {
+		if cryptoOp == cryptoOpUnwrapOnly && !isLocalPlatform(manifest.Platform) {
+			continue
+		}
 		newManifest, m, err := cryptChildren(ctx, cs, manifest, cc, lf, cryptoOp, manifest.Platform)
 		if err != nil || cryptoOp == cryptoOpUnwrapOnly {
 			return ocispec.Descriptor{}, false, err
",[True]
GO-2021-0412,containerd,imgcrypt,6fdd9818a4d8142107b7ecd767d839c9707700d9," func cryptManifestList(ctx context.Context, cs content.Store, desc ocispec.Descr
 		}
 		newManifests = append(newManifests, newManifest)
 	}
+	if cryptoOp == cryptoOpUnwrapOnly {
+		return ocispec.Descriptor{}, false, fmt.Errorf(""No manifest found for local platform"")
+	}
 
 	if modified {
 		// we need to update the index
",[True]
GO-2020-0043,caddyserver,caddy,4d9ee000c8d2cbcdd8284007c1e0f2da7bc3c7c3," func (h *httpContext) InspectServerBlocks(sourceFile string, serverBlocks []cadd
 // MakeServers uses the newly-created siteConfigs to
 // create and return a list of server instances.
 func (h *httpContext) MakeServers() ([]caddy.Server, error) {
-	// make sure TLS is disabled for explicitly-HTTP sites
-	// (necessary when HTTP address shares a block containing tls)
+	// Iterate each site configuration and make sure that:
+	// 1) TLS is disabled for explicitly-HTTP sites (necessary
+	//    when an HTTP address shares a block containing tls)
+	// 2) if QUIC is enabled, TLS ClientAuth is not, because
+	//    currently, QUIC does not support ClientAuth (TODO:
+	//    revisit this when our QUIC implementation supports it)
+	// 3) if TLS ClientAuth is used, StrictHostMatching is on
 	for _, cfg := range h.siteConfigs {
 		if !cfg.TLS.Enabled {
 			continue
",[True]
GO-2020-0043,caddyserver,caddy,4d9ee000c8d2cbcdd8284007c1e0f2da7bc3c7c3," func (h *httpContext) MakeServers() ([]caddy.Server, error) {
 			// instead of 443 because it doesn't know about TLS.
 			cfg.Addr.Port = HTTPSPort
 		}
+		if cfg.TLS.ClientAuth != tls.NoClientCert {
+			if QUIC {
+				return nil, fmt.Errorf(""cannot enable TLS client authentication with QUIC, because QUIC does not yet support it"")
+			}
+			// this must be enabled so that a client cannot connect
+			// using SNI for another site on this listener that
+			// does NOT require ClientAuth, and then send HTTP
+			// requests with the Host header of this site which DOES
+			// require client auth, thus bypassing it...
+			cfg.StrictHostMatching = true
+		}
 	}
 
 	// we must map (group) each config to a bind address
",[True]
GO-2020-0043,caddyserver,caddy,4d9ee000c8d2cbcdd8284007c1e0f2da7bc3c7c3," func (s *Server) serveHTTP(w http.ResponseWriter, r *http.Request) (int, error)
 		r.URL = trimPathPrefix(r.URL, pathPrefix)
 	}
 
+	// enforce strict host matching, which ensures that the SNI
+	// value (if any), matches the Host header; essential for
+	// sites that rely on TLS ClientAuth sharing a port with
+	// sites that do not - if mismatched, close the connection
+	if vhost.StrictHostMatching && r.TLS != nil &&
+		strings.ToLower(r.TLS.ServerName) != strings.ToLower(hostname) {
+		r.Close = true
+		log.Printf(""[ERROR] %s - strict host matching: SNI (%s) and HTTP Host (%s) values differ"",
+			vhost.Addr, r.TLS.ServerName, hostname)
+		return http.StatusForbidden, nil
+	}
+
 	return vhost.middlewareChain.ServeHTTP(w, r)
 }
 
",[True]
GO-2020-0043,caddyserver,caddy,4d9ee000c8d2cbcdd8284007c1e0f2da7bc3c7c3," func assertConfigsCompatible(cfg1, cfg2 *Config) error {
 	if c1.ClientAuth != c2.ClientAuth {
 		return fmt.Errorf(""client authentication policy mismatch"")
 	}
+	if c1.ClientAuth != tls.NoClientCert && c2.ClientAuth != tls.NoClientCert && c1.ClientCAs != c2.ClientCAs {
+		// Two hosts defined on the same listener are not compatible if they
+		// have ClientAuth enabled, because there's no guarantee beyond the
+		// hostname which config will be used (because SNI only has server name).
+		// To prevent clients from bypassing authentication, require that
+		// ClientAuth be configured in an unambiguous manner.
+		return fmt.Errorf(""multiple hosts requiring client authentication ambiguously configured"")
+	}
 
 	return nil
 }
",[True]
GO-2021-0071,lxc,lxd,19c6961cc1012c8a529f20807328a9357f5034f4," func GetOwner(path string) (int, int, error) {
 }
 
 func (set *IdmapSet) doUidshiftIntoContainer(dir string, testmode bool, how string) error {
+	dir = strings.TrimRight(dir, ""/"")
+
 	convert := func(path string, fi os.FileInfo, err error) (e error) {
 		uid, gid, err := GetOwner(path)
 		if err != nil {
",[True]
GO-2021-0071,lxc,lxd,19c6961cc1012c8a529f20807328a9357f5034f4," func (set *IdmapSet) doUidshiftIntoContainer(dir string, testmode bool, how stri
 		if testmode {
 			fmt.Printf(""I would shift %q to %d %d\n"", path, newuid, newgid)
 		} else {
-			err = os.Lchown(path, int(newuid), int(newgid))
-			if err == nil {
-				m := fi.Mode()
-				if m&os.ModeSymlink == 0 {
-					err = os.Chmod(path, m)
-					if err != nil {
-						fmt.Printf(""Error resetting mode on %q, continuing\n"", path)
-					}
-				}
+			err = ShiftOwner(dir, path, int(newuid), int(newgid))
+			if err != nil {
+				return err
 			}
 		}
 		return nil
",[True]
GO-2022-1178,bradleyfalzon,ghinstallation,d24f14f8be70d94129d76026e8b0f4f9170c8c3e," func (t *Transport) refreshToken(ctx context.Context) error {
 	defer resp.Body.Close()
 
 	if resp.StatusCode/100 != 2 {
-		return fmt.Errorf(""request %+v received non 2xx response status %q with body %+v and TLS %+v"", resp.Request, resp.Body, resp.Request, resp.TLS)
+		return fmt.Errorf(""received non 2xx response status %q when fetching %v"", resp.Status, req.URL)
 	}
 
 	return json.NewDecoder(resp.Body).Decode(&t.token)
",[True]
GO-2022-0619,emicklei,go-restful,f292efff46ae17e9d104f865a60a39a2ae9402f1," func (c CrossOriginResourceSharing) isValidAccessControlRequestHeader(header str
 	return false
 }
 
-// Take a list of strings and compile them into a list of regular expressions.
-func compileRegexps(regexpStrings []string) ([]*regexp.Regexp, error) {
+// Take a list of allowed domains as strings and compile them into a list of regular expressions.
+func compileRegexps(allowedDomains []string) ([]*regexp.Regexp, error) {
 	regexps := []*regexp.Regexp{}
-	for _, regexpStr := range regexpStrings {
-		r, err := regexp.Compile(regexpStr)
+	for _, each := range allowedDomains {
+		// make sure the expression represents an exact match
+		if !strings.HasPrefix(each, ""^"") {
+			each = fmt.Sprintf(""^%s$"", each)
+		}
+		r, err := regexp.Compile(each)
 		if err != nil {
 			return regexps, err
 		}
",[False]
GO-2022-0435,go.googlesource.com,go,37065847d87df92b5eb246c88ba2085efcf0b331," func p256GetScalar(out *[32]byte, in []byte) {
 	n := new(big.Int).SetBytes(in)
 	var scalarBytes []byte
 
-	if n.Cmp(p256Params.N) >= 0 {
+	if n.Cmp(p256Params.N) >= 0 || len(in) > len(out) {
 		n.Mod(n, p256Params.N)
 		scalarBytes = n.Bytes()
 	} else {
",[True]
GO-2022-0521,go.googlesource.com,go,08c46ed43d80bbb67cb904944ea3417989be4af3," Loop:
 }
 
 // Skip reads tokens until it has consumed the end element
-// matching the most recent start element already consumed.
-// It recurs if it encounters a start element, so it can be used to
-// skip nested structures.
+// matching the most recent start element already consumed,
+// skipping nested structures.
 // It returns nil if it finds an end element matching the start
 // element; otherwise it returns an error describing the problem.
 func (d *Decoder) Skip() error {
+	var depth int64
 	for {
 		tok, err := d.Token()
 		if err != nil {
",[True]
GO-2022-0521,go.googlesource.com,go,08c46ed43d80bbb67cb904944ea3417989be4af3," func (d *Decoder) Skip() error {
 		}
 		switch tok.(type) {
 		case StartElement:
-			if err := d.Skip(); err != nil {
-				return err
-			}
+			depth++
 		case EndElement:
-			return nil
+			if depth == 0 {
+				return nil
+			}
+			depth--
 		}
 	}
 }
",[True]
GO-2022-0220,go.googlesource.com,go,9b6e9f0c8c66355c0f0575d808b32f52c8c6d21c," func loadOptionalSyscalls() {
 	_AddDllDirectory = windowsFindfunc(k32, []byte(""AddDllDirectory\000""))
 	_AddVectoredContinueHandler = windowsFindfunc(k32, []byte(""AddVectoredContinueHandler\000""))
 	_GetQueuedCompletionStatusEx = windowsFindfunc(k32, []byte(""GetQueuedCompletionStatusEx\000""))
+	_LoadLibraryExA = windowsFindfunc(k32, []byte(""LoadLibraryExA\000""))
 	_LoadLibraryExW = windowsFindfunc(k32, []byte(""LoadLibraryExW\000""))
+	useLoadLibraryEx = (_LoadLibraryExW != nil && _LoadLibraryExA != nil && _AddDllDirectory != nil)
 
 	var advapi32dll = []byte(""advapi32.dll\000"")
-	a32 := stdcall1(_LoadLibraryA, uintptr(unsafe.Pointer(&advapi32dll[0])))
+	a32 := windowsLoadSystemLib(advapi32dll)
 	if a32 == 0 {
 		throw(""advapi32.dll not found"")
 	}
 	_RtlGenRandom = windowsFindfunc(a32, []byte(""SystemFunction036\000""))
 
 	var ntdll = []byte(""ntdll.dll\000"")
-	n32 := stdcall1(_LoadLibraryA, uintptr(unsafe.Pointer(&ntdll[0])))
+	n32 := windowsLoadSystemLib(ntdll)
 	if n32 == 0 {
 		throw(""ntdll.dll not found"")
 	}
",[True]
GO-2022-0220,go.googlesource.com,go,9b6e9f0c8c66355c0f0575d808b32f52c8c6d21c," func loadOptionalSyscalls() {
 		}
 	}
 
+	var winmmdll = []byte(""winmm.dll\000"")
+	m32 := windowsLoadSystemLib(winmmdll)
+	if m32 == 0 {
+		throw(""winmm.dll not found"")
+	}
+	_timeBeginPeriod = windowsFindfunc(m32, []byte(""timeBeginPeriod\000""))
+	_timeEndPeriod = windowsFindfunc(m32, []byte(""timeEndPeriod\000""))
+	if _timeBeginPeriod == nil || _timeEndPeriod == nil {
+		throw(""timeBegin/EndPeriod not found"")
+	}
+
+	var ws232dll = []byte(""ws2_32.dll\000"")
+	ws232 := windowsLoadSystemLib(ws232dll)
+	if ws232 == 0 {
+		throw(""ws2_32.dll not found"")
+	}
+	_WSAGetOverlappedResult = windowsFindfunc(ws232, []byte(""WSAGetOverlappedResult\000""))
+	if _WSAGetOverlappedResult == nil {
+		throw(""WSAGetOverlappedResult not found"")
+	}
+
 	if windowsFindfunc(n32, []byte(""wine_get_version\000"")) != nil {
 		// running on Wine
 		initWine(k32)
",[True]
GO-2022-0220,go.googlesource.com,go,9b6e9f0c8c66355c0f0575d808b32f52c8c6d21c," func compileCallback(fn eface, cleanstack bool) (code uintptr) {
 
 const _LOAD_LIBRARY_SEARCH_SYSTEM32 = 0x00000800
 
+// When available, this function will use LoadLibraryEx with the filename
+// parameter and the important SEARCH_SYSTEM32 argument. But on systems that
+// do not have that option, absoluteFilepath should contain a fallback
+// to the full path inside of system32 for use with vanilla LoadLibrary.
 //go:linkname syscall_loadsystemlibrary syscall.loadsystemlibrary
 //go:nosplit
-func syscall_loadsystemlibrary(filename *uint16) (handle, err uintptr) {
+func syscall_loadsystemlibrary(filename *uint16, absoluteFilepath *uint16) (handle, err uintptr) {
 	lockOSThread()
 	defer unlockOSThread()
 	c := &getg().m.syscall
",[True]
GO-2022-0220,go.googlesource.com,go,9b6e9f0c8c66355c0f0575d808b32f52c8c6d21c," func syscall_loadsystemlibrary(filename *uint16) (handle, err uintptr) {
 		}{filename, 0, _LOAD_LIBRARY_SEARCH_SYSTEM32}
 		c.args = uintptr(noescape(unsafe.Pointer(&args)))
 	} else {
-		// User doesn't have KB2533623 installed. The caller
-		// wanted to only load the filename DLL from the
-		// System32 directory but that facility doesn't exist,
-		// so just load it the normal way. This is a potential
-		// security risk, but so is not installing security
-		// updates.
 		c.fn = getLoadLibrary()
 		c.n = 1
-		c.args = uintptr(noescape(unsafe.Pointer(&filename)))
+		c.args = uintptr(noescape(unsafe.Pointer(&absoluteFilepath)))
 	}
 
 	cgocall(asmstdcallAddr, unsafe.Pointer(c))
",[True]
GO-2022-0220,go.googlesource.com,go,9b6e9f0c8c66355c0f0575d808b32f52c8c6d21c," func Syscall12(trap, nargs, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12 ui
 func Syscall15(trap, nargs, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15 uintptr) (r1, r2 uintptr, err Errno)
 func Syscall18(trap, nargs, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18 uintptr) (r1, r2 uintptr, err Errno)
 func loadlibrary(filename *uint16) (handle uintptr, err Errno)
-func loadsystemlibrary(filename *uint16) (handle uintptr, err Errno)
+func loadsystemlibrary(filename *uint16, absoluteFilepath *uint16) (handle uintptr, err Errno)
 func getprocaddress(handle uintptr, procname *uint8) (proc uintptr, err Errno)
 
 // A DLL implements access to a single DLL.
",[False]
GO-2022-0220,go.googlesource.com,go,9b6e9f0c8c66355c0f0575d808b32f52c8c6d21c," type DLL struct {
 	Handle Handle
 }
 
+// We use this for computing the absolute path for system DLLs on systems
+// where SEARCH_SYSTEM32 is not available.
+var systemDirectoryPrefix string
+
+func init() {
+	n := uint32(MAX_PATH)
+	for {
+		b := make([]uint16, n)
+		l, e := getSystemDirectory(&b[0], n)
+		if e != nil {
+			panic(""Unable to determine system directory: "" + e.Error())
+		}
+		if l <= n {
+			systemDirectoryPrefix = UTF16ToString(b[:l]) + ""\\""
+			break
+		}
+		n = l
+	}
+}
+
 // LoadDLL loads the named DLL file into memory.
 //
 // If name is not an absolute path and is not a known system DLL used by
",[False]
GO-2022-0220,go.googlesource.com,go,9b6e9f0c8c66355c0f0575d808b32f52c8c6d21c," func LoadDLL(name string) (*DLL, error) {
 	var h uintptr
 	var e Errno
 	if sysdll.IsSystemDLL[name] {
-		h, e = loadsystemlibrary(namep)
+		absoluteFilepathp, err := UTF16PtrFromString(systemDirectoryPrefix + name)
+		if err != nil {
+			return nil, err
+		}
+		h, e = loadsystemlibrary(namep, absoluteFilepathp)
 	} else {
 		h, e = loadlibrary(namep)
 	}
",[True]
GO-2022-0220,go.googlesource.com,go,9b6e9f0c8c66355c0f0575d808b32f52c8c6d21c," func GetUserProfileDirectory(t Token, dir *uint16, dirLen *uint32) (err error) {
 	}
 	return
 }
+
+func getSystemDirectory(dir *uint16, dirLen uint32) (len uint32, err error) {
+	r0, _, e1 := Syscall(procGetSystemDirectoryW.Addr(), 2, uintptr(unsafe.Pointer(dir)), uintptr(dirLen), 0)
+	len = uint32(r0)
+	if len == 0 {
+		if e1 != 0 {
+			err = errnoErr(e1)
+		} else {
+			err = EINVAL
+		}
+	}
+	return
+}
",[False]
GO-2022-0220,go.googlesource.com,go,9b6e9f0c8c66355c0f0575d808b32f52c8c6d21c," func osinit() {
 
 	loadOptionalSyscalls()
 
-	useLoadLibraryEx = (_LoadLibraryExW != nil && _AddDllDirectory != nil)
-
 	disableWER()
 
 	initExceptionHandler()
",[True]
GO-2022-0166,go.googlesource.com,go,eb876dd83cb8413335d64e50aae5d38337d1ebb4," func Sign(rand io.Reader, priv *PrivateKey, hash []byte) (r, s *big.Int, err err
 func Verify(pub *PublicKey, hash []byte, r, s *big.Int) bool {
 	// FIPS 186-3, section 4.7
 
+	if pub.P.Sign() == 0 {
+		return false
+	}
+
 	if r.Sign() < 1 || r.Cmp(pub.Q) >= 0 {
 		return false
 	}
",[True]
GO-2021-0227,go.googlesource.com,crypto,8b5274cf687fd9316b4108863654cc57385531e8," userAuthLoop:
 				perms = candidate.perms
 			}
 		case ""gssapi-with-mic"":
+			if config.GSSAPIWithMICConfig == nil {
+				authErr = errors.New(""ssh: gssapi-with-mic auth not configured"")
+				break
+			}
 			gssapiConfig := config.GSSAPIWithMICConfig
 			userAuthRequestGSSAPI, err := parseGSSAPIPayload(userAuthReq.Payload)
 			if err != nil {
",[True]
GO-2022-0192,go.googlesource.com,net,cf3bd585ca2a5a21b057abd8be7eea2204af89d0," func (p *parser) resetInsertionMode() {
 		case a.Table:
 			p.im = inTableIM
 		case a.Template:
+			// TODO: remove this divergence from the HTML5 spec.
+			if n.Namespace != """" {
+				continue
+			}
 			p.im = p.templateStack.top()
 		case a.Head:
 			// TODO: remove this divergence from the HTML5 spec.
",[True]
GO-2022-0197,go.googlesource.com,net,4b62a64f59f73840b9ab79204c94fee61cd1ba2c," func (s *nodeStack) index(n *Node) int {
 // contains returns whether a is within s.
 func (s *nodeStack) contains(a atom.Atom) bool {
 	for _, n := range *s {
-		if n.DataAtom == a {
+		if n.DataAtom == a && n.Namespace == """" {
 			return true
 		}
 	}
",[True]
GO-2022-0515,go.googlesource.com,go,695be961d57508da5a82217f7415200a11845879," func ParseFile(fset *token.FileSet, filename string, src any, mode Mode) (f *ast
 	defer func() {
 		if e := recover(); e != nil {
 			// resume same panic if it's not a bailout
-			if _, ok := e.(bailout); !ok {
+			bail, ok := e.(bailout)
+			if !ok {
 				panic(e)
+			} else if bail.msg != """" {
+				p.errors.Add(p.file.Position(bail.pos), bail.msg)
 			}
 		}
 
",[True]
GO-2022-0515,go.googlesource.com,go,695be961d57508da5a82217f7415200a11845879," func ParseExprFrom(fset *token.FileSet, filename string, src any, mode Mode) (ex
 	defer func() {
 		if e := recover(); e != nil {
 			// resume same panic if it's not a bailout
-			if _, ok := e.(bailout); !ok {
+			bail, ok := e.(bailout)
+			if !ok {
 				panic(e)
+			} else if bail.msg != """" {
+				p.errors.Add(p.file.Position(bail.pos), bail.msg)
 			}
 		}
 		p.errors.Sort()
",[True]
GO-2022-0515,go.googlesource.com,go,695be961d57508da5a82217f7415200a11845879," func (p *parser) parseTypeInstance(typ ast.Expr) ast.Expr {
 }
 
 func (p *parser) tryIdentOrType() ast.Expr {
+	defer decNestLev(incNestLev(p))
+
 	switch p.tok {
 	case token.IDENT:
 		typ := p.parseTypeName(nil)
",[True]
GO-2022-0515,go.googlesource.com,go,695be961d57508da5a82217f7415200a11845879," func (p *parser) parsePrimaryExpr(x ast.Expr) ast.Expr {
 	if x == nil {
 		x = p.parseOperand()
 	}
-	for {
+	// We track the nesting here rather than at the entry for the function,
+	// since it can iteratively produce a nested output, and we want to
+	// limit how deep a structure we generate.
+	var n int
+	defer func() { p.nestLev -= n }()
+	for n = 1; ; n++ {
+		incNestLev(p)
 		switch p.tok {
 		case token.PERIOD:
 			p.next()
",[True]
GO-2022-0515,go.googlesource.com,go,695be961d57508da5a82217f7415200a11845879," func (p *parser) parsePrimaryExpr(x ast.Expr) ast.Expr {
 }
 
 func (p *parser) parseUnaryExpr() ast.Expr {
+	defer decNestLev(incNestLev(p))
+
 	if p.trace {
 		defer un(trace(p, ""UnaryExpr""))
 	}
",[True]
GO-2022-0515,go.googlesource.com,go,695be961d57508da5a82217f7415200a11845879," func (p *parser) parseBinaryExpr(x ast.Expr, prec1 int, check bool) ast.Expr {
 	if x == nil {
 		x = p.parseUnaryExpr()
 	}
-	for {
+	// We track the nesting here rather than at the entry for the function,
+	// since it can iteratively produce a nested output, and we want to
+	// limit how deep a structure we generate.
+	var n int
+	defer func() { p.nestLev -= n }()
+	for n = 1; ; n++ {
+		incNestLev(p)
 		op, oprec := p.tokPrec()
 		if oprec < prec1 {
 			return x
",[True]
GO-2022-0515,go.googlesource.com,go,695be961d57508da5a82217f7415200a11845879," func (p *parser) parseIfHeader() (init ast.Stmt, cond ast.Expr) {
 }
 
 func (p *parser) parseIfStmt() *ast.IfStmt {
+	defer decNestLev(incNestLev(p))
+
 	if p.trace {
 		defer un(trace(p, ""IfStmt""))
 	}
",[True]
GO-2022-0515,go.googlesource.com,go,695be961d57508da5a82217f7415200a11845879," func (p *parser) parseForStmt() ast.Stmt {
 }
 
 func (p *parser) parseStmt() (s ast.Stmt) {
+	defer decNestLev(incNestLev(p))
+
 	if p.trace {
 		defer un(trace(p, ""Statement""))
 	}
",[True]
GO-2022-0247,go.googlesource.com,go,77f2750f4398990eed972186706f160631d7dae4," func (ctxt *Link) address() []*sym.Segment {
 	order = append(order, &Segtext)
 	Segtext.Rwx = 05
 	Segtext.Vaddr = va
-	for _, s := range Segtext.Sections {
+	for i, s := range Segtext.Sections {
 		va = uint64(Rnd(int64(va), int64(s.Align)))
 		s.Vaddr = va
 		va += s.Length
+
+		if ctxt.IsWasm() && i == 0 && va < wasmMinDataAddr {
+			va = wasmMinDataAddr
+		}
 	}
 
 	Segtext.Length = va - uint64(*FlagTextAddr)
",[True]
GO-2021-0142,go.googlesource.com,go,027d7241ce050d197e7fabea3d541ffbe3487258," var overflow = errors.New(""binary: varint overflows a 64-bit integer"")
 func ReadUvarint(r io.ByteReader) (uint64, error) {
 	var x uint64
 	var s uint
-	for i := 0; ; i++ {
+	for i := 0; i < MaxVarintLen64; i++ {
 		b, err := r.ReadByte()
 		if err != nil {
 			return x, err
 		}
 		if b < 0x80 {
-			if i > 9 || i == 9 && b > 1 {
+			if i == 9 && b > 1 {
 				return x, overflow
 			}
 			return x | uint64(b)<<s, nil
",[True]
GO-2021-0142,go.googlesource.com,go,027d7241ce050d197e7fabea3d541ffbe3487258," func ReadUvarint(r io.ByteReader) (uint64, error) {
 		x |= uint64(b&0x7f) << s
 		s += 7
 	}
+	return x, overflow
 }
 
 // ReadVarint reads an encoded signed integer from r and returns it as an int64.
",[True]
GO-2022-0526,go.googlesource.com,go,6fa37e98ea4382bf881428ee0c150ce591500eb7," func (dec *Decoder) decOpFor(wireId typeId, rt reflect.Type, name string, inProg
 	return &op
 }
 
+var maxIgnoreNestingDepth = 10000
+
 // decIgnoreOpFor returns the decoding op for a field that has no destination.
-func (dec *Decoder) decIgnoreOpFor(wireId typeId, inProgress map[typeId]*decOp) *decOp {
+func (dec *Decoder) decIgnoreOpFor(wireId typeId, inProgress map[typeId]*decOp, depth int) *decOp {
+	if depth > maxIgnoreNestingDepth {
+		error_(errors.New(""invalid nesting depth""))
+	}
 	// If this type is already in progress, it's a recursive type (e.g. map[string]*T).
 	// Return the pointer to the op we're already building.
 	if opPtr := inProgress[wireId]; opPtr != nil {
",[True]
GO-2022-0526,go.googlesource.com,go,6fa37e98ea4382bf881428ee0c150ce591500eb7," func (dec *Decoder) decIgnoreOpFor(wireId typeId, inProgress map[typeId]*decOp)
 			errorf(""bad data: undefined type %s"", wireId.string())
 		case wire.ArrayT != nil:
 			elemId := wire.ArrayT.Elem
-			elemOp := dec.decIgnoreOpFor(elemId, inProgress)
+			elemOp := dec.decIgnoreOpFor(elemId, inProgress, depth+1)
 			op = func(i *decInstr, state *decoderState, value reflect.Value) {
 				state.dec.ignoreArray(state, *elemOp, wire.ArrayT.Len)
 			}
",[True]
GO-2022-0526,go.googlesource.com,go,6fa37e98ea4382bf881428ee0c150ce591500eb7," func (dec *Decoder) decIgnoreOpFor(wireId typeId, inProgress map[typeId]*decOp)
 		case wire.MapT != nil:
 			keyId := dec.wireType[wireId].MapT.Key
 			elemId := dec.wireType[wireId].MapT.Elem
-			keyOp := dec.decIgnoreOpFor(keyId, inProgress)
-			elemOp := dec.decIgnoreOpFor(elemId, inProgress)
+			keyOp := dec.decIgnoreOpFor(keyId, inProgress, depth+1)
+			elemOp := dec.decIgnoreOpFor(elemId, inProgress, depth+1)
 			op = func(i *decInstr, state *decoderState, value reflect.Value) {
 				state.dec.ignoreMap(state, *keyOp, *elemOp)
 			}
 
 		case wire.SliceT != nil:
 			elemId := wire.SliceT.Elem
-			elemOp := dec.decIgnoreOpFor(elemId, inProgress)
+			elemOp := dec.decIgnoreOpFor(elemId, inProgress, depth+1)
 			op = func(i *decInstr, state *decoderState, value reflect.Value) {
 				state.dec.ignoreSlice(state, *elemOp)
 			}
",[True]
GO-2022-0526,go.googlesource.com,go,6fa37e98ea4382bf881428ee0c150ce591500eb7," func (dec *Decoder) compileSingle(remoteId typeId, ut *userTypeInfo) (engine *de
 func (dec *Decoder) compileIgnoreSingle(remoteId typeId) *decEngine {
 	engine := new(decEngine)
 	engine.instr = make([]decInstr, 1) // one item
-	op := dec.decIgnoreOpFor(remoteId, make(map[typeId]*decOp))
+	op := dec.decIgnoreOpFor(remoteId, make(map[typeId]*decOp), 0)
 	ovfl := overflow(dec.typeString(remoteId))
 	engine.instr[0] = decInstr{*op, 0, nil, ovfl}
 	engine.numInstr = 1
",[True]
GO-2022-0526,go.googlesource.com,go,6fa37e98ea4382bf881428ee0c150ce591500eb7," func (dec *Decoder) compileDec(remoteId typeId, ut *userTypeInfo) (engine *decEn
 		localField, present := srt.FieldByName(wireField.Name)
 		// TODO(r): anonymous names
 		if !present || !isExported(wireField.Name) {
-			op := dec.decIgnoreOpFor(wireField.Id, make(map[typeId]*decOp))
+			op := dec.decIgnoreOpFor(wireField.Id, make(map[typeId]*decOp), 0)
 			engine.instr[fieldnum] = decInstr{*op, fieldnum, nil, ovfl}
 			continue
 		}
",[True]
GO-2022-0190,go.googlesource.com,go,bc82d7c7db83487e05d7a88e06549d4ae2a688c3," func downloadPackage(p *load.Package) error {
 		security = web.Insecure
 	}
 
+	if err := CheckImportPath(p.ImportPath); err != nil {
+		return fmt.Errorf(""%s: invalid import path: %v"", p.ImportPath, err)
+	}
+
 	if p.Internal.Build.SrcRoot != """" {
 		// Directory exists. Look for checkout along path to src.
 		vcs, rootPath, err = vcsFromDir(p.Dir, p.Internal.Build.SrcRoot)
",[True]
GO-2022-0189,go.googlesource.com,go,bc82d7c7db83487e05d7a88e06549d4ae2a688c3," func downloadPackage(p *load.Package) error {
 		security = web.Insecure
 	}
 
+	if err := CheckImportPath(p.ImportPath); err != nil {
+		return fmt.Errorf(""%s: invalid import path: %v"", p.ImportPath, err)
+	}
+
 	if p.Internal.Build.SrcRoot != """" {
 		// Directory exists. Look for checkout along path to src.
 		vcs, rootPath, err = vcsFromDir(p.Dir, p.Internal.Build.SrcRoot)
",[True]
GO-2022-0535,go.googlesource.com,go,953bc8f391a63adf00bac2515dba62abe8a1e2c2," func (c *Certificate) systemVerify(opts *VerifyOptions) (chains [][]*Certificate
 	if err != nil {
 		return nil, err
 	}
+	if len(chain) < 1 {
+		return nil, errors.New(""x509: internal error: system verifier returned an empty chain"")
+	}
 
-	chains = append(chains, chain)
+	// Mitigate CVE-2020-0601, where the Windows system verifier might be
+	// tricked into using custom curve parameters for a trusted root, by
+	// double-checking all ECDSA signatures. If the system was tricked into
+	// using spoofed parameters, the signature will be invalid for the correct
+	// ones we parsed. (We don't support custom curves ourselves.)
+	for i, parent := range chain[1:] {
+		if parent.PublicKeyAlgorithm != ECDSA {
+			continue
+		}
+		if err := parent.CheckSignature(chain[i].SignatureAlgorithm,
+			chain[i].RawTBSCertificate, chain[i].Signature); err != nil {
+			return nil, err
+		}
+	}
 
-	return chains, nil
+	return [][]*Certificate{chain}, nil
 }
 
 func loadSystemRoots() (*CertPool, error) {
",[True]
GO-2022-0536,go.googlesource.com,go,145e193131eb486077b66009beb051aba07c52a5," func (s *http2Server) maxConcurrentStreams() uint32 {
 	return http2defaultMaxStreams
 }
 
+// maxQueuedControlFrames is the maximum number of control frames like
+// SETTINGS, PING and RST_STREAM that will be queued for writing before
+// the connection is closed to prevent memory exhaustion attacks.
+func (s *http2Server) maxQueuedControlFrames() int {
+	// TODO: if anybody asks, add a Server field, and remember to define the
+	// behavior of negative values.
+	return http2maxQueuedControlFrames
+}
+
 type http2serverInternalState struct {
 	mu          sync.Mutex
 	activeConns map[*http2serverConn]struct{}
",[False]
GO-2022-0536,go.googlesource.com,go,145e193131eb486077b66009beb051aba07c52a5," func (sc *http2serverConn) serve() {
 			}
 		}
 
+		// If the peer is causing us to generate a lot of control frames,
+		// but not reading them from us, assume they are trying to make us
+		// run out of memory.
+		if sc.queuedControlFrames > sc.srv.maxQueuedControlFrames() {
+			sc.vlogf(""http2: too many control frames in send queue, closing connection"")
+			return
+		}
+
 		// Start the shutdown timer after sending a GOAWAY. When sending GOAWAY
 		// with no error code (graceful shutdown), don't start the timer until
 		// all open streams have been completed.
",[True]
GO-2022-0536,go.googlesource.com,go,145e193131eb486077b66009beb051aba07c52a5," func (sc *http2serverConn) writeFrame(wr http2FrameWriteRequest) {
 	}
 
 	if !ignoreWrite {
+		if wr.isControl() {
+			sc.queuedControlFrames++
+			// For extra safety, detect wraparounds, which should not happen,
+			// and pull the plug.
+			if sc.queuedControlFrames < 0 {
+				sc.conn.Close()
+			}
+		}
 		sc.writeSched.Push(wr)
 	}
 	sc.scheduleFrameWrite()
",[True]
GO-2022-0536,go.googlesource.com,go,145e193131eb486077b66009beb051aba07c52a5," func (sc *http2serverConn) scheduleFrameWrite() {
 		}
 		if !sc.inGoAway || sc.goAwayCode == http2ErrCodeNo {
 			if wr, ok := sc.writeSched.Pop(); ok {
+				if wr.isControl() {
+					sc.queuedControlFrames--
+				}
 				sc.startFrameWrite(wr)
 				continue
 			}
",[True]
GO-2022-0536,go.googlesource.com,go,145e193131eb486077b66009beb051aba07c52a5," func (sc *http2serverConn) processSettings(f *http2SettingsFrame) error {
 	if err := f.ForeachSetting(sc.processSetting); err != nil {
 		return err
 	}
+	// TODO: judging by RFC 7540, Section 6.5.3 each SETTINGS frame should be
+	// acknowledged individually, even if multiple are received before the ACK.
 	sc.needToSendSettingsAck = true
 	sc.scheduleFrameWrite()
 	return nil
",[False]
GO-2022-0536,go.googlesource.com,go,145e193131eb486077b66009beb051aba07c52a5," func (cc *http2ClientConn) roundTrip(req *Request) (res *Response, gotErrAfterRe
 		req.Method != ""HEAD"" {
 		// Request gzip only, not deflate. Deflate is ambiguous and
 		// not as universally supported anyway.
-		// See: http://www.gzip.org/zlib/zlib_faq.html#faq38
+		// See: https://zlib.net/zlib_faq.html#faq39
 		//
 		// Note that we don't request this for HEAD requests,
 		// due to a bug in nginx:
",[False]
GO-2022-0536,go.googlesource.com,go,145e193131eb486077b66009beb051aba07c52a5," func (wr http2FrameWriteRequest) StreamID() uint32 {
 	return wr.stream.id
 }
 
+// isControl reports whether wr is a control frame for MaxQueuedControlFrames
+// purposes. That includes non-stream frames and RST_STREAM frames.
+func (wr http2FrameWriteRequest) isControl() bool {
+	return wr.stream == nil
+}
+
 // DataSize returns the number of flow control bytes that must be consumed
 // to write this entire frame. This is 0 for non-DATA frames.
 func (wr http2FrameWriteRequest) DataSize() int {
",[False]
GO-2022-0525,go.googlesource.com,go,e5017a93fcde94f09836200bca55324af037ee5f," func (t *transferReader) parseTransferEncoding() error {
 	if len(raw) != 1 {
 		return &unsupportedTEError{fmt.Sprintf(""too many transfer encodings: %q"", raw)}
 	}
-	if !ascii.EqualFold(textproto.TrimString(raw[0]), ""chunked"") {
+	if !ascii.EqualFold(raw[0], ""chunked"") {
 		return &unsupportedTEError{fmt.Sprintf(""unsupported transfer encoding: %q"", raw[0])}
 	}
 
",[True]
GO-2022-0217,go.googlesource.com,go,193c16a3648b8670a762e925b6ac6e074f468a20," func (curve *CurveParams) doubleJacobian(x, y, z *big.Int) (*big.Int, *big.Int,
 
 	x3 := new(big.Int).Mul(alpha, alpha)
 	beta8 := new(big.Int).Lsh(beta, 3)
+	beta8.Mod(beta8, curve.P)
 	x3.Sub(x3, beta8)
-	for x3.Sign() == -1 {
+	if x3.Sign() == -1 {
 		x3.Add(x3, curve.P)
 	}
 	x3.Mod(x3, curve.P)
",[False]
GO-2021-0172,go.googlesource.com,go,7478ea5dba7ed02ddffd91c1d17ec8141f7cf184," func (r *Reader) readForm(maxMemory int64) (_ *Form, err error) {
 			if err != nil {
 				return nil, err
 			}
-			defer file.Close()
 			_, err = io.Copy(file, io.MultiReader(&b, p))
+			if cerr := file.Close(); err == nil {
+				err = cerr
+			}
 			if err != nil {
 				os.Remove(file.Name())
 				return nil, err
",[True]
GO-2020-0015,go.googlesource.com,text,23ae387dee1f90d29a23c0e87ee0b46038fbed0e," func (u *utf16Decoder) Reset() {
 }
 
 func (u *utf16Decoder) Transform(dst, src []byte, atEOF bool) (nDst, nSrc int, err error) {
+	if len(src) < 2 && atEOF && u.current.bomPolicy&requireBOM != 0 {
+		return 0, 0, ErrMissingBOM
+	}
 	if len(src) == 0 {
-		if atEOF && u.current.bomPolicy&requireBOM != 0 {
-			return 0, 0, ErrMissingBOM
-		}
 		return 0, 0, nil
 	}
-	if u.current.bomPolicy&acceptBOM != 0 {
-		if len(src) < 2 {
-			return 0, 0, transform.ErrShortSrc
-		}
+	if len(src) >= 2 && u.current.bomPolicy&acceptBOM != 0 {
 		switch {
 		case src[0] == 0xfe && src[1] == 0xff:
 			u.current.endianness = BigEndian
",[True]
GO-2020-0015,go.googlesource.com,text,23ae387dee1f90d29a23c0e87ee0b46038fbed0e," func String(t Transformer, s string) (result string, n int, err error) {
 	// Transform the remaining input, growing dst and src buffers as necessary.
 	for {
 		n := copy(src, s[pSrc:])
-		nDst, nSrc, err := t.Transform(dst[pDst:], src[:n], pSrc+n == len(s))
+		atEOF := pSrc+n == len(s)
+		nDst, nSrc, err := t.Transform(dst[pDst:], src[:n], atEOF)
 		pDst += nDst
 		pSrc += nSrc
 
",[True]
GO-2020-0015,go.googlesource.com,text,23ae387dee1f90d29a23c0e87ee0b46038fbed0e," func String(t Transformer, s string) (result string, n int, err error) {
 				dst = grow(dst, pDst)
 			}
 		} else if err == ErrShortSrc {
+			if atEOF {
+				return string(dst[:pDst]), pSrc, err
+			}
 			if nSrc == 0 {
 				src = grow(src, 0)
 			}
",[True]
GO-2023-1992,go.googlesource.com,crypto,c05e17bb3b2dca130fc919668a96b4bec9eb9442," func getLine(data []byte) (line, rest []byte) {
 	return data[0:i], data[j:]
 }
 
-// Decode finds the first clearsigned message in data and returns it, as well
-// as the suffix of data which remains after the message.
+// Decode finds the first clearsigned message in data and returns it, as well as
+// the suffix of data which remains after the message. Any prefix data is
+// discarded.
+//
+// If no message is found, or if the message is invalid, Decode returns nil and
+// the whole data slice. The only allowed header type is Hash, and it is not
+// verified against the signature hash.
 func Decode(data []byte) (b *Block, rest []byte) {
 	// start begins with a newline. However, at the very beginning of
 	// the byte array, we'll accept the start string without it.
",[True]
GO-2023-1992,go.googlesource.com,crypto,c05e17bb3b2dca130fc919668a96b4bec9eb9442," func Decode(data []byte) (b *Block, rest []byte) {
 		return nil, data
 	}
 
-	// Consume the start line.
-	_, rest = getLine(rest)
+	// Consume the start line and check it does not have a suffix.
+	suffix, rest := getLine(rest)
+	if len(suffix) != 0 {
+		return nil, data
+	}
 
 	var line []byte
 	b = &Block{
",[True]
GO-2023-1992,go.googlesource.com,crypto,c05e17bb3b2dca130fc919668a96b4bec9eb9442," func Decode(data []byte) (b *Block, rest []byte) {
 			break
 		}
 
+		// Reject headers with control or Unicode characters.
+		if i := bytes.IndexFunc(line, func(r rune) bool {
+			return r < 0x20 || r > 0x7e
+		}); i != -1 {
+			return nil, data
+		}
+
 		i := bytes.Index(line, []byte{':'})
 		if i == -1 {
 			return nil, data
 		}
 
-		key, val := line[0:i], line[i+1:]
-		key = bytes.TrimSpace(key)
-		val = bytes.TrimSpace(val)
-		b.Headers.Add(string(key), string(val))
+		key, val := string(line[0:i]), string(line[i+1:])
+		key = strings.TrimSpace(key)
+		if key != ""Hash"" {
+			return nil, data
+		}
+		val = strings.TrimSpace(val)
+		b.Headers.Add(key, val)
 	}
 
 	firstLine := true
",[True]
GO-2021-0240,go.googlesource.com,go,74242baa4136c7a9132a8ccd9881354442788c8c," func (z *Reader) init(r io.ReaderAt, size int64) error {
 		return err
 	}
 	z.r = r
-	z.File = make([]*File, 0, end.directoryRecords)
+	// Since the number of directory records is not validated, it is not
+	// safe to preallocate z.File without first checking that the specified
+	// number of files is reasonable, since a malformed archive may
+	// indicate it contains up to 1 << 128 - 1 files. Since each file has a
+	// header which will be _at least_ 30 bytes we can safely preallocate
+	// if (data size / 30) >= end.directoryRecords.
+	if (uint64(size)-end.directorySize)/30 >= end.directoryRecords {
+		z.File = make([]*File, 0, end.directoryRecords)
+	}
 	z.Comment = end.comment
 	rs := io.NewSectionReader(r, 0, size)
 	if _, err = rs.Seek(int64(end.directoryOffset), io.SeekStart); err != nil {
",[True]
GO-2022-0213,go.googlesource.com,go,552987fdbf4c2bc9641016fd323c3ae5d3a0d9a3," func Verify(pub *PublicKey, hash []byte, r, s *big.Int) bool {
 	}
 
 	w := new(big.Int).ModInverse(s, pub.Q)
+	if w == nil {
+		return false
+	}
 
 	n := pub.Q.BitLen()
 	if n%8 != 0 {
",[True]
GO-2022-0520,go.googlesource.com,go,b2cc0fecc2ccd80e6d5d16542cc684f97b3a9c8a," func (h Header) Clone() Header {
 	sv := make([]string, nv) // shared backing array for headers' values
 	h2 := make(Header, len(h))
 	for k, vv := range h {
+		if vv == nil {
+			// Preserve nil values. ReverseProxy distinguishes
+			// between nil and zero-length header values.
+			h2[k] = nil
+			continue
+		}
 		n := copy(sv, vv)
 		h2[k] = sv[:n:n]
 		sv = sv[n:]
",[True]
GO-2021-0245,go.googlesource.com,go,b7a85e0003cedb1b48a1fd3ae5b746ec6330102e," func (p *ReverseProxy) ServeHTTP(rw http.ResponseWriter, req *http.Request) {
 	if req.ContentLength == 0 {
 		outreq.Body = nil // Issue 16036: nil Body for http.Transport retries
 	}
+	if outreq.Body != nil {
+		// Reading from the request body after returning from a handler is not
+		// allowed, and the RoundTrip goroutine that reads the Body can outlive
+		// this handler. This can lead to a crash if the handler panics (see
+		// Issue 46866). Although calling Close doesn't guarantee there isn't
+		// any Read in flight after the handle returns, in practice it's safe to
+		// read after closing it.
+		defer outreq.Body.Close()
+	}
 	if outreq.Header == nil {
 		outreq.Header = make(http.Header) // Issue 33142: historical behavior was to always allocate
 	}
",[True]
GO-2021-0223,go.googlesource.com,go,82175e699a2e2cd83d3aa34949e9b922d66d52f5," func checkChainTrustStatus(c *Certificate, chainCtx *syscall.CertChainContext) e
 		switch status {
 		case syscall.CERT_TRUST_IS_NOT_TIME_VALID:
 			return CertificateInvalidError{c, Expired, """"}
+		case syscall.CERT_TRUST_IS_NOT_VALID_FOR_USAGE:
+			return CertificateInvalidError{c, IncompatibleUsage, """"}
+		// TODO(filippo): surface more error statuses.
 		default:
 			return UnknownAuthorityError{c, nil, nil}
 		}
",[False]
GO-2021-0223,go.googlesource.com,go,82175e699a2e2cd83d3aa34949e9b922d66d52f5," func (c *Certificate) systemVerify(opts *VerifyOptions) (chains [][]*Certificate
 	para := new(syscall.CertChainPara)
 	para.Size = uint32(unsafe.Sizeof(*para))
 
-	// If there's a DNSName set in opts, assume we're verifying
-	// a certificate from a TLS server.
-	if hasDNSName {
-		oids := []*byte{
-			&syscall.OID_PKIX_KP_SERVER_AUTH[0],
-			// Both IE and Chrome allow certificates with
-			// Server Gated Crypto as well. Some certificates
-			// in the wild require them.
-			&syscall.OID_SERVER_GATED_CRYPTO[0],
-			&syscall.OID_SGC_NETSCAPE[0],
+	keyUsages := opts.KeyUsages
+	if len(keyUsages) == 0 {
+		keyUsages = []ExtKeyUsage{ExtKeyUsageServerAuth}
+	}
+	oids := make([]*byte, 0, len(keyUsages))
+	for _, eku := range keyUsages {
+		if eku == ExtKeyUsageAny {
+			oids = nil
+			break
+		}
+		if oid, ok := windowsExtKeyUsageOIDs[eku]; ok {
+			oids = append(oids, &oid[0])
 		}
+		// Like the standard verifier, accept SGC EKUs as equivalent to ServerAuth.
+		if eku == ExtKeyUsageServerAuth {
+			oids = append(oids, &syscall.OID_SERVER_GATED_CRYPTO[0])
+			oids = append(oids, &syscall.OID_SGC_NETSCAPE[0])
+		}
+	}
+	if oids != nil {
 		para.RequestedUsage.Type = syscall.USAGE_MATCH_TYPE_OR
 		para.RequestedUsage.Usage.Length = uint32(len(oids))
 		para.RequestedUsage.Usage.UsageIdentifiers = &oids[0]
",[True]
GO-2021-0223,go.googlesource.com,go,82175e699a2e2cd83d3aa34949e9b922d66d52f5," func (c *Certificate) systemVerify(opts *VerifyOptions) (chains [][]*Certificate
 		return nil, err
 	}
 
-	if hasDNSName {
+	if opts != nil && len(opts.DNSName) > 0 {
 		err = checkChainSSLServerPolicy(c, chainCtx, opts)
 		if err != nil {
 			return nil, err
",[True]
GO-2022-0209,go.googlesource.com,crypto,b7391e95e576cacdcdd422573063bc057239113d,"
 
 package salsa
 
-// This function is implemented in salsa2020_amd64.s.
-
 //go:noescape
 
+// salsa2020XORKeyStream is implemented in salsa20_amd64.s.
 func salsa2020XORKeyStream(out, in *byte, n uint64, nonce, key *byte)
 
 // XORKeyStream crypts bytes from in to out using the given key and counters.
",[False]
GO-2022-0209,go.googlesource.com,crypto,b7391e95e576cacdcdd422573063bc057239113d,"
+// Copyright 2019 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// +build !amd64 appengine gccgo
+
+package salsa
+
+// XORKeyStream crypts bytes from in to out using the given key and counters.
+// In and out must overlap entirely or not at all. Counter
+// contains the raw salsa20 counter bytes (both nonce and block counter).
+func XORKeyStream(out, in []byte, counter *[16]byte, key *[32]byte) {
+	genericXORKeyStream(out, in, counter, key)
+}
",[True]
GO-2020-0014,go.googlesource.com,net,d26f9f9a57f3fab6a695bec0d84433c2c50f8bbf," func inSelectIM(p *parser) bool {
 			}
 			p.addElement()
 		case a.Select:
-			p.tok.Type = EndTagToken
-			return false
+			if p.popUntil(selectScope, a.Select) {
+				p.resetInsertionMode()
+			} else {
+				// Ignore the token.
+				return true
+			}
 		case a.Input, a.Keygen, a.Textarea:
 			if p.elementInScope(selectScope, a.Select) {
 				p.parseImpliedToken(EndTagToken, a.Select, a.Select.String())
",[True]
GO-2020-0014,go.googlesource.com,net,d26f9f9a57f3fab6a695bec0d84433c2c50f8bbf," func inSelectIM(p *parser) bool {
 		case a.Select:
 			if p.popUntil(selectScope, a.Select) {
 				p.resetInsertionMode()
+			} else {
+				// Ignore the token.
+				return true
 			}
 		case a.Template:
 			return inHeadIM(p)
",[True]
GO-2020-0014,go.googlesource.com,net,d26f9f9a57f3fab6a695bec0d84433c2c50f8bbf," func inSelectInTableIM(p *parser) bool {
 	case StartTagToken, EndTagToken:
 		switch p.tok.DataAtom {
 		case a.Caption, a.Table, a.Tbody, a.Tfoot, a.Thead, a.Tr, a.Td, a.Th:
-			if p.tok.Type == StartTagToken || p.elementInScope(tableScope, p.tok.DataAtom) {
-				p.parseImpliedToken(EndTagToken, a.Select, a.Select.String())
-				return false
-			} else {
+			if p.tok.Type == EndTagToken && !p.elementInScope(tableScope, p.tok.DataAtom) {
 				// Ignore the token.
 				return true
 			}
+			// This is like p.popUntil(selectScope, a.Select), but it also
+			// matches <math select>, not just <select>. Matching the MathML
+			// tag is arguably incorrect (conceptually), but it mimics what
+			// Chromium does.
+			for i := len(p.oe) - 1; i >= 0; i-- {
+				if n := p.oe[i]; n.DataAtom == a.Select {
+					p.oe = p.oe[:i]
+					break
+				}
+			}
+			p.resetInsertionMode()
+			return false
 		}
 	}
 	return inSelectIM(p)
",[True]
GO-2022-0524,go.googlesource.com,go,b2b8872c876201eac2d0707276c6999ff3eb185e," func (z *Reader) Read(p []byte) (n int, err error) {
 		return 0, z.err
 	}
 
-	n, z.err = z.decompressor.Read(p)
-	z.digest = crc32.Update(z.digest, crc32.IEEETable, p[:n])
-	z.size += uint32(n)
-	if z.err != io.EOF {
-		// In the normal case we return here.
-		return n, z.err
-	}
+	for n == 0 {
+		n, z.err = z.decompressor.Read(p)
+		z.digest = crc32.Update(z.digest, crc32.IEEETable, p[:n])
+		z.size += uint32(n)
+		if z.err != io.EOF {
+			// In the normal case we return here.
+			return n, z.err
+		}
 
-	// Finished file; check checksum and size.
-	if _, err := io.ReadFull(z.r, z.buf[:8]); err != nil {
-		z.err = noEOF(err)
-		return n, z.err
-	}
-	digest := le.Uint32(z.buf[:4])
-	size := le.Uint32(z.buf[4:8])
-	if digest != z.digest || size != z.size {
-		z.err = ErrChecksum
-		return n, z.err
-	}
-	z.digest, z.size = 0, 0
+		// Finished file; check checksum and size.
+		if _, err := io.ReadFull(z.r, z.buf[:8]); err != nil {
+			z.err = noEOF(err)
+			return n, z.err
+		}
+		digest := le.Uint32(z.buf[:4])
+		size := le.Uint32(z.buf[4:8])
+		if digest != z.digest || size != z.size {
+			z.err = ErrChecksum
+			return n, z.err
+		}
+		z.digest, z.size = 0, 0
 
-	// File is ok; check if there is another.
-	if !z.multistream {
-		return n, io.EOF
-	}
-	z.err = nil // Remove io.EOF
+		// File is ok; check if there is another.
+		if !z.multistream {
+			return n, io.EOF
+		}
+		z.err = nil // Remove io.EOF
 
-	if _, z.err = z.readHeader(); z.err != nil {
-		return n, z.err
+		if _, z.err = z.readHeader(); z.err != nil {
+			return n, z.err
+		}
 	}
 
-	// Read from next file, if necessary.
-	if n > 0 {
-		return n, nil
-	}
-	return z.Read(p)
+	return n, nil
 }
 
 // Close closes the Reader. It does not close the underlying io.Reader.
",[True]
GO-2021-0224,go.googlesource.com,go,fa98f46741f818913a8c11b877520a548715131f," type expectContinueReader struct {
 	resp       *response
 	readCloser io.ReadCloser
 	closed     bool
-	sawEOF     bool
+	sawEOF     atomicBool
 }
 
 func (ecr *expectContinueReader) Read(p []byte) (n int, err error) {
 	if ecr.closed {
 		return 0, ErrBodyReadAfterClose
 	}
-	if !ecr.resp.wroteContinue && !ecr.resp.conn.hijacked() {
-		ecr.resp.wroteContinue = true
-		ecr.resp.conn.bufw.WriteString(""HTTP/1.1 100 Continue\r\n\r\n"")
-		ecr.resp.conn.bufw.Flush()
+	w := ecr.resp
+	if !w.wroteContinue && w.canWriteContinue.isSet() && !w.conn.hijacked() {
+		w.wroteContinue = true
+		w.writeContinueMu.Lock()
+		if w.canWriteContinue.isSet() {
+			w.conn.bufw.WriteString(""HTTP/1.1 100 Continue\r\n\r\n"")
+			w.conn.bufw.Flush()
+			w.canWriteContinue.setFalse()
+		}
+		w.writeContinueMu.Unlock()
 	}
 	n, err = ecr.readCloser.Read(p)
 	if err == io.EOF {
-		ecr.sawEOF = true
+		ecr.sawEOF.setTrue()
 	}
 	return
 }
",[True]
GO-2021-0224,go.googlesource.com,go,fa98f46741f818913a8c11b877520a548715131f," func (cw *chunkWriter) writeHeader(p []byte) {
 	// because we don't know if the next bytes on the wire will be
 	// the body-following-the-timer or the subsequent request.
 	// See Issue 11549.
-	if ecr, ok := w.req.Body.(*expectContinueReader); ok && !ecr.sawEOF {
+	if ecr, ok := w.req.Body.(*expectContinueReader); ok && !ecr.sawEOF.isSet() {
 		w.closeAfterReply = true
 	}
 
",[False]
GO-2021-0224,go.googlesource.com,go,fa98f46741f818913a8c11b877520a548715131f," func (w *response) write(lenData int, dataB []byte, dataS string) (n int, err er
 		}
 		return 0, ErrHijacked
 	}
+
+	if w.canWriteContinue.isSet() {
+		// Body reader wants to write 100 Continue but hasn't yet.
+		// Tell it not to. The store must be done while holding the lock
+		// because the lock makes sure that there is not an active write
+		// this very moment.
+		w.writeContinueMu.Lock()
+		w.canWriteContinue.setFalse()
+		w.writeContinueMu.Unlock()
+	}
+
 	if !w.wroteHeader {
 		w.WriteHeader(StatusOK)
 	}
",[False]
GO-2021-0224,go.googlesource.com,go,fa98f46741f818913a8c11b877520a548715131f," func (c *conn) serve(ctx context.Context) {
 			if req.ProtoAtLeast(1, 1) && req.ContentLength != 0 {
 				// Wrap the Body reader with one that replies on the connection
 				req.Body = &expectContinueReader{readCloser: req.Body, resp: w}
+				w.canWriteContinue.setTrue()
 			}
 		} else if req.Header.get(""Expect"") != """" {
 			w.sendExpectationFailed()
",[False]
GO-2021-0319,go.googlesource.com,go,7f9494c277a471f6f47f4af3036285c0b1419816," func (curve *CurveParams) IsOnCurve(x, y *big.Int) bool {
 		return specific.IsOnCurve(x, y)
 	}
 
+	if x.Sign() < 0 || x.Cmp(curve.P) >= 0 ||
+		y.Sign() < 0 || y.Cmp(curve.P) >= 0 {
+		return false
+	}
+
 	// y² = x³ - 3x + b
 	y2 := new(big.Int).Mul(y, y)
 	y2.Mod(y2, curve.P)
",[True]
GO-2021-0319,go.googlesource.com,go,7f9494c277a471f6f47f4af3036285c0b1419816," func p224PointFromAffine(x, y *big.Int) (p *nistec.P224Point, ok bool) {
 	if x.Sign() == 0 && y.Sign() == 0 {
 		return nistec.NewP224Point(), true
 	}
+	if x.Sign() < 0 || y.Sign() < 0 {
+		return nil, false
+	}
 	if x.BitLen() > 224 || y.BitLen() > 224 {
 		return nil, false
 	}
",[False]
GO-2021-0319,go.googlesource.com,go,7f9494c277a471f6f47f4af3036285c0b1419816," func p384PointFromAffine(x, y *big.Int) (p *nistec.P384Point, ok bool) {
 	if x.Sign() == 0 && y.Sign() == 0 {
 		return nistec.NewP384Point(), true
 	}
+	if x.Sign() < 0 || y.Sign() < 0 {
+		return nil, false
+	}
 	if x.BitLen() > 384 || y.BitLen() > 384 {
 		return nil, false
 	}
",[True]
GO-2021-0319,go.googlesource.com,go,7f9494c277a471f6f47f4af3036285c0b1419816," func p521PointFromAffine(x, y *big.Int) (p *nistec.P521Point, ok bool) {
 	if x.Sign() == 0 && y.Sign() == 0 {
 		return nistec.NewP521Point(), true
 	}
+	if x.Sign() < 0 || y.Sign() < 0 {
+		return nil, false
+	}
 	if x.BitLen() > 521 || y.BitLen() > 521 {
 		return nil, false
 	}
",[True]
GO-2022-0236,go.googlesource.com,net,89ef3d95e781148a0951956029c92a211477f7f9," func trimOWS(x string) string {
 // contains token amongst its comma-separated tokens, ASCII
 // case-insensitively.
 func headerValueContainsToken(v string, token string) bool {
-	v = trimOWS(v)
-	if comma := strings.IndexByte(v, ','); comma != -1 {
-		return tokenEqual(trimOWS(v[:comma]), token) || headerValueContainsToken(v[comma+1:], token)
+	for comma := strings.IndexByte(v, ','); comma != -1; comma = strings.IndexByte(v, ',') {
+		if tokenEqual(trimOWS(v[:comma]), token) {
+			return true
+		}
+		v = v[comma+1:]
 	}
-	return tokenEqual(v, token)
+	return tokenEqual(trimOWS(v), token)
 }
 
 // lowerASCII returns the ASCII lowercase version of b.
",[True]
GO-2022-0193,go.googlesource.com,net,2f5d2388922f370f4355f327fcf4cfe9f5583908," func inBodyIM(p *parser) bool {
 			p.acknowledgeSelfClosingTag()
 			p.popUntil(buttonScope, a.P)
 			p.parseImpliedToken(StartTagToken, a.Form, a.Form.String())
+			if p.form == nil {
+				// NOTE: The 'isindex' element has been removed,
+				// and the 'template' element has not been designed to be
+				// collaborative with the index element.
+				//
+				// Ignore the token.
+				return true
+			}
 			if action != """" {
 				p.form.Attr = []Attribute{{Key: ""action"", Val: action}}
 			}
",[True]
GO-2021-0159,go.googlesource.com,go,26049f6f9171d1190f3bbe05ec304845cfe6399f," func (b *body) readLocked(p []byte) (n int, err error) {
 		if b.hdr != nil {
 			if e := b.readTrailer(); e != nil {
 				err = e
+				// Something went wrong in the trailer, we must not allow any
+				// further reads of any kind to succeed from body, nor any
+				// subsequent requests on the server connection. See
+				// golang.org/issue/12027
+				b.sawEOF = false
+				b.closed = true
 			}
 			b.hdr = nil
 		} else {
",[True]
GO-2021-0159,go.googlesource.com,go,117ddcb83d7f42d6aa72241240af99ded81118e9," func (h Header) WriteSubset(w io.Writer, exclude map[string]bool) error {
 // letter and any letter following a hyphen to upper case;
 // the rest are converted to lowercase.  For example, the
 // canonical key for ""accept-encoding"" is ""Accept-Encoding"".
+// If s contains a space or invalid header field bytes, it is
+// returned without modifications.
 func CanonicalHeaderKey(s string) string { return textproto.CanonicalMIMEHeaderKey(s) }
 
 // hasToken reports whether token appears with v, ASCII
",[False]
GO-2021-0159,go.googlesource.com,go,117ddcb83d7f42d6aa72241240af99ded81118e9," func (r *Reader) upcomingHeaderNewlines() (n int) {
 // the rest are converted to lowercase.  For example, the
 // canonical key for ""accept-encoding"" is ""Accept-Encoding"".
 // MIME header keys are assumed to be ASCII only.
+// If s contains a space or invalid header field bytes, it is
+// returned without modifications.
 func CanonicalMIMEHeaderKey(s string) string {
 	// Quick check for canonical encoding.
 	upper := true
 	for i := 0; i < len(s); i++ {
 		c := s[i]
+		if !validHeaderFieldByte(c) {
+			return s
+		}
 		if upper && 'a' <= c && c <= 'z' {
 			return canonicalMIMEHeaderKey([]byte(s))
 		}
",[True]
GO-2021-0159,go.googlesource.com,go,300d9a21583e7cf0149a778a0611e76ff7c6680f," func (t *transferWriter) shouldSendContentLength() bool {
 		return true
 	}
 	if t.ContentLength == 0 && isIdentity(t.TransferEncoding) {
+		if t.Method == ""GET"" || t.Method == ""HEAD"" {
+			return false
+		}
 		return true
 	}
 
",[True]
GO-2021-0159,go.googlesource.com,go,300d9a21583e7cf0149a778a0611e76ff7c6680f," func readTransfer(msg interface{}, r *bufio.Reader) (err error) {
 		}
 	case *Request:
 		t.Header = rr.Header
+		t.RequestMethod = rr.Method
 		t.ProtoMajor = rr.ProtoMajor
 		t.ProtoMinor = rr.ProtoMinor
 		// Transfer semantics for Requests are exactly like those for
",[True]
GO-2021-0159,go.googlesource.com,go,300d9a21583e7cf0149a778a0611e76ff7c6680f," func readTransfer(msg interface{}, r *bufio.Reader) (err error) {
 	}
 
 	// Transfer encoding, content length
-	t.TransferEncoding, err = fixTransferEncoding(t.RequestMethod, t.Header)
+	t.TransferEncoding, err = fixTransferEncoding(isResponse, t.RequestMethod, t.Header)
 	if err != nil {
 		return err
 	}
",[True]
GO-2021-0159,go.googlesource.com,go,300d9a21583e7cf0149a778a0611e76ff7c6680f," func chunked(te []string) bool { return len(te) > 0 && te[0] == ""chunked"" }
 func isIdentity(te []string) bool { return len(te) == 1 && te[0] == ""identity"" }
 
 // Sanitize transfer encoding
-func fixTransferEncoding(requestMethod string, header Header) ([]string, error) {
+func fixTransferEncoding(isResponse bool, requestMethod string, header Header) ([]string, error) {
 	raw, present := header[""Transfer-Encoding""]
 	if !present {
 		return nil, nil
 	}
-
+	isRequest := !isResponse
 	delete(header, ""Transfer-Encoding"")
 
 	encodings := strings.Split(raw[0], "","")
",[True]
GO-2021-0159,go.googlesource.com,go,300d9a21583e7cf0149a778a0611e76ff7c6680f," func fixTransferEncoding(requestMethod string, header Header) ([]string, error)
 		return nil, &badStringError{""too many transfer encodings"", strings.Join(te, "","")}
 	}
 	if len(te) > 0 {
-		// Chunked encoding trumps Content-Length. See RFC 2616
-		// Section 4.4. Currently len(te) > 0 implies chunked
-		// encoding.
-		delete(header, ""Content-Length"")
+		// RFC 7230 3.3.2 says ""A sender MUST NOT send a
+		// Content-Length header field in any message that
+		// contains a Transfer-Encoding header field.""
+		if len(header[""Content-Length""]) > 0 {
+			if isRequest {
+				return nil, errors.New(""http: invalid Content-Length with Transfer-Encoding"")
+			}
+			delete(header, ""Content-Length"")
+		}
 		return te, nil
 	}
 
",[True]
GO-2021-0159,go.googlesource.com,go,300d9a21583e7cf0149a778a0611e76ff7c6680f," func fixTransferEncoding(requestMethod string, header Header) ([]string, error)
 // function is not a method, because ultimately it should be shared by
 // ReadResponse and ReadRequest.
 func fixLength(isResponse bool, status int, requestMethod string, header Header, te []string) (int64, error) {
-
+	contentLens := header[""Content-Length""]
+	isRequest := !isResponse
 	// Logic based on response type or status
 	if noBodyExpected(requestMethod) {
+		// For HTTP requests, as part of hardening against request
+		// smuggling (RFC 7230), don't allow a Content-Length header for
+		// methods which don't permit bodies. As an exception, allow
+		// exactly one Content-Length header if its value is ""0"".
+		if isRequest && len(contentLens) > 0 && !(len(contentLens) == 1 && contentLens[0] == ""0"") {
+			return 0, fmt.Errorf(""http: method cannot contain a Content-Length; got %q"", contentLens)
+		}
 		return 0, nil
 	}
 	if status/100 == 1 {
",[True]
GO-2021-0159,go.googlesource.com,go,300d9a21583e7cf0149a778a0611e76ff7c6680f," func fixLength(isResponse bool, status int, requestMethod string, header Header,
 		return 0, nil
 	}
 
+	if len(contentLens) > 1 {
+		// harden against HTTP request smuggling. See RFC 7230.
+		return 0, errors.New(""http: message cannot contain multiple Content-Length headers"")
+	}
+
 	// Logic based on Transfer-Encoding
 	if chunked(te) {
 		return -1, nil
 	}
 
 	// Logic based on Content-Length
-	cl := strings.TrimSpace(header.get(""Content-Length""))
+	var cl string
+	if len(contentLens) == 1 {
+		cl = strings.TrimSpace(contentLens[0])
+	}
 	if cl != """" {
 		n, err := parseContentLength(cl)
 		if err != nil {
",[True]
GO-2021-0159,go.googlesource.com,go,300d9a21583e7cf0149a778a0611e76ff7c6680f," func fixLength(isResponse bool, status int, requestMethod string, header Header,
 		header.Del(""Content-Length"")
 	}
 
-	if !isResponse && requestMethod == ""GET"" {
-		// RFC 2616 doesn't explicitly permit nor forbid an
+	if !isResponse {
+		// RFC 2616 neither explicitly permits nor forbids an
 		// entity-body on a GET request so we permit one if
 		// declared, but we default to 0 here (not -1 below)
 		// if there's no mention of a body.
+		// Likewise, all other request methods are assumed to have
+		// no body if neither Transfer-Encoding chunked nor a
+		// Content-Length are set.
 		return 0, nil
 	}
 
",[True]
GO-2021-0159,go.googlesource.com,go,c2db5f4ccc61ba7df96a747e268a277b802cbb87," func (cw *chunkWriter) writeHeader(p []byte) {
 	// don't want to do an unbounded amount of reading here for
 	// DoS reasons, so we only try up to a threshold.
 	if w.req.ContentLength != 0 && !w.closeAfterReply {
-		ecr, isExpecter := w.req.Body.(*expectContinueReader)
-		if !isExpecter || ecr.resp.wroteContinue {
-			var tooBig bool
-			if reqBody, ok := w.req.Body.(*body); ok && reqBody.unreadDataSize() >= maxPostHandlerReadBytes {
+		var discard, tooBig bool
+
+		switch bdy := w.req.Body.(type) {
+		case *expectContinueReader:
+			if bdy.resp.wroteContinue {
+				discard = true
+			}
+		case *body:
+			switch {
+			case bdy.closed:
+				if !bdy.sawEOF {
+					// Body was closed in handler with non-EOF error.
+					w.closeAfterReply = true
+				}
+			case bdy.unreadDataSize() >= maxPostHandlerReadBytes:
 				tooBig = true
-			} else {
-				n, _ := io.CopyN(ioutil.Discard, w.req.Body, maxPostHandlerReadBytes+1)
-				tooBig = n >= maxPostHandlerReadBytes
+			default:
+				discard = true
 			}
-			if tooBig {
-				w.requestTooLarge()
-				delHeader(""Connection"")
-				setHeader.connection = ""close""
-			} else {
-				w.req.Body.Close()
+		default:
+			discard = true
+		}
+
+		if discard {
+			_, err := io.CopyN(ioutil.Discard, w.req.Body, maxPostHandlerReadBytes+1)
+			switch err {
+			case nil:
+				// There must be even more data left over.
+				tooBig = true
+			case ErrBodyReadAfterClose:
+				// Body was already consumed and closed.
+			case io.EOF:
+				// The remaining body was just consumed, close it.
+				err = w.req.Body.Close()
+				if err != nil {
+					w.closeAfterReply = true
+				}
+			default:
+				// Some other kind of error occured, like a read timeout, or
+				// corrupt chunked encoding. In any case, whatever remains
+				// on the wire must not be parsed as another HTTP request.
+				w.closeAfterReply = true
 			}
 		}
+
+		if tooBig {
+			w.requestTooLarge()
+			delHeader(""Connection"")
+			setHeader.connection = ""close""
+		}
 	}
 
 	code := w.status
",[True]
GO-2022-0273,go.googlesource.com,go,bacbc33439b124ffd7392c91a5f5d96eca8c0c0b," func (z *Reader) init(r io.ReaderAt, size int64) error {
 	// indicate it contains up to 1 << 128 - 1 files. Since each file has a
 	// header which will be _at least_ 30 bytes we can safely preallocate
 	// if (data size / 30) >= end.directoryRecords.
-	if (uint64(size)-end.directorySize)/30 >= end.directoryRecords {
+	if end.directorySize < uint64(size) && (uint64(size)-end.directorySize)/30 >= end.directoryRecords {
 		z.File = make([]*File, 0, end.directoryRecords)
 	}
 	z.Comment = end.comment
",[False]
GO-2021-0317,go.googlesource.com,go,ad345c265916bbf6c646865e4642eafce6d39e78," func (z *Rat) SetString(s string) (*Rat, bool) {
 		n := exp5
 		if n < 0 {
 			n = -n
+			if n < 0 {
+				// This can occur if -n overflows. -(-1 << 63) would become
+				// -1 << 63, which is still negative.
+				return nil, false
+			}
 		}
 		if n > 1e6 {
 			return nil, false // avoid excessively large exponents
",[True]
GO-2022-0318,go.googlesource.com,go,fa4d9b8e2bc2612960c80474fca83a4c85a974eb," func (r *codeRepo) Latest() (*RevInfo, error) {
 // If statVers is a valid module version, it is used for the Version field.
 // Otherwise, the Version is derived from the passed-in info and recent tags.
 func (r *codeRepo) convert(info *codehost.RevInfo, statVers string) (*RevInfo, error) {
-	info2 := &RevInfo{
-		Name:  info.Name,
-		Short: info.Short,
-		Time:  info.Time,
-	}
-
 	// If this is a plain tag (no dir/ prefix)
 	// and the module path is unversioned,
 	// and if the underlying file tree has no go.mod,
 	// then allow using the tag with a +incompatible suffix.
+	//
+	// (If the version is +incompatible, then the go.mod file must not exist:
+	// +incompatible is not an ongoing opt-out from semantic import versioning.)
 	var canUseIncompatible func() bool
 	canUseIncompatible = func() bool {
 		var ok bool
",[True]
GO-2022-0318,go.googlesource.com,go,fa4d9b8e2bc2612960c80474fca83a4c85a974eb," func (r *codeRepo) convert(info *codehost.RevInfo, statVers string) (*RevInfo, e
 		return ok
 	}
 
-	invalidf := func(format string, args ...any) error {
-		return &module.ModuleError{
-			Path: r.modPath,
-			Err: &module.InvalidVersionError{
-				Version: info2.Version,
-				Err:     fmt.Errorf(format, args...),
-			},
-		}
-	}
-
-	// checkGoMod verifies that the go.mod file for the module exists or does not
-	// exist as required by info2.Version and the module path represented by r.
-	checkGoMod := func() (*RevInfo, error) {
+	// checkCanonical verifies that the canonical version v is compatible with the
+	// module path represented by r, adding a ""+incompatible"" suffix if needed.
+	//
+	// If statVers is also canonical, checkCanonical also verifies that v is
+	// either statVers or statVers with the added ""+incompatible"" suffix.
+	checkCanonical := func(v string) (*RevInfo, error) {
 		// If r.codeDir is non-empty, then the go.mod file must exist: the module
 		// author — not the module consumer, — gets to decide how to carve up the repo
 		// into modules.
",[True]
GO-2022-0318,go.googlesource.com,go,fa4d9b8e2bc2612960c80474fca83a4c85a974eb," func (r *codeRepo) convert(info *codehost.RevInfo, statVers string) (*RevInfo, e
 		// r.findDir verifies both of these conditions. Execute it now so that
 		// r.Stat will correctly return a notExistError if the go.mod location or
 		// declared module path doesn't match.
-		_, _, _, err := r.findDir(info2.Version)
+		_, _, _, err := r.findDir(v)
 		if err != nil {
 			// TODO: It would be nice to return an error like ""not a module"".
 			// Right now we return ""missing go.mod"", which is a little confusing.
 			return nil, &module.ModuleError{
 				Path: r.modPath,
 				Err: &module.InvalidVersionError{
-					Version: info2.Version,
+					Version: v,
 					Err:     notExistError{err: err},
 				},
 			}
 		}
 
-		// If the version is +incompatible, then the go.mod file must not exist:
-		// +incompatible is not an ongoing opt-out from semantic import versioning.
-		if strings.HasSuffix(info2.Version, ""+incompatible"") {
-			if !canUseIncompatible() {
+		invalidf := func(format string, args ...any) error {
+			return &module.ModuleError{
+				Path: r.modPath,
+				Err: &module.InvalidVersionError{
+					Version: v,
+					Err:     fmt.Errorf(format, args...),
+				},
+			}
+		}
+
+		// Add the +incompatible suffix if needed or requested explicitly, and
+		// verify that its presence or absence is appropriate for this version
+		// (which depends on whether it has an explicit go.mod file).
+
+		if v == strings.TrimSuffix(statVers, ""+incompatible"") {
+			v = statVers
+		}
+		base := strings.TrimSuffix(v, ""+incompatible"")
+		var errIncompatible error
+		if !module.MatchPathMajor(base, r.pathMajor) {
+			if canUseIncompatible() {
+				v = base + ""+incompatible""
+			} else {
 				if r.pathMajor != """" {
-					return nil, invalidf(""+incompatible suffix not allowed: module path includes a major version suffix, so major version must match"")
+					errIncompatible = invalidf(""module path includes a major version suffix, so major version must match"")
 				} else {
-					return nil, invalidf(""+incompatible suffix not allowed: module contains a go.mod file, so semantic import versioning is required"")
+					errIncompatible = invalidf(""module contains a go.mod file, so module path must match major version (%q)"", path.Join(r.pathPrefix, semver.Major(v)))
 				}
 			}
+		} else if strings.HasSuffix(v, ""+incompatible"") {
+			errIncompatible = invalidf(""+incompatible suffix not allowed: major version %s is compatible"", semver.Major(v))
+		}
 
-			if err := module.CheckPathMajor(strings.TrimSuffix(info2.Version, ""+incompatible""), r.pathMajor); err == nil {
-				return nil, invalidf(""+incompatible suffix not allowed: major version %s is compatible"", semver.Major(info2.Version))
+		if statVers != """" && statVers == module.CanonicalVersion(statVers) {
+			// Since the caller-requested version is canonical, it would be very
+			// confusing to resolve it to anything but itself, possibly with a
+			// ""+incompatible"" suffix. Error out explicitly.
+			if statBase := strings.TrimSuffix(statVers, ""+incompatible""); statBase != base {
+				return nil, &module.ModuleError{
+					Path: r.modPath,
+					Err: &module.InvalidVersionError{
+						Version: statVers,
+						Err:     fmt.Errorf(""resolves to version %v (%s is not a tag)"", v, statBase),
+					},
+				}
 			}
 		}
 
-		return info2, nil
+		if errIncompatible != nil {
+			return nil, errIncompatible
+		}
+
+		return &RevInfo{
+			Name:    info.Name,
+			Short:   info.Short,
+			Time:    info.Time,
+			Version: v,
+		}, nil
 	}
 
 	// Determine version.
-	//
-	// If statVers is canonical, then the original call was repo.Stat(statVers).
-	// Since the version is canonical, we must not resolve it to anything but
-	// itself, possibly with a '+incompatible' annotation: we do not need to do
-	// the work required to look for an arbitrary pseudo-version.
-	if statVers != """" && statVers == module.CanonicalVersion(statVers) {
-		info2.Version = statVers
-
-		if module.IsPseudoVersion(info2.Version) {
-			if err := r.validatePseudoVersion(info, info2.Version); err != nil {
-				return nil, err
-			}
-			return checkGoMod()
-		}
 
-		if err := module.CheckPathMajor(info2.Version, r.pathMajor); err != nil {
-			if canUseIncompatible() {
-				info2.Version += ""+incompatible""
-				return checkGoMod()
-			} else {
-				if vErr, ok := err.(*module.InvalidVersionError); ok {
-					// We're going to describe why the version is invalid in more detail,
-					// so strip out the existing “invalid version” wrapper.
-					err = vErr.Err
-				}
-				return nil, invalidf(""module contains a go.mod file, so major version must be compatible: %v"", err)
-			}
+	if module.IsPseudoVersion(statVers) {
+		if err := r.validatePseudoVersion(info, statVers); err != nil {
+			return nil, err
 		}
-
-		return checkGoMod()
+		return checkCanonical(statVers)
 	}
 
-	// statVers is empty or non-canonical, so we need to resolve it to a canonical
-	// version or pseudo-version.
+	// statVers is not a pseudo-version, so we need to either resolve it to a
+	// canonical version or verify that it is already a canonical tag
+	// (not a branch).
 
 	// Derive or verify a version from a code repo tag.
 	// Tag must have a prefix matching codeDir.
",[True]
GO-2022-0318,go.googlesource.com,go,fa4d9b8e2bc2612960c80474fca83a4c85a974eb," func (r *codeRepo) convert(info *codehost.RevInfo, statVers string) (*RevInfo, e
 		if v == """" || !strings.HasPrefix(trimmed, v) {
 			return """", false // Invalid or incomplete version (just vX or vX.Y).
 		}
-		if isRetracted(v) {
-			return """", false
-		}
 		if v == trimmed {
 			tagIsCanonical = true
 		}
-
-		if err := module.CheckPathMajor(v, r.pathMajor); err != nil {
-			if canUseIncompatible() {
-				return v + ""+incompatible"", tagIsCanonical
-			}
-			return """", false
-		}
-
 		return v, tagIsCanonical
 	}
 
 	// If the VCS gave us a valid version, use that.
 	if v, tagIsCanonical := tagToVersion(info.Version); tagIsCanonical {
-		info2.Version = v
-		return checkGoMod()
+		if info, err := checkCanonical(v); err == nil {
+			return info, err
+		}
 	}
 
 	// Look through the tags on the revision for either a usable canonical version
 	// or an appropriate base for a pseudo-version.
-	var pseudoBase string
+	var (
+		highestCanonical string
+		pseudoBase       string
+	)
 	for _, pathTag := range info.Tags {
 		v, tagIsCanonical := tagToVersion(pathTag)
-		if tagIsCanonical {
-			if statVers != """" && semver.Compare(v, statVers) == 0 {
-				// The user requested a non-canonical version, but the tag for the
-				// canonical equivalent refers to the same revision. Use it.
-				info2.Version = v
-				return checkGoMod()
+		if statVers != """" && semver.Compare(v, statVers) == 0 {
+			// The tag is equivalent to the version requested by the user.
+			if tagIsCanonical {
+				// This tag is the canonical form of the requested version,
+				// not some other form with extra build metadata.
+				// Use this tag so that the resolved version will match exactly.
+				// (If it isn't actually allowed, we'll error out in checkCanonical.)
+				return checkCanonical(v)
 			} else {
-				// Save the highest canonical tag for the revision. If we don't find a
-				// better match, we'll use it as the canonical version.
+				// The user explicitly requested something equivalent to this tag. We
+				// can't use the version from the tag directly: since the tag is not
+				// canonical, it could be ambiguous. For example, tags v0.0.1+a and
+				// v0.0.1+b might both exist and refer to different revisions.
 				//
-				// NOTE: Do not replace this with semver.Max. Despite the name,
-				// semver.Max *also* canonicalizes its arguments, which uses
-				// semver.Canonical instead of module.CanonicalVersion and thereby
-				// strips our ""+incompatible"" suffix.
-				if semver.Compare(info2.Version, v) < 0 {
-					info2.Version = v
-				}
+				// The tag is otherwise valid for the module, so we can at least use it as
+				// the base of an unambiguous pseudo-version.
+				//
+				// If multiple tags match, tagToVersion will canonicalize them to the same
+				// base version.
+				pseudoBase = v
+			}
+		}
+		// Save the highest non-retracted canonical tag for the revision.
+		// If we don't find a better match, we'll use it as the canonical version.
+		if tagIsCanonical && semver.Compare(highestCanonical, v) < 0 && !isRetracted(v) {
+			if module.MatchPathMajor(v, r.pathMajor) || canUseIncompatible() {
+				highestCanonical = v
 			}
-		} else if v != """" && semver.Compare(v, statVers) == 0 {
-			// The user explicitly requested something equivalent to this tag. We
-			// can't use the version from the tag directly: since the tag is not
-			// canonical, it could be ambiguous. For example, tags v0.0.1+a and
-			// v0.0.1+b might both exist and refer to different revisions.
-			//
-			// The tag is otherwise valid for the module, so we can at least use it as
-			// the base of an unambiguous pseudo-version.
-			//
-			// If multiple tags match, tagToVersion will canonicalize them to the same
-			// base version.
-			pseudoBase = v
 		}
 	}
 
-	// If we found any canonical tag for the revision, return it.
+	// If we found a valid canonical tag for the revision, return it.
 	// Even if we found a good pseudo-version base, a canonical version is better.
-	if info2.Version != """" {
-		return checkGoMod()
+	if highestCanonical != """" {
+		return checkCanonical(highestCanonical)
 	}
 
 	// Find the highest tagged version in the revision's history, subject to
",[True]
GO-2022-0318,go.googlesource.com,go,fa4d9b8e2bc2612960c80474fca83a4c85a974eb," func (r *codeRepo) convert(info *codehost.RevInfo, statVers string) (*RevInfo, e
 				tag, _ = r.code.RecentTag(info.Name, tagPrefix, allowedMajor(""v0""))
 			}
 		}
-		pseudoBase, _ = tagToVersion(tag) // empty if the tag is invalid
+		pseudoBase, _ = tagToVersion(tag)
 	}
 
-	info2.Version = module.PseudoVersion(r.pseudoMajor, pseudoBase, info.Time, info.Short)
-	return checkGoMod()
+	return checkCanonical(module.PseudoVersion(r.pseudoMajor, pseudoBase, info.Time, info.Short))
 }
 
 // validatePseudoVersion checks that version has a major version compatible with
",[True]
GO-2022-0318,go.googlesource.com,go,fa4d9b8e2bc2612960c80474fca83a4c85a974eb," func (r *codeRepo) validatePseudoVersion(info *codehost.RevInfo, version string)
 		}
 	}()
 
-	if err := module.CheckPathMajor(version, r.pathMajor); err != nil {
-		return err
-	}
-
 	rev, err := module.PseudoVersionRev(version)
 	if err != nil {
 		return err
",[True]
GO-2021-0235,go.googlesource.com,go,d95ca9138026cbe40e0857d76a81a16d03230871," func p224Invert(out, in *p224FieldElement) {
 // p224Contract converts a FieldElement to its unique, minimal form.
 //
 // On entry, in[i] < 2**29
-// On exit, in[i] < 2**28
+// On exit, out[i] < 2**28 and out < p
 func p224Contract(out, in *p224FieldElement) {
 	copy(out[:], in[:])
 
+	// First, carry the bits above 28 to the higher limb.
 	for i := 0; i < 7; i++ {
 		out[i+1] += out[i] >> 28
 		out[i] &= bottom28Bits
",[True]
GO-2021-0235,go.googlesource.com,go,d95ca9138026cbe40e0857d76a81a16d03230871," func p224Contract(out, in *p224FieldElement) {
 	top := out[7] >> 28
 	out[7] &= bottom28Bits
 
+	// Use the reduction identity to carry the overflow.
+	//
+	//   a + top * 2²²⁴ = a + top * 2⁹⁶ - top
 	out[0] -= top
 	out[3] += top << 12
 
-	// We may just have made out[i] negative. So we carry down. If we made
+	// We may just have made out[0] negative. So we carry down. If we made
 	// out[0] negative then we know that out[3] is sufficiently positive
 	// because we just added to it.
 	for i := 0; i < 3; i++ {
",[True]
GO-2021-0235,go.googlesource.com,go,d95ca9138026cbe40e0857d76a81a16d03230871," func p224Contract(out, in *p224FieldElement) {
 	// There are two cases to consider for out[3]:
 	//   1) The first time that we eliminated top, we didn't push out[3] over
 	//      2**28. In this case, the partial carry chain didn't change any values
-	//      and top is zero.
+	//      and top is now zero.
 	//   2) We did push out[3] over 2**28 the first time that we eliminated top.
-	//      The first value of top was in [0..16), therefore, prior to eliminating
-	//      the first top, 0xfff1000 <= out[3] <= 0xfffffff. Therefore, after
-	//      overflowing and being reduced by the second carry chain, out[3] <=
-	//      0xf000. Thus it cannot have overflowed when we eliminated top for the
-	//      second time.
+	//      The first value of top was in [0..2], therefore, after overflowing
+	//      and being reduced by the second carry chain, out[3] <= 2<<12 - 1.
+	// In both cases, out[3] cannot have overflowed when we eliminated top for
+	// the second time.
 
 	// Again, we may just have made out[0] negative, so do the same carry down.
 	// As before, if we made out[0] negative then we know that out[3] is
",[True]
GO-2021-0235,go.googlesource.com,go,d95ca9138026cbe40e0857d76a81a16d03230871," func p224Contract(out, in *p224FieldElement) {
 	bottom3NonZero |= bottom3NonZero >> 1
 	bottom3NonZero = uint32(int32(bottom3NonZero<<31) >> 31)
 
-	// Everything depends on the value of out[3].
-	//    If it's > 0xffff000 and top4AllOnes != 0 then the whole value is >= p
-	//    If it's = 0xffff000 and top4AllOnes != 0 and bottom3NonZero != 0,
-	//      then the whole value is >= p
+	// Assuming top4AllOnes != 0, everything depends on the value of out[3].
+	//    If it's > 0xffff000 then the whole value is > p
+	//    If it's = 0xffff000 and bottom3NonZero != 0, then the whole value is >= p
 	//    If it's < 0xffff000, then the whole value is < p
-	n := out[3] - 0xffff000
+	n := 0xffff000 - out[3]
 	out3Equal := n
 	out3Equal |= out3Equal >> 16
 	out3Equal |= out3Equal >> 8
",[True]
GO-2021-0235,go.googlesource.com,go,d95ca9138026cbe40e0857d76a81a16d03230871," func p224Contract(out, in *p224FieldElement) {
 	out3Equal |= out3Equal >> 1
 	out3Equal = ^uint32(int32(out3Equal<<31) >> 31)
 
-	// If out[3] > 0xffff000 then n's MSB will be zero.
-	out3GT := ^uint32(int32(n) >> 31)
+	// If out[3] > 0xffff000 then n's MSB will be one.
+	out3GT := uint32(int32(n) >> 31)
 
 	mask := top4AllOnes & ((out3Equal & bottom3NonZero) | out3GT)
 	out[0] -= 1 & mask
",[True]
GO-2021-0235,go.googlesource.com,go,d95ca9138026cbe40e0857d76a81a16d03230871," func p224Contract(out, in *p224FieldElement) {
 	out[5] -= 0xfffffff & mask
 	out[6] -= 0xfffffff & mask
 	out[7] -= 0xfffffff & mask
+
+	// Do one final carry down, in case we made out[0] negative. One of
+	// out[0..3] needs to be positive and able to absorb the -1 or the value
+	// would have been < p, and the subtraction wouldn't have happened.
+	for i := 0; i < 3; i++ {
+		mask := uint32(int32(out[i]) >> 31)
+		out[i] += (1 << 28) & mask
+		out[i+1] -= 1 & mask
+	}
 }
 
 // Group element functions.
",[True]
GO-2022-0531,go.googlesource.com,go,fe4de36198794c447fbd9d7cc2d7199a506c76a5," func (hs *serverHandshakeStateTLS13) sendSessionTickets() error {
 	}
 	m.lifetime = uint32(maxSessionTicketLifetime / time.Second)
 
+	// ticket_age_add is a random 32-bit value. See RFC 8446, section 4.6.1
+	// The value is not stored anywhere; we never need to check the ticket age
+	// because 0-RTT is not supported.
+	ageAdd := make([]byte, 4)
+	_, err = hs.c.config.rand().Read(ageAdd)
+	if err != nil {
+		return err
+	}
+	m.ageAdd = binary.LittleEndian.Uint32(ageAdd)
+
+	// ticket_nonce, which must be unique per connection, is always left at
+	// zero because we only ever send one ticket per connection.
+
 	if _, err := c.writeRecord(recordTypeHandshake, m.marshal()); err != nil {
 		return err
 	}
",[True]
GO-2022-0212,go.googlesource.com,go,41b1f88efab9d263408448bf139659119002ea50," func (r *Reader) ReadMIMEHeader() (MIMEHeader, error) {
 			return m, err
 		}
 
-		// Key ends at first colon; should not have trailing spaces
-		// but they appear in the wild, violating specs, so we remove
-		// them if present.
+		// Key ends at first colon.
 		i := bytes.IndexByte(kv, ':')
 		if i < 0 {
 			return m, ProtocolError(""malformed MIME header line: "" + string(kv))
 		}
-		endKey := i
-		for endKey > 0 && kv[endKey-1] == ' ' {
-			endKey--
-		}
-		key := canonicalMIMEHeaderKey(kv[:endKey])
+		key := canonicalMIMEHeaderKey(kv[:i])
 
 		// As per RFC 7230 field-name is a token, tokens consist of one or more chars.
 		// We could return a ProtocolError here, but better to be liberal in what we
",[False]
GO-2022-0523,go.googlesource.com,go,c4c1993fd2a5b26fe45c09592af6d3388a3b2e08," func (d *Decoder) DecodeElement(v any, start *StartElement) error {
 	if val.IsNil() {
 		return errors.New(""nil pointer passed to Unmarshal"")
 	}
-	return d.unmarshal(val.Elem(), start)
+	return d.unmarshal(val.Elem(), start, 0)
 }
 
 // An UnmarshalError represents an error in the unmarshaling process.
",[True]
GO-2022-0523,go.googlesource.com,go,c4c1993fd2a5b26fe45c09592af6d3388a3b2e08," var (
 	textUnmarshalerType = reflect.TypeOf((*encoding.TextUnmarshaler)(nil)).Elem()
 )
 
+const maxUnmarshalDepth = 10000
+
+var errExeceededMaxUnmarshalDepth = errors.New(""exceeded max depth"")
+
 // Unmarshal a single XML element into val.
-func (d *Decoder) unmarshal(val reflect.Value, start *StartElement) error {
+func (d *Decoder) unmarshal(val reflect.Value, start *StartElement, depth int) error {
+	if depth >= maxUnmarshalDepth {
+		return errExeceededMaxUnmarshalDepth
+	}
 	// Find start element if we need it.
 	if start == nil {
 		for {
",[True]
GO-2022-0523,go.googlesource.com,go,c4c1993fd2a5b26fe45c09592af6d3388a3b2e08," func (d *Decoder) unmarshal(val reflect.Value, start *StartElement) error {
 		v.Set(reflect.Append(val, reflect.Zero(v.Type().Elem())))
 
 		// Recur to read element into slice.
-		if err := d.unmarshal(v.Index(n), start); err != nil {
+		if err := d.unmarshal(v.Index(n), start, depth+1); err != nil {
 			v.SetLen(n)
 			return err
 		}
",[True]
GO-2022-0523,go.googlesource.com,go,c4c1993fd2a5b26fe45c09592af6d3388a3b2e08," Loop:
 		case StartElement:
 			consumed := false
 			if sv.IsValid() {
-				consumed, err = d.unmarshalPath(tinfo, sv, nil, &t)
+				// unmarshalPath can call unmarshal, so we need to pass the depth through so that
+				// we can continue to enforce the maximum recusion limit.
+				consumed, err = d.unmarshalPath(tinfo, sv, nil, &t, depth)
 				if err != nil {
 					return err
 				}
 				if !consumed && saveAny.IsValid() {
 					consumed = true
-					if err := d.unmarshal(saveAny, &t); err != nil {
+					if err := d.unmarshal(saveAny, &t, depth+1); err != nil {
 						return err
 					}
 				}
",[True]
GO-2022-0523,go.googlesource.com,go,c4c1993fd2a5b26fe45c09592af6d3388a3b2e08," func copyValue(dst reflect.Value, src []byte) (err error) {
 // The consumed result tells whether XML elements have been consumed
 // from the Decoder until start's matching end element, or if it's
 // still untouched because start is uninteresting for sv's fields.
-func (d *Decoder) unmarshalPath(tinfo *typeInfo, sv reflect.Value, parents []string, start *StartElement) (consumed bool, err error) {
+func (d *Decoder) unmarshalPath(tinfo *typeInfo, sv reflect.Value, parents []string, start *StartElement, depth int) (consumed bool, err error) {
 	recurse := false
 Loop:
 	for i := range tinfo.fields {
",[True]
GO-2022-0523,go.googlesource.com,go,c4c1993fd2a5b26fe45c09592af6d3388a3b2e08," Loop:
 		}
 		if len(finfo.parents) == len(parents) && finfo.name == start.Name.Local {
 			// It's a perfect match, unmarshal the field.
-			return true, d.unmarshal(finfo.value(sv, initNilPointers), start)
+			return true, d.unmarshal(finfo.value(sv, initNilPointers), start, depth+1)
 		}
 		if len(finfo.parents) > len(parents) && finfo.parents[len(parents)] == start.Name.Local {
 			// It's a prefix for the field. Break and recurse
",[True]
GO-2022-0523,go.googlesource.com,go,c4c1993fd2a5b26fe45c09592af6d3388a3b2e08," Loop:
 		}
 		switch t := tok.(type) {
 		case StartElement:
-			consumed2, err := d.unmarshalPath(tinfo, sv, parents, &t)
+			// the recursion depth of unmarshalPath is limited to the path length specified
+			// by the struct field tag, so we don't increment the depth here.
+			consumed2, err := d.unmarshalPath(tinfo, sv, parents, &t, depth)
 			if err != nil {
 				return true, err
 			}
",[True]
GO-2022-0477,go.googlesource.com,go,bb1f4416180511231de6d17a1f2f55c82aafc863," var Reader io.Reader
 func Read(b []byte) (n int, err error) {
 	return io.ReadFull(Reader, b)
 }
+
+// batched returns a function that calls f to populate a []byte by chunking it
+// into subslices of, at most, readMax bytes.
+func batched(f func([]byte) error, readMax int) func([]byte) error {
+	return func(out []byte) error {
+		for len(out) > 0 {
+			read := len(out)
+			if read > readMax {
+				read = readMax
+			}
+			if err := f(out[:read]); err != nil {
+				return err
+			}
+			out = out[read:]
+		}
+		return nil
+	}
+}
",[False]
GO-2022-0477,go.googlesource.com,go,bb1f4416180511231de6d17a1f2f55c82aafc863," type reader struct {
 
 // altGetRandom if non-nil specifies an OS-specific function to get
 // urandom-style randomness.
-var altGetRandom func([]byte) (ok bool)
-
-// batched returns a function that calls f to populate a []byte by chunking it
-// into subslices of, at most, readMax bytes.
-func batched(f func([]byte) error, readMax int) func([]byte) bool {
-	return func(out []byte) bool {
-		for len(out) > 0 {
-			read := len(out)
-			if read > readMax {
-				read = readMax
-			}
-			if f(out[:read]) != nil {
-				return false
-			}
-			out = out[read:]
-		}
-		return true
-	}
-}
+var altGetRandom func([]byte) (err error)
 
 func warnBlocked() {
 	println(""crypto/rand: blocked for 60 seconds waiting to read random data from the kernel"")
",[False]
GO-2022-0477,go.googlesource.com,go,bb1f4416180511231de6d17a1f2f55c82aafc863," func (r *reader) Read(b []byte) (n int, err error) {
 		t := time.AfterFunc(time.Minute, warnBlocked)
 		defer t.Stop()
 	}
-	if altGetRandom != nil && altGetRandom(b) {
+	if altGetRandom != nil && altGetRandom(b) == nil {
 		return len(b), nil
 	}
 	if atomic.LoadUint32(&r.used) != 2 {
",[False]
GO-2022-0477,go.googlesource.com,go,bb1f4416180511231de6d17a1f2f55c82aafc863," func init() { Reader = &rngReader{} }
 type rngReader struct{}
 
 func (r *rngReader) Read(b []byte) (n int, err error) {
-	// RtlGenRandom only accepts 2**32-1 bytes at a time, so truncate.
-	inputLen := uint32(len(b))
-
-	if inputLen == 0 {
-		return 0, nil
-	}
-
-	err = windows.RtlGenRandom(b)
-	if err != nil {
-		return 0, os.NewSyscallError(""RtlGenRandom"", err)
+	// RtlGenRandom only returns 1<<32-1 bytes at a time. We only read at
+	// most 1<<31-1 bytes at a time so that  this works the same on 32-bit
+	// and 64-bit systems.
+	if err := batched(windows.RtlGenRandom, 1<<31-1)(b); err != nil {
+		return 0, err
 	}
-	return int(inputLen), nil
+	return len(b), nil
 }
",[False]
GO-2021-0242,go.googlesource.com,go,6c591f79b0b5327549bd4e94970f7a279efb4ab0," func (z *Rat) SetString(s string) (*Rat, bool) {
 		if n < 0 {
 			n = -n
 		}
+		if n > 1e6 {
+			return nil, false // avoid excessively large exponents
+		}
 		pow5 := z.b.abs.expNN(natFive, nat(nil).setWord(Word(n)), nil) // use underlying array of z.b.abs
 		if exp5 > 0 {
 			z.a.abs = z.a.abs.mul(z.a.abs, pow5)
",[True]
GO-2021-0242,go.googlesource.com,go,6c591f79b0b5327549bd4e94970f7a279efb4ab0," func (z *Rat) SetString(s string) (*Rat, bool) {
 	}
 
 	// apply exp2 contributions
+	if exp2 < -1e7 || exp2 > 1e7 {
+		return nil, false // avoid excessively large exponents
+	}
 	if exp2 > 0 {
-		if int64(uint(exp2)) != exp2 {
-			panic(""exponent too large"")
-		}
 		z.a.abs = z.a.abs.shl(z.a.abs, uint(exp2))
 	} else if exp2 < 0 {
-		if int64(uint(-exp2)) != -exp2 {
-			panic(""exponent too large"")
-		}
 		z.b.abs = z.b.abs.shl(z.b.abs, uint(-exp2))
 	}
 
",[True]
GO-2021-0238,go.googlesource.com,net,37e1c6afe02340126705deced573a85ab75209d7," func inHeadIM(p *parser) bool {
 			// Ignore the token.
 			return true
 		case a.Template:
+			// TODO: remove this divergence from the HTML5 spec.
+			//
+			// We don't handle all of the corner cases when mixing foreign
+			// content (i.e. <math> or <svg>) with <template>. Without this
+			// early return, we can get into an infinite loop, possibly because
+			// of the ""TODO... further divergence"" a little below.
+			//
+			// As a workaround, if we are mixing foreign content and templates,
+			// just ignore the rest of the HTML. Foreign content is rare and a
+			// relatively old HTML feature. Templates are also rare and a
+			// relatively new HTML feature. Their combination is very rare.
+			for _, e := range p.oe {
+				if e.Namespace != """" {
+					p.im = ignoreTheRemainingTokens
+					return true
+				}
+			}
+
 			p.addElement()
 			p.afe = append(p.afe, &scopeMarker)
 			p.framesetOK = false
",[True]
GO-2021-0238,go.googlesource.com,net,37e1c6afe02340126705deced573a85ab75209d7," func inHeadIM(p *parser) bool {
 			if !p.oe.contains(a.Template) {
 				return true
 			}
-			// TODO: remove this divergence from the HTML5 spec.
+			// TODO: remove this further divergence from the HTML5 spec.
 			//
 			// See https://bugs.chromium.org/p/chromium/issues/detail?id=829668
 			p.generateImpliedEndTags()
",[True]
GO-2021-0238,go.googlesource.com,net,37e1c6afe02340126705deced573a85ab75209d7," func afterAfterFramesetIM(p *parser) bool {
 	return true
 }
 
+func ignoreTheRemainingTokens(p *parser) bool {
+	return true
+}
+
 const whitespaceOrNUL = whitespace + ""\x00""
 
 // Section 12.2.6.5
",[False]
GO-2022-0532,go.googlesource.com,go,960ffa98ce73ef2c2060c84c7ac28d37a83f345e," func lookExtensions(path, dir string) (string, error) {
 // The Wait method will return the exit code and release associated resources
 // once the command exits.
 func (c *Cmd) Start() error {
+	if c.Path == """" && c.Err == nil && c.lookPathErr == nil {
+		c.Err = errors.New(""exec: no command"")
+	}
 	if c.Err != nil || c.lookPathErr != nil {
 		c.closeDescriptors(c.closeAfterStart)
 		c.closeDescriptors(c.closeAfterWait)
",[True]
GO-2022-0475,go.googlesource.com,go,062e0e5ce6df339dc26732438ad771f73dbf2292," func dynimport(obj string) {
 			if s.Version != """" {
 				targ += ""#"" + s.Version
 			}
+			checkImportSymName(s.Name)
+			checkImportSymName(targ)
 			fmt.Fprintf(stdout, ""//go:cgo_import_dynamic %s %s %q\n"", s.Name, targ, s.Library)
 		}
 		lib, _ := f.ImportedLibraries()
",[True]
GO-2022-0475,go.googlesource.com,go,062e0e5ce6df339dc26732438ad771f73dbf2292," func dynimport(obj string) {
 			if len(s) > 0 && s[0] == '_' {
 				s = s[1:]
 			}
+			checkImportSymName(s)
 			fmt.Fprintf(stdout, ""//go:cgo_import_dynamic %s %s %q\n"", s, s, """")
 		}
 		lib, _ := f.ImportedLibraries()
",[True]
GO-2022-0475,go.googlesource.com,go,062e0e5ce6df339dc26732438ad771f73dbf2292," func dynimport(obj string) {
 		for _, s := range sym {
 			ss := strings.Split(s, "":"")
 			name := strings.Split(ss[0], ""@"")[0]
+			checkImportSymName(name)
+			checkImportSymName(ss[0])
 			fmt.Fprintf(stdout, ""//go:cgo_import_dynamic %s %s %q\n"", name, ss[0], strings.ToLower(ss[1]))
 		}
 		return
",[True]
GO-2022-0475,go.googlesource.com,go,062e0e5ce6df339dc26732438ad771f73dbf2292," func dynimport(obj string) {
 				// Go symbols.
 				continue
 			}
+			checkImportSymName(s.Name)
 			fmt.Fprintf(stdout, ""//go:cgo_import_dynamic %s %s %q\n"", s.Name, s.Name, s.Library)
 		}
 		lib, err := f.ImportedLibraries()
",[True]
GO-2022-0475,go.googlesource.com,go,062e0e5ce6df339dc26732438ad771f73dbf2292," func dynimport(obj string) {
 	fatalf(""cannot parse %s as ELF, Mach-O, PE or XCOFF"", obj)
 }
 
+// checkImportSymName checks a symbol name we are going to emit as part
+// of a //go:cgo_import_dynamic pragma. These names come from object
+// files, so they may be corrupt. We are going to emit them unquoted,
+// so while they don't need to be valid symbol names (and in some cases,
+// involving symbol versions, they won't be) they must contain only
+// graphic characters and must not contain Go comments.
+func checkImportSymName(s string) {
+	for _, c := range s {
+		if !unicode.IsGraphic(c) || unicode.IsSpace(c) {
+			fatalf(""dynamic symbol %q contains unsupported character"", s)
+		}
+	}
+	if strings.Index(s, ""//"") >= 0 || strings.Index(s, ""/*"") >= 0 {
+		fatalf(""dynamic symbol %q contains Go comment"")
+	}
+}
+
 // Construct a gcc struct matching the gc argument frame.
 // Assumes that in gcc, char is 1 byte, short 2 bytes, int 4 bytes, long long 8 bytes.
 // These assumptions are checked by the gccProlog.
",[False]
GO-2022-0475,go.googlesource.com,go,062e0e5ce6df339dc26732438ad771f73dbf2292," OverlayLoop:
 		noCompiler()
 	}
 
+	// Double check the //go:cgo_ldflag comments in the generated files.
+	// The compiler only permits such comments in files whose base name
+	// starts with ""_cgo_"". Make sure that the comments in those files
+	// are safe. This is a backstop against people somehow smuggling
+	// such a comment into a file generated by cgo.
+	if cfg.BuildToolchainName == ""gc"" && !cfg.BuildN {
+		var flags []string
+		for _, f := range outGo {
+			if !strings.HasPrefix(filepath.Base(f), ""_cgo_"") {
+				continue
+			}
+
+			src, err := ioutil.ReadFile(f)
+			if err != nil {
+				return nil, nil, err
+			}
+
+			const cgoLdflag = ""//go:cgo_ldflag""
+			idx := bytes.Index(src, []byte(cgoLdflag))
+			for idx >= 0 {
+				// We are looking at //go:cgo_ldflag.
+				// Find start of line.
+				start := bytes.LastIndex(src[:idx], []byte(""\n""))
+				if start == -1 {
+					start = 0
+				}
+
+				// Find end of line.
+				end := bytes.Index(src[idx:], []byte(""\n""))
+				if end == -1 {
+					end = len(src)
+				} else {
+					end += idx
+				}
+
+				// Check for first line comment in line.
+				// We don't worry about /* */ comments,
+				// which normally won't appear in files
+				// generated by cgo.
+				commentStart := bytes.Index(src[start:], []byte(""//""))
+				commentStart += start
+				// If that line comment is //go:cgo_ldflag,
+				// it's a match.
+				if bytes.HasPrefix(src[commentStart:], []byte(cgoLdflag)) {
+					// Pull out the flag, and unquote it.
+					// This is what the compiler does.
+					flag := string(src[idx+len(cgoLdflag) : end])
+					flag = strings.TrimSpace(flag)
+					flag = strings.Trim(flag, `""`)
+					flags = append(flags, flag)
+				}
+				src = src[end:]
+				idx = bytes.Index(src, []byte(cgoLdflag))
+			}
+		}
+		if err := checkLinkerFlags(""LDFLAGS"", ""go:cgo_ldflag"", flags); err != nil {
+			return nil, nil, err
+		}
+	}
+
 	return outGo, outObj, nil
 }
 
",[True]
GO-2021-0154,go.googlesource.com,go,64df53ed7f," Curves:
 func (hs *serverHandshakeState) checkForResumption() bool {
 	c := hs.c
 
+	if c.config.SessionTicketsDisabled {
+		return false
+	}
+
 	var ok bool
 	if hs.sessionState, ok = c.decryptTicket(hs.clientHello.sessionTicket); !ok {
 		return false
",[False]
GO-2021-0154,go.googlesource.com,go,64df53ed7f," func (c *Conn) encryptTicket(state *sessionState) ([]byte, error) {
 }
 
 func (c *Conn) decryptTicket(encrypted []byte) (*sessionState, bool) {
-	if len(encrypted) < aes.BlockSize+sha256.Size {
+	if c.config.SessionTicketsDisabled ||
+		len(encrypted) < aes.BlockSize+sha256.Size {
 		return nil, false
 	}
 
",[False]
GO-2021-0160,go.googlesource.com,go,1e066cad1ba23f4064545355b8737e4762dd6838," func (z nat) expNNMontgomery(x, y, m nat) nat {
 	}
 	// convert to regular number
 	zz = zz.montgomery(z, one, m, k0, numWords)
+
+	// One last reduction, just in case.
+	// See golang.org/issue/13907.
+	if zz.cmp(m) >= 0 {
+		// Common case is m has high bit set; in that case,
+		// since zz is the same length as m, there can be just
+		// one multiple of m to remove. Just subtract.
+		// We think that the subtract should be sufficient in general,
+		// so do that unconditionally, but double-check,
+		// in case our beliefs are wrong.
+		// The div is not expected to be reached.
+		zz = zz.sub(zz, m)
+		if zz.cmp(m) >= 0 {
+			_, zz = nat(nil).div(nil, zz, m)
+		}
+	}
+
 	return zz.norm()
 }
 
",[True]
GO-2021-0160,go.googlesource.com,go,4306352182bf94f86f0cfc6a8b0ed461cbf1d82c," func basicMul(z, x, y nat) {
 	}
 }
 
-// montgomery computes x*y*2^(-n*_W) mod m,
-// assuming k = -1/m mod 2^_W.
+// montgomery computes z mod m = x*y*2**(-n*_W) mod m,
+// assuming k = -1/m mod 2**_W.
 // z is used for storing the result which is returned;
 // z must not alias x, y or m.
+// See Gueron, ""Efficient Software Implementations of Modular Exponentiation"".
+// https://eprint.iacr.org/2011/239.pdf
+// In the terminology of that paper, this is an ""Almost Montgomery Multiplication"":
+// x and y are required to satisfy 0 <= z < 2**(n*_W) and then the result
+// z is guaranteed to satisfy 0 <= z < 2**(n*_W), but it may not be < m.
 func (z nat) montgomery(x, y, m nat, k Word, n int) nat {
-	var c1, c2 Word
+	// This code assumes x, y, m are all the same length, n.
+	// (required by addMulVVW and the for loop).
+	// It also assumes that x, y are already reduced mod m,
+	// or else the result will not be properly reduced.
+	if len(x) != n || len(y) != n || len(m) != n {
+		panic(""math/big: mismatched montgomery number lengths"")
+	}
+	var c1, c2, c3 Word
 	z = z.make(n)
 	z.clear()
 	for i := 0; i < n; i++ {
 		d := y[i]
-		c1 += addMulVVW(z, x, d)
+		c2 = addMulVVW(z, x, d)
 		t := z[0] * k
-		c2 = addMulVVW(z, m, t)
-
+		c3 = addMulVVW(z, m, t)
 		copy(z, z[1:])
-		z[n-1] = c1 + c2
-		if z[n-1] < c1 {
+		cx := c1 + c2
+		cy := cx + c3
+		z[n-1] = cy
+		if cx < c2 || cy < c3 {
 			c1 = 1
 		} else {
 			c1 = 0
",[True]
GO-2021-0263,go.googlesource.com,go,61536ec03063b4951163bd09609c86d82631fa27," func NewFile(r io.ReaderAt) (*File, error) {
 			if err := binary.Read(b, bo, &hdr); err != nil {
 				return nil, err
 			}
+			if hdr.Iundefsym > uint32(len(f.Symtab.Syms)) {
+				return nil, &FormatError{offset, fmt.Sprintf(
+					""undefined symbols index in dynamic symbol table command is greater than symbol table length (%d > %d)"",
+					hdr.Iundefsym, len(f.Symtab.Syms)), nil}
+			} else if hdr.Iundefsym+hdr.Nundefsym > uint32(len(f.Symtab.Syms)) {
+				return nil, &FormatError{offset, fmt.Sprintf(
+					""number of undefined symbols after index in dynamic symbol table command is greater than symbol table length (%d > %d)"",
+					hdr.Iundefsym+hdr.Nundefsym, len(f.Symtab.Syms)), nil}
+			}
 			dat := make([]byte, hdr.Nindirectsyms*4)
 			if _, err := r.ReadAt(dat, int64(hdr.Indirectsymoff)); err != nil {
 				return nil, err
",[True]
GO-2021-0226,go.googlesource.com,go,4f5cd0c0331943c7ec72df3b827d972584f77833," func (r *response) Header() http.Header {
 	return r.header
 }
 
-func (r *response) Write(data []byte) (int, error) {
+func (r *response) Write(p []byte) (n int, err error) {
 	if !r.wroteHeader {
 		r.WriteHeader(http.StatusOK)
 	}
-	return r.w.Write(data)
+	if !r.wroteCGIHeader {
+		r.writeCGIHeader(p)
+	}
+	return r.w.Write(p)
 }
 
 func (r *response) WriteHeader(code int) {
",[True]
GO-2021-0226,go.googlesource.com,go,4f5cd0c0331943c7ec72df3b827d972584f77833," func (c *child) serveRequest(req *request, body io.ReadCloser) {
 		httpReq = httpReq.WithContext(envVarCtx)
 		c.handler.ServeHTTP(r, httpReq)
 	}
+	// Make sure we serve something even if nothing was written to r
+	r.Write(nil)
 	r.Close()
 	c.mu.Lock()
 	delete(c.requests, req.reqId)
",[False]
GO-2021-0356,go.googlesource.com,crypto,1baeb1ce4c0b006eff0f294c47cb7617598dfb3d," func (c *Certificate) SignCert(rand io.Reader, authority Signer) error {
 	}
 	c.SignatureKey = authority.PublicKey()
 
-	if v, ok := authority.(AlgorithmSigner); ok {
-		if v.PublicKey().Type() == KeyAlgoRSA {
-			authority = &rsaSigner{v, KeyAlgoRSASHA512}
+	// Default to KeyAlgoRSASHA512 for ssh-rsa signers.
+	if v, ok := authority.(AlgorithmSigner); ok && v.PublicKey().Type() == KeyAlgoRSA {
+		sig, err := v.SignWithAlgorithm(rand, c.bytesForSigning(), KeyAlgoRSASHA512)
+		if err != nil {
+			return err
 		}
+		c.Signature = sig
+		return nil
 	}
 
 	sig, err := authority.Sign(rand, c.bytesForSigning())
",[False]
GO-2021-0356,go.googlesource.com,crypto,1baeb1ce4c0b006eff0f294c47cb7617598dfb3d," func (c *Certificate) Marshal() []byte {
 
 // Type returns the certificate algorithm name. It is part of the PublicKey interface.
 func (c *Certificate) Type() string {
-	algo, ok := certAlgoNames[c.Key.Type()]
-	if !ok {
-		panic(""unknown cert key type "" + c.Key.Type())
+	keyType := c.Key.Type()
+	for certName, keyName := range certKeyAlgoNames {
+		if keyName == keyType {
+			return certName
+		}
 	}
-	return algo
+	panic(""unknown certificate type for key type "" + keyType)
 }
 
 // Verify verifies a signature against the certificate's public
",[False]
GO-2021-0356,go.googlesource.com,crypto,1baeb1ce4c0b006eff0f294c47cb7617598dfb3d," func (c *connection) clientHandshake(dialAddress string, config *ClientConfig) e
 	return c.clientAuthenticate(config)
 }
 
-// verifyHostKeySignature verifies the host key obtained in the key
-// exchange.
+// verifyHostKeySignature verifies the host key obtained in the key exchange.
+// algo is the negotiated algorithm, and may be a certificate type.
 func verifyHostKeySignature(hostKey PublicKey, algo string, result *kexResult) error {
 	sig, rest, ok := parseSignatureBody(result.Signature)
 	if len(rest) > 0 || !ok {
 		return errors.New(""ssh: signature parse error"")
 	}
 
-	// For keys, underlyingAlgo is exactly algo. For certificates,
-	// we have to look up the underlying key algorithm that SSH
-	// uses to evaluate signatures.
-	underlyingAlgo := algo
-	for sigAlgo, certAlgo := range certAlgoNames {
-		if certAlgo == algo {
-			underlyingAlgo = sigAlgo
-		}
-	}
-	if sig.Format != underlyingAlgo {
-		return fmt.Errorf(""ssh: invalid signature algorithm %q, expected %q"", sig.Format, underlyingAlgo)
+	if a := underlyingAlgo(algo); sig.Format != a {
+		return fmt.Errorf(""ssh: invalid signature algorithm %q, expected %q"", sig.Format, a)
 	}
 
 	return hostKey.Verify(result.H, sig)
",[False]
GO-2021-0356,go.googlesource.com,crypto,1baeb1ce4c0b006eff0f294c47cb7617598dfb3d," var supportedMACs = []string{
 
 var supportedCompressions = []string{compressionNone}
 
-// hashFuncs keeps the mapping of supported algorithms to their respective
-// hashes needed for signature verification.
+// hashFuncs keeps the mapping of supported signature algorithms to their
+// respective hashes needed for signing and verification.
 var hashFuncs = map[string]crypto.Hash{
-	KeyAlgoRSA:           crypto.SHA1,
-	KeyAlgoRSASHA256:     crypto.SHA256,
-	KeyAlgoRSASHA512:     crypto.SHA512,
-	KeyAlgoDSA:           crypto.SHA1,
-	KeyAlgoECDSA256:      crypto.SHA256,
-	KeyAlgoECDSA384:      crypto.SHA384,
-	KeyAlgoECDSA521:      crypto.SHA512,
-	CertAlgoRSAv01:       crypto.SHA1,
-	CertAlgoRSASHA256v01: crypto.SHA256,
-	CertAlgoRSASHA512v01: crypto.SHA512,
-	CertAlgoDSAv01:       crypto.SHA1,
-	CertAlgoECDSA256v01:  crypto.SHA256,
-	CertAlgoECDSA384v01:  crypto.SHA384,
-	CertAlgoECDSA521v01:  crypto.SHA512,
+	KeyAlgoRSA:       crypto.SHA1,
+	KeyAlgoRSASHA256: crypto.SHA256,
+	KeyAlgoRSASHA512: crypto.SHA512,
+	KeyAlgoDSA:       crypto.SHA1,
+	KeyAlgoECDSA256:  crypto.SHA256,
+	KeyAlgoECDSA384:  crypto.SHA384,
+	KeyAlgoECDSA521:  crypto.SHA512,
+	// KeyAlgoED25519 doesn't pre-hash.
+	KeyAlgoSKECDSA256: crypto.SHA256,
+	KeyAlgoSKED25519:  crypto.SHA256,
+}
+
+// algorithmsForKeyFormat returns the supported signature algorithms for a given
+// public key format (PublicKey.Type), in order of preference. See RFC 8332,
+// Section 2. See also the note in sendKexInit on backwards compatibility.
+func algorithmsForKeyFormat(keyFormat string) []string {
+	switch keyFormat {
+	case KeyAlgoRSA:
+		return []string{KeyAlgoRSASHA256, KeyAlgoRSASHA512, KeyAlgoRSA}
+	case CertAlgoRSAv01:
+		return []string{CertAlgoRSASHA256v01, CertAlgoRSASHA512v01, CertAlgoRSAv01}
+	default:
+		return []string{keyFormat}
+	}
 }
 
 // unexpectedMessageError results when the SSH message that we received didn't
",[False]
GO-2021-0356,go.googlesource.com,crypto,1baeb1ce4c0b006eff0f294c47cb7617598dfb3d," func (t *handshakeTransport) sendKexInit() error {
 	}
 	io.ReadFull(rand.Reader, msg.Cookie[:])
 
-	if len(t.hostKeys) > 0 {
+	isServer := len(t.hostKeys) > 0
+	if isServer {
 		for _, k := range t.hostKeys {
-			algo := k.PublicKey().Type()
-			switch algo {
-			case KeyAlgoRSA:
-				msg.ServerHostKeyAlgos = append(msg.ServerHostKeyAlgos, []string{KeyAlgoRSASHA512, KeyAlgoRSASHA256, KeyAlgoRSA}...)
-			case CertAlgoRSAv01:
-				msg.ServerHostKeyAlgos = append(msg.ServerHostKeyAlgos, []string{CertAlgoRSASHA512v01, CertAlgoRSASHA256v01, CertAlgoRSAv01}...)
-			default:
-				msg.ServerHostKeyAlgos = append(msg.ServerHostKeyAlgos, algo)
+			// If k is an AlgorithmSigner, presume it supports all signature algorithms
+			// associated with the key format. (Ideally AlgorithmSigner would have a
+			// method to advertise supported algorithms, but it doesn't. This means that
+			// adding support for a new algorithm is a breaking change, as we will
+			// immediately negotiate it even if existing implementations don't support
+			// it. If that ever happens, we'll have to figure something out.)
+			// If k is not an AlgorithmSigner, we can only assume it only supports the
+			// algorithms that matches the key format. (This means that Sign can't pick
+			// a different default.)
+			keyFormat := k.PublicKey().Type()
+			if _, ok := k.(AlgorithmSigner); ok {
+				msg.ServerHostKeyAlgos = append(msg.ServerHostKeyAlgos, algorithmsForKeyFormat(keyFormat)...)
+			} else {
+				msg.ServerHostKeyAlgos = append(msg.ServerHostKeyAlgos, keyFormat)
 			}
 		}
 	} else {
 		msg.ServerHostKeyAlgos = t.hostKeyAlgorithms
 	}
+
 	packet := Marshal(msg)
 
 	// writePacket destroys the contents, so save a copy.
",[False]
GO-2021-0356,go.googlesource.com,crypto,1baeb1ce4c0b006eff0f294c47cb7617598dfb3d," func (t *handshakeTransport) enterKeyExchange(otherInitPacket []byte) error {
 
 	var result *kexResult
 	if len(t.hostKeys) > 0 {
-		result, err = t.server(kex, t.algorithms, &magics)
+		result, err = t.server(kex, &magics)
 	} else {
-		result, err = t.client(kex, t.algorithms, &magics)
+		result, err = t.client(kex, &magics)
 	}
 
 	if err != nil {
",[False]
GO-2021-0356,go.googlesource.com,crypto,1baeb1ce4c0b006eff0f294c47cb7617598dfb3d," func (t *handshakeTransport) client(kex kexAlgorithm, algs *algorithms, magics *
 		return nil, err
 	}
 
-	if err := verifyHostKeySignature(hostKey, algs.hostKey, result); err != nil {
+	if err := verifyHostKeySignature(hostKey, t.algorithms.hostKey, result); err != nil {
 		return nil, err
 	}
 
",[False]
GO-2021-0356,go.googlesource.com,crypto,1baeb1ce4c0b006eff0f294c47cb7617598dfb3d," func (group *dhGroup) Client(c packetConn, randSource io.Reader, magics *handsha
 	}, nil
 }
 
-func (group *dhGroup) Server(c packetConn, randSource io.Reader, magics *handshakeMagics, priv Signer) (result *kexResult, err error) {
+func (group *dhGroup) Server(c packetConn, randSource io.Reader, magics *handshakeMagics, priv AlgorithmSigner, algo string) (result *kexResult, err error) {
 	packet, err := c.readPacket()
 	if err != nil {
 		return
",[False]
GO-2021-0356,go.googlesource.com,crypto,1baeb1ce4c0b006eff0f294c47cb7617598dfb3d," func (group *dhGroup) Server(c packetConn, randSource io.Reader, magics *handsha
 
 	// H is already a hash, but the hostkey signing will apply its
 	// own key-specific hash algorithm.
-	sig, err := signAndMarshal(priv, randSource, H)
+	sig, err := signAndMarshal(priv, randSource, H, algo)
 	if err != nil {
 		return nil, err
 	}
",[False]
GO-2021-0356,go.googlesource.com,crypto,1baeb1ce4c0b006eff0f294c47cb7617598dfb3d," func validateECPublicKey(curve elliptic.Curve, x, y *big.Int) bool {
 	return true
 }
 
-func (kex *ecdh) Server(c packetConn, rand io.Reader, magics *handshakeMagics, priv Signer) (result *kexResult, err error) {
+func (kex *ecdh) Server(c packetConn, rand io.Reader, magics *handshakeMagics, priv AlgorithmSigner, algo string) (result *kexResult, err error) {
 	packet, err := c.readPacket()
 	if err != nil {
 		return nil, err
",[False]
GO-2021-0356,go.googlesource.com,crypto,1baeb1ce4c0b006eff0f294c47cb7617598dfb3d," func (kex *ecdh) Server(c packetConn, rand io.Reader, magics *handshakeMagics, p
 
 	// H is already a hash, but the hostkey signing will apply its
 	// own key-specific hash algorithm.
-	sig, err := signAndMarshal(priv, rand, H)
+	sig, err := signAndMarshal(priv, rand, H, algo)
 	if err != nil {
 		return nil, err
 	}
",[False]
GO-2021-0356,go.googlesource.com,crypto,1baeb1ce4c0b006eff0f294c47cb7617598dfb3d," func (kex *ecdh) Server(c packetConn, rand io.Reader, magics *handshakeMagics, p
 	}, nil
 }
 
+// ecHash returns the hash to match the given elliptic curve, see RFC
+// 5656, section 6.2.1
+func ecHash(curve elliptic.Curve) crypto.Hash {
+	bitSize := curve.Params().BitSize
+	switch {
+	case bitSize <= 256:
+		return crypto.SHA256
+	case bitSize <= 384:
+		return crypto.SHA384
+	}
+	return crypto.SHA512
+}
+
 var kexAlgoMap = map[string]kexAlgorithm{}
 
 func init() {
",[False]
GO-2021-0356,go.googlesource.com,crypto,1baeb1ce4c0b006eff0f294c47cb7617598dfb3d," func (kex *curve25519sha256) Client(c packetConn, rand io.Reader, magics *handsh
 	}, nil
 }
 
-func (kex *curve25519sha256) Server(c packetConn, rand io.Reader, magics *handshakeMagics, priv Signer) (result *kexResult, err error) {
+func (kex *curve25519sha256) Server(c packetConn, rand io.Reader, magics *handshakeMagics, priv AlgorithmSigner, algo string) (result *kexResult, err error) {
 	packet, err := c.readPacket()
 	if err != nil {
 		return
",[False]
GO-2021-0356,go.googlesource.com,crypto,1baeb1ce4c0b006eff0f294c47cb7617598dfb3d," func (kex *curve25519sha256) Server(c packetConn, rand io.Reader, magics *handsh
 
 	H := h.Sum(nil)
 
-	sig, err := signAndMarshal(priv, rand, H)
+	sig, err := signAndMarshal(priv, rand, H, algo)
 	if err != nil {
 		return nil, err
 	}
",[False]
GO-2021-0356,go.googlesource.com,crypto,1baeb1ce4c0b006eff0f294c47cb7617598dfb3d," func (gex *dhGEXSHA) Client(c packetConn, randSource io.Reader, magics *handshak
 // Server half implementation of the Diffie Hellman Key Exchange with SHA1 and SHA256.
 //
 // This is a minimal implementation to satisfy the automated tests.
-func (gex dhGEXSHA) Server(c packetConn, randSource io.Reader, magics *handshakeMagics, priv Signer) (result *kexResult, err error) {
+func (gex dhGEXSHA) Server(c packetConn, randSource io.Reader, magics *handshakeMagics, priv AlgorithmSigner, algo string) (result *kexResult, err error) {
 	// Receive GexRequest
 	packet, err := c.readPacket()
 	if err != nil {
",[False]
GO-2021-0356,go.googlesource.com,crypto,1baeb1ce4c0b006eff0f294c47cb7617598dfb3d," func (gex dhGEXSHA) Server(c packetConn, randSource io.Reader, magics *handshake
 
 	// H is already a hash, but the hostkey signing will apply its
 	// own key-specific hash algorithm.
-	sig, err := signAndMarshal(priv, randSource, H)
+	sig, err := signAndMarshal(priv, randSource, H, algo)
 	if err != nil {
 		return nil, err
 	}
",[False]
GO-2021-0356,go.googlesource.com,crypto,1baeb1ce4c0b006eff0f294c47cb7617598dfb3d," func parsePubKey(in []byte, algo string) (pubKey PublicKey, rest []byte, err err
 	case KeyAlgoSKED25519:
 		return parseSKEd25519(in)
 	case CertAlgoRSAv01, CertAlgoDSAv01, CertAlgoECDSA256v01, CertAlgoECDSA384v01, CertAlgoECDSA521v01, CertAlgoSKECDSA256v01, CertAlgoED25519v01, CertAlgoSKED25519v01:
-		cert, err := parseCert(in, certToPrivAlgo(algo))
+		cert, err := parseCert(in, certKeyAlgoNames[algo])
 		if err != nil {
 			return nil, nil, err
 		}
",[False]
GO-2021-0356,go.googlesource.com,crypto,1baeb1ce4c0b006eff0f294c47cb7617598dfb3d," func (r *rsaPublicKey) Marshal() []byte {
 }
 
 func (r *rsaPublicKey) Verify(data []byte, sig *Signature) error {
-	var hash crypto.Hash
-	switch sig.Format {
-	case KeyAlgoRSA:
-		hash = crypto.SHA1
-	case KeyAlgoRSASHA256:
-		hash = crypto.SHA256
-	case KeyAlgoRSASHA512:
-		hash = crypto.SHA512
-	default:
+	supportedAlgos := algorithmsForKeyFormat(r.Type())
+	if !contains(supportedAlgos, sig.Format) {
 		return fmt.Errorf(""ssh: signature type %s for key type %s"", sig.Format, r.Type())
 	}
+	hash := hashFuncs[sig.Format]
 	h := hash.New()
 	h.Write(data)
 	digest := h.Sum(nil)
",[False]
GO-2021-0356,go.googlesource.com,crypto,1baeb1ce4c0b006eff0f294c47cb7617598dfb3d," func (k *dsaPublicKey) Verify(data []byte, sig *Signature) error {
 	if sig.Format != k.Type() {
 		return fmt.Errorf(""ssh: signature type %s for key type %s"", sig.Format, k.Type())
 	}
-	h := crypto.SHA1.New()
+	h := hashFuncs[sig.Format].New()
 	h.Write(data)
 	digest := h.Sum(nil)
 
",[False]
GO-2021-0356,go.googlesource.com,crypto,1baeb1ce4c0b006eff0f294c47cb7617598dfb3d," func (k *dsaPrivateKey) PublicKey() PublicKey {
 }
 
 func (k *dsaPrivateKey) Sign(rand io.Reader, data []byte) (*Signature, error) {
-	return k.SignWithAlgorithm(rand, data, """")
+	return k.SignWithAlgorithm(rand, data, k.PublicKey().Type())
 }
 
 func (k *dsaPrivateKey) SignWithAlgorithm(rand io.Reader, data []byte, algorithm string) (*Signature, error) {
",[False]
GO-2021-0356,go.googlesource.com,crypto,1baeb1ce4c0b006eff0f294c47cb7617598dfb3d," func (k *dsaPrivateKey) SignWithAlgorithm(rand io.Reader, data []byte, algorithm
 		return nil, fmt.Errorf(""ssh: unsupported signature algorithm %s"", algorithm)
 	}
 
-	h := crypto.SHA1.New()
+	h := hashFuncs[k.PublicKey().Type()].New()
 	h.Write(data)
 	digest := h.Sum(nil)
 	r, s, err := dsa.Sign(rand, k.PrivateKey, digest)
",[False]
GO-2021-0356,go.googlesource.com,crypto,1baeb1ce4c0b006eff0f294c47cb7617598dfb3d," func (k *ecdsaPublicKey) Verify(data []byte, sig *Signature) error {
 		return fmt.Errorf(""ssh: signature type %s for key type %s"", sig.Format, k.Type())
 	}
 
-	h := ecHash(k.Curve).New()
+	h := hashFuncs[sig.Format].New()
 	h.Write(data)
 	digest := h.Sum(nil)
 
",[False]
GO-2021-0356,go.googlesource.com,crypto,1baeb1ce4c0b006eff0f294c47cb7617598dfb3d," func (k *skECDSAPublicKey) Verify(data []byte, sig *Signature) error {
 		return fmt.Errorf(""ssh: signature type %s for key type %s"", sig.Format, k.Type())
 	}
 
-	h := ecHash(k.Curve).New()
+	h := hashFuncs[sig.Format].New()
 	h.Write([]byte(k.application))
 	appDigest := h.Sum(nil)
 
",[False]
GO-2021-0356,go.googlesource.com,crypto,1baeb1ce4c0b006eff0f294c47cb7617598dfb3d," func (k *skEd25519PublicKey) Verify(data []byte, sig *Signature) error {
 		return fmt.Errorf(""invalid size %d for Ed25519 public key"", l)
 	}
 
-	h := sha256.New()
+	h := hashFuncs[sig.Format].New()
 	h.Write([]byte(k.application))
 	appDigest := h.Sum(nil)
 
",[False]
GO-2021-0356,go.googlesource.com,crypto,1baeb1ce4c0b006eff0f294c47cb7617598dfb3d," func NewServerConn(c net.Conn, config *ServerConfig) (*ServerConn, <-chan NewCha
 }
 
 // signAndMarshal signs the data with the appropriate algorithm,
-// and serializes the result in SSH wire format.
-func signAndMarshal(k Signer, rand io.Reader, data []byte) ([]byte, error) {
-	sig, err := k.Sign(rand, data)
+// and serializes the result in SSH wire format. algo is the negotiate
+// algorithm and may be a certificate type.
+func signAndMarshal(k AlgorithmSigner, rand io.Reader, data []byte, algo string) ([]byte, error) {
+	sig, err := k.SignWithAlgorithm(rand, data, underlyingAlgo(algo))
 	if err != nil {
 		return nil, err
 	}
",[False]
GO-2021-0356,go.googlesource.com,crypto,1baeb1ce4c0b006eff0f294c47cb7617598dfb3d," func supportedEllipticCurve(curve elliptic.Curve) bool {
 	return curve == elliptic.P256() || curve == elliptic.P384() || curve == elliptic.P521()
 }
 
-// ecHash returns the hash to match the given elliptic curve, see RFC
-// 5656, section 6.2.1
-func ecHash(curve elliptic.Curve) crypto.Hash {
-	bitSize := curve.Params().BitSize
-	switch {
-	case bitSize <= 256:
-		return crypto.SHA256
-	case bitSize <= 384:
-		return crypto.SHA384
-	}
-	return crypto.SHA512
-}
-
 // parseECDSA parses an ECDSA key according to RFC 5656, section 3.1.
 func parseECDSA(in []byte) (out PublicKey, rest []byte, err error) {
 	var w struct {
",[False]
GO-2021-0356,go.googlesource.com,crypto,1baeb1ce4c0b006eff0f294c47cb7617598dfb3d," func newDSAPrivateKey(key *dsa.PrivateKey) (Signer, error) {
 	return &dsaPrivateKey{key}, nil
 }
 
-type rsaSigner struct {
-	AlgorithmSigner
-	defaultAlgorithm string
-}
-
-func (s *rsaSigner) Sign(rand io.Reader, data []byte) (*Signature, error) {
-	return s.AlgorithmSigner.SignWithAlgorithm(rand, data, s.defaultAlgorithm)
-}
-
 type wrappedSigner struct {
 	signer crypto.Signer
 	pubKey PublicKey
",[False]
GO-2021-0234,go.googlesource.com,go,d0b79e3513a29628f3599dc8860666b6eed75372," func (d *Decoder) Token() (Token, error) {
 	if d.nextToken != nil {
 		t = d.nextToken
 		d.nextToken = nil
-	} else if t, err = d.rawToken(); err != nil {
-		switch {
-		case err == io.EOF && d.t != nil:
-			err = nil
-		case err == io.EOF && d.stk != nil && d.stk.kind != stkEOF:
-			err = d.syntaxError(""unexpected EOF"")
+	} else {
+		if t, err = d.rawToken(); t == nil && err != nil {
+			if err == io.EOF && d.stk != nil && d.stk.kind != stkEOF {
+				err = d.syntaxError(""unexpected EOF"")
+			}
+			return nil, err
 		}
-		return t, err
+		// We still have a token to process, so clear any
+		// errors (e.g. EOF) and proceed.
+		err = nil
 	}
-
 	if !d.Strict {
 		if t1, ok := d.autoClose(t); ok {
 			d.nextToken = t
",[True]
GO-2022-0434,go.googlesource.com,go,0fca8a8f25cf4636fd980e72ba0bded4230922de," func (c *Certificate) systemVerify(opts *VerifyOptions) (chains [][]*Certificate
 	certs := macOS.CFArrayCreateMutable()
 	defer macOS.ReleaseCFArray(certs)
 	leaf := macOS.SecCertificateCreateWithData(c.Raw)
+	if leaf == 0 {
+		return nil, errors.New(""invalid leaf certificate"")
+	}
 	macOS.CFArrayAppendValue(certs, leaf)
 	if opts.Intermediates != nil {
 		for _, lc := range opts.Intermediates.lazyCerts {
",[False]
GO-2022-0434,go.googlesource.com,go,0fca8a8f25cf4636fd980e72ba0bded4230922de," func (c *Certificate) systemVerify(opts *VerifyOptions) (chains [][]*Certificate
 				return nil, err
 			}
 			sc := macOS.SecCertificateCreateWithData(c.Raw)
-			macOS.CFArrayAppendValue(certs, sc)
+			if sc != 0 {
+				macOS.CFArrayAppendValue(certs, sc)
+			}
 		}
 	}
 
",[False]
GO-2020-0012,go.googlesource.com,crypto,bac4c82f69751a6dd76e702d54b3ceb88adab236," func parseED25519(in []byte) (out PublicKey, rest []byte, err error) {
 		return nil, nil, err
 	}
 
-	key := ed25519.PublicKey(w.KeyBytes)
+	if l := len(w.KeyBytes); l != ed25519.PublicKeySize {
+		return nil, nil, fmt.Errorf(""invalid size %d for Ed25519 public key"", l)
+	}
 
-	return (ed25519PublicKey)(key), w.Rest, nil
+	return ed25519PublicKey(w.KeyBytes), w.Rest, nil
 }
 
 func (k ed25519PublicKey) Marshal() []byte {
",[True]
GO-2020-0012,go.googlesource.com,crypto,bac4c82f69751a6dd76e702d54b3ceb88adab236," func (k ed25519PublicKey) Verify(b []byte, sig *Signature) error {
 	if sig.Format != k.Type() {
 		return fmt.Errorf(""ssh: signature type %s for key type %s"", sig.Format, k.Type())
 	}
+	if l := len(k); l != ed25519.PublicKeySize {
+		return fmt.Errorf(""ssh: invalid size %d for Ed25519 public key"", l)
+	}
 
-	edKey := (ed25519.PublicKey)(k)
-	if ok := ed25519.Verify(edKey, b, sig.Blob); !ok {
+	if ok := ed25519.Verify(ed25519.PublicKey(k), b, sig.Blob); !ok {
 		return errors.New(""ssh: signature did not verify"")
 	}
 
",[True]
GO-2020-0012,go.googlesource.com,crypto,bac4c82f69751a6dd76e702d54b3ceb88adab236," func parseSKEd25519(in []byte) (out PublicKey, rest []byte, err error) {
 		return nil, nil, err
 	}
 
+	if l := len(w.KeyBytes); l != ed25519.PublicKeySize {
+		return nil, nil, fmt.Errorf(""invalid size %d for Ed25519 public key"", l)
+	}
+
 	key := new(skEd25519PublicKey)
 	key.application = w.Application
 	key.PublicKey = ed25519.PublicKey(w.KeyBytes)
",[True]
GO-2020-0012,go.googlesource.com,crypto,bac4c82f69751a6dd76e702d54b3ceb88adab236," func (k *skEd25519PublicKey) Verify(data []byte, sig *Signature) error {
 	if sig.Format != k.Type() {
 		return fmt.Errorf(""ssh: signature type %s for key type %s"", sig.Format, k.Type())
 	}
+	if l := len(k.PublicKey); l != ed25519.PublicKeySize {
+		return fmt.Errorf(""invalid size %d for Ed25519 public key"", l)
+	}
 
 	h := sha256.New()
 	h.Write([]byte(k.application))
",[True]
GO-2020-0012,go.googlesource.com,crypto,bac4c82f69751a6dd76e702d54b3ceb88adab236," func (k *skEd25519PublicKey) Verify(data []byte, sig *Signature) error {
 
 	original := Marshal(blob)
 
-	edKey := (ed25519.PublicKey)(k.PublicKey)
-	if ok := ed25519.Verify(edKey, original, edSig.Signature); !ok {
+	if ok := ed25519.Verify(k.PublicKey, original, edSig.Signature); !ok {
 		return errors.New(""ssh: signature did not verify"")
 	}
 
",[True]
GO-2020-0012,go.googlesource.com,crypto,bac4c82f69751a6dd76e702d54b3ceb88adab236," func NewPublicKey(key interface{}) (PublicKey, error) {
 	case *dsa.PublicKey:
 		return (*dsaPublicKey)(key), nil
 	case ed25519.PublicKey:
-		return (ed25519PublicKey)(key), nil
+		if l := len(key); l != ed25519.PublicKeySize {
+			return nil, fmt.Errorf(""ssh: invalid size %d for Ed25519 public key"", l)
+		}
+		return ed25519PublicKey(key), nil
 	default:
 		return nil, fmt.Errorf(""ssh: unsupported key type %T"", key)
 	}
",[True]
GO-2020-0012,go.googlesource.com,crypto,bac4c82f69751a6dd76e702d54b3ceb88adab236," func parseOpenSSHPrivateKey(key []byte, decrypt openSSHDecryptFunc) (crypto.Priv
 		return nil, errors.New(""ssh: malformed OpenSSH key"")
 	}
 
-	// we only handle ed25519 and rsa keys currently
 	switch pk1.Keytype {
 	case KeyAlgoRSA:
 		// https://github.com/openssh/openssh-portable/blob/master/sshkey.c#L2760-L2773
",[False]
GO-2022-0191,go.googlesource.com,go,770130659b6fb2acf271476579a3644e093dda7f," func (c *Certificate) Verify(opts VerifyOptions) (chains [][]*Certificate, err e
 	if opts.Roots.contains(c) {
 		candidateChains = append(candidateChains, []*Certificate{c})
 	} else {
-		if candidateChains, err = c.buildChains(make(map[int][][]*Certificate), []*Certificate{c}, &opts); err != nil {
+		if candidateChains, err = c.buildChains(nil, []*Certificate{c}, nil, &opts); err != nil {
 			return nil, err
 		}
 	}
",[False]
GO-2022-0191,go.googlesource.com,go,770130659b6fb2acf271476579a3644e093dda7f," func appendToFreshChain(chain []*Certificate, cert *Certificate) []*Certificate
 	return n
 }
 
-func (c *Certificate) buildChains(cache map[int][][]*Certificate, currentChain []*Certificate, opts *VerifyOptions) (chains [][]*Certificate, err error) {
-	possibleRoots, failedRoot, rootErr := opts.Roots.findVerifiedParents(c)
-nextRoot:
-	for _, rootNum := range possibleRoots {
-		root := opts.Roots.certs[rootNum]
+// maxChainSignatureChecks is the maximum number of CheckSignatureFrom calls
+// that an invocation of buildChains will (tranistively) make. Most chains are
+// less than 15 certificates long, so this leaves space for multiple chains and
+// for failed checks due to different intermediates having the same Subject.
+const maxChainSignatureChecks = 100
 
+func (c *Certificate) buildChains(cache map[*Certificate][][]*Certificate, currentChain []*Certificate, sigChecks *int, opts *VerifyOptions) (chains [][]*Certificate, err error) {
+	var (
+		hintErr  error
+		hintCert *Certificate
+	)
+
+	considerCandidate := func(certType int, candidate *Certificate) {
 		for _, cert := range currentChain {
-			if cert.Equal(root) {
-				continue nextRoot
+			if cert.Equal(candidate) {
+				return
 			}
 		}
 
-		err = root.isValid(rootCertificate, currentChain, opts)
-		if err != nil {
-			continue
+		if sigChecks == nil {
+			sigChecks = new(int)
+		}
+		*sigChecks++
+		if *sigChecks > maxChainSignatureChecks {
+			err = errors.New(""x509: signature check attempts limit reached while verifying certificate chain"")
+			return
 		}
-		chains = append(chains, appendToFreshChain(currentChain, root))
-	}
 
-	possibleIntermediates, failedIntermediate, intermediateErr := opts.Intermediates.findVerifiedParents(c)
-nextIntermediate:
-	for _, intermediateNum := range possibleIntermediates {
-		intermediate := opts.Intermediates.certs[intermediateNum]
-		for _, cert := range currentChain {
-			if cert.Equal(intermediate) {
-				continue nextIntermediate
+		if err := c.CheckSignatureFrom(candidate); err != nil {
+			if hintErr == nil {
+				hintErr = err
+				hintCert = candidate
 			}
+			return
 		}
-		err = intermediate.isValid(intermediateCertificate, currentChain, opts)
+
+		err = candidate.isValid(certType, currentChain, opts)
 		if err != nil {
-			continue
+			return
 		}
-		var childChains [][]*Certificate
-		childChains, ok := cache[intermediateNum]
-		if !ok {
-			childChains, err = intermediate.buildChains(cache, appendToFreshChain(currentChain, intermediate), opts)
-			cache[intermediateNum] = childChains
+
+		switch certType {
+		case rootCertificate:
+			chains = append(chains, appendToFreshChain(currentChain, candidate))
+		case intermediateCertificate:
+			if cache == nil {
+				cache = make(map[*Certificate][][]*Certificate)
+			}
+			childChains, ok := cache[candidate]
+			if !ok {
+				childChains, err = candidate.buildChains(cache, appendToFreshChain(currentChain, candidate), sigChecks, opts)
+				cache[candidate] = childChains
+			}
+			chains = append(chains, childChains...)
 		}
-		chains = append(chains, childChains...)
+	}
+
+	for _, rootNum := range opts.Roots.findPotentialParents(c) {
+		considerCandidate(rootCertificate, opts.Roots.certs[rootNum])
+	}
+	for _, intermediateNum := range opts.Intermediates.findPotentialParents(c) {
+		considerCandidate(intermediateCertificate, opts.Intermediates.certs[intermediateNum])
 	}
 
 	if len(chains) > 0 {
 		err = nil
 	}
-
 	if len(chains) == 0 && err == nil {
-		hintErr := rootErr
-		hintCert := failedRoot
-		if hintErr == nil {
-			hintErr = intermediateErr
-			hintCert = failedIntermediate
-		}
 		err = UnknownAuthorityError{c, hintErr, hintCert}
 	}
 
",[True]
GO-2022-0537,go.googlesource.com,go,055113ef364337607e3e72ed7d48df67fde6fc66," func (z *Float) GobDecode(buf []byte) error {
 		*z = Float{}
 		return nil
 	}
+	if len(buf) < 6 {
+		return errors.New(""Float.GobDecode: buffer too small"")
+	}
 
 	if buf[0] != floatGobVersion {
 		return fmt.Errorf(""Float.GobDecode: encoding version %d not supported"", buf[0])
",[True]
GO-2022-0537,go.googlesource.com,go,055113ef364337607e3e72ed7d48df67fde6fc66," func (z *Float) GobDecode(buf []byte) error {
 	z.prec = binary.BigEndian.Uint32(buf[2:])
 
 	if z.form == finite {
+		if len(buf) < 10 {
+			return errors.New(""Float.GobDecode: buffer too small for finite form float"")
+		}
 		z.exp = int32(binary.BigEndian.Uint32(buf[6:]))
 		z.mant = z.mant.setBytes(buf[10:])
 	}
",[True]
GO-2022-0537,go.googlesource.com,go,055113ef364337607e3e72ed7d48df67fde6fc66," func (z *Rat) GobDecode(buf []byte) error {
 		*z = Rat{}
 		return nil
 	}
+	if len(buf) < 5 {
+		return errors.New(""Rat.GobDecode: buffer too small"")
+	}
 	b := buf[0]
 	if b>>1 != ratGobVersion {
 		return fmt.Errorf(""Rat.GobDecode: encoding version %d not supported"", b>>1)
 	}
 	const j = 1 + 4
 	i := j + binary.BigEndian.Uint32(buf[j-4:j])
+	if len(buf) < int(i) {
+		return errors.New(""Rat.GobDecode: buffer too small"")
+	}
 	z.a.neg = b&1 != 0
 	z.a.abs = z.a.abs.setBytes(buf[j:i])
 	z.b.abs = z.b.abs.setBytes(buf[i:])
",[True]
GO-2021-0067,go.googlesource.com,go,cd3b4ca9f20fd14187ed4cdfdee1a02ea87e5cd8," func toValidName(name string) string {
 	if strings.HasPrefix(p, ""/"") {
 		p = p[len(""/""):]
 	}
-	for strings.HasPrefix(name, ""../"") {
+	for strings.HasPrefix(p, ""../"") {
 		p = p[len(""../""):]
 	}
 	return p
",[True]
GO-2021-0347,go.googlesource.com,go,452f24ae94f38afa3704d4361d91d51218405c0a," func (p *parser) push(re *Regexp) *Regexp {
 	}
 
 	p.stack = append(p.stack, re)
+	p.checkHeight(re)
 	return re
 }
 
",[False]
GO-2021-0347,go.googlesource.com,go,452f24ae94f38afa3704d4361d91d51218405c0a," func (p *parser) repeat(op Op, min, max int, before, after, lastRepeat string) (
 	re.Sub = re.Sub0[:1]
 	re.Sub[0] = sub
 	p.stack[n-1] = re
+	p.checkHeight(re)
 
 	if op == OpRepeat && (min >= 2 || max >= 2) && !repeatIsValid(re, 1000) {
 		return """", &Error{ErrInvalidRepeatSize, before[:len(before)-len(after)]}
",[False]
GO-2021-0347,go.googlesource.com,go,452f24ae94f38afa3704d4361d91d51218405c0a," func Parse(s string, flags Flags) (*Regexp, error) {
 	// Otherwise, must do real work.
 	var (
 		p          parser
-		err        error
 		c          rune
 		op         Op
 		lastRepeat string
",[False]
GO-2022-0289,go.googlesource.com,go,a76511f3a40ea69ee4f5cd86e735e1c8a84f0aa2," func forkExec(argv0 string, argv []string, attr *ProcAttr) (pid int, err error)
 
 	// Allocate child status pipe close on exec.
 	if err = forkExecPipe(p[:]); err != nil {
-		goto error
+		ForkLock.Unlock()
+		return 0, err
 	}
 
 	// Kick off child.
 	pid, err1 = forkAndExecInChild(argv0p, argvp, envvp, chroot, dir, attr, sys, p[1])
 	if err1 != 0 {
-		err = Errno(err1)
-		goto error
+		Close(p[0])
+		Close(p[1])
+		ForkLock.Unlock()
+		return 0, Errno(err1)
 	}
 	ForkLock.Unlock()
 
",[False]
GO-2022-0289,go.googlesource.com,go,a76511f3a40ea69ee4f5cd86e735e1c8a84f0aa2," func forkExec(argv0 string, argv []string, attr *ProcAttr) (pid int, err error)
 		sys = &zeroSysProcAttr
 	}
 
-	p[0] = -1
-	p[1] = -1
-
 	// Convert args to C form.
 	argv0p, err := BytePtrFromString(argv0)
 	if err != nil {
",[False]
GO-2022-0289,go.googlesource.com,go,a76511f3a40ea69ee4f5cd86e735e1c8a84f0aa2," func forkExec(argv0 string, argv []string, attr *ProcAttr) (pid int, err error)
 
 	// Read got EOF, so pipe closed on exec, so exec succeeded.
 	return pid, nil
-
-error:
-	if p[0] >= 0 {
-		Close(p[0])
-		Close(p[1])
-	}
-	ForkLock.Unlock()
-	return 0, err
 }
 
 // Combination of fork and exec, careful to be thread safe.
",[False]
GO-2022-0171,go.googlesource.com,go,7e5b2e0ec144d5f5b2923a7d5db0b9143f79a35a," func loadSystemRoots() (*CertPool, error) {
 	roots := NewCertPool()
 
 	var data C.CFDataRef = nil
-	err := C.FetchPEMRoots(&data)
+	var untrustedData C.CFDataRef = nil
+	err := C.FetchPEMRoots(&data, &untrustedData)
 	if err == -1 {
 		// TODO: better error message
 		return nil, errors.New(""crypto/x509: failed to load darwin system roots with cgo"")
",[False]
GO-2022-0171,go.googlesource.com,go,7e5b2e0ec144d5f5b2923a7d5db0b9143f79a35a," func loadSystemRoots() (*CertPool, error) {
 	defer C.CFRelease(C.CFTypeRef(data))
 	buf := C.GoBytes(unsafe.Pointer(C.CFDataGetBytePtr(data)), C.int(C.CFDataGetLength(data)))
 	roots.AppendCertsFromPEM(buf)
-	return roots, nil
+	if untrustedData == nil {
+		return roots, nil
+	}
+	defer C.CFRelease(C.CFTypeRef(untrustedData))
+	buf = C.GoBytes(unsafe.Pointer(C.CFDataGetBytePtr(untrustedData)), C.int(C.CFDataGetLength(untrustedData)))
+	untrustedRoots := NewCertPool()
+	untrustedRoots.AppendCertsFromPEM(buf)
+
+	trustedRoots := NewCertPool()
+	for _, c := range roots.certs {
+		if !untrustedRoots.contains(c) {
+			trustedRoots.AddCert(c)
+		}
+	}
+	return trustedRoots, nil
 }
",[False]
GO-2022-0171,go.googlesource.com,go,7e5b2e0ec144d5f5b2923a7d5db0b9143f79a35a,"
 
 package x509
 
-import ""os/exec""
+import (
+	""bytes""
+	""encoding/pem""
+	""fmt""
+	""io/ioutil""
+	""os""
+	""os/exec""
+	""strconv""
+	""sync""
+	""syscall""
+)
 
 func (c *Certificate) systemVerify(opts *VerifyOptions) (chains [][]*Certificate, err error) {
 	return nil, nil
 }
 
+// This code is only used when compiling without cgo.
+// It is here, instead of root_nocgo_darwin.go, so that tests can check it
+// even if the tests are run with cgo enabled.
+// The linker will not include these unused functions in binaries built with cgo enabled.
+
 func execSecurityRoots() (*CertPool, error) {
 	cmd := exec.Command(""/usr/bin/security"", ""find-certificate"", ""-a"", ""-p"", ""/System/Library/Keychains/SystemRootCertificates.keychain"")
 	data, err := cmd.Output()
",[True]
GO-2021-0069,go.googlesource.com,go,1e1fa5903b760c6714ba17e50bf850b01f49135c," func (z nat) divRecursiveStep(u, v nat, depth int, tmp *nat, temps []*nat) {
 
 	// Now u < (v<<B), compute lower bits in the same way.
 	// Choose shift = B-1 again.
-	s := B
+	s := B - 1
 	qhat := *temps[depth]
 	qhat.clear()
 	qhat.divRecursiveStep(u[s:].norm(), v[s:], depth+1, tmp, temps)
",[True]
GO-2022-0533,go.googlesource.com,go,9cd1818a7d019c02fa4898b3e45a323e35033290," func Clean(path string) string {
 		case os.IsPathSeparator(path[r]):
 			// empty path element
 			r++
-		case path[r] == '.' && (r+1 == n || os.IsPathSeparator(path[r+1])):
+		case path[r] == '.' && r+1 == n:
 			// . element
 			r++
+		case path[r] == '.' && os.IsPathSeparator(path[r+1]):
+			// ./ element
+			r++
+
+			for r < len(path) && os.IsPathSeparator(path[r]) {
+				r++
+			}
+			if out.w == 0 && volumeNameLen(path[r:]) > 0 {
+				// When joining prefix ""."" and an absolute path on Windows,
+				// the prefix should not be removed.
+				out.append('.')
+			}
 		case path[r] == '.' && path[r+1] == '.' && (r+2 == n || os.IsPathSeparator(path[r+2])):
 			// .. element: remove to last separator
 			r += 2
",[True]
GO-2022-0761,go.googlesource.com,go,b97df54c31d6c4cc2a28a3c83725366d52329223," func (h *Handler) ServeHTTP(rw http.ResponseWriter, req *http.Request) {
 
 	for k, v := range req.Header {
 		k = strings.Map(upperCaseAndUnderscore, k)
+		if k == ""PROXY"" {
+			// See Issue 16405
+			continue
+		}
 		joinStr := "", ""
 		if k == ""COOKIE"" {
 			joinStr = ""; ""
",[True]
GO-2022-0761,go.googlesource.com,go,b97df54c31d6c4cc2a28a3c83725366d52329223," func ProxyFromEnvironment(req *Request) (*url.URL, error) {
 	}
 	if proxy == """" {
 		proxy = httpProxyEnv.Get()
+		if proxy != """" && os.Getenv(""REQUEST_METHOD"") != """" {
+			return nil, errors.New(""net/http: refusing to use HTTP_PROXY value in CGI environment; see golang.org/s/cgihttpproxy"")
+		}
 	}
 	if proxy == """" {
 		return nil, nil
",[True]
GO-2021-0163,go.googlesource.com,go,6a0bb87bd0bf0fdf8ddbd35f77a75ebd412f61b0," type DLL struct {
 }
 
 // LoadDLL loads the named DLL file into memory.
+//
+// If name is not an absolute path and is not a known system DLL used by
+// Go, Windows will search for the named DLL in many locations, causing
+// potential DLL preloading attacks.
+//
+// Use LazyDLL in golang.org/x/sys/windows for a secure way to
+// load system DLLs.
 func LoadDLL(name string) (*DLL, error) {
 	namep, err := UTF16PtrFromString(name)
 	if err != nil {
",[False]
GO-2021-0163,go.googlesource.com,go,6a0bb87bd0bf0fdf8ddbd35f77a75ebd412f61b0," func (src *Source) Generate(w io.Writer) error {
 			}
 			if *sysRepo {
 				if packageName == ""windows"" {
-					return ""&LazyDLL{Name: "" + arg + "", Flags: LoadLibrarySearchSystem32}""
+					return ""&LazyDLL{Name: "" + arg + "", System: true}""
 				} else {
-					return ""&windows.LazyDLL{Name: "" + arg + "", Flags: windows.LoadLibrarySearchSystem32}""
+					return ""&windows.LazyDLL{Name: "" + arg + "", System: true}""
 				}
 			} else {
 				return syscalldot() + ""NewLazyDLL("" + arg + "")""
",[False]
GO-2021-0243,go.googlesource.com,go,a98589711da5e9d935e8d690cfca92892e86d557," func (ka rsaKeyAgreement) generateClientKeyExchange(config *Config, clientHello
 		return nil, nil, err
 	}
 
-	encrypted, err := rsa.EncryptPKCS1v15(config.rand(), cert.PublicKey.(*rsa.PublicKey), preMasterSecret)
+	rsaKey, ok := cert.PublicKey.(*rsa.PublicKey)
+	if !ok {
+		return nil, nil, errors.New(""tls: server certificate contains incorrect key type for selected ciphersuite"")
+	}
+	encrypted, err := rsa.EncryptPKCS1v15(config.rand(), rsaKey, preMasterSecret)
 	if err != nil {
 		return nil, nil, err
 	}
",[True]
GO-2021-0113,go.googlesource.com,text,383b2e75a7a4198c42f8f87833eefb772868a56f," func (t Tag) Parent() Tag {
 
 // ParseExtension parses s as an extension and returns it on success.
 func ParseExtension(s string) (ext string, err error) {
+	defer func() {
+		if recover() != nil {
+			ext = """"
+			err = ErrSyntax
+		}
+	}()
+
 	scan := makeScannerString(s)
 	var end int
 	if n := len(scan.token); n != 1 {
",[False]
GO-2021-0113,go.googlesource.com,text,383b2e75a7a4198c42f8f87833eefb772868a56f," func (t Tag) findTypeForKey(key string) (start, sep, end int, hasExt bool) {
 // ParseBase parses a 2- or 3-letter ISO 639 code.
 // It returns a ValueError if s is a well-formed but unknown language identifier
 // or another error if another error occurred.
-func ParseBase(s string) (Language, error) {
+func ParseBase(s string) (l Language, err error) {
+	defer func() {
+		if recover() != nil {
+			l = 0
+			err = ErrSyntax
+		}
+	}()
+
 	if n := len(s); n < 2 || 3 < n {
 		return 0, ErrSyntax
 	}
",[False]
GO-2021-0113,go.googlesource.com,text,383b2e75a7a4198c42f8f87833eefb772868a56f," func ParseBase(s string) (Language, error) {
 // ParseScript parses a 4-letter ISO 15924 code.
 // It returns a ValueError if s is a well-formed but unknown script identifier
 // or another error if another error occurred.
-func ParseScript(s string) (Script, error) {
+func ParseScript(s string) (scr Script, err error) {
+	defer func() {
+		if recover() != nil {
+			scr = 0
+			err = ErrSyntax
+		}
+	}()
+
 	if len(s) != 4 {
 		return 0, ErrSyntax
 	}
",[False]
GO-2021-0113,go.googlesource.com,text,383b2e75a7a4198c42f8f87833eefb772868a56f," func EncodeM49(r int) (Region, error) {
 // ParseRegion parses a 2- or 3-letter ISO 3166-1 or a UN M.49 code.
 // It returns a ValueError if s is a well-formed but unknown region identifier
 // or another error if another error occurred.
-func ParseRegion(s string) (Region, error) {
+func ParseRegion(s string) (r Region, err error) {
+	defer func() {
+		if recover() != nil {
+			r = 0
+			err = ErrSyntax
+		}
+	}()
+
 	if n := len(s); n < 2 || 3 < n {
 		return 0, ErrSyntax
 	}
",[False]
GO-2021-0113,go.googlesource.com,text,383b2e75a7a4198c42f8f87833eefb772868a56f," type Variant struct {
 
 // ParseVariant parses and returns a Variant. An error is returned if s is not
 // a valid variant.
-func ParseVariant(s string) (Variant, error) {
+func ParseVariant(s string) (v Variant, err error) {
+	defer func() {
+		if recover() != nil {
+			v = Variant{}
+			err = ErrSyntax
+		}
+	}()
+
 	s = strings.ToLower(s)
 	if id, ok := variantIndex[s]; ok {
 		return Variant{id, s}, nil
",[False]
GO-2021-0113,go.googlesource.com,text,383b2e75a7a4198c42f8f87833eefb772868a56f," func Parse(s string) (t Tag, err error) {
 	if s == """" {
 		return Und, ErrSyntax
 	}
+	defer func() {
+		if recover() != nil {
+			t = Und
+			err = ErrSyntax
+			return
+		}
+	}()
 	if len(s) <= maxAltTaglen {
 		b := [maxAltTaglen]byte{}
 		for i, c := range s {
",[True]
GO-2021-0113,go.googlesource.com,text,383b2e75a7a4198c42f8f87833eefb772868a56f," var errInvalidWeight = errors.New(""ParseAcceptLanguage: invalid weight"")
 // Tags with a weight of zero will be dropped. An error will be returned if the
 // input could not be parsed.
 func ParseAcceptLanguage(s string) (tag []Tag, q []float32, err error) {
+	defer func() {
+		if recover() != nil {
+			tag = nil
+			q = nil
+			err = language.ErrSyntax
+		}
+	}()
+
 	var entry string
 	for s != """" {
 		if entry, s = split(s, ','); entry == """" {
",[False]
GO-2021-0241,go.googlesource.com,go,950fa11c4cb01a145bb07eeb167d90a1846061b3," func (p *ReverseProxy) ServeHTTP(rw http.ResponseWriter, req *http.Request) {
 	// important is ""Connection"" because we want a persistent
 	// connection, regardless of what the client sent to us.
 	for _, h := range hopHeaders {
-		hv := outreq.Header.Get(h)
-		if hv == """" {
-			continue
-		}
-		if h == ""Te"" && hv == ""trailers"" {
-			// Issue 21096: tell backend applications that
-			// care about trailer support that we support
-			// trailers. (We do, but we don't go out of
-			// our way to advertise that unless the
-			// incoming client request thought it was
-			// worth mentioning)
-			continue
-		}
 		outreq.Header.Del(h)
 	}
 
+	// Issue 21096: tell backend applications that care about trailer support
+	// that we support trailers. (We do, but we don't go out of our way to
+	// advertise that unless the incoming client request thought it was worth
+	// mentioning.) Note that we look at req.Header, not outreq.Header, since
+	// the latter has passed through removeConnectionHeaders.
+	if httpguts.HeaderValuesContainsToken(req.Header[""Te""], ""trailers"") {
+		outreq.Header.Set(""Te"", ""trailers"")
+	}
+
 	// After stripping all the hop-by-hop connection headers above, add back any
 	// necessary for protocol upgrades, such as for websockets.
 	if reqUpType != """" {
",[True]
GO-2021-0239,go.googlesource.com,go,c89f1224a544cde464fcb86e78ebb0cc97eedba2," func LookupCNAME(host string) (cname string, err error) {
 // LookupCNAME does not return an error if host does not
 // contain DNS ""CNAME"" records, as long as host resolves to
 // address records.
-func (r *Resolver) LookupCNAME(ctx context.Context, host string) (cname string, err error) {
-	return r.lookupCNAME(ctx, host)
+//
+// The returned canonical name is validated to be a properly
+// formatted presentation-format domain name.
+func (r *Resolver) LookupCNAME(ctx context.Context, host string) (string, error) {
+	cname, err := r.lookupCNAME(ctx, host)
+	if err != nil {
+		return """", err
+	}
+	if !isDomainName(cname) {
+		return """", &DNSError{Err: ""CNAME target is invalid"", Name: host}
+	}
+	return cname, nil
 }
 
 // LookupSRV tries to resolve an SRV query of the given service,
",[True]
GO-2021-0239,go.googlesource.com,go,c89f1224a544cde464fcb86e78ebb0cc97eedba2," func (r *Resolver) LookupCNAME(ctx context.Context, host string) (cname string,
 // That is, it looks up _service._proto.name. To accommodate services
 // publishing SRV records under non-standard names, if both service
 // and proto are empty strings, LookupSRV looks up name directly.
+//
+// The returned service names are validated to be properly
+// formatted presentation-format domain names.
 func LookupSRV(service, proto, name string) (cname string, addrs []*SRV, err error) {
 	return DefaultResolver.lookupSRV(context.Background(), service, proto, name)
 }
",[False]
GO-2021-0239,go.googlesource.com,go,c89f1224a544cde464fcb86e78ebb0cc97eedba2," func LookupSRV(service, proto, name string) (cname string, addrs []*SRV, err err
 // That is, it looks up _service._proto.name. To accommodate services
 // publishing SRV records under non-standard names, if both service
 // and proto are empty strings, LookupSRV looks up name directly.
-func (r *Resolver) LookupSRV(ctx context.Context, service, proto, name string) (cname string, addrs []*SRV, err error) {
-	return r.lookupSRV(ctx, service, proto, name)
+//
+// The returned service names are validated to be properly
+// formatted presentation-format domain names.
+func (r *Resolver) LookupSRV(ctx context.Context, service, proto, name string) (string, []*SRV, error) {
+	cname, addrs, err := r.lookupSRV(ctx, service, proto, name)
+	if err != nil {
+		return """", nil, err
+	}
+	if cname != """" && !isDomainName(cname) {
+		return """", nil, &DNSError{Err: ""SRV header name is invalid"", Name: name}
+	}
+	for _, addr := range addrs {
+		if addr == nil {
+			continue
+		}
+		if !isDomainName(addr.Target) {
+			return """", nil, &DNSError{Err: ""SRV target is invalid"", Name: name}
+		}
+	}
+	return cname, addrs, nil
 }
 
 // LookupMX returns the DNS MX records for the given domain name sorted by preference.
 //
+// The returned mail server names are validated to be properly
+// formatted presentation-format domain names.
+//
 // LookupMX uses context.Background internally; to specify the context, use
 // Resolver.LookupMX.
 func LookupMX(name string) ([]*MX, error) {
",[True]
GO-2021-0239,go.googlesource.com,go,c89f1224a544cde464fcb86e78ebb0cc97eedba2," func LookupMX(name string) ([]*MX, error) {
 }
 
 // LookupMX returns the DNS MX records for the given domain name sorted by preference.
+//
+// The returned mail server names are validated to be properly
+// formatted presentation-format domain names.
 func (r *Resolver) LookupMX(ctx context.Context, name string) ([]*MX, error) {
-	return r.lookupMX(ctx, name)
+	records, err := r.lookupMX(ctx, name)
+	if err != nil {
+		return nil, err
+	}
+	for _, mx := range records {
+		if mx == nil {
+			continue
+		}
+		if !isDomainName(mx.Host) {
+			return nil, &DNSError{Err: ""MX target is invalid"", Name: name}
+		}
+	}
+	return records, nil
 }
 
 // LookupNS returns the DNS NS records for the given domain name.
 //
+// The returned name server names are validated to be properly
+// formatted presentation-format domain names.
+//
 // LookupNS uses context.Background internally; to specify the context, use
 // Resolver.LookupNS.
 func LookupNS(name string) ([]*NS, error) {
",[True]
GO-2021-0239,go.googlesource.com,go,c89f1224a544cde464fcb86e78ebb0cc97eedba2," func LookupNS(name string) ([]*NS, error) {
 }
 
 // LookupNS returns the DNS NS records for the given domain name.
+//
+// The returned name server names are validated to be properly
+// formatted presentation-format domain names.
 func (r *Resolver) LookupNS(ctx context.Context, name string) ([]*NS, error) {
-	return r.lookupNS(ctx, name)
+	records, err := r.lookupNS(ctx, name)
+	if err != nil {
+		return nil, err
+	}
+	for _, ns := range records {
+		if ns == nil {
+			continue
+		}
+		if !isDomainName(ns.Host) {
+			return nil, &DNSError{Err: ""NS target is invalid"", Name: name}
+		}
+	}
+	return records, nil
 }
 
 // LookupTXT returns the DNS TXT records for the given domain name.
",[True]
GO-2021-0239,go.googlesource.com,go,c89f1224a544cde464fcb86e78ebb0cc97eedba2," func LookupAddr(addr string) (names []string, err error) {
 
 // LookupAddr performs a reverse lookup for the given address, returning a list
 // of names mapping to that address.
-func (r *Resolver) LookupAddr(ctx context.Context, addr string) (names []string, err error) {
-	return r.lookupAddr(ctx, addr)
+//
+// The returned names are validated to be properly
+// formatted presentation-format domain names.
+func (r *Resolver) LookupAddr(ctx context.Context, addr string) ([]string, error) {
+	names, err := r.lookupAddr(ctx, addr)
+	if err != nil {
+		return nil, err
+	}
+	for _, name := range names {
+		if !isDomainName(name) {
+			return nil, &DNSError{Err: ""PTR target is invalid"", Name: addr}
+		}
+	}
+	return names, nil
 }
",[True]
GO-2020-0013,go.googlesource.com,crypto,e4e2799dd7aab89f583e1d898300d96367750991," func NewClient(c Conn, chans <-chan NewChannel, reqs <-chan *Request) *Client {
 func NewClientConn(c net.Conn, addr string, config *ClientConfig) (Conn, <-chan NewChannel, <-chan *Request, error) {
 	fullConf := *config
 	fullConf.SetDefaults()
+	if fullConf.HostKeyCallback == nil {
+		c.Close()
+		return nil, nil, nil, errors.New(""ssh: must specify HostKeyCallback"")
+	}
+
 	conn := &connection{
 		sshConn: sshConn{conn: c},
 	}
",[True]
GO-2020-0013,go.googlesource.com,crypto,e4e2799dd7aab89f583e1d898300d96367750991," func (t *handshakeTransport) client(kex kexAlgorithm, algs *algorithms, magics *
 		return nil, err
 	}
 
-	if t.hostKeyCallback != nil {
-		err = t.hostKeyCallback(t.dialAddress, t.remoteAddr, hostKey)
-		if err != nil {
-			return nil, err
-		}
+	err = t.hostKeyCallback(t.dialAddress, t.remoteAddr, hostKey)
+	if err != nil {
+		return nil, err
 	}
 
 	return result, nil
",[False]
GO-2021-0264,go.googlesource.com,go,b24687394b55a93449e2be4e6892ead58ea9a10f," func (r *Reader) initFileList() {
 		for _, file := range r.File {
 			isDir := len(file.Name) > 0 && file.Name[len(file.Name)-1] == '/'
 			name := toValidName(file.Name)
+			if name == """" {
+				continue
+			}
 			for dir := path.Dir(name); dir != "".""; dir = path.Dir(dir) {
 				dirs[dir] = true
 			}
",[False]
GO-2021-0264,go.googlesource.com,go,b24687394b55a93449e2be4e6892ead58ea9a10f," func fileEntryLess(x, y string) bool {
 func (r *Reader) Open(name string) (fs.File, error) {
 	r.initFileList()
 
+	if !fs.ValidPath(name) {
+		return nil, &fs.PathError{Op: ""open"", Path: name, Err: fs.ErrInvalid}
+	}
 	e := r.openLookup(name)
-	if e == nil || !fs.ValidPath(name) {
+	if e == nil {
 		return nil, &fs.PathError{Op: ""open"", Path: name, Err: fs.ErrNotExist}
 	}
 	if e.isDir {
",[True]
GO-2021-0264,go.googlesource.com,go,b24687394b55a93449e2be4e6892ead58ea9a10f," func (r *Reader) Open(name string) (fs.File, error) {
 }
 
 func split(name string) (dir, elem string, isDir bool) {
-	if name[len(name)-1] == '/' {
+	if len(name) > 0 && name[len(name)-1] == '/' {
 		isDir = true
 		name = name[:len(name)-1]
 	}
",[True]
GO-2021-0078,go.googlesource.com,net,aaf60122140d3fcf75376d319f0554393160eb50," func inBodyIM(p *parser) bool {
 				p.acknowledgeSelfClosingTag()
 			}
 			return true
-		case a.Frame:
-			// TODO: remove this divergence from the HTML5 spec.
-			if p.oe.contains(a.Template) {
-				p.addElement()
-				return true
-			}
-		case a.Caption, a.Col, a.Colgroup, a.Head, a.Tbody, a.Td, a.Tfoot, a.Th, a.Thead, a.Tr:
+		case a.Caption, a.Col, a.Colgroup, a.Frame, a.Head, a.Tbody, a.Td, a.Tfoot, a.Th, a.Thead, a.Tr:
 			// Ignore the token.
 		default:
 			p.reconstructActiveFormattingElements()
",[True]
GO-2021-0078,go.googlesource.com,net,aaf60122140d3fcf75376d319f0554393160eb50," func inFramesetIM(p *parser) bool {
 			p.acknowledgeSelfClosingTag()
 		case a.Noframes:
 			return inHeadIM(p)
-		case a.Template:
-			// TODO: remove this divergence from the HTML5 spec.
-			//
-			// See https://bugs.chromium.org/p/chromium/issues/detail?id=829668
-			return inTemplateIM(p)
 		}
 	case EndTagToken:
 		switch p.tok.DataAtom {
",[True]
GO-2022-0211,go.googlesource.com,go,61bb56ad63992a3199acc55b2537c8355ef887b6," func resetProxyConfig() {
 }
 
 func (t *Transport) connectMethodForRequest(treq *transportRequest) (cm connectMethod, err error) {
+	// TODO: the validPort check is redundant after CL 189258, as url.URL.Port
+	// only returns valid ports now. golang.org/issue/33600
 	if port := treq.URL.Port(); !validPort(port) {
 		return cm, fmt.Errorf(""invalid URL port %q"", port)
 	}
",[False]
GO-2022-0211,go.googlesource.com,go,61bb56ad63992a3199acc55b2537c8355ef887b6," func parseHost(host string) (string, error) {
 			}
 			return host1 + host2 + host3, nil
 		}
+	} else if i := strings.LastIndex(host, "":""); i != -1 {
+		colonPort := host[i:]
+		if !validOptionalPort(colonPort) {
+			return """", fmt.Errorf(""invalid port %q after host"", colonPort)
+		}
 	}
 
 	var err error
",[True]
