id,repo_owner,repo_name,sha,raw_patch
GO-2023-2116,gofiber,fiber,8c3916dbf4ad2ed427d02c6eb63ae8b2fa8f019a," func refererMatchesHost(c *fiber.Ctx) error {
 	if referer == """" {
 		return ErrNoReferer
 	}
-	if referer != c.Protocol()+""://""+c.Hostname() {
+
+	refererURL, err := url.Parse(referer)
+	if err != nil {
 		return ErrBadReferer
 	}
+
+	if refererURL.Scheme+""://""+refererURL.Host != c.Protocol()+""://""+c.Hostname() {
+		return ErrBadReferer
+	}
+
 	return nil
 }
"
GO-2023-2116,gofiber,fiber,8c3916dbf4ad2ed427d02c6eb63ae8b2fa8f019a," import (
 func compareTokens(a, b []byte) bool {
 	return subtle.ConstantTimeCompare(a, b) == 1
 }
+
+func compareStrings(a, b string) bool {
+	return subtle.ConstantTimeCompare([]byte(a), []byte(b)) == 1
+}
"
GO-2023-2116,gofiber,fiber,b50d91d58ecdff2a330bf07950244b6c4caf65b1,"
+package csrf
+
+import ""crypto/subtle""
+
+func compareTokens(a, b []byte) bool {
+    return subtle.ConstantTimeCompare(a, b) == 1
+}
"
GO-2023-2116,gofiber,fiber,b50d91d58ecdff2a330bf07950244b6c4caf65b1," import (
 )
 
 // go:generate msgp
-// msgp -file=""manager.go"" -o=""manager_msgp.go"" -tests=false -unexported
+// msgp -file=""storage_manager.go"" -o=""storage_manager_msgp.go"" -tests=false -unexported
 type item struct{}
 
 //msgp:ignore manager
-type manager struct {
+type storageManager struct {
 	pool    sync.Pool
 	memory  *memory.Storage
 	storage fiber.Storage
 }
 
-func newManager(storage fiber.Storage) *manager {
+func newStorageManager(storage fiber.Storage) *storageManager {
 	// Create new storage handler
-	manager := &manager{
+	storageManager := &storageManager{
 		pool: sync.Pool{
 			New: func() interface{} {
 				return new(item)
"
GO-2023-2116,gofiber,fiber,b50d91d58ecdff2a330bf07950244b6c4caf65b1," func (m *manager) getRaw(key string) []byte {
 }
 
 // set data to storage or memory
-func (m *manager) setRaw(key string, raw []byte, exp time.Duration) {
+func (m *storageManager) setRaw(key string, raw []byte, exp time.Duration) {
 	if m.storage != nil {
 		_ = m.storage.Set(key, raw, exp) //nolint:errcheck // TODO: Do not ignore error
 	} else {
"
GO-2023-2116,gofiber,fiber,b50d91d58ecdff2a330bf07950244b6c4caf65b1," func (m *manager) setRaw(key string, raw []byte, exp time.Duration) {
 		m.memory.Set(utils.CopyString(key), raw, exp)
 	}
 }
+
+// delete data from storage or memory
+func (m *storageManager) delRaw(key string) {
+	if m.storage != nil {
+		_ = m.storage.Delete(key) //nolint:errcheck // TODO: Do not ignore error
+	} else {
+		m.memory.Delete(key)
+	}
+}
"
GO-2023-2115,gofiber,fiber,8c3916dbf4ad2ed427d02c6eb63ae8b2fa8f019a," func refererMatchesHost(c *fiber.Ctx) error {
 	if referer == """" {
 		return ErrNoReferer
 	}
-	if referer != c.Protocol()+""://""+c.Hostname() {
+
+	refererURL, err := url.Parse(referer)
+	if err != nil {
 		return ErrBadReferer
 	}
+
+	if refererURL.Scheme+""://""+refererURL.Host != c.Protocol()+""://""+c.Hostname() {
+		return ErrBadReferer
+	}
+
 	return nil
 }
"
GO-2023-2115,gofiber,fiber,8c3916dbf4ad2ed427d02c6eb63ae8b2fa8f019a," import (
 func compareTokens(a, b []byte) bool {
 	return subtle.ConstantTimeCompare(a, b) == 1
 }
+
+func compareStrings(a, b string) bool {
+	return subtle.ConstantTimeCompare([]byte(a), []byte(b)) == 1
+}
"
GO-2023-2115,gofiber,fiber,b50d91d58ecdff2a330bf07950244b6c4caf65b1,"
+package csrf
+
+import ""crypto/subtle""
+
+func compareTokens(a, b []byte) bool {
+    return subtle.ConstantTimeCompare(a, b) == 1
+}
"
GO-2023-2115,gofiber,fiber,b50d91d58ecdff2a330bf07950244b6c4caf65b1," import (
 )
 
 // go:generate msgp
-// msgp -file=""manager.go"" -o=""manager_msgp.go"" -tests=false -unexported
+// msgp -file=""storage_manager.go"" -o=""storage_manager_msgp.go"" -tests=false -unexported
 type item struct{}
 
 //msgp:ignore manager
-type manager struct {
+type storageManager struct {
 	pool    sync.Pool
 	memory  *memory.Storage
 	storage fiber.Storage
 }
 
-func newManager(storage fiber.Storage) *manager {
+func newStorageManager(storage fiber.Storage) *storageManager {
 	// Create new storage handler
-	manager := &manager{
+	storageManager := &storageManager{
 		pool: sync.Pool{
 			New: func() interface{} {
 				return new(item)
"
GO-2023-2115,gofiber,fiber,b50d91d58ecdff2a330bf07950244b6c4caf65b1," func (m *manager) getRaw(key string) []byte {
 }
 
 // set data to storage or memory
-func (m *manager) setRaw(key string, raw []byte, exp time.Duration) {
+func (m *storageManager) setRaw(key string, raw []byte, exp time.Duration) {
 	if m.storage != nil {
 		_ = m.storage.Set(key, raw, exp) //nolint:errcheck // TODO: Do not ignore error
 	} else {
"
GO-2023-2115,gofiber,fiber,b50d91d58ecdff2a330bf07950244b6c4caf65b1," func (m *manager) setRaw(key string, raw []byte, exp time.Duration) {
 		m.memory.Set(utils.CopyString(key), raw, exp)
 	}
 }
+
+// delete data from storage or memory
+func (m *storageManager) delRaw(key string) {
+	if m.storage != nil {
+		_ = m.storage.Delete(key) //nolint:errcheck // TODO: Do not ignore error
+	} else {
+		m.memory.Delete(key)
+	}
+}
"
GO-2022-0253,cloudflare,cfrpki,648658b1b176a747b52645989cfddc73a81eacad," func (s *state) MainRRDP(pSpan opentracing.Span) {
 				sentry.CaptureException(err)
 			})
 
-			if s.RRDPFailover {
+			// GHSA-g9wh-3vrx-r7hg: Do not process responses that are too large
+			if s.RRDPFailover && err.Error() != ""http: request body too large"" {
 				log.Errorf(""Error when processing %v (for %v): %v. Will add to rsync."", path, rsync, err)
 				rSpan.LogKV(""event"", ""rrdp failure"", ""type"", ""failover to rsync"", ""message"", err)
 			} else {
"
GO-2020-0019,gorilla,websocket,5b740c29263eb386f33f265561c8262522f19d37," func newConn(conn net.Conn, isServer bool, readBufferSize, writeBufferSize int,
 	return c
 }
 
+// setReadRemaining tracks the number of bytes remaining on the connection. If n
+// overflows, an ErrReadLimit is returned.
+func (c *Conn) setReadRemaining(n int64) error {
+	if n < 0 {
+		return ErrReadLimit
+	}
+
+	c.readRemaining = n
+	return nil
+}
+
 // Subprotocol returns the negotiated protocol for the connection.
 func (c *Conn) Subprotocol() string {
 	return c.subprotocol
"
GO-2020-0019,gorilla,websocket,5b740c29263eb386f33f265561c8262522f19d37," func (c *Conn) NextReader() (messageType int, r io.Reader, err error) {
 			c.readErr = hideTempErr(err)
 			break
 		}
+
 		if frameType == TextMessage || frameType == BinaryMessage {
 			c.messageReader = &messageReader{c}
 			c.reader = c.messageReader
"
GO-2022-1002,pandatix,go-cvss,d9d478ff0c13b8b09ace030db9262f3c2fe031f4," func (cvss20 CVSS20) Vector() string {
 // Attributes values must not be manipulated directly. Use Get
 // and Set methods.
 type CVSS20 struct {
-	Base
-	Temporal
-	Environmental
+	base
+	temporal
+	environmental
 }
 
-// Base is the group of metrics defined with such name by the
+// base is the group of metrics defined with such name by the
 // first.org CVSS v2.0 rev2 specification.
 // Mandatory.
-type Base struct {
+type base struct {
 	// AV -> [L,A,N]
-	AccessVector string
+	accessVector string
 	// AC -> [H,M,L]
-	AccessComplexity string
+	accessComplexity string
 	// Au -> [M,S,N]
-	Authentication string
+	authentication string
 	// C -> [N,P,C]
-	ConfidentialityImpact string
+	confidentialityImpact string
 	// I -> [N,P,C]
-	IntegrityImpact string
+	integrityImpact string
 	// A -> [N,P,C]
-	AvailabilityImpact string
+	availabilityImpact string
 }
 
-// Temporal is the group of metrics defined with such name by the
+// temporal is the group of metrics defined with such name by the
 // first.org CVSS v2.0 rev2 specification.
 // Not mandatory.
-type Temporal struct {
+type temporal struct {
 	// E -> [U,POC,F,F,H,ND]
-	Exploitability string
+	exploitability string
 	// RL -> [OF,TF,W,U,ND]
-	RemediationLevel string
+	remediationLevel string
 	// RC -> [UC,UR,C,ND]
-	ReportConfidence string
+	reportConfidence string
 }
 
-// Environmental is the group of metrics defined with such name by the
+// environmental is the group of metrics defined with such name by the
 // first.org CVSS v2.0 rev2 specification.
 // Not mandatory.
-type Environmental struct {
+type environmental struct {
 	// CDP -> [N,L,LM,MH,H,ND]
-	CollateralDamagePotential string
+	collateralDamagePotential string
 	// TD -> [N,L,M,H,ND]
-	TargetDistribution string
+	targetDistribution string
 	// CR,IR,AR -> [L,M,H,ND]
-	ConfidentialityRequirement string
-	IntegrityRequirement       string
-	AvailabilityRequirement    string
+	confidentialityRequirement string
+	integrityRequirement       string
+	availabilityRequirement    string
 }
 
 func (cvss20 CVSS20) Get(abv string) (string, error) {
 	switch abv {
 	case ""AV"":
-		return cvss20.AccessVector, nil
+		return cvss20.accessVector, nil
 	case ""AC"":
-		return cvss20.AccessComplexity, nil
+		return cvss20.accessComplexity, nil
 	case ""Au"":
-		return cvss20.Authentication, nil
+		return cvss20.authentication, nil
 	case ""C"":
-		return cvss20.ConfidentialityImpact, nil
+		return cvss20.confidentialityImpact, nil
 	case ""I"":
-		return cvss20.IntegrityImpact, nil
+		return cvss20.integrityImpact, nil
 	case ""A"":
-		return cvss20.AvailabilityImpact, nil
+		return cvss20.availabilityImpact, nil
 	case ""E"":
-		return cvss20.Exploitability, nil
+		return cvss20.exploitability, nil
 	case ""RL"":
-		return cvss20.RemediationLevel, nil
+		return cvss20.remediationLevel, nil
 	case ""RC"":
-		return cvss20.ReportConfidence, nil
+		return cvss20.reportConfidence, nil
 	case ""CDP"":
-		return cvss20.CollateralDamagePotential, nil
+		return cvss20.collateralDamagePotential, nil
 	case ""TD"":
-		return cvss20.TargetDistribution, nil
+		return cvss20.targetDistribution, nil
 	case ""CR"":
-		return cvss20.ConfidentialityRequirement, nil
+		return cvss20.confidentialityRequirement, nil
 	case ""IR"":
-		return cvss20.IntegrityRequirement, nil
+		return cvss20.integrityRequirement, nil
 	case ""AR"":
-		return cvss20.AvailabilityRequirement, nil
+		return cvss20.availabilityRequirement, nil
 	default:
 		return """", &ErrInvalidMetric{Abv: abv}
 	}
"
GO-2022-1002,pandatix,go-cvss,d9d478ff0c13b8b09ace030db9262f3c2fe031f4," func (cvss20 *CVSS20) Set(abv string, value string) error {
 		if err := validate(value, []string{""L"", ""A"", ""N""}); err != nil {
 			return err
 		}
-		cvss20.AccessVector = value
+		cvss20.accessVector = value
 	case ""AC"":
 		if err := validate(value, []string{""H"", ""M"", ""L""}); err != nil {
 			return err
 		}
-		cvss20.AccessComplexity = value
+		cvss20.accessComplexity = value
 	case ""Au"":
 		if err := validate(value, []string{""M"", ""S"", ""N""}); err != nil {
 			return err
 		}
-		cvss20.Authentication = value
+		cvss20.authentication = value
 	case ""C"":
 		if err := validate(value, []string{""N"", ""P"", ""C""}); err != nil {
 			return err
 		}
-		cvss20.ConfidentialityImpact = value
+		cvss20.confidentialityImpact = value
 	case ""I"":
 		if err := validate(value, []string{""N"", ""P"", ""C""}); err != nil {
 			return err
 		}
-		cvss20.IntegrityImpact = value
+		cvss20.integrityImpact = value
 	case ""A"":
 		if err := validate(value, []string{""N"", ""P"", ""C""}); err != nil {
 			return err
 		}
-		cvss20.AvailabilityImpact = value
+		cvss20.availabilityImpact = value
 	// Temporal
 	case ""E"":
 		if err := validate(value, []string{""U"", ""POC"", ""F"", ""H"", ""ND""}); err != nil {
 			return err
 		}
-		cvss20.Exploitability = value
+		cvss20.exploitability = value
 	case ""RL"":
 		if err := validate(value, []string{""OF"", ""TF"", ""W"", ""U"", ""ND""}); err != nil {
 			return err
 		}
-		cvss20.RemediationLevel = value
+		cvss20.remediationLevel = value
 	case ""RC"":
 		if err := validate(value, []string{""UC"", ""UR"", ""C"", ""ND""}); err != nil {
 			return err
 		}
-		cvss20.ReportConfidence = value
+		cvss20.reportConfidence = value
 	// Environmental
 	case ""CDP"":
 		if err := validate(value, []string{""N"", ""L"", ""LM"", ""MH"", ""H"", ""ND""}); err != nil {
 			return err
 		}
-		cvss20.CollateralDamagePotential = value
+		cvss20.collateralDamagePotential = value
 	case ""TD"":
 		if err := validate(value, []string{""N"", ""L"", ""M"", ""H"", ""ND""}); err != nil {
 			return err
 		}
-		cvss20.TargetDistribution = value
+		cvss20.targetDistribution = value
 	case ""CR"":
 		if err := validate(value, []string{""L"", ""M"", ""H"", ""ND""}); err != nil {
 			return err
 		}
-		cvss20.ConfidentialityRequirement = value
+		cvss20.confidentialityRequirement = value
 	case ""IR"":
 		if err := validate(value, []string{""L"", ""M"", ""H"", ""ND""}); err != nil {
 			return err
 		}
-		cvss20.IntegrityRequirement = value
+		cvss20.integrityRequirement = value
 	case ""AR"":
 		if err := validate(value, []string{""L"", ""M"", ""H"", ""ND""}); err != nil {
 			return err
 		}
-		cvss20.AvailabilityRequirement = value
+		cvss20.availabilityRequirement = value
 	default:
 		return &ErrInvalidMetric{Abv: abv}
 	}
"
GO-2023-1597,kitabisa,teler-waf,d1d49cfddfa3ec2adad962870f14b85cd1aaf739," func (t *Teler) checkCustomRules(r *http.Request) error {
 // If a match is found, it returns an error indicating a common web attack has been detected.
 // If no match is found, it returns nil.
 func (t *Teler) checkCommonWebAttack(r *http.Request) error {
-	// Decode the URL-encoded request URI of the URL
-	uri := toURLDecode(r.URL.RequestURI())
+	// Decode the URL-encoded and unescape HTML entities request URI of the URL
+	uri := stringDeUnescape(r.URL.RequestURI())
 
 	// Declare byte slice for request body.
 	var body string
"
GO-2023-1597,kitabisa,teler-waf,d1d49cfddfa3ec2adad962870f14b85cd1aaf739," func (t *Teler) checkCommonWebAttack(r *http.Request) error {
 		body = buf.String()
 	}
 
-	// Decode the URL-encoded of body
-	body = toURLDecode(body)
+	// Decode the URL-encoded and unescape HTML entities of body
+	body = stringDeUnescape(body)
 
 	// Iterate over the filters in the CommonWebAttack data stored in the t.threat.cwa.Filters field
 	for _, filter := range t.threat.cwa.Filters {
"
GO-2022-0701,kubernetes,kubernetes,37f730f68c7f06e060f90714439bfb0dbb2df5e7,"
+/*
+Copyright 2015 The Kubernetes Authors All rights reserved.
+
+Licensed under the Apache License, Version 2.0 (the ""License"");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an ""AS IS"" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+package validation
+
+import (
+	""fmt""
+	""strings""
+)
+
+// NameMayNotBe specifies strings that cannot be used as names specified as path segments (like the REST API or etcd store)
+var NameMayNotBe = []string{""."", ""..""}
+
+// NameMayNotContain specifies substrings that cannot be used in names specified as path segments (like the REST API or etcd store)
+var NameMayNotContain = []string{""/"", ""%""}
+
+// ValidatePathSegmentName validates the name can be used as a path segment
+func ValidatePathSegmentName(name string, prefix bool) (bool, string) {
+	// Only check for exact matches if this is the full name (not a prefix)
+	if prefix == false {
+		for _, illegalName := range NameMayNotBe {
+			if name == illegalName {
+				return false, fmt.Sprintf(`name may not be %q`, illegalName)
+			}
+		}
+	}
+
+	for _, illegalContent := range NameMayNotContain {
+		if strings.Contains(name, illegalContent) {
+			return false, fmt.Sprintf(`name may not contain %q`, illegalContent)
+		}
+	}
+
+	return true, """"
+}
"
GO-2021-0085,opencontainers,runc,cad42f6e0932db0ce08c3a3d9e89e6063ec283e4," func setprocattr(attr, value string) error {
 	}
 	defer f.Close()
 
+	if err := utils.EnsureProcHandle(f); err != nil {
+		return err
+	}
+
 	_, err = fmt.Fprintf(f, ""%s"", value)
 	return err
 }
"
GO-2021-0085,opencontainers,runc,cad42f6e0932db0ce08c3a3d9e89e6063ec283e4," func setprocattr(attr, value string) error {
 // changeOnExec reimplements aa_change_onexec from libapparmor in Go
 func changeOnExec(name string) error {
 	value := ""exec "" + name
-	if err := setprocattr(""exec"", value); err != nil {
+	if err := setProcAttr(""exec"", value); err != nil {
 		return fmt.Errorf(""apparmor failed to apply profile: %s"", err)
 	}
 	return nil
"
GO-2021-0085,opencontainers,runc,cad42f6e0932db0ce08c3a3d9e89e6063ec283e4," func InitLabels(options []string) (plabel string, mlabel string, Err error) {
 				return """", mountLabel, nil
 			}
 			if i := strings.Index(opt, "":""); i == -1 {
-				return """", """", fmt.Errorf(""Bad label option %q, valid options 'disable' or \n'user, role, level, type' followed by ':' and a value"", opt)
+				return """", """", fmt.Errorf(""Bad label option %q, valid options 'disable' or \n'user, role, level, type, filetype' followed by ':' and a value"", opt)
 			}
 			con := strings.SplitN(opt, "":"", 2)
 			if !validOptions[con[0]] {
-				return """", """", fmt.Errorf(""Bad label option %q, valid options 'disable, user, role, level, type'"", con[0])
+				return """", """", fmt.Errorf(""Bad label option %q, valid options 'disable, user, role, level, type, filetype'"", con[0])
 
 			}
+			if con[0] == ""filetype"" {
+				mcon[""type""] = con[1]
+			}
 			pcon[con[0]] = con[1]
 			if con[0] == ""level"" || con[0] == ""user"" {
 				mcon[con[0]] = con[1]
"
GO-2021-0085,opencontainers,runc,cad42f6e0932db0ce08c3a3d9e89e6063ec283e4," func SetExecLabel(label string) error {
 	return writeCon(fmt.Sprintf(""/proc/self/task/%d/attr/exec"", syscall.Gettid()), label)
 }
 
+/*
+SetTaskLabel sets the SELinux label for the current thread, or an error.
+This requires the dyntransition permission.
+*/
+func SetTaskLabel(label string) error {
+	return writeCon(fmt.Sprintf(""/proc/self/task/%d/attr/current"", syscall.Gettid()), label)
+}
+
 // SetSocketLabel takes a process label and tells the kernel to assign the
 // label to the next socket that gets created
 func SetSocketLabel(label string) error {
"
GO-2021-0085,opencontainers,runc,cad42f6e0932db0ce08c3a3d9e89e6063ec283e4," func SocketLabel() (string, error) {
 	return readCon(fmt.Sprintf(""/proc/self/task/%d/attr/sockcreate"", syscall.Gettid()))
 }
 
+// PeerLabel retrieves the label of the client on the other side of a socket
+func PeerLabel(fd uintptr) (string, error) {
+	return unix.GetsockoptString(int(fd), syscall.SOL_SOCKET, syscall.SO_PEERSEC)
+}
+
 // SetKeyLabel takes a process label and tells the kernel to assign the
 // label to the next kernel keyring that gets created
 func SetKeyLabel(label string) error {
"
GO-2021-0085,opencontainers,runc,cad42f6e0932db0ce08c3a3d9e89e6063ec283e4," func SetExecLabel(label string) error {
 	return nil
 }
 
+/*
+SetTaskLabel sets the SELinux label for the current thread, or an error.
+This requires the dyntransition permission.
+*/
+func SetTaskLabel(label string) error {
+        return nil
+}
+
 /*
 SetSocketLabel sets the SELinux label that the kernel will use for any programs
 that are executed by the current process thread, or an error.
"
GO-2021-0085,opencontainers,runc,cad42f6e0932db0ce08c3a3d9e89e6063ec283e4," func SocketLabel() (string, error) {
 	return """", nil
 }
 
+// PeerLabel retrieves the label of the client on the other side of a socket
+func PeerLabel(fd uintptr) (string, error) {
+	return """", nil
+}
+
 // SetKeyLabel takes a process label and tells the kernel to assign the
 // label to the next kernel keyring that gets created
 func SetKeyLabel(label string) error {
"
GO-2021-0100,containers,storage,306fcabc964470e4b3b87a43a8f6b7d698209ee1," func DecompressStream(archive io.Reader) (io.ReadCloser, error) {
 		readBufWrapper := p.NewReadCloserWrapper(buf, bz2Reader)
 		return readBufWrapper, nil
 	case Xz:
-		xzReader, chdone, err := xzDecompress(buf)
+		xzReader, err := xz.NewReader(buf)
 		if err != nil {
 			return nil, err
 		}
 		readBufWrapper := p.NewReadCloserWrapper(buf, xzReader)
-		return ioutils.NewReadCloserWrapper(readBufWrapper, func() error {
-			<-chdone
-			return readBufWrapper.Close()
-		}), nil
+		return readBufWrapper, nil
 	case Zstd:
 		return zstdReader(buf)
 	default:
"
GO-2021-0100,containers,storage,306fcabc964470e4b3b87a43a8f6b7d698209ee1,"
+// Copyright 2014-2021 Ulrich Kunitz. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package hash
+
+// Roller provides an interface for rolling hashes. The hash value will become
+// valid after hash has been called Len times.
+type Roller interface {
+	Len() int
+	RollByte(x byte) uint64
+}
+
+// Hashes computes all hash values for the array p. Note that the state of the
+// roller is changed.
+func Hashes(r Roller, p []byte) []uint64 {
+	n := r.Len()
+	if len(p) < n {
+		return nil
+	}
+	h := make([]uint64, len(p)-n+1)
+	for i := 0; i < n-1; i++ {
+		r.RollByte(p[i])
+	}
+	for i := range h {
+		h[i] = r.RollByte(p[i+n-1])
+	}
+	return h
+}
"
GO-2021-0100,containers,storage,306fcabc964470e4b3b87a43a8f6b7d698209ee1,"
+// Copyright 2014-2021 Ulrich Kunitz. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package lzma
+
+/* Naming conventions follows the CodeReviewComments in the Go Wiki. */
+
+// ntz32Const is used by the functions NTZ and NLZ.
+const ntz32Const = 0x04d7651f
+
+// ntz32Table is a helper table for de Bruijn algorithm by Danny Dubé.
+// See Henry S. Warren, Jr. ""Hacker's Delight"" section 5-1 figure 5-26.
+var ntz32Table = [32]int8{
+	0, 1, 2, 24, 3, 19, 6, 25,
+	22, 4, 20, 10, 16, 7, 12, 26,
+	31, 23, 18, 5, 21, 9, 15, 11,
+	30, 17, 8, 14, 29, 13, 28, 27,
+}
+
+/*
+// ntz32 computes the number of trailing zeros for an unsigned 32-bit integer.
+func ntz32(x uint32) int {
+	if x == 0 {
+		return 32
+	}
+	x = (x & -x) * ntz32Const
+	return int(ntz32Table[x>>27])
+}
+*/
+
+// nlz32 computes the number of leading zeros for an unsigned 32-bit integer.
+func nlz32(x uint32) int {
+	// Smear left most bit to the right
+	x |= x >> 1
+	x |= x >> 2
+	x |= x >> 4
+	x |= x >> 8
+	x |= x >> 16
+	// Use ntz mechanism to calculate nlz.
+	x++
+	if x == 0 {
+		return 0
+	}
+	x *= ntz32Const
+	return 32 - int(ntz32Table[x>>27])
+}
"
GO-2021-0100,containers,storage,306fcabc964470e4b3b87a43a8f6b7d698209ee1,"
+// Copyright 2014-2021 Ulrich Kunitz. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package lzma
+
+import (
+	""errors""
+	""io""
+)
+
+// ErrLimit indicates that the limit of the LimitedByteWriter has been
+// reached.
+var ErrLimit = errors.New(""limit reached"")
+
+// LimitedByteWriter provides a byte writer that can be written until a
+// limit is reached. The field N provides the number of remaining
+// bytes.
+type LimitedByteWriter struct {
+	BW io.ByteWriter
+	N  int64
+}
+
+// WriteByte writes a single byte to the limited byte writer. It returns
+// ErrLimit if the limit has been reached. If the byte is successfully
+// written the field N of the LimitedByteWriter will be decremented by
+// one.
+func (l *LimitedByteWriter) WriteByte(c byte) error {
+	if l.N <= 0 {
+		return ErrLimit
+	}
+	if err := l.BW.WriteByte(c); err != nil {
+		return err
+	}
+	l.N--
+	return nil
+}
"
GO-2021-0100,containers,storage,306fcabc964470e4b3b87a43a8f6b7d698209ee1," func DetectCompression(source []byte) Compression {
 	return Uncompressed
 }
 
-func xzDecompress(archive io.Reader) (io.ReadCloser, <-chan struct{}, error) {
-	args := []string{""xz"", ""-d"", ""-c"", ""-q""}
-
-	return cmdStream(exec.Command(args[0], args[1:]...), archive)
-}
-
 // DecompressStream decompresses the archive and returns a ReaderCloser with the decompressed archive.
 func DecompressStream(archive io.Reader) (io.ReadCloser, error) {
 	p := pools.BufioReader32KPool
"
GO-2023-2052,gofiber,fiber,b8c9ede6efa231116c4bd8bb9d5e03eac1cb76dc," func (*Ctx) isLocalHost(address string) bool {
 
 // IsFromLocal will return true if request came from local.
 func (c *Ctx) IsFromLocal() bool {
-	ips := c.IPs()
-	if len(ips) == 0 {
-		ips = append(ips, c.IP())
-	}
-	return c.isLocalHost(ips[0])
+	return c.isLocalHost(c.fasthttp.RemoteIP().String())
 }
"
GO-2020-0021,gogs,gogs,83283bca4cb4e0f4ec48a28af680f0d88db3d2c8," func SearchRepos(ctx *middleware.Context) {
 		opt.Limit = 10
 	}
 
+	// Check visibility.
+	if ctx.IsSigned && opt.Uid > 0 {
+		if ctx.User.Id == opt.Uid {
+			opt.Private = true
+		} else {
+			u, err := models.GetUserById(opt.Uid)
+			if err != nil {
+				ctx.JSON(500, map[string]interface{}{
+					""ok"":    false,
+					""error"": err.Error(),
+				})
+				return
+			}
+			if u.IsOrganization() && u.IsOrgOwner(ctx.User.Id) {
+				opt.Private = true
+			}
+			// FIXME: how about collaborators?
+		}
+	}
+
 	repos, err := models.SearchRepositoryByName(opt)
 	if err != nil {
 		ctx.JSON(500, map[string]interface{}{
"
GO-2022-0370,mellium,xmpp,0d92aa486da69b71f2f4a30e62aa722c711b98ac," func NewClient(ctx context.Context, origin, location string, addr jid.JID, rwc i
 	d := Dialer{
 		Origin: origin,
 	}
-	cfg, err := d.config(location)
+	cfg, err := d.config(addr.Domain().String(), location)
 	if err != nil {
 		return nil, err
 	}
"
GO-2022-0370,mellium,xmpp,0d92aa486da69b71f2f4a30e62aa722c711b98ac," func (d *Dialer) Dial(ctx context.Context, addr jid.JID) (net.Conn, error) {
 		if !d.InsecureNoTLS && strings.HasPrefix(u, ""ws:"") {
 			continue
 		}
-		cfg, err = d.config(u)
+		cfg, err = d.config(addr.Domain().String(), u)
 		if err != nil {
 			continue
 		}
"
GO-2020-0017,dgrijalva,jwt-go,ec0a89a131e3e8567adcb21254a5cd20a70ea4ab,"
+package jwt
+
+import (
+	""encoding/json""
+	""reflect""
+)
+
+// ClaimStrings is used for parsing claim properties that
+// can be either a string or array of strings
+type ClaimStrings []string
+
+// UnmarshalJSON implements the json package's Unmarshaler interface
+func (c *ClaimStrings) UnmarshalJSON(data []byte) error {
+	var value interface{}
+	err := json.Unmarshal(data, &value)
+	if err != nil {
+		return err
+	}
+	switch v := value.(type) {
+	case string:
+		*c = ClaimStrings{v}
+	case []interface{}:
+		result := make(ClaimStrings, 0, len(v))
+		for i, vv := range v {
+			if x, ok := vv.(string); ok {
+				result = append(result, x)
+			} else {
+				return &json.UnsupportedTypeError{Type: reflect.TypeOf(v[i])}
+			}
+		}
+		*c = result
+	case nil:
+	default:
+		return &json.UnsupportedTypeError{Type: reflect.TypeOf(v)}
+	}
+	return nil
+}
"
GO-2020-0017,dgrijalva,jwt-go,ec0a89a131e3e8567adcb21254a5cd20a70ea4ab," func (c *StandardClaims) VerifyNotBefore(cmp int64, req bool) bool {
 
 // ----- helpers
 
-func verifyAud(aud string, cmp string, required bool) bool {
-	if aud == """" {
+func verifyAud(aud ClaimStrings, cmp string, required bool) bool {
+	if len(aud) == 0 {
 		return !required
 	}
-	if subtle.ConstantTimeCompare([]byte(aud), []byte(cmp)) != 0 {
-		return true
+	for _, audStr := range aud {
+		if subtle.ConstantTimeCompare([]byte(audStr), []byte(cmp)) != 0 {
+			return true
+		}
 	}
 	return false
 }
"
GO-2022-0400,ntbosscher,gobase,a8d40bce9c429d324122d18c446924dab809e812," func middleware(config Config) *server {
 }
 
 type server struct {
-	next                     http.Handler
+	next http.Handler
 	perRequestFilter         PerRequestFilter
 	ignoreRoutesWithPrefixes []string
 	ignoreRoutes             []string
 	authHandler              func(request *res.Request) (res.Responder, context.Context)
 }
 
-const defaultLoginEndpoint = ""/api/auth/login""
-const defaultRefreshEndpoint = ""/api/auth/refresh""
-const defaultLogoutEndpoint = ""/api/auth/logout""
-const defaultRegisterEndpoint = ""/api/auth/register""
-
 func (s *server) ServeHTTP(w http.ResponseWriter, r *http.Request) {
 
 	ignoredRoute := false
"
GO-2022-1052,tendermint,tendermint,a2a6852ab99e4a0f9e79f0ea8c1726e262e25c76," func NewPool(evidenceDB dbm.DB, stateDB sm.Store, blockStore BlockStore) (*Pool,
 		logger:          log.NewNopLogger(),
 		evidenceStore:   evidenceDB,
 		evidenceList:    clist.New(),
-		consensusBuffer: make([]types.Evidence, 0),
+		consensusBuffer: make([]duplicateVoteSet, 0),
 	}
 
 	// if pending evidence already in db, in event of prior failure, then check for expiration,
"
GO-2022-1052,tendermint,tendermint,a2a6852ab99e4a0f9e79f0ea8c1726e262e25c76," func (evpool *Pool) AddEvidence(ev types.Evidence) error {
 
 	// We have already verified this piece of evidence - no need to do it again
 	if evpool.isPending(ev) {
-		evpool.logger.Info(""Evidence already pending, ignoring this one"", ""ev"", ev)
+		evpool.logger.Debug(""Evidence already pending, ignoring this one"", ""ev"", ev)
 		return nil
 	}
 
"
GO-2022-1052,tendermint,tendermint,a2a6852ab99e4a0f9e79f0ea8c1726e262e25c76," func (evpool *Pool) removePendingEvidence(evidence types.Evidence) {
 		evpool.logger.Error(""Unable to delete pending evidence"", ""err"", err)
 	} else {
 		atomic.AddUint32(&evpool.evidenceSize, ^uint32(0))
-		evpool.logger.Info(""Deleted pending evidence"", ""evidence"", evidence)
+		evpool.logger.Debug(""Deleted pending evidence"", ""evidence"", evidence)
 	}
 }
 
"
GO-2022-0346,quay,claircore,691f2023a1720a0579e688b69a2f4bfe1f4b7821," func checkMagic(ctx context.Context, r io.Reader) bool {
 
 	return false
 }
+
+// RelPath takes a member and forcibly interprets it as a path underneath root.
+//
+// This should be used anytime a path for a new file on disk is needed when
+// unpacking a tar.
+func relPath(root, member string) string {
+	return filepath.Join(root, filepath.Join(""/"", member))
+}
"
GO-2022-1129,crewjam,saml,aee3fb1edeeaf1088fcb458727e0fd863d277f8b," import (
 	""regexp""
 	""time""
 
-	xrv ""github.com/mattermost/xml-roundtrip-validator""
-
 	""github.com/beevik/etree""
+	xrv ""github.com/mattermost/xml-roundtrip-validator""
 	dsig ""github.com/russellhaering/goxmldsig""
 	""github.com/russellhaering/goxmldsig/etreeutils""
 
"
GO-2022-1129,crewjam,saml,aee3fb1edeeaf1088fcb458727e0fd863d277f8b," func (sp *ServiceProvider) ValidateLogoutResponseRequest(req *http.Request) erro
 
 // ValidateLogoutResponseForm returns a nil error if the logout response is valid.
 func (sp *ServiceProvider) ValidateLogoutResponseForm(postFormData string) error {
+	retErr := &InvalidResponseError{
+		Now: TimeNow(),
+	}
+
 	rawResponseBuf, err := base64.StdEncoding.DecodeString(postFormData)
 	if err != nil {
-		return fmt.Errorf(""unable to parse base64: %s"", err)
+		retErr.PrivateErr = fmt.Errorf(""unable to parse base64: %s"", err)
+		return retErr
 	}
+	retErr.Response = string(rawResponseBuf)
 
 	// TODO(ross): add test case for this (SLO does not have tests right now)
 	if err := xrv.Validate(bytes.NewReader(rawResponseBuf)); err != nil {
 		return fmt.Errorf(""response contains invalid XML: %s"", err)
 	}
 
-	var resp LogoutResponse
-	if err := xml.Unmarshal(rawResponseBuf, &resp); err != nil {
-		return fmt.Errorf(""cannot unmarshal response: %s"", err)
+	doc := etree.NewDocument()
+	if err := doc.ReadFromBytes(rawResponseBuf); err != nil {
+		retErr.PrivateErr = err
+		return retErr
 	}
 
-	if err := sp.validateLogoutResponse(&resp); err != nil {
-		return err
+	if err := sp.validateSignature(doc.Root()); err != nil {
+		retErr.PrivateErr = err
+		return retErr
 	}
 
-	doc := etree.NewDocument()
-	if err := doc.ReadFromBytes(rawResponseBuf); err != nil {
+	var resp LogoutResponse
+	if err := unmarshalElement(doc.Root(), &resp); err != nil {
+		retErr.PrivateErr = err
+		return retErr
+	}
+	if err := sp.validateLogoutResponse(&resp); err != nil {
 		return err
 	}
-
-	responseEl := doc.Root()
-	return sp.validateSigned(responseEl)
+	return nil
 }
 
 // ValidateLogoutResponseRedirect returns a nil error if the logout response is valid.
"
GO-2022-1129,crewjam,saml,aee3fb1edeeaf1088fcb458727e0fd863d277f8b," func (sp *ServiceProvider) ValidateLogoutResponseForm(postFormData string) error
 // URL Binding appears to be gzip / flate encoded
 // See https://www.oasis-open.org/committees/download.php/20645/sstc-saml-tech-overview-2%200-draft-10.pdf  6.6
 func (sp *ServiceProvider) ValidateLogoutResponseRedirect(queryParameterData string) error {
+	retErr := &InvalidResponseError{
+		Now: TimeNow(),
+	}
+
 	rawResponseBuf, err := base64.StdEncoding.DecodeString(queryParameterData)
 	if err != nil {
-		return fmt.Errorf(""unable to parse base64: %s"", err)
+		retErr.PrivateErr = fmt.Errorf(""unable to parse base64: %s"", err)
+		return retErr
 	}
+	retErr.Response = string(rawResponseBuf)
 
 	gr, err := ioutil.ReadAll(flate.NewReader(bytes.NewBuffer(rawResponseBuf)))
 	if err != nil {
-		return err
+		retErr.PrivateErr = err
+		return retErr
 	}
 
 	if err := xrv.Validate(bytes.NewReader(gr)); err != nil {
 		return err
 	}
 
-	decoder := xml.NewDecoder(bytes.NewReader(gr))
-
-	var resp LogoutResponse
-
-	err = decoder.Decode(&resp)
-	if err != nil {
-		return fmt.Errorf(""unable to flate decode: %s"", err)
+	doc := etree.NewDocument()
+	if err := doc.ReadFromBytes(rawResponseBuf); err != nil {
+		retErr.PrivateErr = err
+		return retErr
 	}
 
-	if err := sp.validateLogoutResponse(&resp); err != nil {
-		return err
+	if err := sp.validateSignature(doc.Root()); err != nil {
+		retErr.PrivateErr = err
+		return retErr
 	}
 
-	doc := etree.NewDocument()
-	if _, err := doc.ReadFrom(bytes.NewReader(gr)); err != nil {
+	var resp LogoutResponse
+	if err := unmarshalElement(doc.Root(), &resp); err != nil {
+		retErr.PrivateErr = err
+		return retErr
+	}
+	if err := sp.validateLogoutResponse(&resp); err != nil {
 		return err
 	}
-
-	responseEl := doc.Root()
-	return sp.validateSigned(responseEl)
+	return nil
 }
 
 // validateLogoutResponse validates the LogoutResponse fields. Returns a nil error if the LogoutResponse is valid.
"
GO-2022-0379,distribution,distribution,b59a6f827947f9e0e67df0cfb571046de4733586," func init() {
 	}
 
 	imageIndexFunc := func(b []byte) (distribution.Manifest, distribution.Descriptor, error) {
+		if err := validateIndex(b); err != nil {
+			return nil, distribution.Descriptor{}, err
+		}
 		m := new(DeserializedManifestList)
 		err := m.UnmarshalJSON(b)
 		if err != nil {
"
GO-2022-0379,distribution,distribution,b59a6f827947f9e0e67df0cfb571046de4733586," func (m DeserializedManifestList) Payload() (string, []byte, error) {
 
 	return mediaType, m.canonical, nil
 }
+
+// unknownDocument represents a manifest, manifest list, or index that has not
+// yet been validated
+type unknownDocument struct {
+	Config interface{} `json:""config,omitempty""`
+	Layers interface{} `json:""layers,omitempty""`
+}
+
+// validateIndex returns an error if the byte slice is invalid JSON or if it
+// contains fields that belong to a manifest
+func validateIndex(b []byte) error {
+	var doc unknownDocument
+	if err := json.Unmarshal(b, &doc); err != nil {
+		return err
+	}
+	if doc.Config != nil || doc.Layers != nil {
+		return errors.New(""index: expected index but found manifest"")
+	}
+	return nil
+}
"
GO-2022-0379,distribution,distribution,b59a6f827947f9e0e67df0cfb571046de4733586," var (
 
 func init() {
 	ocischemaFunc := func(b []byte) (distribution.Manifest, distribution.Descriptor, error) {
+		if err := validateManifest(b); err != nil {
+			return nil, distribution.Descriptor{}, err
+		}
 		m := new(DeserializedManifest)
 		err := m.UnmarshalJSON(b)
 		if err != nil {
"
GO-2022-0379,distribution,distribution,b59a6f827947f9e0e67df0cfb571046de4733586," func (m *DeserializedManifest) MarshalJSON() ([]byte, error) {
 func (m DeserializedManifest) Payload() (string, []byte, error) {
 	return v1.MediaTypeImageManifest, m.canonical, nil
 }
+
+// unknownDocument represents a manifest, manifest list, or index that has not
+// yet been validated
+type unknownDocument struct {
+	Manifests interface{} `json:""manifests,omitempty""`
+}
+
+// validateManifest returns an error if the byte slice is invalid JSON or if it
+// contains fields that belong to a index
+func validateManifest(b []byte) error {
+	var doc unknownDocument
+	if err := json.Unmarshal(b, &doc); err != nil {
+		return err
+	}
+	if doc.Manifests != nil {
+		return errors.New(""ocimanifest: expected manifest but found index"")
+	}
+	return nil
+}
"
GO-2021-0066,kubernetes,kubernetes,11793434dac97a49bfed0150b56ac63e5dc34634," func ReadDockercfgFile(searchPaths []string) (cfg DockerConfig, err error) {
 			continue
 		}
 		cfg, err := readDockerConfigFileFromBytes(contents)
-		if err == nil {
-			klog.V(4).Infof(""found .dockercfg at %s"", absDockerConfigFileLocation)
-			return cfg, nil
+		if err != nil {
+			klog.V(4).Infof(""couldn't get the config from %q contents: %v"", absDockerConfigFileLocation, err)
+			continue
 		}
+
+		klog.V(4).Infof(""found .dockercfg at %s"", absDockerConfigFileLocation)
+		return cfg, nil
+
 	}
 	return nil, fmt.Errorf(""couldn't find valid .dockercfg after checking in %v"", searchPaths)
 }
"
GO-2022-0945,square,go-jose,2c5656adca9909843c4ff50acf1d2cf8f32da7e6," func (ctx *genericEncrypter) EncryptWithAuthData(plaintext, aad []byte) (*JsonWe
 	return obj, nil
 }
 
-// Decrypt and validate the object and return the plaintext.
+// Decrypt and validate the object and return the plaintext. Note that this
+// function does not support multi-recipient, if you desire multi-recipient
+// decryption use DecryptMulti instead.
 func (obj JsonWebEncryption) Decrypt(decryptionKey interface{}) ([]byte, error) {
 	headers := obj.mergedHeaders(nil)
 
+	if len(obj.recipients) > 1 {
+		return nil, errors.New(""square/go-jose: too many recipients in payload; expecting only one"")
+	}
+
 	if len(headers.Crit) > 0 {
 		return nil, fmt.Errorf(""square/go-jose: unsupported crit header"")
 	}
"
GO-2022-0945,square,go-jose,789a4c4bd4c118f7564954f441b29c153ccd6a96," func (ctx *cbcAEAD) Open(dst, nonce, ciphertext, data []byte) ([]byte, error) {
 		return nil, err
 	}
 
-	ret, out := resize(dst, len(dst)+len(plaintext))
+	ret, out := resize(dst, uint64(len(dst))+uint64(len(plaintext)))
 	copy(out, plaintext)
 
 	return ret, nil
"
GO-2020-0009,square,go-jose,789a4c4bd4c118f7564954f441b29c153ccd6a96," func (ctx *cbcAEAD) Overhead() int {
 // Seal encrypts and authenticates the plaintext.
 func (ctx *cbcAEAD) Seal(dst, nonce, plaintext, data []byte) []byte {
 	// Output buffer -- must take care not to mangle plaintext input.
-	ciphertext := make([]byte, len(plaintext)+ctx.Overhead())[:len(plaintext)]
+	ciphertext := make([]byte, uint64(len(plaintext))+uint64(ctx.Overhead()))[:len(plaintext)]
 	copy(ciphertext, plaintext)
 	ciphertext = padBuffer(ciphertext, ctx.blockCipher.BlockSize())
 
"
GO-2020-0009,square,go-jose,789a4c4bd4c118f7564954f441b29c153ccd6a96," func (ctx *cbcAEAD) Seal(dst, nonce, plaintext, data []byte) []byte {
 	cbc.CryptBlocks(ciphertext, ciphertext)
 	authtag := ctx.computeAuthTag(data, nonce, ciphertext)
 
-	ret, out := resize(dst, len(dst)+len(ciphertext)+len(authtag))
+	ret, out := resize(dst, uint64(len(dst))+uint64(len(ciphertext))+uint64(len(authtag)))
 	copy(out, ciphertext)
 	copy(out[len(ciphertext):], authtag)
 
"
GO-2020-0009,square,go-jose,789a4c4bd4c118f7564954f441b29c153ccd6a96," func (ctx *cbcAEAD) Open(dst, nonce, ciphertext, data []byte) ([]byte, error) {
 		return nil, err
 	}
 
-	ret, out := resize(dst, len(dst)+len(plaintext))
+	ret, out := resize(dst, uint64(len(dst))+uint64(len(plaintext)))
 	copy(out, plaintext)
 
 	return ret, nil
"
GO-2020-0009,square,go-jose,789a4c4bd4c118f7564954f441b29c153ccd6a96," func (ctx *cbcAEAD) computeAuthTag(aad, nonce, ciphertext []byte) []byte {
 // resize ensures the the given slice has a capacity of at least n bytes.
 // If the capacity of the slice is less than n, a new slice is allocated
 // and the existing data will be copied.
-func resize(in []byte, n int) (head, tail []byte) {
-	if cap(in) >= n {
+func resize(in []byte, n uint64) (head, tail []byte) {
+	if uint64(cap(in)) >= n {
 		head = in[:n]
 	} else {
 		head = make([]byte, n)
"
GO-2020-0009,square,go-jose,789a4c4bd4c118f7564954f441b29c153ccd6a96," func resize(in []byte, n int) (head, tail []byte) {
 // Apply padding
 func padBuffer(buffer []byte, blockSize int) []byte {
 	missing := blockSize - (len(buffer) % blockSize)
-	ret, out := resize(buffer, len(buffer)+missing)
+	ret, out := resize(buffer, uint64(len(buffer))+uint64(missing))
 	padding := bytes.Repeat([]byte{byte(missing)}, missing)
 	copy(out, padding)
 	return ret
"
GO-2020-0009,square,go-jose,789a4c4bd4c118f7564954f441b29c153ccd6a96," type concatKDF struct {
 
 // NewConcatKDF builds a KDF reader based on the given inputs.
 func NewConcatKDF(hash crypto.Hash, z, algID, ptyUInfo, ptyVInfo, supPubInfo, supPrivInfo []byte) io.Reader {
-	buffer := make([]byte, len(algID)+len(ptyUInfo)+len(ptyVInfo)+len(supPubInfo)+len(supPrivInfo))
+	buffer := make([]byte, uint64(len(algID))+uint64(len(ptyUInfo))+uint64(len(ptyVInfo))+uint64(len(supPubInfo))+uint64(len(supPrivInfo)))
 	n := 0
 	n += copy(buffer, algID)
 	n += copy(buffer[n:], ptyUInfo)
"
GO-2020-0009,square,go-jose,789a4c4bd4c118f7564954f441b29c153ccd6a96," import (
 
 // DeriveECDHES derives a shared encryption key using ECDH/ConcatKDF as described in JWE/JWA.
 // It is an error to call this function with a private/public key that are not on the same
-// curve. Callers must ensure that the keys are valid before calling this function.
+// curve. Callers must ensure that the keys are valid before calling this function. Output
+// size may be at most 1<<16 bytes (64 KiB).
 func DeriveECDHES(alg string, apuData, apvData []byte, priv *ecdsa.PrivateKey, pub *ecdsa.PublicKey, size int) []byte {
+	if size > 1<<16 {
+		panic(""ECDH-ES output size too large, must be less than 1<<16"")
+	}
+
 	// algId, partyUInfo, partyVInfo inputs must be prefixed with the length
 	algID := lengthPrefixed([]byte(alg))
 	ptyUInfo := lengthPrefixed(apuData)
"
GO-2022-0572,beego,beego,d5df5e470d0a8ed291930ae802fd7e6b95226519," func (t *Tree) match(treePattern string, pattern string, wildcardValues []string
 	if runObject == nil && len(t.fixrouters) > 0 {
 		// Filter the .json .xml .html extension
 		for _, str := range allowSuffixExt {
-			if strings.HasSuffix(seg, str) {
+			if strings.HasSuffix(seg, str) && strings.HasSuffix(treePattern, seg){
 				for _, subTree := range t.fixrouters {
+					// strings.HasSuffix(treePattern, seg) avoid cases: /aaa.html/bbb could access /aaa/bbb
 					if subTree.prefix == seg[:len(seg)-len(str)] {
 						runObject = subTree.match(treePattern, pattern, wildcardValues, ctx)
 						if runObject != nil {
"
GO-2023-2119,Consensys,gnark,3421eaa7d544286abf3de8c46282b8d4da6d5da0," func (s *instance) batchOpening() error {
 		s.zeta,
 		s.hFunc,
 		s.pk.Kzg,
+		s.proof.ZShiftedOpening.ClaimedValue.Marshal(),
 	)
 
 	return err
"
GO-2022-0762,microcosm-cc,bluemonday,524f142fe46e945b7dcd291d7805c4b7dcf75bee," func (p *Policy) matchRegex(elementName string) (map[string]attrPolicy, bool) {
 	}
 	return aps, matched
 }
+
+
+// normaliseElementName takes a HTML element like <script> which is user input
+// and returns a lower case version of it that is immune to UTF-8 to ASCII
+// conversion tricks (like the use of upper case cyrillic i scrİpt which a
+// strings.ToLower would convert to script). Instead this func will preserve
+// all non-ASCII as their escaped equivalent, i.e. \u0130 which reveals the
+// characters when lower cased
+func normaliseElementName(str string) string {
+	// that useful QuoteToASCII put quote marks at the start and end
+	// so those are trimmed off
+	return strings.TrimSuffix(
+		strings.TrimPrefix(
+			strings.ToLower(
+				strconv.QuoteToASCII(str),
+			),
+			`""`),
+		`""`,
+	)
+}
\ No newline at end of file
"
GO-2022-0355,valyala,fasthttp,6b5bc7bb304975147b4af68df54ac214ed2554c1," func normalizePath(dst, src []byte) []byte {
 		b = b[:nn+1]
 	}
 
+	if filepath.Separator == '\\' {
+		// remove \.\ parts
+		b = dst
+		for {
+			n := bytes.Index(b, strBackSlashDotBackSlash)
+			if n < 0 {
+				break
+			}
+			nn := n + len(strSlashDotSlash) - 1
+			copy(b[n:], b[nn:])
+			b = b[:len(b)-nn+n]
+		}
+
+		// remove /foo/..\ parts
+		for {
+			n := bytes.Index(b, strSlashDotDotBackSlash)
+			if n < 0 {
+				break
+			}
+			nn := bytes.LastIndexByte(b[:n], '/')
+			if nn < 0 {
+				nn = 0
+			}
+			n += len(strSlashDotDotBackSlash) - 1
+			copy(b[nn:], b[n:])
+			b = b[:len(b)-n+nn]
+		}
+
+		// remove /foo\..\ parts
+		for {
+			n := bytes.Index(b, strBackSlashDotDotBackSlash)
+			if n < 0 {
+				break
+			}
+			nn := bytes.LastIndexByte(b[:n], '/')
+			if nn < 0 {
+				nn = 0
+			}
+			n += len(strBackSlashDotDotBackSlash) - 1
+			copy(b[nn:], b[n:])
+			b = b[:len(b)-n+nn]
+		}
+
+		// remove trailing \foo\..
+		n := bytes.LastIndex(b, strBackSlashDotDot)
+		if n >= 0 && n+len(strSlashDotDot) == len(b) {
+			nn := bytes.LastIndexByte(b[:n], '/')
+			if nn < 0 {
+				return append(dst[:0], strSlash...)
+			}
+			b = b[:nn+1]
+		}
+	}
+
 	return b
 }
 
"
GO-2022-0957,tidwall,match,c2f534168b739a7ec1821a33839fb2f029f26bbc," func deepMatch(str, pattern string) bool {
 }
 
 func deepMatchRune(str, pattern string) bool {
+	if pattern == ""*"" {
+		return true
+	}
+	for len(pattern) > 1 && pattern[0] == '*' && pattern[1] == '*' {
+		pattern = pattern[1:]
+	}
+
 	var sr, pr rune
 	var srsz, prsz int
 
"
GO-2022-0274,opencontainers,runc,f50369af4b571e358f20b139eea52d612eb55eed," func encodeIDMapping(idMap []configs.IDMap) ([]byte, error) {
 	return data.Bytes(), nil
 }
 
+// netlinkError is an error wrapper type for use by custom netlink message
+// types. Panics with errors are wrapped in netlinkError so that the recover
+// in bootstrapData can distinguish intentional panics.
+type netlinkError struct{ error }
+
 // bootstrapData encodes the necessary data in netlink binary format
 // as a io.Reader.
 // Consumer can write the data to a bootstrap program
 // such as one that uses nsenter package to bootstrap the container's
 // init process correctly, i.e. with correct namespaces, uid/gid
 // mapping etc.
-func (c *linuxContainer) bootstrapData(cloneFlags uintptr, nsMaps map[configs.NamespaceType]string, it initType) (io.Reader, error) {
+func (c *linuxContainer) bootstrapData(cloneFlags uintptr, nsMaps map[configs.NamespaceType]string, it initType) (_ io.Reader, Err error) {
 	// create the netlink message
 	r := nl.NewNetlinkRequest(int(InitMsg), 0)
 
+	// Our custom messages cannot bubble up an error using returns, instead
+	// they will panic with the specific error type, netlinkError. In that
+	// case, recover from the panic and return that as an error.
+	defer func() {
+		if r := recover(); r != nil {
+			if e, ok := r.(netlinkError); ok {
+				Err = e.error
+			} else {
+				panic(r)
+			}
+		}
+	}()
+
 	// write cloneFlags
 	r.AddData(&Int32msg{
 		Type:  CloneFlagsAttr,
"
GO-2022-0274,opencontainers,runc,dde509df4e28cec33b3c99c6cda3d4fd5beafc77," func (c *linuxContainer) bootstrapData(cloneFlags uintptr, nsMaps map[configs.Na
 		var mounts []byte
 		for _, m := range c.config.Mounts {
 			if m.IsBind() {
+				if strings.IndexByte(m.Source, 0) >= 0 {
+					return nil, fmt.Errorf(""mount source string contains null byte: %q"", m.Source)
+				}
 				mounts = append(mounts, []byte(m.Source)...)
 			}
 			mounts = append(mounts, byte(0))
"
GO-2022-0274,opencontainers,runc,dde509df4e28cec33b3c99c6cda3d4fd5beafc77," func createLibcontainerMount(cwd string, m specs.Mount) (*configs.Mount, error)
 			mnt.Source = filepath.Join(cwd, m.Source)
 		}
 	}
+
+	// None of the mount arguments can contain a null byte. Normally such
+	// strings would either cause some other failure or would just be truncated
+	// when we hit the null byte, but because we serialise these strings as
+	// netlink messages (which don't have special null-byte handling) we need
+	// to block this as early as possible.
+	if strings.IndexByte(mnt.Source, 0) >= 0 ||
+		strings.IndexByte(mnt.Destination, 0) >= 0 ||
+		strings.IndexByte(mnt.Device, 0) >= 0 {
+		return nil, errors.New(""mount field contains null byte"")
+	}
+
 	return mnt, nil
 }
 
"
GO-2022-1045,sylabs,sif,07fb86029a12e3210f6131e065570124605daeaa," func (d *digest) UnmarshalJSON(data []byte) error {
 		return fmt.Errorf(""%w: %v"", errDigestMalformed, err)
 	}
 
-	for h, n := range supportedAlgorithms {
+	for h, n := range supportedDigestAlgorithms {
 		if n == name {
 			digest, err := newDigest(h, v)
 			if err != nil {
"
GO-2023-1717,vitessio,vitess,adf10196760ad0b3991a7aa7a8580a544e6ddf88," func (ki *KeyspaceInfo) SetKeyspaceName(name string) {
 	ki.keyspace = name
 }
 
+var invalidKeyspaceNameChars = ""/""
+
+// ValidateKeyspaceName checks if the provided name is a valid name for a
+// keyspace.
+//
+// As of v16.0.1, ""all invalid characters"" is just the forward slash (""/"").
+func ValidateKeyspaceName(name string) error {
+	if strings.ContainsAny(name, invalidKeyspaceNameChars) {
+		return vterrors.Errorf(vtrpcpb.Code_INVALID_ARGUMENT, ""keyspace name %s contains invalid characters; may not contain any of the following: %+v"", name, strings.Split(invalidKeyspaceNameChars, """"))
+	}
+
+	return nil
+}
+
 // GetServedFrom returns a Keyspace_ServedFrom record if it exists.
 func (ki *KeyspaceInfo) GetServedFrom(tabletType topodatapb.TabletType) *topodatapb.Keyspace_ServedFrom {
 	for _, ksf := range ki.ServedFroms {
"
GO-2023-1574,containerd,containerd,133f6bb6cd827ce35a5fb279c1ead12b9d21460a," func setCapabilities(s *Spec) {
 	}
 }
 
+// ensureAdditionalGids ensures that the primary GID is also included in the additional GID list.
+func ensureAdditionalGids(s *Spec) {
+	setProcess(s)
+	for _, f := range s.Process.User.AdditionalGids {
+		if f == s.Process.User.GID {
+			return
+		}
+	}
+	s.Process.User.AdditionalGids = append([]uint32{s.Process.User.GID}, s.Process.User.AdditionalGids...)
+}
+
 // WithDefaultSpec returns a SpecOpts that will populate the spec with default
 // values.
 //
"
GO-2023-1574,containerd,containerd,133f6bb6cd827ce35a5fb279c1ead12b9d21460a," func WithAdditionalGIDs(userstr string) SpecOpts {
 	}
 }
 
+// WithAppendAdditionalGroups append additional groups within the container.
+// The passed in groups can be either a gid or a groupname.
+func WithAppendAdditionalGroups(groups ...string) SpecOpts {
+	return func(ctx context.Context, client Client, c *containers.Container, s *Spec) (err error) {
+		// For LCOW or on Darwin additional GID's are not supported
+		if s.Windows != nil || runtime.GOOS == ""darwin"" {
+			return nil
+		}
+		setProcess(s)
+		setAdditionalGids := func(root string) error {
+			defer ensureAdditionalGids(s)
+			gpath, err := fs.RootPath(root, ""/etc/group"")
+			if err != nil {
+				return err
+			}
+			ugroups, err := user.ParseGroupFile(gpath)
+			if err != nil {
+				return err
+			}
+			groupMap := make(map[string]user.Group)
+			for _, group := range ugroups {
+				groupMap[group.Name] = group
+			}
+			var gids []uint32
+			for _, group := range groups {
+				gid, err := strconv.ParseUint(group, 10, 32)
+				if err == nil {
+					gids = append(gids, uint32(gid))
+				} else {
+					g, ok := groupMap[group]
+					if !ok {
+						return fmt.Errorf(""unable to find group %s"", group)
+					}
+					gids = append(gids, uint32(g.Gid))
+				}
+			}
+			s.Process.User.AdditionalGids = append(s.Process.User.AdditionalGids, gids...)
+			return nil
+		}
+		if c.Snapshotter == """" && c.SnapshotKey == """" {
+			if !filepath.IsAbs(s.Root.Path) {
+				return errors.New(""rootfs absolute path is required"")
+			}
+			return setAdditionalGids(s.Root.Path)
+		}
+		if c.Snapshotter == """" {
+			return errors.New(""no snapshotter set for container"")
+		}
+		if c.SnapshotKey == """" {
+			return errors.New(""rootfs snapshot not created for container"")
+		}
+		snapshotter := client.SnapshotService(c.Snapshotter)
+		mounts, err := snapshotter.Mounts(ctx, c.SnapshotKey)
+		if err != nil {
+			return err
+		}
+
+		mounts = tryReadonlyMounts(mounts)
+		return mount.WithTempMount(ctx, mounts, setAdditionalGids)
+	}
+}
+
 // WithCapabilities sets Linux capabilities on the process
 func WithCapabilities(caps []string) SpecOpts {
 	return func(_ context.Context, _ Client, _ *containers.Container, s *Spec) error {
"
GO-2021-0103,holiman,uint256,6785da6e3eea403260a5760029e722aa4ff1716d," func (z *Int) AddOverflow(x, y *Int) bool {
 	return carry != 0
 }
 
-// AddMod sets z to the sum ( x+y ) mod m, and returns z
+// AddMod sets z to the sum ( x+y ) mod m, and returns z.
+// If m == 0, z is set to 0 (OBS: differs from the big.Int)
 func (z *Int) AddMod(x, y, m *Int) *Int {
+	if m.IsZero() {
+		return z.Clear()
+	}
 	if z == m { // z is an alias for m  // TODO: Understand why needed and add tests for all ""division"" methods.
 		m = m.Clone()
 	}
"
GO-2021-0103,holiman,uint256,6785da6e3eea403260a5760029e722aa4ff1716d," func (z *Int) SMod(x, y *Int) *Int {
 }
 
 // MulMod calculates the modulo-m multiplication of x and y and
-// returns z
+// returns z.
+// If m == 0, z is set to 0 (OBS: differs from the big.Int)
 func (z *Int) MulMod(x, y, m *Int) *Int {
+	if x.IsZero() || y.IsZero() || m.IsZero() {
+		return z.Clear()
+	}
 	p := umul(x, y)
 	var (
 		pl Int
"
GO-2020-0041,unknwon,cae,07971c00a1bfd9dc171c3ad0bfab5b67c2287e11," func Copy(dest, src string) error {
 	}
 	return os.Chmod(dest, si.Mode())
 }
+
+// Clean cleans up given path and returns a relative path that goes straight down.
+func Clean(p string) string {
+	return strings.Trim(path.Clean(""/""+p), ""/"")
+}
"
GO-2021-0228,unknwon,cae,07971c00a1bfd9dc171c3ad0bfab5b67c2287e11," func Copy(dest, src string) error {
 	}
 	return os.Chmod(dest, si.Mode())
 }
+
+// Clean cleans up given path and returns a relative path that goes straight down.
+func Clean(p string) string {
+	return strings.Trim(path.Clean(""/""+p), ""/"")
+}
"
GO-2023-1494,elgs,gosqljson,2740b331546cb88eb61771df4c07d389e9f0363a," func ExecDb(db *sql.DB, sqlStatement string, sqlParams ...interface{}) (int64, e
 	}
 	return 0, errors.New(fmt.Sprint(""Invalid SQL:"", sqlStatement))
 }
+
+func SqlSafe(s *string) {
+	*s = strings.Replace(*s, ""'"", ""''"", -1)
+	*s = strings.Replace(*s, ""--"", """", -1)
+}
"
GO-2021-0109,ory,fosite,03dd55813f5521985f7dd64277b7ba0cf1441319," func (f *Fosite) writeJsonError(rw http.ResponseWriter, err error) {
 	}
 
 	rw.WriteHeader(rfcerr.Code)
-	rw.Write(js)
+	// ignoring the error because the connection is broken when it happens
+	_, _ = rw.Write(js)
 }
"
GO-2021-0109,ory,fosite,03dd55813f5521985f7dd64277b7ba0cf1441319," func (f *Fosite) WriteAccessResponse(rw http.ResponseWriter, requester AccessReq
 	rw.Header().Set(""Content-Type"", ""application/json;charset=UTF-8"")
 
 	rw.WriteHeader(http.StatusOK)
-	rw.Write(js)
+	_, _ = rw.Write(js)
 }
"
GO-2021-0109,ory,fosite,03dd55813f5521985f7dd64277b7ba0cf1441319," func (f *Fosite) WriteAuthorizeError(rw http.ResponseWriter, ar AuthorizeRequest
 		}
 
 		rw.WriteHeader(rfcerr.Code)
-		rw.Write(js)
+		_, _ = rw.Write(js)
 		return
 	}
 
"
GO-2021-0109,ory,fosite,03dd55813f5521985f7dd64277b7ba0cf1441319," func (i *IDTokenHandleHelper) GetAccessTokenHash(ctx context.Context, requester
 
 	buffer := bytes.NewBufferString(token)
 	hash := sha256.New()
-	hash.Write(buffer.Bytes())
+	// sha256.digest.Write() always returns nil for err, the panic should never happen
+	_, err := hash.Write(buffer.Bytes())
+	if err != nil {
+		panic(err)
+	}
 	hashBuf := bytes.NewBuffer(hash.Sum([]byte{}))
 	len := hashBuf.Len()
 
"
GO-2021-0109,ory,fosite,03dd55813f5521985f7dd64277b7ba0cf1441319," func (f *Fosite) WriteRevocationResponse(rw http.ResponseWriter, err error) {
 		}
 
 		rw.WriteHeader(ErrInvalidRequest.Code)
-		rw.Write(js)
+		_, _ = rw.Write(js)
 	} else if errors.Is(err, ErrInvalidClient) {
 		rw.Header().Set(""Content-Type"", ""application/json;charset=UTF-8"")
 
"
GO-2021-0109,ory,fosite,03dd55813f5521985f7dd64277b7ba0cf1441319," func (f *Fosite) WriteRevocationResponse(rw http.ResponseWriter, err error) {
 		}
 
 		rw.WriteHeader(ErrInvalidClient.Code)
-		rw.Write(js)
+		_, _ = rw.Write(js)
 	} else {
 		// 200 OK
 		rw.WriteHeader(http.StatusOK)
"
GO-2021-0109,ory,fosite,03dd55813f5521985f7dd64277b7ba0cf1441319," func (c *HMACStrategy) Signature(token string) string {
 
 func generateHMAC(data []byte, key *[32]byte) []byte {
 	h := hmac.New(sha512.New512_256, key[:])
-	h.Write(data)
+	// sha512.digest.Write() always returns nil for err, the panic should never happen
+	_, err := h.Write(data)
+	if err != nil {
+		panic(err)
+	}
 	return h.Sum(nil)
 }
"
GO-2021-0112,mongodb,mongo-go-driver,2aca31d5986a9e1c65a92264736de9fdc3b9b4ca," func (vw *valueWriter) WriteObjectID(oid primitive.ObjectID) error {
 }
 
 func (vw *valueWriter) WriteRegex(pattern string, options string) error {
+	if !isValidCString(pattern) || !isValidCString(options) {
+		return errors.New(""BSON regex values cannot contain null bytes"")
+	}
 	if err := vw.writeElementHeader(bsontype.Regex, mode(0), ""WriteRegex""); err != nil {
 		return err
 	}
"
GO-2021-0112,mongodb,mongo-go-driver,2aca31d5986a9e1c65a92264736de9fdc3b9b4ca," func (vw *valueWriter) writeLength() error {
 	vw.buf[start+3] = byte(length >> 24)
 	return nil
 }
+
+func isValidCString(cs string) bool {
+	return !strings.ContainsRune(cs, '\x00')
+}
"
GO-2021-0112,mongodb,mongo-go-driver,2aca31d5986a9e1c65a92264736de9fdc3b9b4ca," func appendBinarySubtype2(dst []byte, subtype byte, b []byte) []byte {
 	dst = appendLength(dst, int32(len(b)))
 	return append(dst, b...)
 }
+
+func isValidCString(cs string) bool {
+	return !strings.ContainsRune(cs, '\x00')
+}
"
GO-2022-0706,elastic,apm-agent-go,dd3e8c593580e7b80a98b57e1cc6e017e56747b4," func (c *Context) build() *model.Context {
 	default:
 		return nil
 	}
+	if len(c.sanitizedFieldNames) != 0 {
+		if c.model.Request != nil {
+			sanitizeRequest(c.model.Request, c.sanitizedFieldNames)
+		}
+		if c.model.Response != nil {
+			sanitizeResponse(c.model.Response, c.sanitizedFieldNames)
+		}
+
+	}
 	return &c.model
 }
 
"
GO-2022-0706,elastic,apm-agent-go,dd3e8c593580e7b80a98b57e1cc6e017e56747b4," func (t *Tracer) newError() *Error {
 	if e.recording {
 		e.Timestamp = time.Now()
 		e.Context.captureHeaders = instrumentationConfig.captureHeaders
+		e.Context.sanitizedFieldNames = instrumentationConfig.sanitizedFieldNames
 		e.stackTraceLimit = instrumentationConfig.stackTraceLimit
 	}
 
"
GO-2022-0706,elastic,apm-agent-go,dd3e8c593580e7b80a98b57e1cc6e017e56747b4," func (t *Tracer) StartTransactionOptions(name, transactionType string, opts Tran
 	tx.stackTraceLimit = instrumentationConfig.stackTraceLimit
 	tx.Context.captureHeaders = instrumentationConfig.captureHeaders
 	tx.propagateLegacyHeader = instrumentationConfig.propagateLegacyHeader
-	tx.sanitizedFieldNames = instrumentationConfig.sanitizedFieldNames
+	tx.Context.sanitizedFieldNames = instrumentationConfig.sanitizedFieldNames
 	tx.breakdownMetricsEnabled = t.breakdownMetrics.enabled
 
 	var root bool
"
GO-2021-0051,labstack,echo,4422e3b66b9fd498ed1ae1d0242d660d0ed3faaa," func StaticWithConfig(config StaticConfig) echo.MiddlewareFunc {
 			if err != nil {
 				return
 			}
-			name := filepath.Join(config.Root, path.Clean(""/""+p)) // ""/""+ for security
+			name := filepath.Join(config.Root, filepath.Clean(""/""+p)) // ""/""+ for security
 
 			if config.IgnoreBase {
 				routePath := path.Base(strings.TrimRight(c.Path(), ""/*""))
"
GO-2023-1515,rancher,wrangler,341018c8fef3e12867c7cb2649bd2cecac75f287," func (g *Git) LsRemote(branch string, commit string) (string, error) {
 	}
 
 	output := &bytes.Buffer{}
-	if err := g.gitCmd(output, ""ls-remote"", g.URL, formatRefForBranch(branch)); err != nil {
+	if err := g.gitCmd(output, ""ls-remote"", ""--"", g.URL, formatRefForBranch(branch)); err != nil {
 		return """", err
 	}
 
"
GO-2022-0586,hashicorp,go-getter,38e97387488f5439616be60874979433a12edb48," func (c *Client) Get(ctx context.Context, req *Request) (*GetResult, error) {
 		return nil, err
 	}
 
+	// Pass along the configured Getter client in the context for usage with the X-Terraform-Get feature.
+	ctx = NewContextWithClient(ctx, c)
+
 	// Store this locally since there are cases we swap this
 	if req.GetMode == ModeInvalid {
 		req.GetMode = ModeAny
 	}
 
+	// Client setting takes precedence for all requests
+	if c.DisableSymlinks {
+		req.DisableSymlinks = true
+	}
+
 	// If there is a subdir component, then we download the root separately
 	// and then copy over the proper subdir.
 	req.Src, req.subDir = SourceDirSubdir(req.Src)
+
 	if req.subDir != """" {
+		// Check if the subdirectory is attempting to traverse upwards, outside of
+		// the cloned repository path.
+		req.subDir = filepath.Clean(req.subDir)
+		if containsDotDot(req.subDir) {
+			return nil, fmt.Errorf(""subdirectory component contain path traversal out of the repository"")
+		}
+
+		// Prevent absolute paths, remove a leading path separator from the subdirectory
+		if req.subDir[0] == os.PathSeparator {
+			req.subDir = req.subDir[1:]
+		}
+
 		td, tdcloser, err := safetemp.Dir("""", ""getter"")
 		if err != nil {
 			return nil, err
"
GO-2022-0586,hashicorp,go-getter,38e97387488f5439616be60874979433a12edb48," func (c *Client) get(ctx context.Context, req *Request, g Getter) (*GetResult, *
 	// Determine if we have an archive type
 	archiveV := q.Get(""archive"")
 	if archiveV != """" {
-		// Delete the paramter since it is a magic parameter we don't
+		// Delete the parameter since it is a magic parameter we don't
 		// want to pass on to the Getter
 		q.Del(""archive"")
 		req.u.RawQuery = q.Encode()
"
GO-2022-0586,hashicorp,go-getter,38e97387488f5439616be60874979433a12edb48," func (c *Client) get(ctx context.Context, req *Request, g Getter) (*GetResult, *
 				filename = v
 			}
 
+			if containsDotDot(filename) {
+				return nil, &getError{true, fmt.Errorf(""filename query parameter contain path traversal"")}
+			}
+
 			req.Dst = filepath.Join(req.Dst, filename)
 		}
 	}
"
GO-2022-0586,hashicorp,go-getter,38e97387488f5439616be60874979433a12edb48," func (c *Client) get(ctx context.Context, req *Request, g Getter) (*GetResult, *
 			return nil, &getError{true, err}
 		}
 
-		err = copyDir(ctx, req.realDst, subDir, false, req.umask())
+		err = copyDir(ctx, req.realDst, subDir, false, req.DisableSymlinks, req.umask())
 		if err != nil {
 			return nil, &getError{false, err}
 		}
"
GO-2022-0586,hashicorp,go-getter,38e97387488f5439616be60874979433a12edb48," import (
 func main() {
 	modeRaw := flag.String(""mode"", ""any"", ""get mode (any, file, dir)"")
 	progress := flag.Bool(""progress"", false, ""display terminal progress"")
+	noSymlinks := flag.Bool(""disable-symlinks"", false, ""prevent copying or writing files through symlinks"")
 	flag.Parse()
 	args := flag.Args()
 	if len(args) < 2 {
"
GO-2022-0586,hashicorp,go-getter,38e97387488f5439616be60874979433a12edb48," func main() {
 	if *progress {
 		req.ProgressListener = defaultProgressBar
 	}
-
 	wg := sync.WaitGroup{}
 	wg.Add(1)
 
 	client := getter.DefaultClient
 
+	// Disable symlinks for all client requests
+	if *noSymlinks {
+		client.DisableSymlinks = true
+	}
+
 	getters := getter.Getters
 	getters = append(getters, new(gcs.Getter))
 	getters = append(getters, new(s3.Getter))
"
GO-2022-0586,hashicorp,go-getter,38e97387488f5439616be60874979433a12edb48," import (
 // should already exist.
 //
 // If ignoreDot is set to true, then dot-prefixed files/folders are ignored.
-func copyDir(ctx context.Context, dst string, src string, ignoreDot bool, umask os.FileMode) error {
+func copyDir(ctx context.Context, dst string, src string, ignoreDot bool, disableSymlinks bool, umask os.FileMode) error {
 	src, err := filepath.EvalSymlinks(src)
 	if err != nil {
 		return err
"
GO-2022-0586,hashicorp,go-getter,38e97387488f5439616be60874979433a12edb48," func copyDir(ctx context.Context, dst string, src string, ignoreDot bool, umask
 			}
 		}
 
+		if disableSymlinks {
+			if info.Mode()&os.ModeSymlink == os.ModeSymlink {
+				return ErrSymlinkCopy
+			}
+		}
+
 		// The ""path"" has the src prefixed to it. We need to join our
 		// destination with the path without the src on it.
 		dstPath := filepath.Join(dst, path[len(src):])
"
GO-2022-0586,hashicorp,go-getter,38e97387488f5439616be60874979433a12edb48," func copyDir(ctx context.Context, dst string, src string, ignoreDot bool, umask
 		}
 
 		// If we have a file, copy the contents.
-		_, err = copyFile(ctx, dstPath, path, info.Mode(), umask)
+		_, err = copyFile(ctx, dstPath, path, disableSymlinks, info.Mode(), umask)
 		return err
 	}
 
"
GO-2022-0586,hashicorp,go-getter,38e97387488f5439616be60874979433a12edb48," func init() {
 	// The order of the Getters in the list may affect the result
 	// depending if the Request.Src is detected as valid by multiple getters
 	Getters = []Getter{
-		&GitGetter{[]Detector{
-			new(GitHubDetector),
-			new(GitDetector),
-			new(BitBucketDetector),
-			new(GitLabDetector),
-		},
+		&GitGetter{
+			Detectors: []Detector{
+				new(GitHubDetector),
+				new(GitDetector),
+				new(BitBucketDetector),
+				new(GitLabDetector),
+			},
 		},
 		new(HgGetter),
 		new(SmbClientGetter),
"
GO-2022-0586,hashicorp,go-getter,38e97387488f5439616be60874979433a12edb48," func copyReader(dst string, src io.Reader, fmode, umask os.FileMode) error {
 }
 
 // copyFile copies a file in chunks from src path to dst path, using umask to create the dst file
-func copyFile(ctx context.Context, dst, src string, fmode, umask os.FileMode) (int64, error) {
+func copyFile(ctx context.Context, dst, src string, disableSymlinks bool, fmode, umask os.FileMode) (int64, error) {
+
+	if disableSymlinks {
+		fileInfo, err := os.Lstat(src)
+		if err != nil {
+			return 0, fmt.Errorf(""failed to check copy file source for symlinks: %w"", err)
+		}
+
+		if fileInfo.Mode()&os.ModeSymlink == os.ModeSymlink {
+			return 0, ErrSymlinkCopy
+		}
+	}
+
 	srcF, err := os.Open(src)
 	if err != nil {
 		return 0, err
"
GO-2022-0586,hashicorp,go-getter,38e97387488f5439616be60874979433a12edb48," func (g *GitGetter) Get(ctx context.Context, req *Request) error {
 		req.u.RawQuery = q.Encode()
 	}
 
+	if g.Timeout > 0 {
+		var cancel context.CancelFunc
+		ctx, cancel = context.WithTimeout(ctx, g.Timeout)
+		defer cancel()
+	}
+
 	var sshKeyFile string
 	if sshKey != """" {
 		// Check that the git version is sufficiently new.
-		if err := checkGitVersion(""2.3""); err != nil {
+		if err := checkGitVersion(ctx, ""2.3""); err != nil {
 			return fmt.Errorf(""Error using ssh key: %v"", err)
 		}
 
"
GO-2022-0586,hashicorp,go-getter,38e97387488f5439616be60874979433a12edb48," func (g *GitGetter) Get(ctx context.Context, req *Request) error {
 
 	// Next: check out the proper tag/branch if it is specified, and checkout
 	if ref != """" {
-		if err := g.checkout(req.Dst, ref); err != nil {
+		if err := g.checkout(ctx, req.Dst, ref); err != nil {
 			return err
 		}
 	}
"
GO-2022-0586,hashicorp,go-getter,38e97387488f5439616be60874979433a12edb48," func (g *GitGetter) GetFile(ctx context.Context, req *Request) error {
 	return fg.GetFile(ctx, req)
 }
 
-func (g *GitGetter) checkout(dst string, ref string) error {
-	cmd := exec.Command(""git"", ""checkout"", ref)
+func (g *GitGetter) checkout(ctx context.Context, dst string, ref string) error {
+	cmd := exec.CommandContext(ctx, ""git"", ""checkout"", ref)
 	cmd.Dir = dst
 	return getRunCommand(cmd)
 }
"
GO-2022-0586,hashicorp,go-getter,38e97387488f5439616be60874979433a12edb48," func (g *GitGetter) update(ctx context.Context, dst, sshKeyFile, ref string, dep
 		// Not a branch, switch to default branch. This will also catch
 		// non-existent branches, in which case we want to switch to default
 		// and then checkout the proper branch later.
-		ref = findDefaultBranch(dst)
+		ref = findDefaultBranch(ctx, dst)
 	}
 
 	// We have to be on a branch to pull
-	if err := g.checkout(dst, ref); err != nil {
+	if err := g.checkout(ctx, dst, ref); err != nil {
 		return err
 	}
 
 	if depth > 0 {
-		cmd = exec.Command(""git"", ""pull"", ""--depth"", strconv.Itoa(depth), ""--ff-only"")
+		cmd = exec.CommandContext(ctx, ""git"", ""pull"", ""--depth"", strconv.Itoa(depth), ""--ff-only"")
 	} else {
-		cmd = exec.Command(""git"", ""pull"", ""--ff-only"")
+		cmd = exec.CommandContext(ctx, ""git"", ""pull"", ""--ff-only"")
 	}
 
 	cmd.Dir = dst
"
GO-2022-0586,hashicorp,go-getter,38e97387488f5439616be60874979433a12edb48," func (g *GitGetter) fetchSubmodules(ctx context.Context, dst, sshKeyFile string,
 // findDefaultBranch checks the repo's origin remote for its default branch
 // (generally ""master""). ""master"" is returned if an origin default branch
 // can't be determined.
-func findDefaultBranch(dst string) string {
+func findDefaultBranch(ctx context.Context, dst string) string {
 	var stdoutbuf bytes.Buffer
-	cmd := exec.Command(""git"", ""branch"", ""-r"", ""--points-at"", ""refs/remotes/origin/HEAD"")
+	cmd := exec.CommandContext(ctx, ""git"", ""branch"", ""-r"", ""--points-at"", ""refs/remotes/origin/HEAD"")
 	cmd.Dir = dst
 	cmd.Stdout = &stdoutbuf
 	err := cmd.Run()
"
GO-2022-0586,hashicorp,go-getter,38e97387488f5439616be60874979433a12edb48," func setupGitEnv(cmd *exec.Cmd, sshKeyFile string) {
 // checkGitVersion is used to check the version of git installed on the system
 // against a known minimum version. Returns an error if the installed version
 // is older than the given minimum.
-func checkGitVersion(min string) error {
+func checkGitVersion(ctx context.Context, min string) error {
 	want, err := version.NewVersion(min)
 	if err != nil {
 		return err
 	}
 
-	out, err := exec.Command(""git"", ""version"").Output()
+	out, err := exec.CommandContext(ctx, ""git"", ""version"").Output()
 	if err != nil {
 		return err
 	}
"
GO-2022-0586,hashicorp,go-getter,38e97387488f5439616be60874979433a12edb48," func (g *HgGetter) Get(ctx context.Context, req *Request) error {
 	if err != nil && !os.IsNotExist(err) {
 		return err
 	}
+
+	if g.Timeout > 0 {
+		var cancel context.CancelFunc
+		ctx, cancel = context.WithTimeout(ctx, g.Timeout)
+		defer cancel()
+	}
+
 	if err != nil {
-		if err := g.clone(req.Dst, newURL); err != nil {
+		if err := g.clone(ctx, req.Dst, newURL); err != nil {
 			return err
 		}
 	}
 
-	if err := g.pull(req.Dst, newURL); err != nil {
+	if err := g.pull(ctx, req.Dst, newURL); err != nil {
 		return err
 	}
 
"
GO-2022-0586,hashicorp,go-getter,38e97387488f5439616be60874979433a12edb48," func (g *HgGetter) pull(dst string, u *url.URL) error {
 func (g *HgGetter) update(ctx context.Context, dst string, u *url.URL, rev string) error {
 	args := []string{""update""}
 	if rev != """" {
-		args = append(args, rev)
+		args = append(args, ""--"", rev)
 	}
 
 	cmd := exec.CommandContext(ctx, ""hg"", args...)
"
GO-2022-0586,hashicorp,go-getter,38e97387488f5439616be60874979433a12edb48," func (g *HttpGetter) Get(ctx context.Context, req *Request) error {
 		}
 	}
 
+	// If the HTTP client is nil, check if there is one available in the context,
+	// otherwise create one using cleanhttp's default transport.
 	if g.Client == nil {
-		g.Client = httpClient
+		if client := httpClientFromContext(ctx); client != nil {
+			g.Client = client
+		} else {
+			g.Client = httpClient
+		}
 	}
 
+	// Pass along the configured HTTP client in the context for usage with the X-Terraform-Get feature.
+	ctx = context.WithValue(ctx, httpClientValue, g.Client)
+
 	// Add terraform-get to the parameter.
 	q := req.u.Query()
 	q.Add(""terraform-get"", ""1"")
 	req.u.RawQuery = q.Encode()
 
+	readCtx := ctx
+	if g.ReadTimeout > 0 {
+		var cancel context.CancelFunc
+		readCtx, cancel = context.WithTimeout(ctx, g.ReadTimeout)
+		defer cancel()
+	}
+
 	// Get the URL
-	httpReq, err := http.NewRequestWithContext(ctx, ""GET"", req.u.String(), nil)
+	httpReq, err := http.NewRequestWithContext(readCtx, ""GET"", req.u.String(), nil)
 	if err != nil {
 		return err
 	}
"
GO-2022-0586,hashicorp,go-getter,38e97387488f5439616be60874979433a12edb48," func (g *HttpGetter) Get(ctx context.Context, req *Request) error {
 	if err != nil {
 		return err
 	}
-
 	defer resp.Body.Close()
+
+	body := resp.Body
+	if maxBytes := httpMaxBytesFromContext(ctx); maxBytes > 0 {
+		body = newLimitedWrappedReaderCloser(body, maxBytes)
+	}
+
 	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
 		return fmt.Errorf(""bad response code: %d"", resp.StatusCode)
 	}
 
+	if disabled := xTerraformGetDisabled(ctx); disabled {
+		return nil
+	}
+
+	// Get client with configured Getters from the context
+	// If the client is nil, we know we're using the HttpGetter directly. In this case,
+	// we don't know exactly which protocols are configured, but we can make a good guess.
+	//
+	// This prevents all default getters from being allowed when only using the
+	// HttpGetter directly. To enable protocol switching, a client ""wrapper"" must
+	// be used.
+	var getterClient *Client
+	if v := ClientFromContext(ctx); v != nil {
+		getterClient = v
+	} else {
+		getterClient = &Client{
+			Getters: []Getter{g},
+		}
+	}
+
 	// Extract the source URL
 	var source string
 	if v := resp.Header.Get(""X-Terraform-Get""); v != """" {
 		source = v
 	} else {
-		source, err = g.parseMeta(resp.Body)
+		source, err = g.parseMeta(readCtx, body)
 		if err != nil {
 			return err
 		}
 	}
+
 	if source == """" {
 		return fmt.Errorf(""no source URL was returned"")
 	}
 
-	// If there is a subdir component, then we download the root separately
-	// into a temporary directory, then copy over the proper subdir.
-	source, subDir := SourceDirSubdir(source)
-	req = &Request{
-		GetMode: ModeDir,
-		Src:     source,
-		Dst:     req.Dst,
-	}
-	if subDir == """" {
-		_, err = DefaultClient.Get(ctx, req)
-		return err
-	}
-	// We have a subdir, time to jump some hoops
-	return g.getSubdir(ctx, req, source, subDir)
+	return g.getXTerraformSource(ctx, req, source, getterClient)
 }
 
 // GetFile fetches the file from src and stores it at dst.
"
GO-2022-0586,hashicorp,go-getter,38e97387488f5439616be60874979433a12edb48," func (g *HttpGetter) Get(ctx context.Context, req *Request) error {
 // falsely identified as being replaced, or corrupted with extra bytes
 // appended.
 func (g *HttpGetter) GetFile(ctx context.Context, req *Request) error {
+	// Optionally enforce a maxiumum HTTP response body size.
+	if g.MaxBytes > 0 {
+		ctx = context.WithValue(ctx, httpMaxBytesValue, g.MaxBytes)
+	}
+
 	if g.Netrc {
 		// Add auth from netrc if we can
 		if err := addAuthFromNetrc(req.u); err != nil {
"
GO-2022-0586,hashicorp,go-getter,38e97387488f5439616be60874979433a12edb48," func (g *HttpGetter) GetFile(ctx context.Context, req *Request) error {
 	}
 
 	var currentFileSize int64
+	var httpReq *http.Request
+
+	if g.DoNotCheckHeadFirst == false {
+		headCtx := ctx
 
-	// We first make a HEAD request so we can check
-	// if the server supports range queries. If the server/URL doesn't
-	// support HEAD requests, we just fall back to GET.
-	httpReq, err := http.NewRequestWithContext(ctx, ""HEAD"", req.u.String(), nil)
+		if g.HeadFirstTimeout > 0 {
+			var cancel context.CancelFunc
+
+			headCtx, cancel = context.WithTimeout(ctx, g.HeadFirstTimeout)
+			defer cancel()
+		}
+
+		// We first make a HEAD request so we can check
+		// if the server supports range queries. If the server/URL doesn't
+		// support HEAD requests, we just fall back to GET.
+		httpReq, err = http.NewRequestWithContext(headCtx, ""HEAD"", req.u.String(), nil)
+		if err != nil {
+			return err
+		}
+		if g.Header != nil {
+			httpReq.Header = g.Header.Clone()
+		}
+		headResp, err := g.Client.Do(httpReq)
+		if err == nil {
+			headResp.Body.Close()
+			if headResp.StatusCode == 200 {
+				// If the HEAD request succeeded, then attempt to set the range
+				// query if we can.
+				if headResp.Header.Get(""Accept-Ranges"") == ""bytes"" && headResp.ContentLength >= 0 {
+					if fi, err := f.Stat(); err == nil {
+						if _, err = f.Seek(0, io.SeekEnd); err == nil {
+							currentFileSize = fi.Size()
+							httpReq.Header.Set(""Range"", fmt.Sprintf(""bytes=%d-"", currentFileSize))
+							if currentFileSize >= headResp.ContentLength {
+								// file already present
+								return nil
+							}
+						}
+					}
+				}
+			}
+		}
+	}
+
+	readCtx := ctx
+	if g.ReadTimeout > 0 {
+		var cancel context.CancelFunc
+		readCtx, cancel = context.WithTimeout(ctx, g.ReadTimeout)
+		defer cancel()
+	}
+
+	httpReq, err = http.NewRequestWithContext(readCtx, ""GET"", req.u.String(), nil)
 	if err != nil {
 		return err
 	}
 	if g.Header != nil {
 		httpReq.Header = g.Header.Clone()
 	}
-	headResp, err := g.Client.Do(httpReq)
-	if err == nil {
-		headResp.Body.Close()
-		if headResp.StatusCode == 200 {
-			// If the HEAD request succeeded, then attempt to set the range
-			// query if we can.
-			if headResp.Header.Get(""Accept-Ranges"") == ""bytes"" && headResp.ContentLength >= 0 {
-				if fi, err := f.Stat(); err == nil {
-					if _, err = f.Seek(0, io.SeekEnd); err == nil {
-						currentFileSize = fi.Size()
-						httpReq.Header.Set(""Range"", fmt.Sprintf(""bytes=%d-"", currentFileSize))
-						if currentFileSize >= headResp.ContentLength {
-							// file already present
-							return nil
-						}
-					}
-				}
-			}
-		}
+	if currentFileSize > 0 {
+		httpReq.Header.Set(""Range"", fmt.Sprintf(""bytes=%d-"", currentFileSize))
 	}
-	httpReq.Method = ""GET""
 
 	resp, err := g.Client.Do(httpReq)
 	if err != nil {
"
GO-2022-0586,hashicorp,go-getter,38e97387488f5439616be60874979433a12edb48," func (g *HttpGetter) GetFile(ctx context.Context, req *Request) error {
 
 	body := resp.Body
 
+	if maxBytes := httpMaxBytesFromContext(readCtx); maxBytes > 0 {
+		body = newLimitedWrappedReaderCloser(body, maxBytes)
+	}
+
 	if req.ProgressListener != nil {
 		// track download
 		fn := filepath.Base(req.u.EscapedPath())
"
GO-2022-0586,hashicorp,go-getter,38e97387488f5439616be60874979433a12edb48," func (g *HttpGetter) getSubdir(ctx context.Context, req *Request, source, subDir
 	}
 	defer tdcloser.Close()
 
-	// Download that into the given directory
-	if _, err := Get(ctx, td, source); err != nil {
+	tdReq := &Request{
+		Src:             source,
+		Dst:             td,
+		GetMode:         ModeDir,
+		DisableSymlinks: req.DisableSymlinks,
+	}
+	if _, err := client.Get(ctx, tdReq); err != nil {
 		return err
 	}
 
"
GO-2022-0586,hashicorp,go-getter,38e97387488f5439616be60874979433a12edb48," func (g *Getter) getObject(ctx context.Context, client *s3.S3, req *getter.Reque
 		s3req.VersionId = aws.String(version)
 	}
 
-	resp, err := client.GetObject(s3req)
+	resp, err := client.GetObjectWithContext(ctx, s3req)
 	if err != nil {
 		return err
 	}
"
GO-2022-0586,hashicorp,go-getter,38e97387488f5439616be60874979433a12edb48," func SourceDirSubdir(src string) (string, string) {
 //
 // The returned path is the full absolute path.
 func SubdirGlob(dst, subDir string) (string, error) {
-	matches, err := filepath.Glob(filepath.Join(dst, subDir))
+	pattern := filepath.Join(dst, subDir)
+
+	matches, err := filepath.Glob(pattern)
 	if err != nil {
 		return """", err
 	}
"
GO-2022-0586,hashicorp,go-getter,a2ebce998f8d4105bd4b78d6c99a12803ad97a45," func (c *Client) Get() error {
 	dst := c.Dst
 	src, subDir := SourceDirSubdir(src)
 	if subDir != """" {
+		// Check if the subdirectory is attempting to traverse updwards, outside of
+		// the cloned repository path.
+		subDir := filepath.Clean(subDir)
+		if containsDotDot(subDir) {
+			return fmt.Errorf(""subdirectory component contain path traversal out of the repository"")
+		}
+		// Prevent absolute paths, remove a leading path separator from the subdirectory
+		if subDir[0] == os.PathSeparator {
+			subDir = subDir[1:]
+		}
+
 		td, tdcloser, err := safetemp.Dir("""", ""getter"")
 		if err != nil {
 			return err
"
GO-2022-0586,hashicorp,go-getter,a2ebce998f8d4105bd4b78d6c99a12803ad97a45," func (c *Client) Get() error {
 				filename = v
 			}
 
+			if containsDotDot(filename) {
+				return fmt.Errorf(""filename query parameter contain path traversal"")
+			}
+
 			dst = filepath.Join(dst, filename)
 		}
 	}
"
GO-2022-0586,hashicorp,go-getter,a2ebce998f8d4105bd4b78d6c99a12803ad97a45," func (c *Client) Get() error {
 			return err
 		}
 
-		return copyDir(c.Ctx, realDst, subDir, false, c.umask())
+		return copyDir(c.Ctx, realDst, subDir, false, c.DisableSymlinks, c.umask())
 	}
 
 	return nil
"
GO-2022-0586,hashicorp,go-getter,a2ebce998f8d4105bd4b78d6c99a12803ad97a45," func mode(mode, umask os.FileMode) os.FileMode {
 // should already exist.
 //
 // If ignoreDot is set to true, then dot-prefixed files/folders are ignored.
-func copyDir(ctx context.Context, dst string, src string, ignoreDot bool, umask os.FileMode) error {
-	src, err := filepath.EvalSymlinks(src)
+func copyDir(ctx context.Context, dst string, src string, ignoreDot bool, disableSymlinks bool, umask os.FileMode) error {
+	// We can safely evaluate the symlinks here, even if disabled, because they
+	// will be checked before actual use in walkFn and copyFile
+	var err error
+	src, err = filepath.EvalSymlinks(src)
 	if err != nil {
 		return err
 	}
"
GO-2022-0586,hashicorp,go-getter,a2ebce998f8d4105bd4b78d6c99a12803ad97a45," func copyDir(ctx context.Context, dst string, src string, ignoreDot bool, umask
 		if err != nil {
 			return err
 		}
+
+		if disableSymlinks {
+			fileInfo, err := os.Lstat(path)
+			if err != nil {
+				return fmt.Errorf(""failed to check copy file source for symlinks: %w"", err)
+			}
+			if fileInfo.Mode()&os.ModeSymlink == os.ModeSymlink {
+				return ErrSymlinkCopy
+			}
+			// if info.Mode()&os.ModeSymlink == os.ModeSymlink {
+			// 	return ErrSymlinkCopy
+			// }
+		}
+
 		if path == src {
 			return nil
 		}
"
GO-2022-0586,hashicorp,go-getter,a2ebce998f8d4105bd4b78d6c99a12803ad97a45," func copyDir(ctx context.Context, dst string, src string, ignoreDot bool, umask
 		}
 
 		// If we have a file, copy the contents.
-		_, err = copyFile(ctx, dstPath, path, info.Mode(), umask)
+		_, err = copyFile(ctx, dstPath, path, disableSymlinks, info.Mode(), umask)
 		return err
 	}
 
"
GO-2022-0586,hashicorp,go-getter,a2ebce998f8d4105bd4b78d6c99a12803ad97a45," func copyReader(dst string, src io.Reader, fmode, umask os.FileMode) error {
 }
 
 // copyFile copies a file in chunks from src path to dst path, using umask to create the dst file
-func copyFile(ctx context.Context, dst, src string, fmode, umask os.FileMode) (int64, error) {
+func copyFile(ctx context.Context, dst, src string, disableSymlinks bool, fmode, umask os.FileMode) (int64, error) {
+	if disableSymlinks {
+		fileInfo, err := os.Lstat(src)
+		if err != nil {
+			return 0, fmt.Errorf(""failed to check copy file source for symlinks: %w"", err)
+		}
+		if fileInfo.Mode()&os.ModeSymlink == os.ModeSymlink {
+			return 0, ErrSymlinkCopy
+		}
+	}
+
 	srcF, err := os.Open(src)
 	if err != nil {
 		return 0, err
"
GO-2022-0586,hashicorp,go-getter,a2ebce998f8d4105bd4b78d6c99a12803ad97a45," func (g *FileGetter) GetFile(dst string, u *url.URL) error {
 		return os.Symlink(path, dst)
 	}
 
+	var disableSymlinks bool
+
+	if g.client != nil && g.client.DisableSymlinks {
+		disableSymlinks = true
+	}
+
 	// Copy
-	_, err = copyFile(ctx, dst, path, fi.Mode(), g.client.umask())
+	_, err = copyFile(ctx, dst, path, disableSymlinks, fi.Mode(), g.client.umask())
 	return err
 }
"
GO-2022-0586,hashicorp,go-getter,a2ebce998f8d4105bd4b78d6c99a12803ad97a45," func (g *FileGetter) GetFile(dst string, u *url.URL) error {
 		}
 	}
 
+	var disableSymlinks bool
+
+	if g.client != nil && g.client.DisableSymlinks {
+		disableSymlinks = true
+	}
+
 	// Copy
-	_, err = copyFile(ctx, dst, path, 0666, g.client.umask())
+	_, err = copyFile(ctx, dst, path, disableSymlinks, 0666, g.client.umask())
 	return err
 }
 
"
GO-2022-0586,hashicorp,go-getter,a2ebce998f8d4105bd4b78d6c99a12803ad97a45," import (
 // a GCS bucket.
 type GCSGetter struct {
 	getter
+
+	// Timeout sets a deadline which all GCS operations should
+	// complete within. Zero value means no timeout.
+	Timeout time.Duration
 }
 
 func (g *GCSGetter) ClientMode(u *url.URL) (ClientMode, error) {
 	ctx := g.Context()
 
+	if g.Timeout > 0 {
+		var cancel context.CancelFunc
+		ctx, cancel = context.WithTimeout(ctx, g.Timeout)
+		defer cancel()
+	}
+
 	// Parse URL
 	bucket, object, _, err := g.parseURL(u)
 	if err != nil {
"
GO-2022-0586,hashicorp,go-getter,a2ebce998f8d4105bd4b78d6c99a12803ad97a45," func (g *GCSGetter) ClientMode(u *url.URL) (ClientMode, error) {
 func (g *GCSGetter) Get(dst string, u *url.URL) error {
 	ctx := g.Context()
 
+	if g.Timeout > 0 {
+		var cancel context.CancelFunc
+		ctx, cancel = context.WithTimeout(ctx, g.Timeout)
+		defer cancel()
+	}
+
 	// Parse URL
 	bucket, object, _, err := g.parseURL(u)
 	if err != nil {
"
GO-2022-0586,hashicorp,go-getter,a2ebce998f8d4105bd4b78d6c99a12803ad97a45," func (g *GCSGetter) Get(dst string, u *url.URL) error {
 func (g *GCSGetter) GetFile(dst string, u *url.URL) error {
 	ctx := g.Context()
 
+	if g.Timeout > 0 {
+		var cancel context.CancelFunc
+		ctx, cancel = context.WithTimeout(ctx, g.Timeout)
+		defer cancel()
+	}
+
 	// Parse URL
 	bucket, object, fragment, err := g.parseURL(u)
 	if err != nil {
"
GO-2022-0586,hashicorp,go-getter,a2ebce998f8d4105bd4b78d6c99a12803ad97a45," func (g *GitGetter) ClientMode(_ *url.URL) (ClientMode, error) {
 
 func (g *GitGetter) Get(dst string, u *url.URL) error {
 	ctx := g.Context()
+
+	if g.Timeout > 0 {
+		var cancel context.CancelFunc
+		ctx, cancel = context.WithTimeout(ctx, g.Timeout)
+		defer cancel()
+	}
+
 	if _, err := exec.LookPath(""git""); err != nil {
 		return fmt.Errorf(""git must be available and on the PATH"")
 	}
"
GO-2022-0586,hashicorp,go-getter,a2ebce998f8d4105bd4b78d6c99a12803ad97a45," func (g *GitGetter) Get(dst string, u *url.URL) error {
 	var sshKeyFile string
 	if sshKey != """" {
 		// Check that the git version is sufficiently new.
-		if err := checkGitVersion(""2.3""); err != nil {
+		if err := checkGitVersion(ctx, ""2.3""); err != nil {
 			return fmt.Errorf(""Error using ssh key: %v"", err)
 		}
 
"
GO-2022-0586,hashicorp,go-getter,a2ebce998f8d4105bd4b78d6c99a12803ad97a45," func (g *GitGetter) Get(dst string, u *url.URL) error {
 
 	// Next: check out the proper tag/branch if it is specified, and checkout
 	if ref != """" {
-		if err := g.checkout(dst, ref); err != nil {
+		if err := g.checkout(ctx, dst, ref); err != nil {
 			return err
 		}
 	}
"
GO-2022-0586,hashicorp,go-getter,a2ebce998f8d4105bd4b78d6c99a12803ad97a45," func (g *GitGetter) GetFile(dst string, u *url.URL) error {
 	return fg.GetFile(dst, u)
 }
 
-func (g *GitGetter) checkout(dst string, ref string) error {
-	cmd := exec.Command(""git"", ""checkout"", ref)
+func (g *GitGetter) checkout(ctx context.Context, dst string, ref string) error {
+	cmd := exec.CommandContext(ctx, ""git"", ""checkout"", ref)
 	cmd.Dir = dst
 	return getRunCommand(cmd)
 }
"
GO-2022-0586,hashicorp,go-getter,a2ebce998f8d4105bd4b78d6c99a12803ad97a45," func (g *GitGetter) clone(ctx context.Context, dst, sshKeyFile string, u *url.UR
 
 	originalRef := ref // we handle an unspecified ref differently than explicitly selecting the default branch below
 	if ref == """" {
-		ref = findRemoteDefaultBranch(u)
+		ref = findRemoteDefaultBranch(ctx, u)
 	}
 	if depth > 0 {
 		args = append(args, ""--depth"", strconv.Itoa(depth))
"
GO-2022-0586,hashicorp,go-getter,a2ebce998f8d4105bd4b78d6c99a12803ad97a45," func (g *GitGetter) clone(ctx context.Context, dst, sshKeyFile string, u *url.UR
 		// If we didn't add --depth and --branch above then we will now be
 		// on the remote repository's default branch, rather than the selected
 		// ref, so we'll need to fix that before we return.
-		return g.checkout(dst, originalRef)
+		return g.checkout(ctx, dst, originalRef)
 	}
 	return nil
 }
"
GO-2022-0586,hashicorp,go-getter,a2ebce998f8d4105bd4b78d6c99a12803ad97a45," func (g *GitGetter) update(ctx context.Context, dst, sshKeyFile, ref string, dep
 		// Not a branch, switch to default branch. This will also catch
 		// non-existent branches, in which case we want to switch to default
 		// and then checkout the proper branch later.
-		ref = findDefaultBranch(dst)
+		ref = findDefaultBranch(ctx, dst)
 	}
 
 	// We have to be on a branch to pull
-	if err := g.checkout(dst, ref); err != nil {
+	if err := g.checkout(ctx, dst, ref); err != nil {
 		return err
 	}
 
 	if depth > 0 {
-		cmd = exec.Command(""git"", ""pull"", ""--depth"", strconv.Itoa(depth), ""--ff-only"")
+		cmd = exec.CommandContext(ctx, ""git"", ""pull"", ""--depth"", strconv.Itoa(depth), ""--ff-only"")
 	} else {
-		cmd = exec.Command(""git"", ""pull"", ""--ff-only"")
+		cmd = exec.CommandContext(ctx, ""git"", ""pull"", ""--ff-only"")
 	}
 
 	cmd.Dir = dst
"
GO-2022-0586,hashicorp,go-getter,a2ebce998f8d4105bd4b78d6c99a12803ad97a45," func (g *GitGetter) fetchSubmodules(ctx context.Context, dst, sshKeyFile string,
 // findDefaultBranch checks the repo's origin remote for its default branch
 // (generally ""master""). ""master"" is returned if an origin default branch
 // can't be determined.
-func findDefaultBranch(dst string) string {
+func findDefaultBranch(ctx context.Context, dst string) string {
 	var stdoutbuf bytes.Buffer
-	cmd := exec.Command(""git"", ""branch"", ""-r"", ""--points-at"", ""refs/remotes/origin/HEAD"")
+	cmd := exec.CommandContext(ctx, ""git"", ""branch"", ""-r"", ""--points-at"", ""refs/remotes/origin/HEAD"")
 	cmd.Dir = dst
 	cmd.Stdout = &stdoutbuf
 	err := cmd.Run()
"
GO-2022-0586,hashicorp,go-getter,a2ebce998f8d4105bd4b78d6c99a12803ad97a45," func findDefaultBranch(dst string) string {
 
 // findRemoteDefaultBranch checks the remote repo's HEAD symref to return the remote repo's
 // default branch. ""master"" is returned if no HEAD symref exists.
-func findRemoteDefaultBranch(u *url.URL) string {
+func findRemoteDefaultBranch(ctx context.Context, u *url.URL) string {
 	var stdoutbuf bytes.Buffer
-	cmd := exec.Command(""git"", ""ls-remote"", ""--symref"", u.String(), ""HEAD"")
+	cmd := exec.CommandContext(ctx, ""git"", ""ls-remote"", ""--symref"", u.String(), ""HEAD"")
 	cmd.Stdout = &stdoutbuf
 	err := cmd.Run()
 	matches := lsRemoteSymRefRegexp.FindStringSubmatch(stdoutbuf.String())
"
GO-2022-0586,hashicorp,go-getter,a2ebce998f8d4105bd4b78d6c99a12803ad97a45," func setupGitEnv(cmd *exec.Cmd, sshKeyFile string) {
 // checkGitVersion is used to check the version of git installed on the system
 // against a known minimum version. Returns an error if the installed version
 // is older than the given minimum.
-func checkGitVersion(min string) error {
+func checkGitVersion(ctx context.Context, min string) error {
 	want, err := version.NewVersion(min)
 	if err != nil {
 		return err
 	}
 
-	out, err := exec.Command(""git"", ""version"").Output()
+	out, err := exec.CommandContext(ctx, ""git"", ""version"").Output()
 	if err != nil {
 		return err
 	}
"
GO-2022-0586,hashicorp,go-getter,a2ebce998f8d4105bd4b78d6c99a12803ad97a45," func (g *HgGetter) ClientMode(_ *url.URL) (ClientMode, error) {
 
 func (g *HgGetter) Get(dst string, u *url.URL) error {
 	ctx := g.Context()
+
+	if g.Timeout > 0 {
+		var cancel context.CancelFunc
+		ctx, cancel = context.WithTimeout(ctx, g.Timeout)
+		defer cancel()
+	}
+
 	if _, err := exec.LookPath(""hg""); err != nil {
 		return fmt.Errorf(""hg must be available and on the PATH"")
 	}
"
GO-2022-0586,hashicorp,go-getter,a2ebce998f8d4105bd4b78d6c99a12803ad97a45," func (g *HgGetter) Get(dst string, u *url.URL) error {
 		return err
 	}
 	if err != nil {
-		if err := g.clone(dst, newURL); err != nil {
+		if err := g.clone(ctx, dst, newURL); err != nil {
 			return err
 		}
 	}
 
-	if err := g.pull(dst, newURL); err != nil {
+	if err := g.pull(ctx, dst, newURL); err != nil {
 		return err
 	}
 
"
GO-2022-0586,hashicorp,go-getter,a2ebce998f8d4105bd4b78d6c99a12803ad97a45," func (g *HgGetter) pull(dst string, u *url.URL) error {
 func (g *HgGetter) update(ctx context.Context, dst string, u *url.URL, rev string) error {
 	args := []string{""update""}
 	if rev != """" {
-		args = append(args, rev)
+		args = append(args, ""--"", rev)
 	}
 
 	cmd := exec.CommandContext(ctx, ""hg"", args...)
"
GO-2022-0586,hashicorp,go-getter,a2ebce998f8d4105bd4b78d6c99a12803ad97a45," func (g *HttpGetter) Get(dst string, u *url.URL) error {
 		}
 	}
 
+	// If the HTTP client is nil, check if there is one available in the context,
+	// otherwise create one using cleanhttp's default transport.
 	if g.Client == nil {
-		g.Client = httpClient
-		if g.client != nil && g.client.Insecure {
-			insecureTransport := cleanhttp.DefaultTransport()
-			insecureTransport.TLSClientConfig = &tls.Config{InsecureSkipVerify: true}
-			g.Client.Transport = insecureTransport
+		if client := httpClientFromContext(ctx); client != nil {
+			g.Client = client
+		} else {
+			client := httpClient
+			if g.client != nil && g.client.Insecure {
+				insecureTransport := cleanhttp.DefaultTransport()
+				insecureTransport.TLSClientConfig = &tls.Config{InsecureSkipVerify: true}
+				client.Transport = insecureTransport
+			}
+			g.Client = client
 		}
 	}
 
+	// Pass along the configured HTTP client in the context for usage with the X-Terraform-Get feature.
+	ctx = context.WithValue(ctx, httpClientValue, g.Client)
+
 	// Add terraform-get to the parameter.
 	q := u.Query()
 	q.Add(""terraform-get"", ""1"")
 	u.RawQuery = q.Encode()
 
+	readCtx := ctx
+
+	if g.ReadTimeout > 0 {
+		var cancel context.CancelFunc
+		readCtx, cancel = context.WithTimeout(ctx, g.ReadTimeout)
+		defer cancel()
+	}
+
 	// Get the URL
-	req, err := http.NewRequestWithContext(ctx, ""GET"", u.String(), nil)
+	req, err := http.NewRequestWithContext(readCtx, ""GET"", u.String(), nil)
 	if err != nil {
 		return err
 	}
"
GO-2022-0586,hashicorp,go-getter,a2ebce998f8d4105bd4b78d6c99a12803ad97a45," func (g *HttpGetter) Get(dst string, u *url.URL) error {
 	if err != nil {
 		return err
 	}
-
 	defer resp.Body.Close()
+
+	body := resp.Body
+
+	if maxBytes := httpMaxBytesFromContext(ctx); maxBytes > 0 {
+		body = newLimitedWrappedReaderCloser(body, maxBytes)
+	}
+
 	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
 		return fmt.Errorf(""bad response code: %d"", resp.StatusCode)
 	}
 
-	// Extract the source URL
+	if disabled := xTerraformGetDisabled(ctx); disabled {
+		return nil
+	}
+
+	// Extract the source URL,
 	var source string
 	if v := resp.Header.Get(""X-Terraform-Get""); v != """" {
 		source = v
 	} else {
-		source, err = g.parseMeta(resp.Body)
+		source, err = g.parseMeta(readCtx, body)
 		if err != nil {
 			return err
 		}
"
GO-2022-0586,hashicorp,go-getter,a2ebce998f8d4105bd4b78d6c99a12803ad97a45," func (g *HttpGetter) Get(dst string, u *url.URL) error {
 	source, subDir := SourceDirSubdir(source)
 	if subDir == """" {
 		var opts []ClientOption
+
+		// Check if the protocol was switched to one which was not configured.
+		//
+		// Otherwise, all default getters are allowed.
+		if g.client != nil && g.client.Getters != nil {
+			protocol := strings.Split(source, "":"")[0]
+			_, allowed := g.client.Getters[protocol]
+			if !allowed {
+				return fmt.Errorf(""no getter available for X-Terraform-Get source protocol: %q"", protocol)
+			}
+		}
+
+		// Add any getter client options.
 		if g.client != nil {
 			opts = g.client.Options
 		}
+
+		// If the client is nil, we know we're using the HttpGetter directly. In this case,
+		// we don't know exactly which protocols are configued, but we can make a good guess.
+		//
+		// This prevents all default getters from being allowed when only using the
+		// HttpGetter directly. To enable protocol switching, a client ""wrapper"" must
+		// be used.
+		if g.client == nil {
+			opts = append(opts, WithGetters(map[string]Getter{
+				""http"":  g,
+				""https"": g,
+			}))
+		}
+
+		// Ensure we pass along the context we constructed in this function.
+		//
+		// This is especially important to enforce a limit on X-Terraform-Get redirects
+		// which could be setup, if configured, at the top of this function.
+		opts = append(opts, WithContext(ctx))
+
+		// Note: this allows the protocol to be switched to another configured getters.
 		return Get(dst, source, opts...)
 	}
 
"
GO-2022-0586,hashicorp,go-getter,a2ebce998f8d4105bd4b78d6c99a12803ad97a45," func (g *HttpGetter) Get(dst string, u *url.URL) error {
 // appended.
 func (g *HttpGetter) GetFile(dst string, src *url.URL) error {
 	ctx := g.Context()
+
+	// Optionally enforce a maxiumum HTTP response body size.
+	if g.MaxBytes > 0 {
+		ctx = context.WithValue(ctx, httpMaxBytesValue, g.MaxBytes)
+	}
+
 	if g.Netrc {
 		// Add auth from netrc if we can
 		if err := addAuthFromNetrc(src); err != nil {
"
GO-2022-0586,hashicorp,go-getter,a2ebce998f8d4105bd4b78d6c99a12803ad97a45," func (g *HttpGetter) GetFile(dst string, src *url.URL) error {
 		}
 	}
 
-	var currentFileSize int64
+	var (
+		currentFileSize int64
+		req             *http.Request
+	)
 
-	// We first make a HEAD request so we can check
-	// if the server supports range queries. If the server/URL doesn't
-	// support HEAD requests, we just fall back to GET.
-	req, err := http.NewRequestWithContext(ctx, ""HEAD"", src.String(), nil)
-	if err != nil {
-		return err
-	}
-	if g.Header != nil {
-		req.Header = g.Header.Clone()
-	}
-	headResp, err := g.Client.Do(req)
-	if err == nil {
-		headResp.Body.Close()
-		if headResp.StatusCode == 200 {
-			// If the HEAD request succeeded, then attempt to set the range
-			// query if we can.
-			if headResp.Header.Get(""Accept-Ranges"") == ""bytes"" && headResp.ContentLength >= 0 {
-				if fi, err := f.Stat(); err == nil {
-					if _, err = f.Seek(0, io.SeekEnd); err == nil {
-						currentFileSize = fi.Size()
-						if currentFileSize >= headResp.ContentLength {
-							// file already present
-							return nil
+	if !g.DoNotCheckHeadFirst {
+		headCtx := ctx
+
+		if g.HeadFirstTimeout > 0 {
+			var cancel context.CancelFunc
+
+			headCtx, cancel = context.WithTimeout(ctx, g.HeadFirstTimeout)
+			defer cancel()
+		}
+
+		// We first make a HEAD request so we can check
+		// if the server supports range queries. If the server/URL doesn't
+		// support HEAD requests, we just fall back to GET.
+		req, err = http.NewRequestWithContext(headCtx, ""HEAD"", src.String(), nil)
+		if err != nil {
+			return err
+		}
+		if g.Header != nil {
+			req.Header = g.Header.Clone()
+		}
+		headResp, err := g.Client.Do(req)
+		if err == nil {
+			headResp.Body.Close()
+			if headResp.StatusCode == 200 {
+				// If the HEAD request succeeded, then attempt to set the range
+				// query if we can.
+				if headResp.Header.Get(""Accept-Ranges"") == ""bytes"" && headResp.ContentLength >= 0 {
+					if fi, err := f.Stat(); err == nil {
+						if _, err = f.Seek(0, io.SeekEnd); err == nil {
+							currentFileSize = fi.Size()
+							if currentFileSize >= headResp.ContentLength {
+								// file already present
+								return nil
+							}
 						}
 					}
 				}
"
GO-2022-0586,hashicorp,go-getter,a2ebce998f8d4105bd4b78d6c99a12803ad97a45," func (g *HttpGetter) GetFile(dst string, src *url.URL) error {
 		}
 	}
 
-	req, err = http.NewRequestWithContext(ctx, ""GET"", src.String(), nil)
+	readCtx := ctx
+
+	if g.ReadTimeout > 0 {
+		var cancel context.CancelFunc
+		readCtx, cancel = context.WithTimeout(ctx, g.ReadTimeout)
+		defer cancel()
+	}
+
+	req, err = http.NewRequestWithContext(readCtx, ""GET"", src.String(), nil)
 	if err != nil {
 		return err
 	}
"
GO-2022-0586,hashicorp,go-getter,a2ebce998f8d4105bd4b78d6c99a12803ad97a45," func (g *HttpGetter) GetFile(dst string, src *url.URL) error {
 
 	body := resp.Body
 
+	if maxBytes := httpMaxBytesFromContext(ctx); maxBytes > 0 {
+		body = newLimitedWrappedReaderCloser(body, maxBytes)
+	}
+
 	if g.client != nil && g.client.ProgressListener != nil {
 		// track download
 		fn := filepath.Base(src.EscapedPath())
"
GO-2022-0586,hashicorp,go-getter,a2ebce998f8d4105bd4b78d6c99a12803ad97a45," func (g *HttpGetter) GetFile(dst string, src *url.URL) error {
 	}
 	defer body.Close()
 
-	n, err := Copy(ctx, f, body)
+	n, err := Copy(readCtx, f, body)
 	if err == nil && n < resp.ContentLength {
 		err = io.ErrShortWrite
 	}
"
GO-2022-0586,hashicorp,go-getter,a2ebce998f8d4105bd4b78d6c99a12803ad97a45," import (
 // a S3 bucket.
 type S3Getter struct {
 	getter
+
+	// Timeout sets a deadline which all S3 operations should
+	// complete within. Zero value means no timeout.
+	Timeout time.Duration
 }
 
 func (g *S3Getter) ClientMode(u *url.URL) (ClientMode, error) {
 	// Parse URL
+	ctx := g.Context()
+
+	if g.Timeout > 0 {
+		var cancel context.CancelFunc
+		ctx, cancel = context.WithTimeout(ctx, g.Timeout)
+		defer cancel()
+	}
+
 	region, bucket, path, _, creds, err := g.parseUrl(u)
 	if err != nil {
 		return 0, err
"
GO-2022-0586,hashicorp,go-getter,a2ebce998f8d4105bd4b78d6c99a12803ad97a45," func (g *S3Getter) ClientMode(u *url.URL) (ClientMode, error) {
 		Bucket: aws.String(bucket),
 		Prefix: aws.String(path),
 	}
-	resp, err := client.ListObjects(req)
+	resp, err := client.ListObjectsWithContext(ctx, req)
 	if err != nil {
 		return 0, err
 	}
"
GO-2022-0586,hashicorp,go-getter,a2ebce998f8d4105bd4b78d6c99a12803ad97a45," func (g *S3Getter) ClientMode(u *url.URL) (ClientMode, error) {
 func (g *S3Getter) Get(dst string, u *url.URL) error {
 	ctx := g.Context()
 
+	if g.Timeout > 0 {
+		var cancel context.CancelFunc
+		ctx, cancel = context.WithTimeout(ctx, g.Timeout)
+		defer cancel()
+	}
+
 	// Parse URL
 	region, bucket, path, _, creds, err := g.parseUrl(u)
 	if err != nil {
"
GO-2022-0586,hashicorp,go-getter,a2ebce998f8d4105bd4b78d6c99a12803ad97a45," func (g *S3Getter) Get(dst string, u *url.URL) error {
 			req.Marker = aws.String(lastMarker)
 		}
 
-		resp, err := client.ListObjects(req)
+		resp, err := client.ListObjectsWithContext(ctx, req)
 		if err != nil {
 			return err
 		}
"
GO-2022-0586,hashicorp,go-getter,a2ebce998f8d4105bd4b78d6c99a12803ad97a45," func (g *S3Getter) Get(dst string, u *url.URL) error {
 
 func (g *S3Getter) GetFile(dst string, u *url.URL) error {
 	ctx := g.Context()
+
+	if g.Timeout > 0 {
+		var cancel context.CancelFunc
+		ctx, cancel = context.WithTimeout(ctx, g.Timeout)
+		defer cancel()
+	}
+
 	region, bucket, path, version, creds, err := g.parseUrl(u)
 	if err != nil {
 		return err
"
GO-2022-0586,hashicorp,go-getter,a2ebce998f8d4105bd4b78d6c99a12803ad97a45," func (g *S3Getter) getObject(ctx context.Context, client *s3.S3, dst, bucket, ke
 		req.VersionId = aws.String(version)
 	}
 
-	resp, err := client.GetObject(req)
+	resp, err := client.GetObjectWithContext(ctx, req)
 	if err != nil {
 		return err
 	}
"
GO-2022-0586,hashicorp,go-getter,a2ebce998f8d4105bd4b78d6c99a12803ad97a45," func SourceDirSubdir(src string) (string, string) {
 //
 // The returned path is the full absolute path.
 func SubdirGlob(dst, subDir string) (string, error) {
-	matches, err := filepath.Glob(filepath.Join(dst, subDir))
+	pattern := filepath.Join(dst, subDir)
+
+	matches, err := filepath.Glob(pattern)
 	if err != nil {
 		return """", err
 	}
"
GO-2023-2074,gomarkdown,markdown,14b16010c2ee7ff33a940a541d993bd043a88940," func (p *Parser) Block(data []byte) {
 		// <div>
 		//     ...
 		// </div>
+
+		if len(data) == 0 {
+			continue
+		}
+
 		if data[0] == '<' {
 			if i := p.html(data, true); i > 0 {
 				data = data[i:]
"
GO-2021-0237,AndrewBurian,powermux,5e60a8a0372b35a898796c2697c40e8daabed8e9," func NewServeMux() *ServeMux {
 func (s *ServeMux) getAll(r *http.Request, ex *routeExecution) {
 	path := r.URL.EscapedPath()
 
-	// Check for redirect
-	if path != ""/"" && strings.HasSuffix(path, ""/"") {
-		r.URL.Path = strings.TrimRight(path, ""/"")
-		ex.handler = http.RedirectHandler(r.URL.RequestURI(), http.StatusPermanentRedirect)
-		ex.pattern = r.URL.EscapedPath()
-		return
-	}
-
 	// fill it
 	if route, ok := s.hostRoutes[r.URL.Host]; ok {
 		route.execute(ex, r.Method, path)
"
GO-2022-0978,open-policy-agent,opa,25a597bc3f4985162e7f65f9c36599f4f8f55823," func (qc *queryCompiler) checkDeprecatedBuiltins(_ *QueryContext, body Body) (Bo
 
 func (qc *queryCompiler) rewriteWithModifiers(_ *QueryContext, body Body) (Body, error) {
 	f := newEqualityFactory(newLocalVarGenerator(""q"", body))
-	body, err := rewriteWithModifiersInBody(qc.compiler, f, body)
+	body, err := rewriteWithModifiersInBody(qc.compiler, qc.unsafeBuiltinsMap(), f, body)
 	if err != nil {
 		return nil, Errors{err}
 	}
"
GO-2022-0978,open-policy-agent,opa,3e8c754ed007b22393cf65e48751ad9f6457fee8," func (qc *queryCompiler) checkDeprecatedBuiltins(_ *QueryContext, body Body) (Bo
 
 func (qc *queryCompiler) rewriteWithModifiers(_ *QueryContext, body Body) (Body, error) {
 	f := newEqualityFactory(newLocalVarGenerator(""q"", body))
-	body, err := rewriteWithModifiersInBody(qc.compiler, f, body)
+	body, err := rewriteWithModifiersInBody(qc.compiler, qc.unsafeBuiltinsMap(), f, body)
 	if err != nil {
 		return nil, Errors{err}
 	}
"
GO-2022-0603,go-yaml,yaml,8f96da9f5d5eff988554c1aae1784627c4bf6754," func (p *parser) peek() yaml_event_type_t {
 	if p.event.typ != yaml_NO_EVENT {
 		return p.event.typ
 	}
-	if !yaml_parser_parse(&p.parser, &p.event) {
+	// It's curious choice from the underlying API to generally return a
+	// positive result on success, but on this case return true in an error
+	// scenario. This was the source of bugs in the past (issue #666).
+	if !yaml_parser_parse(&p.parser, &p.event) || p.parser.error != yaml_NO_ERROR {
 		p.fail()
 	}
 	return p.event.typ
"
GO-2023-1872,openfga,openfga,087ce392595f3c319ab3028b5089118ea4063452," func ValidateAllAuthorizationModels(ctx context.Context, db storage.OpenFGADatas
 
 				// validate each model
 				for _, model := range models {
-					_, err := typesystem.NewAndValidate(model)
+					_, err := typesystem.NewAndValidate(context.Background(), model)
 
 					validationResult := validationResult{
 						StoreID:       store.Id,
"
GO-2023-1872,openfga,openfga,087ce392595f3c319ab3028b5089118ea4063452," func (q *ExpandQuery) Execute(ctx context.Context, req *openfgapb.ExpandRequest)
 		return nil, serverErrors.ValidationError(typesystem.ErrInvalidSchemaVersion)
 	}
 
-	typesys := typesystem.New(model)
+	typesys, err := typesystem.NewAndValidate(ctx, model)
+	if err != nil {
+		return nil, serverErrors.ValidationError(typesystem.ErrInvalidModel)
+	}
 
 	if err = validation.ValidateObject(typesys, tk); err != nil {
 		return nil, serverErrors.ValidationError(err)
"
GO-2023-1872,openfga,openfga,087ce392595f3c319ab3028b5089118ea4063452," func (w *WriteAuthorizationModelCommand) Execute(ctx context.Context, req *openf
 		TypeDefinitions: req.GetTypeDefinitions(),
 	}
 
-	_, err := typesystem.NewAndValidate(model)
+	_, err := typesystem.NewAndValidate(ctx, model)
 	if err != nil {
 		return nil, serverErrors.InvalidAuthorizationModelInput(err)
 	}
"
GO-2023-1872,openfga,openfga,087ce392595f3c319ab3028b5089118ea4063452," func (s *Server) ListObjects(ctx context.Context, req *openfgapb.ListObjectsRequ
 		return nil, err
 	}
 
-	typesys := typesystem.New(model)
+	typesys, err := typesystem.NewAndValidate(ctx, model)
+	if err != nil {
+		return nil, serverErrors.ValidationError(typesystem.ErrInvalidModel)
+	}
 
 	ctx = typesystem.ContextWithTypesystem(ctx, typesys)
 
"
GO-2023-1872,openfga,openfga,087ce392595f3c319ab3028b5089118ea4063452," func (s *Server) StreamedListObjects(req *openfgapb.StreamedListObjectsRequest,
 		return serverErrors.HandleError("""", err)
 	}
 
-	typesys := typesystem.New(model)
+	typesys, err := typesystem.NewAndValidate(ctx, model)
+	if err != nil {
+		return serverErrors.ValidationError(typesystem.ErrInvalidModel)
+	}
 
 	ctx = typesystem.ContextWithTypesystem(ctx, typesys)
 
"
GO-2023-1872,openfga,openfga,087ce392595f3c319ab3028b5089118ea4063452," func (s *Server) Check(ctx context.Context, req *openfgapb.CheckRequest) (*openf
 		return nil, serverErrors.ValidationError(typesystem.ErrInvalidSchemaVersion)
 	}
 
-	typesys := typesystem.New(model)
+	typesys, err := typesystem.NewAndValidate(ctx, model)
+	if err != nil {
+		return nil, serverErrors.ValidationError(typesystem.ErrInvalidModel)
+	}
 
 	if err := validation.ValidateUserObjectRelation(typesys, tk); err != nil {
 		return nil, serverErrors.ValidationError(err)
"
GO-2023-1872,openfga,openfga,087ce392595f3c319ab3028b5089118ea4063452," func (t *TypeSystem) relationInvolvesExclusion(objectType, relation string, visi
 	return false, nil
 }
 
+// hasEntrypoints recursively walks the rewrite definition for the given relation to determine if there is at least
+// one path in the rewrite rule that could relate to at least one concrete object type. If there is no such path that
+// could lead to at least one relationship with some object type, then false is returned along with an error indicating
+// no entrypoints were found. If at least one relationship with a specific object type is found while walking the rewrite,
+// then true is returned along with a nil error.
+func hasEntrypoints(
+	typedefs map[string]map[string]*openfgapb.Relation,
+	typeName, relationName string,
+	rewrite *openfgapb.Userset,
+	visitedRelations map[string]map[string]struct{},
+) (bool, error) {
+
+	v := maps.Clone(visitedRelations)
+
+	if val, ok := v[typeName]; ok {
+		val[relationName] = struct{}{}
+	} else {
+		v[typeName] = map[string]struct{}{
+			relationName: {},
+		}
+	}
+
+	relation, ok := typedefs[typeName][relationName]
+	if !ok {
+		return false, fmt.Errorf(""undefined type definition for '%s#%s'"", typeName, relationName)
+	}
+
+	switch rw := rewrite.Userset.(type) {
+	case *openfgapb.Userset_This:
+		for _, assignableType := range relation.GetTypeInfo().GetDirectlyRelatedUserTypes() {
+			if assignableType.GetRelationOrWildcard() == nil || assignableType.GetWildcard() != nil {
+				return true, nil
+			}
+
+			assignableTypeName := assignableType.GetType()
+			assignableRelationName := assignableType.GetRelation()
+
+			assignableRelation, ok := typedefs[assignableTypeName][assignableRelationName]
+			if !ok {
+				return false, fmt.Errorf(""undefined type definition for '%s#%s'"", assignableTypeName, assignableRelationName)
+			}
+
+			if _, ok := v[assignableTypeName][assignableRelationName]; ok {
+				continue
+			}
+
+			hasEntrypoint, err := hasEntrypoints(typedefs, assignableTypeName, assignableRelationName, assignableRelation.GetRewrite(), v)
+			if err != nil {
+				return false, err
+			}
+
+			if hasEntrypoint {
+				return true, nil
+			}
+		}
+
+		return false, nil
+	case *openfgapb.Userset_ComputedUserset:
+
+		computedRelationName := rw.ComputedUserset.GetRelation()
+		computedRelation, ok := typedefs[typeName][computedRelationName]
+		if !ok {
+			return false, fmt.Errorf(""undefined type definition for '%s#%s'"", typeName, computedRelationName)
+		}
+
+		if _, ok := v[typeName][computedRelationName]; ok {
+			return false, nil
+		}
+
+		hasEntrypoint, err := hasEntrypoints(typedefs, typeName, computedRelationName, computedRelation.GetRewrite(), v)
+		if err != nil {
+			return false, err
+		}
+
+		return hasEntrypoint, nil
+	case *openfgapb.Userset_TupleToUserset:
+		tuplesetRelationName := rw.TupleToUserset.GetTupleset().GetRelation()
+		computedRelationName := rw.TupleToUserset.ComputedUserset.GetRelation()
+
+		tuplesetRelation, ok := typedefs[typeName][tuplesetRelationName]
+		if !ok {
+			return false, fmt.Errorf(""undefined type definition for '%s#%s'"", typeName, tuplesetRelationName)
+		}
+
+		for _, assignableType := range tuplesetRelation.GetTypeInfo().GetDirectlyRelatedUserTypes() {
+			assignableTypeName := assignableType.GetType()
+
+			if assignableRelation, ok := typedefs[assignableTypeName][computedRelationName]; ok {
+				if _, ok := v[assignableTypeName][computedRelationName]; ok {
+					continue
+				}
+
+				hasEntrypoint, err := hasEntrypoints(typedefs, assignableTypeName, computedRelationName, assignableRelation.GetRewrite(), v)
+				if err != nil {
+					return false, err
+				}
+
+				if hasEntrypoint {
+					return true, nil
+				}
+			}
+		}
+
+		return false, nil
+
+	case *openfgapb.Userset_Union:
+
+		for _, child := range rw.Union.Child {
+
+			hasEntrypoints, err := hasEntrypoints(typedefs, typeName, relationName, child, maps.Clone(visitedRelations))
+			if err != nil {
+				return false, err
+			}
+
+			if hasEntrypoints {
+				return true, nil
+			}
+		}
+
+		return false, nil
+	case *openfgapb.Userset_Intersection:
+
+		for _, child := range rw.Intersection.Child {
+
+			// all of the children must have an entrypoint
+			hasEntrypoints, err := hasEntrypoints(typedefs, typeName, relationName, child, maps.Clone(visitedRelations))
+			if err != nil {
+				return false, err
+			}
+
+			if !hasEntrypoints {
+				return false, nil
+			}
+		}
+
+		return true, nil
+	case *openfgapb.Userset_Difference:
+
+		v := maps.Clone(visitedRelations)
+
+		hasEntrypoint, err := hasEntrypoints(typedefs, typeName, relationName, rw.Difference.GetBase(), v)
+		if err != nil {
+			return false, err
+		}
+
+		if !hasEntrypoint {
+			return false, nil
+		}
+
+		hasEntrypoint, err = hasEntrypoints(typedefs, typeName, relationName, rw.Difference.GetSubtract(), v)
+		if err != nil {
+			return false, err
+		}
+
+		if !hasEntrypoint {
+			return false, nil
+		}
+
+		return true, nil
+	}
+
+	return false, nil
+}
+
 // NewAndValidate is like New but also validates the model according to the following rules:
 //  1. Checks that the *TypeSystem have a valid schema version.
 //  2. For every rewrite the relations in the rewrite must:
"
GO-2023-1859,lestrrat-go,jwx,6c41e3822485fc7e11dd70b4b0524b075d66b103," func (c Hmac) Open(dst, nonce, ciphertext, data []byte) ([]byte, error) {
 		return nil, fmt.Errorf(`failed to compute auth tag: %w`, err)
 	}
 
-	if subtle.ConstantTimeCompare(expectedTag, tag) != 1 {
-		return nil, fmt.Errorf(`invalid ciphertext (tag mismatch)`)
-	}
-
 	cbc := cipher.NewCBCDecrypter(c.blockCipher, nonce)
 	buf := make([]byte, tagOffset)
 	cbc.CryptBlocks(buf, ciphertext)
 
-	plaintext, err := unpad(buf, c.blockCipher.BlockSize())
-	if err != nil {
-		return nil, fmt.Errorf(`failed to generate plaintext from decrypted blocks: %w`, err)
+	toRemove, good := extractPadding(buf)
+	cmp := subtle.ConstantTimeCompare(expectedTag, tag) & int(good)
+	if cmp != 1 {
+		return nil, errors.New(`invalid ciphertext`)
 	}
+
+	plaintext := buf[:len(buf)-toRemove]
 	ret := ensureSize(dst, len(plaintext))
 	out := ret[len(dst):]
 	copy(out, plaintext)
"
GO-2023-1859,lestrrat-go,jwx,d9ddbc8e5009cfdd8c28413390b67afa7f576dd6," func _main() error {
 		},
 		{
 			name:     `EllipticCurveAlgorithm`,
-			comment:  ` EllipticCurveAlgorithm represents the algorithms used for EC keys`,
+			comment:  `EllipticCurveAlgorithm represents the algorithms used for EC keys`,
 			filename: `elliptic_gen.go`,
 			elements: []element{
 				{
"
GO-2023-1859,lestrrat-go,jwx,d9ddbc8e5009cfdd8c28413390b67afa7f576dd6," func (c Hmac) Open(dst, nonce, ciphertext, data []byte) ([]byte, error) {
 	buf := make([]byte, tagOffset)
 	cbc.CryptBlocks(buf, ciphertext)
 
-	plaintext, err := unpad(buf, c.blockCipher.BlockSize())
-	if err != nil {
-		return nil, errors.Wrap(err, `failed to generate plaintext from decrypted blocks`)
+	toRemove, good := extractPadding(buf)
+	cmp := subtle.ConstantTimeCompare(expectedTag, tag) & int(good)
+	if cmp != 1 {
+		return nil, errors.New(""invalid ciphertext"")
 	}
+
+	plaintext := buf[:len(buf)-toRemove]
 	ret := ensureSize(dst, len(plaintext))
 	out := ret[len(dst):]
 	copy(out, plaintext)
"
GO-2022-0646,aws,aws-sdk-go,ae9b9fd92af132cfd8d879809d8611825ba135f4," func (s S3Target) GoString() string {
 	return s.String()
 }
 
+// SetConnectionName sets the ConnectionName field's value.
+func (s *S3Target) SetConnectionName(v string) *S3Target {
+	s.ConnectionName = &v
+	return s
+}
+
 // SetExclusions sets the Exclusions field's value.
 func (s *S3Target) SetExclusions(v []*string) *S3Target {
 	s.Exclusions = v
"
GO-2022-0646,aws,aws-sdk-go,ae9b9fd92af132cfd8d879809d8611825ba135f4," func (s *AppSummary) SetDescription(v string) *AppSummary {
 	return s
 }
 
+// SetImportedAppId sets the ImportedAppId field's value.
+func (s *AppSummary) SetImportedAppId(v string) *AppSummary {
+	s.ImportedAppId = &v
+	return s
+}
+
 // SetLastModified sets the LastModified field's value.
 func (s *AppSummary) SetLastModified(v time.Time) *AppSummary {
 	s.LastModified = &v
"
GO-2022-0646,aws,aws-sdk-go,ae9b9fd92af132cfd8d879809d8611825ba135f4," func (s *AppSummary) SetLatestReplicationTime(v time.Time) *AppSummary {
 	return s
 }
 
+// SetLaunchConfigurationStatus sets the LaunchConfigurationStatus field's value.
+func (s *AppSummary) SetLaunchConfigurationStatus(v string) *AppSummary {
+	s.LaunchConfigurationStatus = &v
+	return s
+}
+
 // SetLaunchDetails sets the LaunchDetails field's value.
 func (s *AppSummary) SetLaunchDetails(v *LaunchDetails) *AppSummary {
 	s.LaunchDetails = v
"
GO-2022-0646,aws,aws-sdk-go,ae9b9fd92af132cfd8d879809d8611825ba135f4," func (s *AppSummary) SetName(v string) *AppSummary {
 	return s
 }
 
+// SetReplicationConfigurationStatus sets the ReplicationConfigurationStatus field's value.
+func (s *AppSummary) SetReplicationConfigurationStatus(v string) *AppSummary {
+	s.ReplicationConfigurationStatus = &v
+	return s
+}
+
 // SetReplicationStatus sets the ReplicationStatus field's value.
 func (s *AppSummary) SetReplicationStatus(v string) *AppSummary {
 	s.ReplicationStatus = &v
"
GO-2022-0646,aws,aws-sdk-go,ae9b9fd92af132cfd8d879809d8611825ba135f4," func (s *GetAppLaunchConfigurationOutput) SetAppId(v string) *GetAppLaunchConfig
 	return s
 }
 
+// SetAutoLaunch sets the AutoLaunch field's value.
+func (s *GetAppLaunchConfigurationOutput) SetAutoLaunch(v bool) *GetAppLaunchConfigurationOutput {
+	s.AutoLaunch = &v
+	return s
+}
+
 // SetRoleName sets the RoleName field's value.
 func (s *GetAppLaunchConfigurationOutput) SetRoleName(v string) *GetAppLaunchConfigurationOutput {
 	s.RoleName = &v
"
GO-2022-0646,aws,aws-sdk-go,ae9b9fd92af132cfd8d879809d8611825ba135f4," func (s S3Location) GoString() string {
 	return s.String()
 }
 
+// Validate inspects the fields of the type to determine if they are valid.
+func (s *S3Location) Validate() error {
+	invalidParams := request.ErrInvalidParams{Context: ""S3Location""}
+	if s.Bucket != nil && len(*s.Bucket) < 3 {
+		invalidParams.Add(request.NewErrParamMinLen(""Bucket"", 3))
+	}
+
+	if invalidParams.Len() > 0 {
+		return invalidParams
+	}
+	return nil
+}
+
 // SetBucket sets the Bucket field's value.
 func (s *S3Location) SetBucket(v string) *S3Location {
 	s.Bucket = &v
"
GO-2022-0646,aws,aws-sdk-go,ae9b9fd92af132cfd8d879809d8611825ba135f4," func (s ServerGroupLaunchConfiguration) GoString() string {
 	return s.String()
 }
 
+// Validate inspects the fields of the type to determine if they are valid.
+func (s *ServerGroupLaunchConfiguration) Validate() error {
+	invalidParams := request.ErrInvalidParams{Context: ""ServerGroupLaunchConfiguration""}
+	if s.ServerLaunchConfigurations != nil {
+		for i, v := range s.ServerLaunchConfigurations {
+			if v == nil {
+				continue
+			}
+			if err := v.Validate(); err != nil {
+				invalidParams.AddNested(fmt.Sprintf(""%s[%v]"", ""ServerLaunchConfigurations"", i), err.(request.ErrInvalidParams))
+			}
+		}
+	}
+
+	if invalidParams.Len() > 0 {
+		return invalidParams
+	}
+	return nil
+}
+
 // SetLaunchOrder sets the LaunchOrder field's value.
 func (s *ServerGroupLaunchConfiguration) SetLaunchOrder(v int64) *ServerGroupLaunchConfiguration {
 	s.LaunchOrder = &v
"
GO-2021-0110,ory,fosite,0c9e0f6d654913ad57c507dd9a36631e1858a3e9," func (m *MockAccessResponder) EXPECT() *MockAccessResponderMockRecorder {
 
 // GetAccessToken mocks base method
 func (m *MockAccessResponder) GetAccessToken() string {
+	m.ctrl.T.Helper()
 	ret := m.ctrl.Call(m, ""GetAccessToken"")
 	ret0, _ := ret[0].(string)
 	return ret0
"
GO-2021-0110,ory,fosite,0c9e0f6d654913ad57c507dd9a36631e1858a3e9," func (m *MockAccessResponder) ToMap() map[string]interface{} {
 
 // ToMap indicates an expected call of ToMap
 func (mr *MockAccessResponderMockRecorder) ToMap() *gomock.Call {
+	mr.mock.ctrl.T.Helper()
 	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""ToMap"", reflect.TypeOf((*MockAccessResponder)(nil).ToMap))
 }
"
GO-2021-0110,ory,fosite,0c9e0f6d654913ad57c507dd9a36631e1858a3e9," func (m *MockAccessTokenStorage) EXPECT() *MockAccessTokenStorageMockRecorder {
 
 // CreateAccessTokenSession mocks base method
 func (m *MockAccessTokenStorage) CreateAccessTokenSession(arg0 context.Context, arg1 string, arg2 fosite.Requester) error {
+	m.ctrl.T.Helper()
 	ret := m.ctrl.Call(m, ""CreateAccessTokenSession"", arg0, arg1, arg2)
 	ret0, _ := ret[0].(error)
 	return ret0
"
GO-2021-0110,ory,fosite,0c9e0f6d654913ad57c507dd9a36631e1858a3e9," func (m *MockAccessTokenStorage) GetAccessTokenSession(arg0 context.Context, arg
 
 // GetAccessTokenSession indicates an expected call of GetAccessTokenSession
 func (mr *MockAccessTokenStorageMockRecorder) GetAccessTokenSession(arg0, arg1, arg2 interface{}) *gomock.Call {
+	mr.mock.ctrl.T.Helper()
 	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""GetAccessTokenSession"", reflect.TypeOf((*MockAccessTokenStorage)(nil).GetAccessTokenSession), arg0, arg1, arg2)
 }
"
GO-2021-0110,ory,fosite,0c9e0f6d654913ad57c507dd9a36631e1858a3e9," func (m *MockAccessTokenStrategy) EXPECT() *MockAccessTokenStrategyMockRecorder
 
 // AccessTokenSignature mocks base method
 func (m *MockAccessTokenStrategy) AccessTokenSignature(arg0 string) string {
+	m.ctrl.T.Helper()
 	ret := m.ctrl.Call(m, ""AccessTokenSignature"", arg0)
 	ret0, _ := ret[0].(string)
 	return ret0
"
GO-2021-0110,ory,fosite,0c9e0f6d654913ad57c507dd9a36631e1858a3e9," func (m *MockAccessTokenStrategy) ValidateAccessToken(arg0 context.Context, arg1
 
 // ValidateAccessToken indicates an expected call of ValidateAccessToken
 func (mr *MockAccessTokenStrategyMockRecorder) ValidateAccessToken(arg0, arg1, arg2 interface{}) *gomock.Call {
+	mr.mock.ctrl.T.Helper()
 	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""ValidateAccessToken"", reflect.TypeOf((*MockAccessTokenStrategy)(nil).ValidateAccessToken), arg0, arg1, arg2)
 }
"
GO-2021-0110,ory,fosite,0c9e0f6d654913ad57c507dd9a36631e1858a3e9," func (m *MockAuthorizeCodeStorage) EXPECT() *MockAuthorizeCodeStorageMockRecorde
 
 // CreateAuthorizeCodeSession mocks base method
 func (m *MockAuthorizeCodeStorage) CreateAuthorizeCodeSession(arg0 context.Context, arg1 string, arg2 fosite.Requester) error {
+	m.ctrl.T.Helper()
 	ret := m.ctrl.Call(m, ""CreateAuthorizeCodeSession"", arg0, arg1, arg2)
 	ret0, _ := ret[0].(error)
 	return ret0
"
GO-2021-0110,ory,fosite,0c9e0f6d654913ad57c507dd9a36631e1858a3e9," func (m *MockAuthorizeCodeStorage) InvalidateAuthorizeCodeSession(arg0 context.C
 
 // InvalidateAuthorizeCodeSession indicates an expected call of InvalidateAuthorizeCodeSession
 func (mr *MockAuthorizeCodeStorageMockRecorder) InvalidateAuthorizeCodeSession(arg0, arg1 interface{}) *gomock.Call {
+	mr.mock.ctrl.T.Helper()
 	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""InvalidateAuthorizeCodeSession"", reflect.TypeOf((*MockAuthorizeCodeStorage)(nil).InvalidateAuthorizeCodeSession), arg0, arg1)
 }
"
GO-2021-0110,ory,fosite,0c9e0f6d654913ad57c507dd9a36631e1858a3e9," func (m *MockAuthorizeCodeStrategy) EXPECT() *MockAuthorizeCodeStrategyMockRecor
 
 // AuthorizeCodeSignature mocks base method
 func (m *MockAuthorizeCodeStrategy) AuthorizeCodeSignature(arg0 string) string {
+	m.ctrl.T.Helper()
 	ret := m.ctrl.Call(m, ""AuthorizeCodeSignature"", arg0)
 	ret0, _ := ret[0].(string)
 	return ret0
"
GO-2021-0110,ory,fosite,0c9e0f6d654913ad57c507dd9a36631e1858a3e9," func (m *MockAuthorizeCodeStrategy) ValidateAuthorizeCode(arg0 context.Context,
 
 // ValidateAuthorizeCode indicates an expected call of ValidateAuthorizeCode
 func (mr *MockAuthorizeCodeStrategyMockRecorder) ValidateAuthorizeCode(arg0, arg1, arg2 interface{}) *gomock.Call {
+	mr.mock.ctrl.T.Helper()
 	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""ValidateAuthorizeCode"", reflect.TypeOf((*MockAuthorizeCodeStrategy)(nil).ValidateAuthorizeCode), arg0, arg1, arg2)
 }
"
GO-2021-0110,ory,fosite,0c9e0f6d654913ad57c507dd9a36631e1858a3e9," func (m *MockAuthorizeEndpointHandler) EXPECT() *MockAuthorizeEndpointHandlerMoc
 
 // HandleAuthorizeEndpointRequest mocks base method
 func (m *MockAuthorizeEndpointHandler) HandleAuthorizeEndpointRequest(arg0 context.Context, arg1 fosite.AuthorizeRequester, arg2 fosite.AuthorizeResponder) error {
+	m.ctrl.T.Helper()
 	ret := m.ctrl.Call(m, ""HandleAuthorizeEndpointRequest"", arg0, arg1, arg2)
 	ret0, _ := ret[0].(error)
 	return ret0
"
GO-2021-0110,ory,fosite,0c9e0f6d654913ad57c507dd9a36631e1858a3e9," func (m *MockAuthorizeEndpointHandler) HandleAuthorizeEndpointRequest(arg0 conte
 
 // HandleAuthorizeEndpointRequest indicates an expected call of HandleAuthorizeEndpointRequest
 func (mr *MockAuthorizeEndpointHandlerMockRecorder) HandleAuthorizeEndpointRequest(arg0, arg1, arg2 interface{}) *gomock.Call {
+	mr.mock.ctrl.T.Helper()
 	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""HandleAuthorizeEndpointRequest"", reflect.TypeOf((*MockAuthorizeEndpointHandler)(nil).HandleAuthorizeEndpointRequest), arg0, arg1, arg2)
 }
"
GO-2021-0110,ory,fosite,0c9e0f6d654913ad57c507dd9a36631e1858a3e9," func (m *MockAuthorizeResponder) GetQuery() url.Values {
 
 // GetQuery indicates an expected call of GetQuery
 func (mr *MockAuthorizeResponderMockRecorder) GetQuery() *gomock.Call {
+	mr.mock.ctrl.T.Helper()
 	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""GetQuery"", reflect.TypeOf((*MockAuthorizeResponder)(nil).GetQuery))
 }
"
GO-2021-0110,ory,fosite,0c9e0f6d654913ad57c507dd9a36631e1858a3e9," func (m *MockClient) EXPECT() *MockClientMockRecorder {
 
 // GetAudience mocks base method
 func (m *MockClient) GetAudience() fosite.Arguments {
+	m.ctrl.T.Helper()
 	ret := m.ctrl.Call(m, ""GetAudience"")
 	ret0, _ := ret[0].(fosite.Arguments)
 	return ret0
"
GO-2021-0110,ory,fosite,0c9e0f6d654913ad57c507dd9a36631e1858a3e9," func (m *MockClient) IsPublic() bool {
 
 // IsPublic indicates an expected call of IsPublic
 func (mr *MockClientMockRecorder) IsPublic() *gomock.Call {
+	mr.mock.ctrl.T.Helper()
 	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""IsPublic"", reflect.TypeOf((*MockClient)(nil).IsPublic))
 }
"
GO-2021-0110,ory,fosite,0c9e0f6d654913ad57c507dd9a36631e1858a3e9," func (m *MockHasher) EXPECT() *MockHasherMockRecorder {
 
 // Compare mocks base method
 func (m *MockHasher) Compare(arg0 context.Context, arg1, arg2 []byte) error {
+	m.ctrl.T.Helper()
 	ret := m.ctrl.Call(m, ""Compare"", arg0, arg1, arg2)
 	ret0, _ := ret[0].(error)
 	return ret0
"
GO-2021-0110,ory,fosite,0c9e0f6d654913ad57c507dd9a36631e1858a3e9," func (m *MockHasher) Hash(arg0 context.Context, arg1 []byte) ([]byte, error) {
 
 // Hash indicates an expected call of Hash
 func (mr *MockHasherMockRecorder) Hash(arg0, arg1 interface{}) *gomock.Call {
+	mr.mock.ctrl.T.Helper()
 	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""Hash"", reflect.TypeOf((*MockHasher)(nil).Hash), arg0, arg1)
 }
"
GO-2021-0110,ory,fosite,0c9e0f6d654913ad57c507dd9a36631e1858a3e9," func (m *MockOpenIDConnectTokenStrategy) EXPECT() *MockOpenIDConnectTokenStrateg
 
 // GenerateIDToken mocks base method
 func (m *MockOpenIDConnectTokenStrategy) GenerateIDToken(arg0 context.Context, arg1 fosite.Requester) (string, error) {
+	m.ctrl.T.Helper()
 	ret := m.ctrl.Call(m, ""GenerateIDToken"", arg0, arg1)
 	ret0, _ := ret[0].(string)
 	ret1, _ := ret[1].(error)
"
GO-2021-0110,ory,fosite,0c9e0f6d654913ad57c507dd9a36631e1858a3e9," func (m *MockOpenIDConnectTokenStrategy) GenerateIDToken(arg0 context.Context, a
 
 // GenerateIDToken indicates an expected call of GenerateIDToken
 func (mr *MockOpenIDConnectTokenStrategyMockRecorder) GenerateIDToken(arg0, arg1 interface{}) *gomock.Call {
+	mr.mock.ctrl.T.Helper()
 	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""GenerateIDToken"", reflect.TypeOf((*MockOpenIDConnectTokenStrategy)(nil).GenerateIDToken), arg0, arg1)
 }
"
GO-2021-0110,ory,fosite,0c9e0f6d654913ad57c507dd9a36631e1858a3e9," func (m *MockTokenIntrospector) EXPECT() *MockTokenIntrospectorMockRecorder {
 
 // IntrospectToken mocks base method
 func (m *MockTokenIntrospector) IntrospectToken(arg0 context.Context, arg1 string, arg2 fosite.TokenType, arg3 fosite.AccessRequester, arg4 []string) (fosite.TokenType, error) {
+	m.ctrl.T.Helper()
 	ret := m.ctrl.Call(m, ""IntrospectToken"", arg0, arg1, arg2, arg3, arg4)
 	ret0, _ := ret[0].(fosite.TokenType)
 	ret1, _ := ret[1].(error)
"
GO-2021-0110,ory,fosite,0c9e0f6d654913ad57c507dd9a36631e1858a3e9," func (m *MockTokenIntrospector) IntrospectToken(arg0 context.Context, arg1 strin
 
 // IntrospectToken indicates an expected call of IntrospectToken
 func (mr *MockTokenIntrospectorMockRecorder) IntrospectToken(arg0, arg1, arg2, arg3, arg4 interface{}) *gomock.Call {
+	mr.mock.ctrl.T.Helper()
 	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""IntrospectToken"", reflect.TypeOf((*MockTokenIntrospector)(nil).IntrospectToken), arg0, arg1, arg2, arg3, arg4)
 }
"
GO-2021-0110,ory,fosite,0c9e0f6d654913ad57c507dd9a36631e1858a3e9," func (m *MockClientCredentialsGrantStorage) EXPECT() *MockClientCredentialsGrant
 
 // CreateAccessTokenSession mocks base method
 func (m *MockClientCredentialsGrantStorage) CreateAccessTokenSession(arg0 context.Context, arg1 string, arg2 fosite.Requester) error {
+	m.ctrl.T.Helper()
 	ret := m.ctrl.Call(m, ""CreateAccessTokenSession"", arg0, arg1, arg2)
 	ret0, _ := ret[0].(error)
 	return ret0
"
GO-2021-0110,ory,fosite,0c9e0f6d654913ad57c507dd9a36631e1858a3e9," func (m *MockClientCredentialsGrantStorage) GetAccessTokenSession(arg0 context.C
 
 // GetAccessTokenSession indicates an expected call of GetAccessTokenSession
 func (mr *MockClientCredentialsGrantStorageMockRecorder) GetAccessTokenSession(arg0, arg1, arg2 interface{}) *gomock.Call {
+	mr.mock.ctrl.T.Helper()
 	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""GetAccessTokenSession"", reflect.TypeOf((*MockClientCredentialsGrantStorage)(nil).GetAccessTokenSession), arg0, arg1, arg2)
 }
"
GO-2021-0110,ory,fosite,0c9e0f6d654913ad57c507dd9a36631e1858a3e9," func (m *MockResourceOwnerPasswordCredentialsGrantStorage) EXPECT() *MockResourc
 
 // Authenticate mocks base method
 func (m *MockResourceOwnerPasswordCredentialsGrantStorage) Authenticate(arg0 context.Context, arg1, arg2 string) error {
+	m.ctrl.T.Helper()
 	ret := m.ctrl.Call(m, ""Authenticate"", arg0, arg1, arg2)
 	ret0, _ := ret[0].(error)
 	return ret0
"
GO-2021-0110,ory,fosite,0c9e0f6d654913ad57c507dd9a36631e1858a3e9," func (m *MockResourceOwnerPasswordCredentialsGrantStorage) GetRefreshTokenSessio
 
 // GetRefreshTokenSession indicates an expected call of GetRefreshTokenSession
 func (mr *MockResourceOwnerPasswordCredentialsGrantStorageMockRecorder) GetRefreshTokenSession(arg0, arg1, arg2 interface{}) *gomock.Call {
+	mr.mock.ctrl.T.Helper()
 	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""GetRefreshTokenSession"", reflect.TypeOf((*MockResourceOwnerPasswordCredentialsGrantStorage)(nil).GetRefreshTokenSession), arg0, arg1, arg2)
 }
"
GO-2021-0110,ory,fosite,0c9e0f6d654913ad57c507dd9a36631e1858a3e9," func (m *MockTokenRevocationStorage) EXPECT() *MockTokenRevocationStorageMockRec
 
 // CreateAccessTokenSession mocks base method
 func (m *MockTokenRevocationStorage) CreateAccessTokenSession(arg0 context.Context, arg1 string, arg2 fosite.Requester) error {
+	m.ctrl.T.Helper()
 	ret := m.ctrl.Call(m, ""CreateAccessTokenSession"", arg0, arg1, arg2)
 	ret0, _ := ret[0].(error)
 	return ret0
"
GO-2021-0110,ory,fosite,0c9e0f6d654913ad57c507dd9a36631e1858a3e9," func (m *MockTokenRevocationStorage) RevokeRefreshToken(arg0 context.Context, ar
 
 // RevokeRefreshToken indicates an expected call of RevokeRefreshToken
 func (mr *MockTokenRevocationStorageMockRecorder) RevokeRefreshToken(arg0, arg1 interface{}) *gomock.Call {
+	mr.mock.ctrl.T.Helper()
 	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""RevokeRefreshToken"", reflect.TypeOf((*MockTokenRevocationStorage)(nil).RevokeRefreshToken), arg0, arg1)
 }
"
GO-2021-0110,ory,fosite,0c9e0f6d654913ad57c507dd9a36631e1858a3e9," func (m *MockCoreStorage) EXPECT() *MockCoreStorageMockRecorder {
 
 // CreateAccessTokenSession mocks base method
 func (m *MockCoreStorage) CreateAccessTokenSession(arg0 context.Context, arg1 string, arg2 fosite.Requester) error {
+	m.ctrl.T.Helper()
 	ret := m.ctrl.Call(m, ""CreateAccessTokenSession"", arg0, arg1, arg2)
 	ret0, _ := ret[0].(error)
 	return ret0
"
GO-2021-0110,ory,fosite,0c9e0f6d654913ad57c507dd9a36631e1858a3e9," func (m *MockCoreStorage) InvalidateAuthorizeCodeSession(arg0 context.Context, a
 
 // InvalidateAuthorizeCodeSession indicates an expected call of InvalidateAuthorizeCodeSession
 func (mr *MockCoreStorageMockRecorder) InvalidateAuthorizeCodeSession(arg0, arg1 interface{}) *gomock.Call {
+	mr.mock.ctrl.T.Helper()
 	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""InvalidateAuthorizeCodeSession"", reflect.TypeOf((*MockCoreStorage)(nil).InvalidateAuthorizeCodeSession), arg0, arg1)
 }
"
GO-2021-0110,ory,fosite,0c9e0f6d654913ad57c507dd9a36631e1858a3e9," func (m *MockCoreStrategy) EXPECT() *MockCoreStrategyMockRecorder {
 
 // AccessTokenSignature mocks base method
 func (m *MockCoreStrategy) AccessTokenSignature(arg0 string) string {
+	m.ctrl.T.Helper()
 	ret := m.ctrl.Call(m, ""AccessTokenSignature"", arg0)
 	ret0, _ := ret[0].(string)
 	return ret0
"
GO-2021-0110,ory,fosite,0c9e0f6d654913ad57c507dd9a36631e1858a3e9," func (m *MockCoreStrategy) ValidateRefreshToken(arg0 context.Context, arg1 fosit
 
 // ValidateRefreshToken indicates an expected call of ValidateRefreshToken
 func (mr *MockCoreStrategyMockRecorder) ValidateRefreshToken(arg0, arg1, arg2 interface{}) *gomock.Call {
+	mr.mock.ctrl.T.Helper()
 	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""ValidateRefreshToken"", reflect.TypeOf((*MockCoreStrategy)(nil).ValidateRefreshToken), arg0, arg1, arg2)
 }
"
GO-2021-0110,ory,fosite,0c9e0f6d654913ad57c507dd9a36631e1858a3e9," func (m *MockOpenIDConnectRequestStorage) EXPECT() *MockOpenIDConnectRequestStor
 
 // CreateOpenIDConnectSession mocks base method
 func (m *MockOpenIDConnectRequestStorage) CreateOpenIDConnectSession(arg0 context.Context, arg1 string, arg2 fosite.Requester) error {
+	m.ctrl.T.Helper()
 	ret := m.ctrl.Call(m, ""CreateOpenIDConnectSession"", arg0, arg1, arg2)
 	ret0, _ := ret[0].(error)
 	return ret0
"
GO-2021-0110,ory,fosite,0c9e0f6d654913ad57c507dd9a36631e1858a3e9," func (m *MockOpenIDConnectRequestStorage) GetOpenIDConnectSession(arg0 context.C
 
 // GetOpenIDConnectSession indicates an expected call of GetOpenIDConnectSession
 func (mr *MockOpenIDConnectRequestStorageMockRecorder) GetOpenIDConnectSession(arg0, arg1, arg2 interface{}) *gomock.Call {
+	mr.mock.ctrl.T.Helper()
 	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""GetOpenIDConnectSession"", reflect.TypeOf((*MockOpenIDConnectRequestStorage)(nil).GetOpenIDConnectSession), arg0, arg1, arg2)
 }
"
GO-2021-0110,ory,fosite,0c9e0f6d654913ad57c507dd9a36631e1858a3e9," func (m *MockPKCERequestStorage) EXPECT() *MockPKCERequestStorageMockRecorder {
 
 // CreatePKCERequestSession mocks base method
 func (m *MockPKCERequestStorage) CreatePKCERequestSession(arg0 context.Context, arg1 string, arg2 fosite.Requester) error {
+	m.ctrl.T.Helper()
 	ret := m.ctrl.Call(m, ""CreatePKCERequestSession"", arg0, arg1, arg2)
 	ret0, _ := ret[0].(error)
 	return ret0
"
GO-2021-0110,ory,fosite,0c9e0f6d654913ad57c507dd9a36631e1858a3e9," func (m *MockPKCERequestStorage) GetPKCERequestSession(arg0 context.Context, arg
 
 // GetPKCERequestSession indicates an expected call of GetPKCERequestSession
 func (mr *MockPKCERequestStorageMockRecorder) GetPKCERequestSession(arg0, arg1, arg2 interface{}) *gomock.Call {
+	mr.mock.ctrl.T.Helper()
 	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""GetPKCERequestSession"", reflect.TypeOf((*MockPKCERequestStorage)(nil).GetPKCERequestSession), arg0, arg1, arg2)
 }
"
GO-2021-0110,ory,fosite,0c9e0f6d654913ad57c507dd9a36631e1858a3e9," func (m *MockRefreshTokenStrategy) EXPECT() *MockRefreshTokenStrategyMockRecorde
 
 // GenerateRefreshToken mocks base method
 func (m *MockRefreshTokenStrategy) GenerateRefreshToken(arg0 context.Context, arg1 fosite.Requester) (string, string, error) {
+	m.ctrl.T.Helper()
 	ret := m.ctrl.Call(m, ""GenerateRefreshToken"", arg0, arg1)
 	ret0, _ := ret[0].(string)
 	ret1, _ := ret[1].(string)
"
GO-2021-0110,ory,fosite,0c9e0f6d654913ad57c507dd9a36631e1858a3e9," func (m *MockRefreshTokenStrategy) ValidateRefreshToken(arg0 context.Context, ar
 
 // ValidateRefreshToken indicates an expected call of ValidateRefreshToken
 func (mr *MockRefreshTokenStrategyMockRecorder) ValidateRefreshToken(arg0, arg1, arg2 interface{}) *gomock.Call {
+	mr.mock.ctrl.T.Helper()
 	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""ValidateRefreshToken"", reflect.TypeOf((*MockRefreshTokenStrategy)(nil).ValidateRefreshToken), arg0, arg1, arg2)
 }
"
GO-2021-0110,ory,fosite,0c9e0f6d654913ad57c507dd9a36631e1858a3e9," func (m *MockRevocationHandler) EXPECT() *MockRevocationHandlerMockRecorder {
 
 // RevokeToken mocks base method
 func (m *MockRevocationHandler) RevokeToken(arg0 context.Context, arg1 string, arg2 fosite.TokenType, arg3 fosite.Client) error {
+	m.ctrl.T.Helper()
 	ret := m.ctrl.Call(m, ""RevokeToken"", arg0, arg1, arg2, arg3)
 	ret0, _ := ret[0].(error)
 	return ret0
"
GO-2021-0110,ory,fosite,0c9e0f6d654913ad57c507dd9a36631e1858a3e9," func (m *MockRevocationHandler) RevokeToken(arg0 context.Context, arg1 string, a
 
 // RevokeToken indicates an expected call of RevokeToken
 func (mr *MockRevocationHandlerMockRecorder) RevokeToken(arg0, arg1, arg2, arg3 interface{}) *gomock.Call {
+	mr.mock.ctrl.T.Helper()
 	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""RevokeToken"", reflect.TypeOf((*MockRevocationHandler)(nil).RevokeToken), arg0, arg1, arg2, arg3)
 }
"
GO-2021-0110,ory,fosite,0c9e0f6d654913ad57c507dd9a36631e1858a3e9," func (m *MockTokenEndpointHandler) EXPECT() *MockTokenEndpointHandlerMockRecorde
 
 // HandleTokenEndpointRequest mocks base method
 func (m *MockTokenEndpointHandler) HandleTokenEndpointRequest(arg0 context.Context, arg1 fosite.AccessRequester) error {
+	m.ctrl.T.Helper()
 	ret := m.ctrl.Call(m, ""HandleTokenEndpointRequest"", arg0, arg1)
 	ret0, _ := ret[0].(error)
 	return ret0
"
GO-2021-0110,ory,fosite,0c9e0f6d654913ad57c507dd9a36631e1858a3e9," func (m *MockTokenEndpointHandler) PopulateTokenEndpointResponse(arg0 context.Co
 
 // PopulateTokenEndpointResponse indicates an expected call of PopulateTokenEndpointResponse
 func (mr *MockTokenEndpointHandlerMockRecorder) PopulateTokenEndpointResponse(arg0, arg1, arg2 interface{}) *gomock.Call {
+	mr.mock.ctrl.T.Helper()
 	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""PopulateTokenEndpointResponse"", reflect.TypeOf((*MockTokenEndpointHandler)(nil).PopulateTokenEndpointResponse), arg0, arg1, arg2)
 }
"
GO-2021-0110,ory,fosite,0c9e0f6d654913ad57c507dd9a36631e1858a3e9," func (m *MockTransactional) EXPECT() *MockTransactionalMockRecorder {
 
 // BeginTX mocks base method
 func (m *MockTransactional) BeginTX(arg0 context.Context) (context.Context, error) {
+	m.ctrl.T.Helper()
 	ret := m.ctrl.Call(m, ""BeginTX"", arg0)
 	ret0, _ := ret[0].(context.Context)
 	ret1, _ := ret[1].(error)
"
GO-2021-0110,ory,fosite,0c9e0f6d654913ad57c507dd9a36631e1858a3e9," func (m *MockTransactional) Rollback(arg0 context.Context) error {
 
 // Rollback indicates an expected call of Rollback
 func (mr *MockTransactionalMockRecorder) Rollback(arg0 interface{}) *gomock.Call {
+	mr.mock.ctrl.T.Helper()
 	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""Rollback"", reflect.TypeOf((*MockTransactional)(nil).Rollback), arg0)
 }
"
GO-2021-0110,ory,fosite,0c9e0f6d654913ad57c507dd9a36631e1858a3e9," func NewMemoryStore() *MemoryStore {
 		Users:                  make(map[string]MemoryUserRelation),
 		AccessTokenRequestIDs:  make(map[string]string),
 		RefreshTokenRequestIDs: make(map[string]string),
+		BlacklistedJTIs:        make(map[string]time.Time),
 	}
 }
 
"
GO-2021-0105,ethereum,go-ethereum,87c0ba92136a75db0ab2aba1046d4a9860375d6a," func (pre *Prestate) Apply(vmConfig vm.Config, chainConfig *params.ChainConfig,
 	}
 	execRs := &ExecutionResult{
 		StateRoot:   root,
-		TxRoot:      types.DeriveSha(includedTxs),
-		ReceiptRoot: types.DeriveSha(receipts),
+		TxRoot:      types.DeriveSha(includedTxs, new(trie.Trie)),
+		ReceiptRoot: types.DeriveSha(receipts, new(trie.Trie)),
 		Bloom:       types.CreateBloom(receipts),
 		LogsHash:    rlpHash(statedb.Logs()),
 		Receipts:    receipts,
"
GO-2021-0105,ethereum,go-ethereum,87c0ba92136a75db0ab2aba1046d4a9860375d6a," func (c *Clique) FinalizeAndAssemble(chain consensus.ChainHeaderReader, header *
 	header.UncleHash = types.CalcUncleHash(nil)
 
 	// Assemble and return the final block for sealing
-	return types.NewBlock(header, txs, nil, receipts), nil
+	return types.NewBlock(header, txs, nil, receipts, new(trie.Trie)), nil
 }
 
 // Authorize injects a private key into the consensus engine to mint new blocks
"
GO-2021-0105,ethereum,go-ethereum,87c0ba92136a75db0ab2aba1046d4a9860375d6a," func (ethash *Ethash) FinalizeAndAssemble(chain consensus.ChainHeaderReader, hea
 	header.Root = state.IntermediateRoot(chain.Config().IsEIP158(header.Number))
 
 	// Header seems complete, assemble into a block and return
-	return types.NewBlock(header, txs, uncles, receipts), nil
+	return types.NewBlock(header, txs, uncles, receipts, new(trie.Trie)), nil
 }
 
 // SealHash returns the hash of a block prior to it being sealed.
"
GO-2021-0105,ethereum,go-ethereum,87c0ba92136a75db0ab2aba1046d4a9860375d6a," func (v *BlockValidator) ValidateBody(block *types.Block) error {
 	if hash := types.CalcUncleHash(block.Uncles()); hash != header.UncleHash {
 		return fmt.Errorf(""uncle root hash mismatch: have %x, want %x"", hash, header.UncleHash)
 	}
-	if hash := types.DeriveSha(block.Transactions()); hash != header.TxHash {
+	if hash := types.DeriveSha(block.Transactions(), new(trie.Trie)); hash != header.TxHash {
 		return fmt.Errorf(""transaction root hash mismatch: have %x, want %x"", hash, header.TxHash)
 	}
 	if !v.bc.HasBlockAndState(block.ParentHash(), block.NumberU64()-1) {
"
GO-2021-0105,ethereum,go-ethereum,87c0ba92136a75db0ab2aba1046d4a9860375d6a," func (v *BlockValidator) ValidateState(block *types.Block, statedb *state.StateD
 		return fmt.Errorf(""invalid bloom (remote: %x  local: %x)"", header.Bloom, rbloom)
 	}
 	// Tre receipt Trie's root (R = (Tr [[H1, R1], ... [Hn, R1]]))
-	receiptSha := types.DeriveSha(receipts)
+	receiptSha := types.DeriveSha(receipts, new(trie.Trie))
 	if receiptSha != header.ReceiptHash {
 		return fmt.Errorf(""invalid receipt root hash (remote: %x local: %x)"", header.ReceiptHash, receiptSha)
 	}
"
GO-2021-0105,ethereum,go-ethereum,87c0ba92136a75db0ab2aba1046d4a9860375d6a," func (g *Genesis) ToBlock(db ethdb.Database) *types.Block {
 	statedb.Commit(false)
 	statedb.Database().TrieDB().Commit(root, true, nil)
 
-	return types.NewBlock(head, nil, nil, nil)
+	return types.NewBlock(head, nil, nil, nil, new(trie.Trie))
 }
 
 // Commit writes the block and state of a genesis specification to the database.
"
GO-2021-0105,ethereum,go-ethereum,87c0ba92136a75db0ab2aba1046d4a9860375d6a," func InspectDatabase(db ethdb.Database) error {
 		numHashPairing  common.StorageSize
 		hashNumPairing  common.StorageSize
 		trieSize        common.StorageSize
+		codeSize        common.StorageSize
 		txlookupSize    common.StorageSize
 		accountSnapSize common.StorageSize
 		storageSnapSize common.StorageSize
"
GO-2021-0105,ethereum,go-ethereum,87c0ba92136a75db0ab2aba1046d4a9860375d6a," func InspectDatabase(db ethdb.Database) error {
 			chtTrieNodes += size
 		case bytes.HasPrefix(key, []byte(""blt-"")) && len(key) == 4+common.HashLength:
 			bloomTrieNodes += size
+		case bytes.HasPrefix(key, codePrefix) && len(key) == len(codePrefix)+common.HashLength:
+			codeSize += size
 		case len(key) == common.HashLength:
 			trieSize += size
 		default:
"
GO-2021-0105,ethereum,go-ethereum,87c0ba92136a75db0ab2aba1046d4a9860375d6a," func InspectDatabase(db ethdb.Database) error {
 		{""Key-Value store"", ""Block hash->number"", hashNumPairing.String()},
 		{""Key-Value store"", ""Transaction index"", txlookupSize.String()},
 		{""Key-Value store"", ""Bloombit index"", bloomBitsSize.String()},
+		{""Key-Value store"", ""Contract codes"", codeSize.String()},
 		{""Key-Value store"", ""Trie nodes"", trieSize.String()},
 		{""Key-Value store"", ""Trie preimages"", preimageSize.String()},
 		{""Key-Value store"", ""Account snapshot"", accountSnapSize.String()},
"
GO-2021-0105,ethereum,go-ethereum,87c0ba92136a75db0ab2aba1046d4a9860375d6a," func NewDatabaseWithCache(db ethdb.Database, cache int, journal string) Database
 	return &cachingDB{
 		db:            trie.NewDatabaseWithCache(db, cache, journal),
 		codeSizeCache: csc,
+		codeCache:     fastcache.New(codeCacheSize),
 	}
 }
 
 type cachingDB struct {
 	db            *trie.Database
 	codeSizeCache *lru.Cache
+	codeCache     *fastcache.Cache
 }
 
 // OpenTrie opens the main account trie at a specific root hash.
"
GO-2021-0105,ethereum,go-ethereum,87c0ba92136a75db0ab2aba1046d4a9860375d6a," func (s *StateDB) Commit(deleteEmptyObjects bool) (common.Hash, error) {
 	s.IntermediateRoot(deleteEmptyObjects)
 
 	// Commit objects to the trie, measuring the elapsed time
+	codeWriter := s.db.TrieDB().DiskDB().NewBatch()
 	for addr := range s.stateObjectsDirty {
 		if obj := s.stateObjects[addr]; !obj.deleted {
 			// Write any contract code associated with the state object
 			if obj.code != nil && obj.dirtyCode {
-				s.db.TrieDB().InsertBlob(common.BytesToHash(obj.CodeHash()), obj.code)
+				rawdb.WriteCode(codeWriter, common.BytesToHash(obj.CodeHash()), obj.code)
 				obj.dirtyCode = false
 			}
 			// Write any storage changes in the state object to its storage trie
"
GO-2021-0105,ethereum,go-ethereum,87c0ba92136a75db0ab2aba1046d4a9860375d6a," func (s *StateDB) Commit(deleteEmptyObjects bool) (common.Hash, error) {
 	if len(s.stateObjectsDirty) > 0 {
 		s.stateObjectsDirty = make(map[common.Address]struct{})
 	}
+	if codeWriter.ValueSize() > 0 {
+		if err := codeWriter.Write(); err != nil {
+			log.Crit(""Failed to commit dirty codes"", ""error"", err)
+		}
+	}
 	// Write the account trie changes, measuing the amount of wasted time
 	var start time.Time
 	if metrics.EnabledExpensive {
"
GO-2021-0105,ethereum,go-ethereum,87c0ba92136a75db0ab2aba1046d4a9860375d6a," func NewStateSync(root common.Hash, database ethdb.KeyValueReader, bloom *trie.S
 			return err
 		}
 		syncer.AddSubTrie(obj.Root, 64, parent, nil)
-		syncer.AddRawEntry(common.BytesToHash(obj.CodeHash), 64, parent)
+		syncer.AddCodeEntry(common.BytesToHash(obj.CodeHash), 64, parent)
 		return nil
 	}
 	syncer = trie.NewSync(root, database, callback, bloom)
"
GO-2021-0105,ethereum,go-ethereum,87c0ba92136a75db0ab2aba1046d4a9860375d6a," type storageblock struct {
 // The values of TxHash, UncleHash, ReceiptHash and Bloom in header
 // are ignored and set to values derived from the given txs, uncles
 // and receipts.
-func NewBlock(header *Header, txs []*Transaction, uncles []*Header, receipts []*Receipt) *Block {
+func NewBlock(header *Header, txs []*Transaction, uncles []*Header, receipts []*Receipt, hasher Hasher) *Block {
 	b := &Block{header: CopyHeader(header), td: new(big.Int)}
 
 	// TODO: panic if len(txs) != len(receipts)
 	if len(txs) == 0 {
 		b.header.TxHash = EmptyRootHash
 	} else {
-		b.header.TxHash = DeriveSha(Transactions(txs))
+		b.header.TxHash = DeriveSha(Transactions(txs), hasher)
 		b.transactions = make(Transactions, len(txs))
 		copy(b.transactions, txs)
 	}
"
GO-2021-0105,ethereum,go-ethereum,87c0ba92136a75db0ab2aba1046d4a9860375d6a," func NewBlock(header *Header, txs []*Transaction, uncles []*Header, receipts []*
 	if len(receipts) == 0 {
 		b.header.ReceiptHash = EmptyRootHash
 	} else {
-		b.header.ReceiptHash = DeriveSha(Receipts(receipts))
+		b.header.ReceiptHash = DeriveSha(Receipts(receipts), hasher)
 		b.header.Bloom = CreateBloom(receipts)
 	}
 
"
GO-2021-0105,ethereum,go-ethereum,87c0ba92136a75db0ab2aba1046d4a9860375d6a," import (
 
 	""github.com/ethereum/go-ethereum/common""
 	""github.com/ethereum/go-ethereum/rlp""
-	""github.com/ethereum/go-ethereum/trie""
 )
 
+// DerivableList is the interface which can derive the hash.
 type DerivableList interface {
 	Len() int
 	GetRlp(i int) []byte
 }
 
-func DeriveSha(list DerivableList) common.Hash {
+// Hasher is the tool used to calculate the hash of derivable list.
+type Hasher interface {
+	Reset()
+	Update([]byte, []byte)
+	Hash() common.Hash
+}
+
+func DeriveSha(list DerivableList, hasher Hasher) common.Hash {
+	hasher.Reset()
 	keybuf := new(bytes.Buffer)
-	trie := new(trie.Trie)
 	for i := 0; i < list.Len(); i++ {
 		keybuf.Reset()
 		rlp.Encode(keybuf, uint(i))
-		trie.Update(keybuf.Bytes(), list.GetRlp(i))
+		hasher.Update(keybuf.Bytes(), list.GetRlp(i))
 	}
-	return trie.Hash()
+	return hasher.Hash()
 }
"
GO-2021-0105,ethereum,go-ethereum,87c0ba92136a75db0ab2aba1046d4a9860375d6a," func (q *queue) DeliverBodies(id string, txLists [][]*types.Transaction, uncleLi
 	q.lock.Lock()
 	defer q.lock.Unlock()
 	validate := func(index int, header *types.Header) error {
-		if types.DeriveSha(types.Transactions(txLists[index])) != header.TxHash {
+		if types.DeriveSha(types.Transactions(txLists[index]), new(trie.Trie)) != header.TxHash {
 			return errInvalidBody
 		}
 		if types.CalcUncleHash(uncleLists[index]) != header.UncleHash {
"
GO-2021-0105,ethereum,go-ethereum,87c0ba92136a75db0ab2aba1046d4a9860375d6a," func (q *queue) DeliverReceipts(id string, receiptList [][]*types.Receipt) (int,
 	q.lock.Lock()
 	defer q.lock.Unlock()
 	validate := func(index int, header *types.Header) error {
-		if types.DeriveSha(types.Receipts(receiptList[index])) != header.ReceiptHash {
+		if types.DeriveSha(types.Receipts(receiptList[index]), new(trie.Trie)) != header.ReceiptHash {
 			return errInvalidReceipt
 		}
 		return nil
"
GO-2021-0105,ethereum,go-ethereum,87c0ba92136a75db0ab2aba1046d4a9860375d6a," func (s *stateSync) process(req *stateReq) (int, error) {
 
 	// Iterate over all the delivered data and inject one-by-one into the trie
 	for _, blob := range req.response {
-		_, hash, err := s.processNodeData(blob)
+		hash, err := s.processNodeData(blob)
 		switch err {
 		case nil:
 			s.numUncommitted++
"
GO-2021-0105,ethereum,go-ethereum,87c0ba92136a75db0ab2aba1046d4a9860375d6a," func (s *stateSync) process(req *stateReq) (int, error) {
 // processNodeData tries to inject a trie node data blob delivered from a remote
 // peer into the state trie, returning whether anything useful was written or any
 // error occurred.
-func (s *stateSync) processNodeData(blob []byte) (bool, common.Hash, error) {
+func (s *stateSync) processNodeData(blob []byte) (common.Hash, error) {
 	res := trie.SyncResult{Data: blob}
 	s.keccak.Reset()
 	s.keccak.Write(blob)
 	s.keccak.Sum(res.Hash[:0])
-	committed, _, err := s.sched.Process([]trie.SyncResult{res})
-	return committed, res.Hash, err
+	err := s.sched.Process(res)
+	return res.Hash, err
 }
 
 // updateStats bumps the various state sync progress counters and displays a log
"
GO-2021-0105,ethereum,go-ethereum,87c0ba92136a75db0ab2aba1046d4a9860375d6a," func (f *BlockFetcher) loop() {
 						announce.time = task.time
 
 						// If the block is empty (header only), short circuit into the final import queue
-						if header.TxHash == types.DeriveSha(types.Transactions{}) && header.UncleHash == types.CalcUncleHash([]*types.Header{}) {
+						if header.TxHash == types.EmptyRootHash && header.UncleHash == types.EmptyUncleHash {
 							log.Trace(""Block empty, skipping body retrieval"", ""peer"", announce.origin, ""number"", header.Number, ""hash"", header.Hash())
 
 							block := types.NewBlockWithHeader(header)
"
GO-2021-0105,ethereum,go-ethereum,87c0ba92136a75db0ab2aba1046d4a9860375d6a," func (f *BlockFetcher) loop() {
 							continue
 						}
 						if txnHash == (common.Hash{}) {
-							txnHash = types.DeriveSha(types.Transactions(task.transactions[i]))
+							txnHash = types.DeriveSha(types.Transactions(task.transactions[i]), new(trie.Trie))
 						}
 						if txnHash != announce.header.TxHash {
 							continue
"
GO-2021-0105,ethereum,go-ethereum,87c0ba92136a75db0ab2aba1046d4a9860375d6a," func (pm *ProtocolManager) handleMsg(p *peer) error {
 				return errResp(ErrDecode, ""msg %v: %v"", msg, err)
 			}
 			// Retrieve the requested state entry, stopping if enough was found
-			if entry, err := pm.blockchain.TrieNode(hash); err == nil {
+			// todo now the code and trienode is mixed in the protocol level,
+			// separate these two types.
+			entry, err := pm.blockchain.TrieNode(hash)
+			if len(entry) == 0 || err != nil {
+				// Read the contract code with prefix only to save unnecessary lookups.
+				entry, err = pm.blockchain.ContractCodeWithPrefix(hash)
+			}
+			if err == nil && len(entry) > 0 {
 				data = append(data, entry)
 				bytes += len(entry)
 			}
"
GO-2021-0105,ethereum,go-ethereum,87c0ba92136a75db0ab2aba1046d4a9860375d6a," func (pm *ProtocolManager) handleMsg(p *peer) error {
 			log.Warn(""Propagated block has invalid uncles"", ""have"", hash, ""exp"", request.Block.UncleHash())
 			break // TODO(karalabe): return error eventually, but wait a few releases
 		}
-		if hash := types.DeriveSha(request.Block.Transactions()); hash != request.Block.TxHash() {
+		if hash := types.DeriveSha(request.Block.Transactions(), new(trie.Trie)); hash != request.Block.TxHash() {
 			log.Warn(""Propagated block has invalid body"", ""have"", hash, ""exp"", request.Block.TxHash())
 			break // TODO(karalabe): return error eventually, but wait a few releases
 		}
"
GO-2021-0105,ethereum,go-ethereum,87c0ba92136a75db0ab2aba1046d4a9860375d6a," func (r *BlockRequest) Validate(db ethdb.Database, msg *Msg) error {
 	if r.Header == nil {
 		return errHeaderUnavailable
 	}
-	if r.Header.TxHash != types.DeriveSha(types.Transactions(body.Transactions)) {
+	if r.Header.TxHash != types.DeriveSha(types.Transactions(body.Transactions), new(trie.Trie)) {
 		return errTxHashMismatch
 	}
 	if r.Header.UncleHash != types.CalcUncleHash(body.Uncles) {
"
GO-2021-0105,ethereum,go-ethereum,87c0ba92136a75db0ab2aba1046d4a9860375d6a," func (r *ReceiptsRequest) Validate(db ethdb.Database, msg *Msg) error {
 	if r.Header == nil {
 		return errHeaderUnavailable
 	}
-	if r.Header.ReceiptHash != types.DeriveSha(receipt) {
+	if r.Header.ReceiptHash != types.DeriveSha(receipt, new(trie.Trie)) {
 		return errReceiptHashMismatch
 	}
 	// Validations passed, store and return
"
GO-2021-0105,ethereum,go-ethereum,87c0ba92136a75db0ab2aba1046d4a9860375d6a," func (h *serverHandler) handleMsg(p *clientPeer, wg *sync.WaitGroup) error {
 						p.bumpInvalid()
 						continue
 					}
-					code, err := triedb.Node(common.BytesToHash(account.CodeHash))
+					code, err := h.blockchain.StateCache().ContractCode(common.BytesToHash(request.AccKey), common.BytesToHash(account.CodeHash))
 					if err != nil {
 						p.Log().Warn(""Failed to retrieve account code"", ""block"", header.Number, ""hash"", header.Hash(), ""account"", common.BytesToHash(request.AccKey), ""codehash"", common.BytesToHash(account.CodeHash), ""err"", err)
 						continue
"
GO-2021-0105,ethereum,go-ethereum,87c0ba92136a75db0ab2aba1046d4a9860375d6a," type CodeRequest struct {
 
 // StoreResult stores the retrieved data in local database
 func (req *CodeRequest) StoreResult(db ethdb.Database) {
-	db.Put(req.Hash[:], req.Data)
+	rawdb.WriteCode(db, req.Hash, req.Data)
 }
 
 // BlockRequest is the ODR request type for retrieving block bodies
"
GO-2021-0105,ethereum,go-ethereum,87c0ba92136a75db0ab2aba1046d4a9860375d6a," func (db *odrDatabase) ContractCode(addrHash, codeHash common.Hash) ([]byte, err
 	if codeHash == sha3Nil {
 		return nil, nil
 	}
-	if code, err := db.backend.Database().Get(codeHash[:]); err == nil {
+	code := rawdb.ReadCode(db.backend.Database(), codeHash)
+	if len(code) != 0 {
 		return code, nil
 	}
 	id := *db.id
"
GO-2021-0105,ethereum,go-ethereum,87c0ba92136a75db0ab2aba1046d4a9860375d6a," func (w *worker) updateSnapshot() {
 		w.current.txs,
 		uncles,
 		w.current.receipts,
+		new(trie.Trie),
 	)
 
 	w.snapshotState = w.current.state.Copy()
"
GO-2021-0105,ethereum,go-ethereum,87c0ba92136a75db0ab2aba1046d4a9860375d6a," var cachedNodeSize = int(reflect.TypeOf(cachedNode{}).Size())
 // reference map.
 const cachedNodeChildrenSize = 48
 
-// rlp returns the raw rlp encoded blob of the cached node, either directly from
-// the cache, or by regenerating it from the collapsed node.
+// rlp returns the raw rlp encoded blob of the cached trie node, either directly
+// from the cache, or by regenerating it from the collapsed node.
 func (n *cachedNode) rlp() []byte {
 	if node, ok := n.node.(rawNode); ok {
 		return node
"
GO-2021-0105,ethereum,go-ethereum,87c0ba92136a75db0ab2aba1046d4a9860375d6a," func (n *cachedNode) obj(hash common.Hash) node {
 	return expandNode(hash[:], n.node)
 }
 
-// forChilds invokes the callback for  all the tracked children of this node,
-// both the implicit ones  from inside the node as well as the explicit ones
-//from outside the node.
+// forChilds invokes the callback for all the tracked children of this node,
+// both the implicit ones from inside the node as well as the explicit ones
+// from outside the node.
 func (n *cachedNode) forChilds(onChild func(hash common.Hash)) {
 	for child := range n.children {
 		onChild(child)
"
GO-2021-0105,ethereum,go-ethereum,87c0ba92136a75db0ab2aba1046d4a9860375d6a," func (db *Database) Nodes() []common.Hash {
 }
 
 // Reference adds a new reference from a parent node to a child node.
+// This function is used to add reference between internal trie node
+// and external node(e.g. storage trie root), all internal trie nodes
+// are referenced together by database itself.
 func (db *Database) Reference(child common.Hash, parent common.Hash) {
 	db.lock.Lock()
 	defer db.lock.Unlock()
"
GO-2021-0105,ethereum,go-ethereum,87c0ba92136a75db0ab2aba1046d4a9860375d6a," func (db *Database) Cap(limit common.StorageSize) error {
 	size := db.dirtiesSize + common.StorageSize((len(db.dirties)-1)*cachedNodeSize)
 	size += db.childrenSize - common.StorageSize(len(db.dirties[common.Hash{}].children)*(common.HashLength+2))
 
-	// We reuse an ephemeral buffer for the keys. The batch Put operation
-	// copies it internally, so we can reuse it.
-	var keyBuf [secureKeyLength]byte
-	copy(keyBuf[:], secureKeyPrefix)
-
 	// If the preimage cache got large enough, push to disk. If it's still small
 	// leave for later to deduplicate writes.
 	flushPreimages := db.preimagesSize > 4*1024*1024
 	if flushPreimages {
-		for hash, preimage := range db.preimages {
-			copy(keyBuf[secureKeyPrefixLength:], hash[:])
-			if err := batch.Put(keyBuf[:], preimage); err != nil {
-				log.Error(""Failed to commit preimage from trie database"", ""err"", err)
+		rawdb.WritePreimages(batch, db.preimages)
+		if batch.ValueSize() > ethdb.IdealBatchSize {
+			if err := batch.Write(); err != nil {
 				return err
 			}
-			if batch.ValueSize() > ethdb.IdealBatchSize {
-				if err := batch.Write(); err != nil {
-					return err
-				}
-				batch.Reset()
-			}
+			batch.Reset()
 		}
 	}
 	// Keep committing nodes from the flush-list until we're below allowance
"
GO-2021-0105,ethereum,go-ethereum,87c0ba92136a75db0ab2aba1046d4a9860375d6a," func (db *Database) Cap(limit common.StorageSize) error {
 	for size > limit && oldest != (common.Hash{}) {
 		// Fetch the oldest referenced node and push into the batch
 		node := db.dirties[oldest]
-		if err := batch.Put(oldest[:], node.rlp()); err != nil {
-			return err
-		}
+		rawdb.WriteTrieNode(batch, oldest, node.rlp())
+
 		// If we exceeded the ideal batch size, commit and reset
 		if batch.ValueSize() >= ethdb.IdealBatchSize {
 			if err := batch.Write(); err != nil {
"
GO-2021-0105,ethereum,go-ethereum,87c0ba92136a75db0ab2aba1046d4a9860375d6a," func (db *Database) Cap(limit common.StorageSize) error {
 	defer db.lock.Unlock()
 
 	if flushPreimages {
-		db.preimages = make(map[common.Hash][]byte)
-		db.preimagesSize = 0
+		db.preimages, db.preimagesSize = make(map[common.Hash][]byte), 0
 	}
 	for db.oldest != oldest {
 		node := db.dirties[db.oldest]
"
GO-2021-0105,ethereum,go-ethereum,87c0ba92136a75db0ab2aba1046d4a9860375d6a," func (db *Database) Commit(node common.Hash, report bool, callback func(common.H
 	start := time.Now()
 	batch := db.diskdb.NewBatch()
 
-	// We reuse an ephemeral buffer for the keys. The batch Put operation
-	// copies it internally, so we can reuse it.
-	var keyBuf [secureKeyLength]byte
-	copy(keyBuf[:], secureKeyPrefix)
-
 	// Move all of the accumulated preimages into a write batch
-	for hash, preimage := range db.preimages {
-		copy(keyBuf[secureKeyPrefixLength:], hash[:])
-		if err := batch.Put(keyBuf[:], preimage); err != nil {
-			log.Error(""Failed to commit preimage from trie database"", ""err"", err)
+	rawdb.WritePreimages(batch, db.preimages)
+	if batch.ValueSize() > ethdb.IdealBatchSize {
+		if err := batch.Write(); err != nil {
 			return err
 		}
-		// If the batch is too large, flush to disk
-		if batch.ValueSize() > ethdb.IdealBatchSize {
-			if err := batch.Write(); err != nil {
-				return err
-			}
-			batch.Reset()
-		}
+		batch.Reset()
 	}
 	// Since we're going to replay trie node writes into the clean cache, flush out
 	// any batched pre-images before continuing.
"
GO-2021-0105,ethereum,go-ethereum,87c0ba92136a75db0ab2aba1046d4a9860375d6a," func (db *Database) Commit(node common.Hash, report bool, callback func(common.H
 	batch.Reset()
 
 	// Reset the storage counters and bumpd metrics
-	db.preimages = make(map[common.Hash][]byte)
-	db.preimagesSize = 0
+	db.preimages, db.preimagesSize = make(map[common.Hash][]byte), 0
 
 	memcacheCommitTimeTimer.Update(time.Since(start))
 	memcacheCommitSizeMeter.Mark(int64(storage - db.dirtiesSize))
"
GO-2021-0105,ethereum,go-ethereum,87c0ba92136a75db0ab2aba1046d4a9860375d6a," func (db *Database) commit(hash common.Hash, batch ethdb.Batch, uncacher *cleane
 	if err != nil {
 		return err
 	}
-	if err := batch.Put(hash[:], node.rlp()); err != nil {
-		return err
-	}
+	// If we've reached an optimal batch size, commit and start over
+	rawdb.WriteTrieNode(batch, hash, node.rlp())
 	if callback != nil {
 		callback(hash)
 	}
-	// If we've reached an optimal batch size, commit and start over
 	if batch.ValueSize() >= ethdb.IdealBatchSize {
 		if err := batch.Write(); err != nil {
 			return err
"
GO-2021-0105,ethereum,go-ethereum,87c0ba92136a75db0ab2aba1046d4a9860375d6a," func (t *SecureTrie) GetKey(shaKey []byte) []byte {
 	if key, ok := t.getSecKeyCache()[string(shaKey)]; ok {
 		return key
 	}
-	key, _ := t.trie.db.preimage(common.BytesToHash(shaKey))
-	return key
+	return t.trie.db.preimage(common.BytesToHash(shaKey))
 }
 
 // Commit writes all nodes and the secure hash pre-images to the trie's database.
"
GO-2021-0105,ethereum,go-ethereum,87c0ba92136a75db0ab2aba1046d4a9860375d6a," func NewSync(root common.Hash, database ethdb.KeyValueReader, callback LeafCallb
 	ts := &Sync{
 		database: database,
 		membatch: newSyncMemBatch(),
-		requests: make(map[common.Hash]*request),
+		nodeReqs: make(map[common.Hash]*request),
+		codeReqs: make(map[common.Hash]*request),
 		queue:    prque.New(nil),
 		bloom:    bloom,
 	}
"
GO-2021-0105,ethereum,go-ethereum,87c0ba92136a75db0ab2aba1046d4a9860375d6a," func (s *Sync) AddSubTrie(root common.Hash, depth int, parent common.Hash, callb
 	if root == emptyRoot {
 		return
 	}
-	if _, ok := s.membatch.batch[root]; ok {
+	if s.membatch.hasNode(root) {
 		return
 	}
 	if s.bloom == nil || s.bloom.Contains(root[:]) {
-		// Bloom filter says this might be a duplicate, double check
-		blob, _ := s.database.Get(root[:])
-		if local, err := decodeNode(root[:], blob); local != nil && err == nil {
+		// Bloom filter says this might be a duplicate, double check.
+		// If database says yes, then at least the trie node is present
+		// and we hold the assumption that it's NOT legacy contract code.
+		blob := rawdb.ReadTrieNode(s.database, root)
+		if len(blob) > 0 {
 			return
 		}
 		// False positive, bump fault meter
"
GO-2021-0105,ethereum,go-ethereum,87c0ba92136a75db0ab2aba1046d4a9860375d6a," func (s *Sync) AddSubTrie(root common.Hash, depth int, parent common.Hash, callb
 	}
 	// If this sub-trie has a designated parent, link them together
 	if parent != (common.Hash{}) {
-		ancestor := s.requests[parent]
+		ancestor := s.nodeReqs[parent]
 		if ancestor == nil {
 			panic(fmt.Sprintf(""sub-trie ancestor not found: %x"", parent))
 		}
"
GO-2021-0105,ethereum,go-ethereum,87c0ba92136a75db0ab2aba1046d4a9860375d6a," func (s *Sync) children(req *request, object node) ([]*request, error) {
 		if node, ok := (child.node).(hashNode); ok {
 			// Try to resolve the node from the local database
 			hash := common.BytesToHash(node)
-			if _, ok := s.membatch.batch[hash]; ok {
+			if s.membatch.hasNode(hash) {
 				continue
 			}
 			if s.bloom == nil || s.bloom.Contains(node) {
-				// Bloom filter says this might be a duplicate, double check
-				if ok, _ := s.database.Has(node); ok {
+				// Bloom filter says this might be a duplicate, double check.
+				// If database says yes, then at least the trie node is present
+				// and we hold the assumption that it's NOT legacy contract code.
+				if blob := rawdb.ReadTrieNode(s.database, common.BytesToHash(node)); len(blob) > 0 {
 					continue
 				}
 				// False positive, bump fault meter
"
GO-2021-0105,ethereum,go-ethereum,87c0ba92136a75db0ab2aba1046d4a9860375d6a," func (s *Sync) children(req *request, object node) ([]*request, error) {
 // committed themselves.
 func (s *Sync) commit(req *request) (err error) {
 	// Write the node content to the membatch
-	s.membatch.batch[req.hash] = req.data
-
-	delete(s.requests, req.hash)
-
+	if req.code {
+		s.membatch.codes[req.hash] = req.data
+		delete(s.codeReqs, req.hash)
+	} else {
+		s.membatch.nodes[req.hash] = req.data
+		delete(s.nodeReqs, req.hash)
+	}
 	// Check all parents for completion
 	for _, parent := range req.parents {
 		parent.deps--
"
GO-2021-0105,ethereum,go-ethereum,87c0ba92136a75db0ab2aba1046d4a9860375d6a," func (b *SyncBloom) init(database ethdb.Iteratee) {
 	)
 	for it.Next() && atomic.LoadUint32(&b.closed) == 0 {
 		// If the database entry is a trie node, add it to the bloom
-		if key := it.Key(); len(key) == common.HashLength {
+		key := it.Key()
+		if len(key) == common.HashLength {
 			b.bloom.Add(syncBloomHasher(key))
 			bloomLoadMeter.Mark(1)
 		}
+		// If the database entry is a contract code, add it to the bloom
+		if ok, hash := rawdb.IsCodeKey(key); ok {
+			b.bloom.Add(syncBloomHasher(hash))
+			bloomLoadMeter.Mark(1)
+		}
 		// If enough time elapsed since the last iterator swap, restart
 		if time.Since(swap) > 8*time.Second {
 			key := common.CopyBytes(it.Key())
"
GO-2021-0105,ethereum,go-ethereum,87c0ba92136a75db0ab2aba1046d4a9860375d6a," func (t *Trie) hashRoot(db *Database) (node, node, error) {
 	t.unhashed = 0
 	return hashed, cached, nil
 }
+
+// Reset drops the referenced root node and cleans all internal state.
+func (t *Trie) Reset() {
+	t.root = nil
+	t.unhashed = 0
+}
"
GO-2021-0105,ethereum,go-ethereum,87c0ba92136a75db0ab2aba1046d4a9860375d6a," func (s *StateDB) Commit(deleteEmptyObjects bool) (common.Hash, error) {
 		if account.Root != emptyRoot {
 			s.db.TrieDB().Reference(account.Root, parent)
 		}
-		code := common.BytesToHash(account.CodeHash)
-		if code != emptyCode {
-			s.db.TrieDB().Reference(code, parent)
-		}
 		return nil
 	})
 	if metrics.EnabledExpensive {
"
GO-2022-0248,cloudflare,cfrpki,eb9cc4db7b7b79e44f56dfaa959fccdfb2af8284," func (s *state) WriteRsyncFileOnDisk(path string, data []byte, withdraw bool) er
 	if err != nil {
 		log.Fatal(err)
 	}
-	// GHSA-cqh2-vc2f-q4fh: Prevent parent directory writes outside of Basepath
-	fPath = strings.ReplaceAll(fPath, ""../"", """")
+	// GHSA-8459-6rc9-8vf8: Prevent parent directory writes outside of Basepath
+	if strings.Contains(fPath, ""../"") || strings.Contains(fPath, ""..\\"") {
+		return fmt.Errorf(""Path %q contains illegal path element"", fPath)
+	}
 
 	f, err := os.Create(filepath.Join(s.Basepath, fPath))
 	if err != nil {
"
GO-2022-0248,cloudflare,cfrpki,eb9cc4db7b7b79e44f56dfaa959fccdfb2af8284," func (v *Validator) ValidateROA(roa *librpki.RPKIROA) error {
 }
 
 func (v *Validator) AddManifest(pkifile *PKIFile, mft *librpki.RPKIManifest) (bool, []*PKIFile, *Resource, error) {
-	pathCert := ExtractPathManifest(mft)
+	pathCert, err := ExtractPathManifest(mft)
+	if err != nil {
+		return false, nil, nil, fmt.Errorf(""ExtractPathManifest failed: %v"", err)
+	}
 
 	valid, _, res, err := v.AddCert(mft.Certificate, false)
 	if res == nil {
"
GO-2023-1623,crossplane,crossplane-runtime,53508a9f4374604db140dd8ab2fa52276441e738," func (p *Paved) setValue(s Segments, value any) error {
 				return errors.Errorf(""%s is not an array"", s[:i])
 			}
 
+			if p.maxFieldPathIndexEnabled() && current.Index > p.maxFieldPathIndex {
+				return errors.Errorf(""index %d is greater than max allowed index %d"", current.Index, p.maxFieldPathIndex)
+			}
+
 			if final {
 				array[current.Index] = v
 				return nil
"
GO-2021-0058,crewjam,saml,da4f1a0612c0a8dd0452cf8b3c7a6518f6b4d053," func NewIdpAuthnRequest(idp *IdentityProvider, r *http.Request) (*IdpAuthnReques
 	default:
 		return nil, fmt.Errorf(""method not allowed"")
 	}
+
 	return req, nil
 }
 
"
GO-2021-0098,git-lfs,git-lfs,fc664697ed2c2081ee9633010de0a7f9debea72a," func (h *commandCredentialHelper) Approve(creds Creds) error {
 
 func (h *commandCredentialHelper) exec(subcommand string, input Creds) (Creds, error) {
 	output := new(bytes.Buffer)
-	cmd := exec.Command(""git"", ""credential"", subcommand)
+	cmd := subprocess.ExecCommand(""git"", ""credential"", subcommand)
 	cmd.Stdin = bufferCreds(input)
 	cmd.Stdout = output
 	/*
"
GO-2023-1602,russellhaering,gosaml2,f9d66040241093e8702649baff50cc70d2c683c0," func (sp *SAMLServiceProvider) decryptAssertions(el *etree.Element) error {
 			return fmt.Errorf(""unable to decrypt encrypted assertion: %v"", derr)
 		}
 
-		doc, _, err := parseResponse(raw)
+		doc, _, err := parseResponse(raw, sp.MaximumDecompressedBodySize)
 		if err != nil {
 			return fmt.Errorf(""unable to create element from decrypted assertion bytes: %v"", err)
 		}
"
GO-2022-0980,hashicorp,consul-template,d6a6f4af219c28e67d847ba0e0b2bea8f5bb9076," func (t *Template) Execute(i *ExecuteInput) (*ExecuteResult, error) {
 	}, nil
 }
 
+func redactinator(used *dep.Set, b *Brain, err error) error {
+	pairs := make([]string, 0, used.Len())
+	for _, d := range used.List() {
+		if data, ok := b.Recall(d); ok {
+			if vd, ok := data.(*dep.Secret); ok {
+				for _, v := range vd.Data {
+					pairs = append(pairs, fmt.Sprintf(""%v"", v), ""[redacted]"")
+				}
+			}
+		}
+	}
+	return fmt.Errorf(strings.NewReplacer(pairs...).Replace(err.Error()))
+}
+
 // funcMapInput is input to the funcMap, which builds the template functions.
 type funcMapInput struct {
 	newTmpl          *template.Template
"
GO-2021-0072,distribution,distribution,91c507a39abfce14b5c8541cf284330e22208c0f," func (buh *blobUploadHandler) PatchBlobData(w http.ResponseWriter, r *http.Reque
 
 	// TODO(dmcgowan): support Content-Range header to seek and write range
 
-	if err := copyFullPayload(w, r, buh.Upload, buh, ""blob PATCH"", &buh.Errors); err != nil {
-		// copyFullPayload reports the error if necessary
+	if err := copyFullPayload(w, r, buh.Upload, -1, buh, ""blob PATCH""); err != nil {
+		buh.Errors = append(buh.Errors, errcode.ErrorCodeUnknown.WithDetail(err.Error()))
 		return
 	}
 
"
GO-2021-0072,distribution,distribution,91c507a39abfce14b5c8541cf284330e22208c0f," func (buh *blobUploadHandler) PutBlobUploadComplete(w http.ResponseWriter, r *ht
 		return
 	}
 
-	if err := copyFullPayload(w, r, buh.Upload, buh, ""blob PUT"", &buh.Errors); err != nil {
-		// copyFullPayload reports the error if necessary
+	if err := copyFullPayload(w, r, buh.Upload, -1, buh, ""blob PUT""); err != nil {
+		buh.Errors = append(buh.Errors, errcode.ErrorCodeUnknown.WithDetail(err.Error()))
 		return
 	}
 
"
GO-2021-0072,distribution,distribution,91c507a39abfce14b5c8541cf284330e22208c0f," func (imh *manifestHandler) PutManifest(w http.ResponseWriter, r *http.Request)
 	}
 
 	var jsonBuf bytes.Buffer
-	if err := copyFullPayload(w, r, &jsonBuf, imh, ""image manifest PUT"", &imh.Errors); err != nil {
+	if err := copyFullPayload(w, r, &jsonBuf, maxManifestBodySize, imh, ""image manifest PUT""); err != nil {
 		// copyFullPayload reports the error if necessary
+		imh.Errors = append(imh.Errors, v2.ErrorCodeManifestInvalid.WithDetail(err.Error()))
 		return
 	}
 
"
GO-2022-0300,graph-gophers,graphql-go,eae31ca73eb3473c544710955d1dbebc22605bfe," func Validate(s *types.Schema, doc *types.ExecutableDefinition, variables map[st
 
 		// Check if max depth is exceeded, if it's set. If max depth is exceeded,
 		// don't continue to validate the document and exit early.
-		if validateMaxDepth(opc, op.Selections, 1) {
+		if validateMaxDepth(opc, op.Selections, nil, 1) {
 			return c.errs
 		}
 
"
GO-2022-0300,graph-gophers,graphql-go,eae31ca73eb3473c544710955d1dbebc22605bfe," func validateValue(c *opContext, v *types.InputValueDefinition, val interface{},
 
 // validates the query doesn't go deeper than maxDepth (if set). Returns whether
 // or not query validated max depth to avoid excessive recursion.
-func validateMaxDepth(c *opContext, sels []types.Selection, depth int) bool {
+//
+// The visited map is necessary to ensure that max depth validation does not get stuck in cyclical
+// fragment spreads.
+func validateMaxDepth(c *opContext, sels []types.Selection, visited map[*types.FragmentDefinition]struct{}, depth int) bool {
 	// maxDepth checking is turned off when maxDepth is 0
 	if c.maxDepth == 0 {
 		return false
 	}
 
 	exceededMaxDepth := false
+	if visited == nil {
+		visited = map[*types.FragmentDefinition]struct{}{}
+	}
 
 	for _, sel := range sels {
 		switch sel := sel.(type) {
"
GO-2022-0300,graph-gophers,graphql-go,eae31ca73eb3473c544710955d1dbebc22605bfe," func validateMaxDepth(c *opContext, sels []types.Selection, depth int) bool {
 				c.addErr(sel.Alias.Loc, ""MaxDepthExceeded"", ""Field %q has depth %d that exceeds max depth %d"", sel.Name.Name, depth, c.maxDepth)
 				continue
 			}
-			exceededMaxDepth = exceededMaxDepth || validateMaxDepth(c, sel.SelectionSet, depth+1)
+			exceededMaxDepth = exceededMaxDepth || validateMaxDepth(c, sel.SelectionSet, visited, depth+1)
+
 		case *types.InlineFragment:
 			// Depth is not checked because inline fragments resolve to other fields which are checked.
 			// Depth is not incremented because inline fragments have the same depth as neighboring fields
-			exceededMaxDepth = exceededMaxDepth || validateMaxDepth(c, sel.Selections, depth)
+			exceededMaxDepth = exceededMaxDepth || validateMaxDepth(c, sel.Selections, visited, depth)
 		case *types.FragmentSpread:
 			// Depth is not checked because fragments resolve to other fields which are checked.
 			frag := c.doc.Fragments.Get(sel.Name.Name)
"
GO-2022-0300,graph-gophers,graphql-go,eae31ca73eb3473c544710955d1dbebc22605bfe," func validateMaxDepth(c *opContext, sels []types.Selection, depth int) bool {
 				c.addErr(sel.Loc, ""MaxDepthEvaluationError"", ""Unknown fragment %q. Unable to evaluate depth."", sel.Name.Name)
 				continue
 			}
+
+			if _, ok := visited[frag]; ok {
+				// we've already seen this fragment, don't check depth again.
+				continue
+			}
+			visited[frag] = struct{}{}
+
 			// Depth is not incremented because fragments have the same depth as surrounding fields
-			exceededMaxDepth = exceededMaxDepth || validateMaxDepth(c, frag.Selections, depth)
+			exceededMaxDepth = exceededMaxDepth || validateMaxDepth(c, frag.Selections, visited, depth)
 		}
 	}
 
"
GO-2022-1114,duke-git,lancet,f133b32faa05eb93e66175d01827afa4b7094572," func UnZip(zipFile string, destPath string) error {
 	return nil
 }
 
+func safeFilepathJoin(path1, path2 string) (string, error) {
+	relPath, err := filepath.Rel(""."", path2)
+	if err != nil || strings.HasPrefix(relPath, "".."") {
+		return """", fmt.Errorf(""(zipslip) filepath is unsafe %q: %v"", path2, err)
+	}
+	if path1 == """" {
+		path1 = "".""
+	}
+	return filepath.Join(path1, filepath.Join(""/"", relPath)), nil
+}
+
 // IsLink checks if a file is symbol link or not
 func IsLink(path string) bool {
 	fi, err := os.Lstat(path)
"
GO-2022-1114,duke-git,lancet,f869a0a67098e92d24ddd913e188b32404fa72c9," func UnZip(zipFile string, destPath string) error {
 	return nil
 }
 
+func safeFilepathJoin(path1, path2 string) (string, error) {
+	relPath, err := filepath.Rel(""."", path2)
+	if err != nil || strings.HasPrefix(relPath, "".."") {
+		return """", fmt.Errorf(""(zipslip) filepath is unsafe %q: %v"", path2, err)
+	}
+	if path1 == """" {
+		path1 = "".""
+	}
+	return filepath.Join(path1, filepath.Join(""/"", relPath)), nil
+}
+
 // IsLink checks if a file is symbol link or not
 func IsLink(path string) bool {
 	fi, err := os.Lstat(path)
"
GO-2023-1832,notaryproject,notation-go,39c8ed050a65cca3f3f308534acb612096735a64," func NewRepository() Repository {
 }
 
 func (t Repository) Resolve(ctx context.Context, reference string) (ocispec.Descriptor, error) {
+	if t.MissMatchDigest {
+		return ocispec.Descriptor{
+			MediaType:   ""application/vnd.docker.distribution.manifest.v2+json"",
+			Digest:      ZeroDigest,
+			Size:        528,
+			Annotations: Annotations,
+		}, nil
+	}
 	return t.ResolveResponse, t.ResolveError
 }
 
"
GO-2020-0007,seccomp,libseccomp-golang,06e7a29f36a34b8cf419aeb87b979ee508e58f9e," func (f *ScmpFilter) setFilterAttr(attr scmpFilterAttr, value C.uint32_t) error
 // DOES NOT LOCK OR CHECK VALIDITY
 // Assumes caller has already done this
 // Wrapper for seccomp_rule_add_... functions
-func (f *ScmpFilter) addRuleWrapper(call ScmpSyscall, action ScmpAction, exact bool, cond C.scmp_cast_t) error {
-	var length C.uint
-	if cond != nil {
-		length = 1
-	} else {
-		length = 0
+func (f *ScmpFilter) addRuleWrapper(call ScmpSyscall, action ScmpAction, exact bool, length C.uint, cond C.scmp_cast_t) error {
+	if length != 0 && cond == nil {
+		return fmt.Errorf(""null conditions list, but length is nonzero"")
 	}
 
 	var retCode C.int
"
GO-2020-0007,seccomp,libseccomp-golang,06e7a29f36a34b8cf419aeb87b979ee508e58f9e," func (f *ScmpFilter) addRuleWrapper(call ScmpSyscall, action ScmpAction, exact b
 		return fmt.Errorf(""unrecognized syscall"")
 	} else if syscall.Errno(-1*retCode) == syscall.EPERM {
 		return fmt.Errorf(""requested action matches default action of filter"")
+	} else if syscall.Errno(-1*retCode) == syscall.EINVAL {
+		return fmt.Errorf(""two checks on same syscall argument"")
 	} else if retCode != 0 {
 		return syscall.Errno(-1 * retCode)
 	}
"
GO-2022-0444,theupdateframework,go-tuf,ed6788e710fc3093a7ecc2d078bf734c0f200d8d," func (c *Client) UpdateRoots() error {
 // getLocalMeta decodes and verifies metadata from local storage.
 // The verification of local files is purely for consistency, if an attacker
 // has compromised the local storage, there is no guarantee it can be trusted.
+// Before trying to load the metadata files, it clears the in-memory copy of the local metadata.
+// This is to insure that all of the loaded metadata files at the end are indeed verified by the latest root.
+// If some of the metadata files fail to load it will proceed with trying to load the rest,
+// but still return an error at the end, if such occurred. Otherwise returns nil.
 func (c *Client) getLocalMeta() error {
+	var retErr error
+	loadFailed := false
+	// Clear the in-memory copy of the local metadata. The goal is to reload and take into account
+	// only the metadata files that are verified by the latest root. Otherwise, their content should
+	// be ignored.
+	c.localMeta = make(map[string]json.RawMessage)
+
+	// Load the latest root meta
 	if err := c.loadAndVerifyLocalRootMeta( /*ignoreExpiredCheck=*/ false); err != nil {
 		return err
 	}
 
+	// Load into memory the existing meta, if any, from the local storage
 	meta, err := c.local.GetMeta()
 	if err != nil {
 		return nil
 	}
 
+	// Verify the top-level metadata (timestamp, snapshot and targets) against the latest root and load it, if okay
 	if timestampJSON, ok := meta[""timestamp.json""]; ok {
 		timestamp := &data.Timestamp{}
 		if err := c.db.UnmarshalTrusted(timestampJSON, timestamp, ""timestamp""); err != nil {
-			return err
+			loadFailed = true
+			retErr = err
+		} else {
+			c.localMeta[""timestamp.json""] = meta[""timestamp.json""]
+			c.timestampVer = timestamp.Version
 		}
-		c.timestampVer = timestamp.Version
 	}
 
 	if snapshotJSON, ok := meta[""snapshot.json""]; ok {
 		snapshot := &data.Snapshot{}
 		if err := c.db.UnmarshalTrusted(snapshotJSON, snapshot, ""snapshot""); err != nil {
-			return err
+			loadFailed = true
+			retErr = err
+		} else {
+			c.localMeta[""snapshot.json""] = meta[""snapshot.json""]
+			c.snapshotVer = snapshot.Version
 		}
-		c.snapshotVer = snapshot.Version
 	}
 
 	if targetsJSON, ok := meta[""targets.json""]; ok {
 		targets := &data.Targets{}
 		if err := c.db.UnmarshalTrusted(targetsJSON, targets, ""targets""); err != nil {
-			return err
+			loadFailed = true
+			retErr = err
+		} else {
+			c.localMeta[""targets.json""] = meta[""targets.json""]
+			c.targetsVer = targets.Version
+			// FIXME(TUF-0.9) temporarily support files with leading path separators.
+			// c.targets = targets.Targets
+			c.loadTargets(targets.Targets)
 		}
-		c.targetsVer = targets.Version
-		// FIXME(TUF-0.9) temporarily support files with leading path separators.
-		// c.targets = targets.Targets
-		c.loadTargets(targets.Targets)
 	}
-
-	c.localMeta = meta
+	if loadFailed {
+		// If any of the metadata failed to be verified, return the reason for that failure
+		return retErr
+	}
 	return nil
 }
 
"
GO-2022-0444,theupdateframework,go-tuf,ed6788e710fc3093a7ecc2d078bf734c0f200d8d," func (c *Client) decodeRoot(b json.RawMessage) error {
 // root and targets file meta.
 func (c *Client) decodeSnapshot(b json.RawMessage) (data.SnapshotFiles, error) {
 	snapshot := &data.Snapshot{}
+	// 5.5.(3 and 6) - Verify it's signed correctly and it's not expired
 	if err := c.db.Unmarshal(b, snapshot, ""snapshot"", c.snapshotVer); err != nil {
 		return data.SnapshotFiles{}, ErrDecodeFailed{""snapshot.json"", err}
 	}
-	c.snapshotVer = snapshot.Version
+	// 5.5.5 - Check for top-level targets rollback attack
+	// Verify explicitly that current targets meta version is less than or equal to the new one
+	if snapshot.Meta[""targets.json""].Version < c.targetsVer {
+		return data.SnapshotFiles{}, verify.ErrLowVersion{Actual: snapshot.Meta[""targets.json""].Version, Current: c.targetsVer}
+	}
+
+	// 5.5.5 - Get the local/trusted snapshot metadata, if any, and check all target metafiles against rollback attack
+	// In case the local snapshot metadata was not verified by the keys in the latest root during getLocalMeta(),
+	// snapshot.json won't be present in c.localMeta and thus this check will not be processed.
+	if snapshotJSON, ok := c.localMeta[""snapshot.json""]; ok {
+		currentSnapshot := &data.Snapshot{}
+		if err := c.db.UnmarshalTrusted(snapshotJSON, currentSnapshot, ""snapshot""); err != nil {
+			return data.SnapshotFiles{}, err
+		}
+		// 5.5.5 - Check for rollback attacks in both top-level and delegated targets roles (note that the Meta object includes both)
+		for path, local := range currentSnapshot.Meta {
+			if newMeta, ok := snapshot.Meta[path]; ok {
+				// 5.5.5 - Check for rollback attack
+				if newMeta.Version < local.Version {
+					return data.SnapshotFiles{}, verify.ErrLowVersion{Actual: newMeta.Version, Current: local.Version}
+				}
+			} else {
+				// 5.5.5 - Abort the update if a target file has been removed from the new snapshot file
+				return data.SnapshotFiles{}, verify.ErrMissingTargetFile
+			}
+		}
+	}
+	// At this point we can trust the new snapshot, the top-level targets, and any delegated targets versions it refers to
+	// so we can update the client's trusted versions and proceed with persisting the new snapshot metadata
+	// c.snapshotVer was already set when we verified the timestamp metadata
+	c.targetsVer = snapshot.Meta[""targets.json""].Version
 	return snapshot.Meta, nil
 }
 
"
GO-2022-0444,theupdateframework,go-tuf,ed6788e710fc3093a7ecc2d078bf734c0f200d8d," func (t *tmpFile) Delete() error {
 }
 
 func cmdGet(args *docopt.Args, client *tuf.Client) error {
-	if _, err := client.Update(); err != nil && !tuf.IsLatestSnapshot(err) {
+	if _, err := client.Update(); err != nil {
 		return err
 	}
 	target := util.NormalizeTarget(args.String[""<target>""])
"
GO-2022-0444,theupdateframework,go-tuf,ed6788e710fc3093a7ecc2d078bf734c0f200d8d," List available target files.
 }
 
 func cmdList(args *docopt.Args, client *tuf.Client) error {
-	if _, err := client.Update(); err != nil && !tuf.IsLatestSnapshot(err) {
+	if _, err := client.Update(); err != nil {
 		return err
 	}
 	targets, err := client.Targets()
"
GO-2022-0444,theupdateframework,go-tuf,ed6788e710fc3093a7ecc2d078bf734c0f200d8d," func SnapshotFileMetaEqual(actual data.SnapshotFileMeta, expected data.SnapshotF
 	if expected.Length != 0 && actual.Length != expected.Length {
 		return ErrWrongLength{expected.Length, actual.Length}
 	}
-
+	// 5.6.2 - Check against snapshot role's targets hash
 	if len(expected.Hashes) != 0 {
 		if err := hashEqual(actual.Hashes, expected.Hashes); err != nil {
 			return err
 		}
 	}
-
+	// 5.6.4 - Check against snapshot role's snapshot version
 	if err := versionEqual(actual.Version, expected.Version); err != nil {
 		return err
 	}
"
GO-2022-0444,theupdateframework,go-tuf,ed6788e710fc3093a7ecc2d078bf734c0f200d8d," func (db *DB) VerifyIgnoreExpiredCheck(s *data.Signed, role string, minVersion i
 }
 
 func (db *DB) Verify(s *data.Signed, role string, minVersion int64) error {
-
+	// Verify signatures and versions
 	err := db.VerifyIgnoreExpiredCheck(s, role, minVersion)
 
 	if err != nil {
"
GO-2022-0444,theupdateframework,go-tuf,ed6788e710fc3093a7ecc2d078bf734c0f200d8d," func (db *DB) Verify(s *data.Signed, role string, minVersion int64) error {
 	if err := json.Unmarshal(s.Signed, sm); err != nil {
 		return err
 	}
-
+	// Verify expiration
 	if IsExpired(sm.Expires) {
 		return ErrExpired{sm.Expires}
 	}
"
GO-2022-1188,sajari,docconv,42bcff666855ab978e67a9041d0cdea552f20301," func ConvertDocx(r io.Reader) (string, map[string]string, error) {
 		size = si.Size()
 		ra = f
 	} else {
-		b, err := ioutil.ReadAll(r)
+		b, err := ioutil.ReadAll(io.LimitReader(r, maxBytes))
 		if err != nil {
 			return """", nil, nil
 		}
"
GO-2022-1188,sajari,docconv,42bcff666855ab978e67a9041d0cdea552f20301," func ConvertODT(r io.Reader) (string, map[string]string, error) {
 	meta := make(map[string]string)
 	var textBody string
 
-	b, err := ioutil.ReadAll(r)
+	b, err := ioutil.ReadAll(io.LimitReader(r, maxBytes))
 	if err != nil {
 		return """", nil, err
 	}
"
GO-2022-1188,sajari,docconv,42bcff666855ab978e67a9041d0cdea552f20301," func ConvertPages(r io.Reader) (string, map[string]string, error) {
 	meta := make(map[string]string)
 	var textBody string
 
-	b, err := ioutil.ReadAll(r)
+	b, err := ioutil.ReadAll(io.LimitReader(r, maxBytes))
 	if err != nil {
 		return """", nil, fmt.Errorf(""error reading data: %v"", err)
 	}
"
GO-2022-1188,sajari,docconv,42bcff666855ab978e67a9041d0cdea552f20301," func ConvertXML(r io.Reader) (string, map[string]string, error) {
 func XMLToText(r io.Reader, breaks []string, skip []string, strict bool) (string, error) {
 	var result string
 
-	dec := xml.NewDecoder(r)
+	dec := xml.NewDecoder(io.LimitReader(r, maxBytes))
 	dec.Strict = strict
 	for {
 		t, err := dec.Token()
"
GO-2022-1188,sajari,docconv,42bcff666855ab978e67a9041d0cdea552f20301," func XMLToText(r io.Reader, breaks []string, skip []string, strict bool) (string
 // XMLToMap converts XML to a nested string map.
 func XMLToMap(r io.Reader) (map[string]string, error) {
 	m := make(map[string]string)
-	dec := xml.NewDecoder(r)
+	dec := xml.NewDecoder(io.LimitReader(r, maxBytes))
 	var tagName string
 	for {
 		t, err := dec.Token()
"
GO-2020-0033,go-aah,aah,881dc9f71d1f7a4e8a9a39df9c5c081d3a2da1ec," func (s *staticManager) Serve(ctx *Context) error {
 
 	// Serve directory
 	if fi.Mode().IsDir() && ctx.route.ListDir {
+		fmt.Println(""here 1"")
 		// redirect if the directory name doesn't end in a slash
 		if ctx.Req.Path[len(ctx.Req.Path)-1] != '/' {
 			ctx.Log().Debugf(""redirecting to dir: %s"", ctx.Req.Path+""/"")
"
GO-2021-0095,google,go-tpm,d7806cce857a1a020190c03348e5361725d8f141," func LoadKey2(rw io.ReadWriter, keyBlob []byte, srkAuth []byte) (tpmutil.Handle,
 	defer zeroBytes(sharedSecret[:])
 
 	authIn := []interface{}{ordLoadKey2, k}
-	ca, err := newCommandAuth(osapr.AuthHandle, osapr.NonceEven, sharedSecret[:], authIn)
+	ca, err := newCommandAuth(osapr.AuthHandle, osapr.NonceEven, nil, sharedSecret[:], authIn)
 	if err != nil {
 		return 0, err
 	}
"
GO-2021-0095,google,go-tpm,d7806cce857a1a020190c03348e5361725d8f141," func Quote2(rw io.ReadWriter, handle tpmutil.Handle, data []byte, pcrVals []int,
 		return nil, err
 	}
 	authIn := []interface{}{ordQuote2, hash, pcrSel, addVersion}
-	ca, err := newCommandAuth(osapr.AuthHandle, osapr.NonceEven, sharedSecret[:], authIn)
+	ca, err := newCommandAuth(osapr.AuthHandle, osapr.NonceEven, nil, sharedSecret[:], authIn)
 	if err != nil {
 		return nil, err
 	}
"
GO-2021-0095,google,go-tpm,d7806cce857a1a020190c03348e5361725d8f141," func GetPubKey(rw io.ReadWriter, keyHandle tpmutil.Handle, srkAuth []byte) ([]by
 	defer zeroBytes(sharedSecret[:])
 
 	authIn := []interface{}{ordGetPubKey}
-	ca, err := newCommandAuth(osapr.AuthHandle, osapr.NonceEven, sharedSecret[:], authIn)
+	ca, err := newCommandAuth(osapr.AuthHandle, osapr.NonceEven, nil, sharedSecret[:], authIn)
 	if err != nil {
 		return nil, err
 	}
"
GO-2021-0095,google,go-tpm,d7806cce857a1a020190c03348e5361725d8f141," func newOSAPSession(rw io.ReadWriter, entityType uint16, entityValue tpmutil.Han
 }
 
 // newCommandAuth creates a new commandAuth structure over the given
-// parameters, using the given secret for HMAC computation.
-func newCommandAuth(authHandle tpmutil.Handle, nonceEven Nonce, key []byte, params []interface{}) (*commandAuth, error) {
+// parameters, using the given secret and the given odd nonce, if provided,
+// for the HMAC. If no odd nonce is provided, one is randomly generated.
+func newCommandAuth(authHandle tpmutil.Handle, nonceEven Nonce, nonceOdd *Nonce, key []byte, params []interface{}) (*commandAuth, error) {
 	// Auth = HMAC-SHA1(key, SHA1(params) || NonceEven || NonceOdd || ContSession)
 	digestBytes, err := tpmutil.Pack(params...)
 	if err != nil {
 		return nil, err
 	}
-
 	digest := sha1.Sum(digestBytes)
-	ca := &commandAuth{AuthHandle: authHandle}
-	if _, err := rand.Read(ca.NonceOdd[:]); err != nil {
-		return nil, err
+
+	// Use the passed-in nonce if non-nil, otherwise generate it now.
+	var odd Nonce
+	if nonceOdd != nil {
+		odd = *nonceOdd
+	} else {
+		if _, err := rand.Read(odd[:]); err != nil {
+			return nil, err
+		}
+	}
+
+	ca := &commandAuth{
+		AuthHandle: authHandle,
+		NonceOdd:   odd,
 	}
 
 	authBytes, err := tpmutil.Pack(digest, nonceEven, ca.NonceOdd, ca.ContSession)
"
GO-2021-0095,google,go-tpm,d7806cce857a1a020190c03348e5361725d8f141," func sealHelper(rw io.ReadWriter, pcrInfo *pcrInfoLong, data []byte, srkAuth []b
 	//               len(data) || data)
 	//
 	authIn := []interface{}{ordSeal, sc.EncAuth, uint32(binary.Size(pcrInfo)), pcrInfo, tpmutil.U32Bytes(data)}
-	ca, err := newCommandAuth(osapr.AuthHandle, osapr.NonceEven, sharedSecret[:], authIn)
+	ca, err := newCommandAuth(osapr.AuthHandle, osapr.NonceEven, nil, sharedSecret[:], authIn)
 	if err != nil {
 		return nil, err
 	}
"
GO-2021-0095,google,go-tpm,d7806cce857a1a020190c03348e5361725d8f141," func Unseal(rw io.ReadWriter, sealed []byte, srkAuth []byte) ([]byte, error) {
 	authIn := []interface{}{ordUnseal, tsd}
 
 	// The first commandAuth uses the shared secret as an HMAC key.
-	ca1, err := newCommandAuth(osapr.AuthHandle, osapr.NonceEven, sharedSecret[:], authIn)
+	ca1, err := newCommandAuth(osapr.AuthHandle, osapr.NonceEven, nil, sharedSecret[:], authIn)
 	if err != nil {
 		return nil, err
 	}
 
 	// The second commandAuth is based on OIAP instead of OSAP and uses the
 	// SRK auth value as an HMAC key instead of the shared secret.
-	ca2, err := newCommandAuth(oiapr.AuthHandle, oiapr.NonceEven, srkAuth, authIn)
+	ca2, err := newCommandAuth(oiapr.AuthHandle, oiapr.NonceEven, nil, srkAuth, authIn)
 	if err != nil {
 		return nil, err
 	}
"
GO-2021-0095,google,go-tpm,d7806cce857a1a020190c03348e5361725d8f141," func Quote(rw io.ReadWriter, handle tpmutil.Handle, data []byte, pcrNums []int,
 		return nil, nil, err
 	}
 	authIn := []interface{}{ordQuote, hash, pcrSel}
-	ca, err := newCommandAuth(osapr.AuthHandle, osapr.NonceEven, sharedSecret[:], authIn)
+	ca, err := newCommandAuth(osapr.AuthHandle, osapr.NonceEven, nil, sharedSecret[:], authIn)
 	if err != nil {
 		return nil, nil, err
 	}
"
GO-2021-0095,google,go-tpm,d7806cce857a1a020190c03348e5361725d8f141," func MakeIdentity(rw io.ReadWriter, srkAuth []byte, ownerAuth []byte, aikAuth []
 	// digest = SHA1(ordMakeIdentity || encAuth || caDigest || aik)
 	//
 	authIn := []interface{}{ordMakeIdentity, encAuth, caDigest, aik}
-	ca1, err := newCommandAuth(osaprSRK.AuthHandle, osaprSRK.NonceEven, sharedSecretSRK[:], authIn)
+	ca1, err := newCommandAuth(osaprSRK.AuthHandle, osaprSRK.NonceEven, nil, sharedSecretSRK[:], authIn)
 	if err != nil {
 		return nil, err
 	}
 
-	ca2, err := newCommandAuth(osaprOwn.AuthHandle, osaprOwn.NonceEven, sharedSecretOwn[:], authIn)
+	ca2, err := newCommandAuth(osaprOwn.AuthHandle, osaprOwn.NonceEven, nil, sharedSecretOwn[:], authIn)
 	if err != nil {
 		return nil, err
 	}
"
GO-2021-0095,google,go-tpm,d7806cce857a1a020190c03348e5361725d8f141," func ActivateIdentity(rw io.ReadWriter, aikAuth []byte, ownerAuth []byte, aik tp
 	defer zeroBytes(sharedSecretOwn[:])
 
 	authIn := []interface{}{ordActivateIdentity, tpmutil.U32Bytes(asym)}
-	ca1, err := newCommandAuth(oiaprAIK.AuthHandle, oiaprAIK.NonceEven, aikAuth, authIn)
+	ca1, err := newCommandAuth(oiaprAIK.AuthHandle, oiaprAIK.NonceEven, nil, aikAuth, authIn)
 	if err != nil {
 		return nil, fmt.Errorf(""newCommandAuth failed: %v"", err)
 	}
-	ca2, err := newCommandAuth(osaprOwn.AuthHandle, osaprOwn.NonceEven, sharedSecretOwn[:], authIn)
+	ca2, err := newCommandAuth(osaprOwn.AuthHandle, osaprOwn.NonceEven, nil, sharedSecretOwn[:], authIn)
 	if err != nil {
 		return nil, fmt.Errorf(""newCommandAuth failed: %v"", err)
 	}
"
GO-2021-0095,google,go-tpm,d7806cce857a1a020190c03348e5361725d8f141," func ResetLockValue(rw io.ReadWriter, ownerAuth Digest) error {
 	// digest = SHA1(ordResetLockValue)
 	//
 	authIn := []interface{}{ordResetLockValue}
-	ca, err := newCommandAuth(osaprOwn.AuthHandle, osaprOwn.NonceEven, sharedSecretOwn[:], authIn)
+	ca, err := newCommandAuth(osaprOwn.AuthHandle, osaprOwn.NonceEven, nil, sharedSecretOwn[:], authIn)
 	if err != nil {
 		return err
 	}
"
GO-2021-0095,google,go-tpm,d7806cce857a1a020190c03348e5361725d8f141," func ownerReadInternalHelper(rw io.ReadWriter, kh tpmutil.Handle, ownerAuth Dige
 	// digest = SHA1(ordOwnerReadInternalPub || kh)
 	//
 	authIn := []interface{}{ordOwnerReadInternalPub, kh}
-	ca, err := newCommandAuth(osaprOwn.AuthHandle, osaprOwn.NonceEven, sharedSecretOwn[:], authIn)
+	ca, err := newCommandAuth(osaprOwn.AuthHandle, osaprOwn.NonceEven, nil, sharedSecretOwn[:], authIn)
 	if err != nil {
 		return nil, err
 	}
"
GO-2021-0095,google,go-tpm,d7806cce857a1a020190c03348e5361725d8f141," func NVDefineSpace(rw io.ReadWriter, nvData NVDataPublic, ownAuth []byte) error
 		encAuthData := sha1.Sum(xorData)
 
 		authIn := []interface{}{ordNVDefineSpace, nvData, encAuthData}
-		ca, err := newCommandAuth(osaprOwn.AuthHandle, osaprOwn.NonceEven, sharedSecretOwn[:], authIn)
+		ca, err := newCommandAuth(osaprOwn.AuthHandle, osaprOwn.NonceEven, nil, sharedSecretOwn[:], authIn)
 		if err != nil {
 			return err
 		}
"
GO-2021-0095,google,go-tpm,d7806cce857a1a020190c03348e5361725d8f141," func NVReadValue(rw io.ReadWriter, index, offset, len uint32, ownAuth []byte) ([
 	defer osaprOwn.Close(rw)
 	defer zeroBytes(sharedSecretOwn[:])
 	authIn := []interface{}{ordNVReadValue, index, offset, len}
-	ca, err := newCommandAuth(osaprOwn.AuthHandle, osaprOwn.NonceEven, sharedSecretOwn[:], authIn)
+	ca, err := newCommandAuth(osaprOwn.AuthHandle, osaprOwn.NonceEven, nil, sharedSecretOwn[:], authIn)
 	if err != nil {
 		return nil, fmt.Errorf(""failed to construct owner auth fields: %v"", err)
 	}
"
GO-2021-0095,google,go-tpm,d7806cce857a1a020190c03348e5361725d8f141," func NVReadValueAuth(rw io.ReadWriter, index, offset, len uint32, auth []byte) (
 	defer osapr.Close(rw)
 	defer zeroBytes(sharedSecret[:])
 	authIn := []interface{}{ordNVReadValueAuth, index, offset, len}
-	ca, err := newCommandAuth(osapr.AuthHandle, osapr.NonceEven, sharedSecret[:], authIn)
+	ca, err := newCommandAuth(osapr.AuthHandle, osapr.NonceEven, nil, sharedSecret[:], authIn)
 	if err != nil {
 		return nil, fmt.Errorf(""failed to construct auth fields: %v"", err)
 	}
"
GO-2021-0095,google,go-tpm,d7806cce857a1a020190c03348e5361725d8f141," func NVWriteValue(rw io.ReadWriter, index, offset uint32, data []byte, ownAuth [
 	defer osaprOwn.Close(rw)
 	defer zeroBytes(sharedSecretOwn[:])
 	authIn := []interface{}{ordNVWriteValue, index, offset, len(data), data}
-	ca, err := newCommandAuth(osaprOwn.AuthHandle, osaprOwn.NonceEven, sharedSecretOwn[:], authIn)
+	ca, err := newCommandAuth(osaprOwn.AuthHandle, osaprOwn.NonceEven, nil, sharedSecretOwn[:], authIn)
 	if err != nil {
 		return fmt.Errorf(""failed to construct owner auth fields: %v"", err)
 	}
"
GO-2021-0095,google,go-tpm,d7806cce857a1a020190c03348e5361725d8f141," func NVWriteValueAuth(rw io.ReadWriter, index, offset uint32, data []byte, auth
 	defer osapr.Close(rw)
 	defer zeroBytes(sharedSecret[:])
 	authIn := []interface{}{ordNVWriteValueAuth, index, offset, len(data), data}
-	ca, err := newCommandAuth(osapr.AuthHandle, osapr.NonceEven, sharedSecret[:], authIn)
+	ca, err := newCommandAuth(osapr.AuthHandle, osapr.NonceEven, nil, sharedSecret[:], authIn)
 	if err != nil {
 		return fmt.Errorf(""failed to construct auth fields: %v"", err)
 	}
"
GO-2021-0095,google,go-tpm,d7806cce857a1a020190c03348e5361725d8f141," func OwnerClear(rw io.ReadWriter, ownerAuth Digest) error {
 	// digest = SHA1(ordOwnerClear)
 	//
 	authIn := []interface{}{ordOwnerClear}
-	ca, err := newCommandAuth(osaprOwn.AuthHandle, osaprOwn.NonceEven, sharedSecretOwn[:], authIn)
+	ca, err := newCommandAuth(osaprOwn.AuthHandle, osaprOwn.NonceEven, nil, sharedSecretOwn[:], authIn)
 	if err != nil {
 		return err
 	}
"
GO-2021-0095,google,go-tpm,d7806cce857a1a020190c03348e5361725d8f141," func TakeOwnership(rw io.ReadWriter, newOwnerAuth Digest, newSRKAuth Digest, pub
 	// The digest for TakeOwnership is
 	//
 	// SHA1(ordTakeOwnership || pidOwner || encOwnerAuth || encSRKAuth || srk)
-	authIn := []interface{}{ordTakeOwnership, pidOwner, encOwnerAuth, encSRKAuth, srk}
-	ca, err := newCommandAuth(oiapr.AuthHandle, oiapr.NonceEven, newOwnerAuth[:], authIn)
+	authIn := []interface{}{ordTakeOwnership, pidOwner, tpmutil.U32Bytes(encOwnerAuth), tpmutil.U32Bytes(encSRKAuth), srk}
+	ca, err := newCommandAuth(oiapr.AuthHandle, oiapr.NonceEven, nil, newOwnerAuth[:], authIn)
 	if err != nil {
 		return err
 	}
"
GO-2021-0095,google,go-tpm,d7806cce857a1a020190c03348e5361725d8f141," func Sign(rw io.ReadWriter, keyAuth []byte, keyHandle tpmutil.Handle, hash crypt
 	defer zeroBytes(sharedSecret[:])
 
 	authIn := []interface{}{ordSign, tpmutil.U32Bytes(data)}
-	ca, err := newCommandAuth(osapr.AuthHandle, osapr.NonceEven, sharedSecret[:], authIn)
+	ca, err := newCommandAuth(osapr.AuthHandle, osapr.NonceEven, nil, sharedSecret[:], authIn)
 	if err != nil {
 		return nil, err
 	}
"
GO-2023-1640,dablelv,go-huge-util,0e308b0fac8973e6fa251b0ab095cdc5c1c0956b," func IsFileE(path string) (bool, error) {
 	return false, err
 }
 
-// IsSymlink checks a file whether is a symbolic link.
+// IsSymlink checks a file whether is a symbolic link on Linux.
 // Note that this doesn't work for the shortcut file on windows.
+// If you want to check a file whether is a shortcut file on Windows please use IsShortcut function.
 func IsSymlink(path string) bool {
 	if info, err := os.Lstat(path); err == nil && info.Mode()&os.ModeSymlink != 0 {
 		return true
"
GO-2023-1640,dablelv,go-huge-util,0e308b0fac8973e6fa251b0ab095cdc5c1c0956b," func IsSymlink(path string) bool {
 	return false
 }
 
-// IsSymlinkE checks a file whether is a symbolic link.
+// IsSymlinkE checks a file whether is a symbolic link on Linux.
 // Note that this doesn't work for the shortcut file on windows.
+// If you want to check a file whether is a shortcut file on Windows please use IsShortcut function.
 func IsSymlinkE(path string) (bool, error) {
 	info, err := os.Lstat(path)
 	if err == nil && info.Mode()&os.ModeSymlink != 0 {
"
GO-2023-1640,dablelv,go-huge-util,0e308b0fac8973e6fa251b0ab095cdc5c1c0956b," func FileToBytes(path string) []byte {
 	return byteStream
 }
 
-// BytesToFile writes data to a file. If the file does not exist it will be created with permission mode 0644.
-func BytesToFile(filePath string, data []byte) error {
-	exist, _ := IsPathExist(filePath)
+// BytesToFile writes data to a file.
+// If the file does not exist it will be created with permission mode 0644.
+func BytesToFile(path string, data []byte) error {
+	exist, _ := IsExist(path)
 	if !exist {
-		if err := CreateFile(filePath); err != nil {
+		if err := CreateFile(path); err != nil {
 			return err
 		}
 	}
-	return ioutil.WriteFile(filePath, data, 0644)
+	return ioutil.WriteFile(path, data, 0644)
 }
 
 // GetDirAllEntryPaths gets all the file or dir paths in the specified directory recursively.
"
GO-2023-1640,dablelv,go-huge-util,0e308b0fac8973e6fa251b0ab095cdc5c1c0956b," func GetDirAllEntryPathsFollowSymlink(dirname string, incl bool) ([]string, erro
 	}
 	return paths, nil
 }
+
+// ClearFile clears a file content.
+func ClearFile(path string) error {
+	f, err := os.OpenFile(path, os.O_WRONLY|os.O_TRUNC, 0777)
+	if err != nil {
+		return err
+	}
+	defer f.Close()
+	return nil
+}
"
GO-2023-1640,dablelv,go-huge-util,0e308b0fac8973e6fa251b0ab095cdc5c1c0956b," import (
 // dir
 // ├── bar.txt
 // └── foo.txt
-// Note that if a file is a symbolic link it will be skipped.
+// Note that if a file is a symbolic link on Linux it will be skipped.
+// If you want to follow a symbolic link please use the function ZipFollowSymlink.
 func Zip(zipPath string, paths ...string) error {
 	// Create zip file and it's parent dir.
 	if err := os.MkdirAll(filepath.Dir(zipPath), os.ModePerm); err != nil {
"
GO-2022-0588,microcosm-cc,bluemonday,c788a2a4d42e081ad54a31368478820bb4a42fb4," func (p *Policy) AllowElementsContent(names ...string) *Policy {
 	return p
 }
 
+// AllowUnsafe permits fundamentally unsafe elements.
+//
+// If false (default) then elements such as `style` and `script` will not be
+// permitted even if declared in a policy. These elements when combined with
+// untrusted input cannot be safely handled by bluemonday at this point in
+// time.
+//
+// If true then `style` and `script` would be permitted by bluemonday if a
+// policy declares them. However this is not recommended under any circumstance
+// and can lead to XSS being rendered thus defeating the purpose of using a
+// HTML sanitizer.
+func (p *Policy) AllowUnsafe(allowUnsafe bool) *Policy {
+	p.init()
+	p.allowUnsafe = allowUnsafe
+	return p
+}
+
 // addDefaultElementsWithoutAttrs adds the HTML elements that we know are valid
 // without any attributes to an internal map.
 // i.e. we know that <table> is valid, but <bdo> isn't valid as the ""dir"" attr
"
GO-2022-0588,microcosm-cc,bluemonday,c788a2a4d42e081ad54a31368478820bb4a42fb4," func (p *Policy) sanitize(r io.Reader, w io.Writer) error {
 
 			mostRecentlyStartedToken = normaliseElementName(token.Data)
 
+			switch normaliseElementName(token.Data) {
+			case `script`:
+				if !p.allowUnsafe {
+					continue
+				}
+			case `style`:
+				if !p.allowUnsafe {
+					continue
+				}
+			}
+
 			aps, ok := p.elsAndAttrs[token.Data]
 			if !ok {
 				aa, matched := p.matchRegex(token.Data)
"
GO-2022-0588,microcosm-cc,bluemonday,c788a2a4d42e081ad54a31368478820bb4a42fb4," func (p *Policy) sanitize(r io.Reader, w io.Writer) error {
 				mostRecentlyStartedToken = """"
 			}
 
+			switch normaliseElementName(token.Data) {
+			case `script`:
+				if !p.allowUnsafe {
+					continue
+				}
+			case `style`:
+				if !p.allowUnsafe {
+					continue
+				}
+			}
+
 			if skipClosingTag && closingTagToSkipStack[len(closingTagToSkipStack)-1] == token.Data {
 				closingTagToSkipStack = closingTagToSkipStack[:len(closingTagToSkipStack)-1]
 				if len(closingTagToSkipStack) == 0 {
"
GO-2022-0588,microcosm-cc,bluemonday,c788a2a4d42e081ad54a31368478820bb4a42fb4," func (p *Policy) sanitize(r io.Reader, w io.Writer) error {
 
 		case html.SelfClosingTagToken:
 
+			switch normaliseElementName(token.Data) {
+			case `script`:
+				if !p.allowUnsafe {
+					continue
+				}
+			case `style`:
+				if !p.allowUnsafe {
+					continue
+				}
+			}
+
 			aps, ok := p.elsAndAttrs[token.Data]
 			if !ok {
 				aa, matched := p.matchRegex(token.Data)
"
GO-2022-0588,microcosm-cc,bluemonday,c788a2a4d42e081ad54a31368478820bb4a42fb4," func (p *Policy) sanitize(r io.Reader, w io.Writer) error {
 				case `script`:
 					// not encouraged, but if a policy allows JavaScript we
 					// should not HTML escape it as that would break the output
-					if _, err := buff.WriteString(token.Data); err != nil {
-						return err
+					//
+					// requires p.AllowUnsafe()
+					if p.allowUnsafe {
+						if _, err := buff.WriteString(token.Data); err != nil {
+							return err
+						}
 					}
 				case ""style"":
 					// not encouraged, but if a policy allows CSS styles we
 					// should not HTML escape it as that would break the output
-					if _, err := buff.WriteString(token.Data); err != nil {
-						return err
+					//
+					// requires p.AllowUnsafe()
+					if p.allowUnsafe {
+						if _, err := buff.WriteString(token.Data); err != nil {
+							return err
+						}
 					}
 				default:
 					// HTML escape the text
"
GO-2023-1578,hashicorp,go-getter,78e6721a2a76266718dc92c3c03c1571dffdefdc," func (d *Bzip2Decompressor) Decompress(dst, src string, dir bool, umask os.FileM
 	bzipR := bzip2.NewReader(f)
 
 	// Copy it out
-	return copyReader(dst, bzipR, 0622, umask)
+	return copyReader(dst, bzipR, 0622, umask, d.FileSizeLimit)
 }
"
GO-2023-1578,hashicorp,go-getter,78e6721a2a76266718dc92c3c03c1571dffdefdc," func (d *GzipDecompressor) Decompress(dst, src string, dir bool, umask os.FileMo
 	defer gzipR.Close()
 
 	// Copy it out
-	return copyReader(dst, gzipR, 0622, umask)
+	return copyReader(dst, gzipR, 0622, umask, d.FileSizeLimit)
 }
"
GO-2023-1578,hashicorp,go-getter,78e6721a2a76266718dc92c3c03c1571dffdefdc," func (d *TarDecompressor) Decompress(dst, src string, dir bool, umask os.FileMod
 	}
 	defer f.Close()
 
-	return untar(f, dst, src, dir, umask)
+	return untar(f, dst, src, dir, umask, d.FileSizeLimit, d.FilesLimit)
 }
"
GO-2023-1578,hashicorp,go-getter,78e6721a2a76266718dc92c3c03c1571dffdefdc," func (d *TarBzip2Decompressor) Decompress(dst, src string, dir bool, umask os.Fi
 
 	// Bzip2 compression is second
 	bzipR := bzip2.NewReader(f)
-	return untar(bzipR, dst, src, dir, umask)
+	return untar(bzipR, dst, src, dir, umask, d.FileSizeLimit, d.FilesLimit)
 }
"
GO-2023-1578,hashicorp,go-getter,78e6721a2a76266718dc92c3c03c1571dffdefdc," func (d *TarGzipDecompressor) Decompress(dst, src string, dir bool, umask os.Fil
 	}
 	defer gzipR.Close()
 
-	return untar(gzipR, dst, src, dir, umask)
+	return untar(gzipR, dst, src, dir, umask, d.FileSizeLimit, d.FilesLimit)
 }
"
GO-2023-1578,hashicorp,go-getter,78e6721a2a76266718dc92c3c03c1571dffdefdc," func (d *TarXzDecompressor) Decompress(dst, src string, dir bool, umask os.FileM
 		return fmt.Errorf(""Error opening an xz reader for %s: %s"", src, err)
 	}
 
-	return untar(txzR, dst, src, dir, umask)
+	return untar(txzR, dst, src, dir, umask, d.FileSizeLimit, d.FilesLimit)
 }
"
GO-2023-1578,hashicorp,go-getter,78e6721a2a76266718dc92c3c03c1571dffdefdc," func (d *TarZstdDecompressor) Decompress(dst, src string, dir bool, umask os.Fil
 	}
 	defer zstdR.Close()
 
-	return untar(zstdR, dst, src, dir, umask)
+	return untar(zstdR, dst, src, dir, umask, d.FileSizeLimit, d.FilesLimit)
 }
"
GO-2023-1578,hashicorp,go-getter,78e6721a2a76266718dc92c3c03c1571dffdefdc," func (d *XzDecompressor) Decompress(dst, src string, dir bool, umask os.FileMode
 		return err
 	}
 
-	// Copy it out
-	return copyReader(dst, xzR, 0622, umask)
+	// Copy it out, potentially using a file size limit.
+	return copyReader(dst, xzR, 0622, umask, d.FileSizeLimit)
 }
"
GO-2023-1578,hashicorp,go-getter,78e6721a2a76266718dc92c3c03c1571dffdefdc," func (d *ZstdDecompressor) Decompress(dst, src string, dir bool, umask os.FileMo
 	}
 	defer zstdR.Close()
 
-	// Copy it out
-	return copyReader(dst, zstdR, 0622, umask)
+	// Copy it out, potentially using a file size limit.
+	return copyReader(dst, zstdR, 0622, umask, d.FileSizeLimit)
 }
"
GO-2023-1578,hashicorp,go-getter,78e6721a2a76266718dc92c3c03c1571dffdefdc," func (g *GCSGetter) getObject(ctx context.Context, client *storage.Client, dst,
 		return err
 	}
 
-	return copyReader(dst, rc, 0666, g.client.umask())
+	// There is no limit set for the size of an object from GCS
+	return copyReader(dst, rc, 0666, g.client.umask(), 0)
 }
 
 func (g *GCSGetter) parseURL(u *url.URL) (bucket, path, fragment string, err error) {
"
GO-2023-1578,hashicorp,go-getter,78e6721a2a76266718dc92c3c03c1571dffdefdc," func (g *S3Getter) getObject(ctx context.Context, client *s3.S3, dst, bucket, ke
 	}
 	defer body.Close()
 
-	return copyReader(dst, body, 0666, g.client.umask())
+	// There is no limit set for the size of an object from S3
+	return copyReader(dst, body, 0666, g.client.umask(), 0)
 }
 
 func (g *S3Getter) getAWSConfig(region string, url *url.URL, creds *credentials.Credentials) *aws.Config {
"
GO-2021-0061,go-yaml,yaml,bb4e33bf68bf89cad44d386192cbed201f35b241," func (d *decoder) alias(n *node, out reflect.Value) (good bool) {
 		failf(""anchor '%s' value contains itself"", n.value)
 	}
 	d.aliases[n] = true
+	d.aliasDepth++
 	good = d.unmarshal(n.alias, out)
+	d.aliasDepth--
 	delete(d.aliases, n)
 	return good
 }
"
GO-2020-0026,openshift,source-to-image,f5cbcbc5cc6f8cc2f479a7302443bea407a700cb," func New(fs fs.FileSystem) Tar {
 	}
 }
 
+// NewParanoid creates a new Tar that has restrictions
+// on what it can do while extracting files.
+func NewParanoid(fs fs.FileSystem) Tar {
+	return &stiTar{
+		FileSystem:           fs,
+		exclude:              DefaultExclusionPattern,
+		timeout:              defaultTimeout,
+		disallowOverwrite:    true,
+		disallowOutsidePaths: true,
+		disallowSpecialFiles: true,
+	}
+}
+
 // stiTar is an implementation of the Tar interface
 type stiTar struct {
 	fs.FileSystem
-	timeout          time.Duration
-	exclude          *regexp.Regexp
-	includeDirInPath bool
+	timeout              time.Duration
+	exclude              *regexp.Regexp
+	includeDirInPath     bool
+	disallowOverwrite    bool
+	disallowOutsidePaths bool
+	disallowSpecialFiles bool
 }
 
 // SetExclusionPattern sets the exclusion pattern for tar creation.  The
"
GO-2020-0026,openshift,source-to-image,f5cbcbc5cc6f8cc2f479a7302443bea407a700cb," func (t *stiTar) extractLink(dir string, header *tar.Header, tarReader io.Reader
 
 func (t *stiTar) extractFile(dir string, header *tar.Header, tarReader io.Reader) error {
 	path := filepath.Join(dir, header.Name)
+	if t.disallowOverwrite {
+		if _, err := os.Stat(path); !os.IsNotExist(err) {
+			glog.Warningf(""Refusing to overwrite existing file: %s"", path)
+			return nil
+		}
+	}
+
 	glog.V(3).Infof(""Creating %s"", path)
 
 	file, err := os.Create(path)
"
GO-2023-1595,FiloSottile,nistec,c58aa1223ccf3943513e1e661cebce95af137244," func p256PointDoubleAsm(res, in *P256Point)
 // Montgomery domain (with R 2²⁵⁶) as four uint64 limbs in little-endian order.
 type p256OrdElement [4]uint64
 
+// p256OrdReduce ensures s is in the range [0, ord(G)-1].
+func p256OrdReduce(s *p256OrdElement) {
+	// Since 2 * ord(G) > 2²⁵⁶, we can just conditionally subtract ord(G),
+	// keeping the result if it doesn't underflow.
+	t0, b := bits.Sub64(s[0], 0xf3b9cac2fc632551, 0)
+	t1, b := bits.Sub64(s[1], 0xbce6faada7179e84, b)
+	t2, b := bits.Sub64(s[2], 0xffffffffffffffff, b)
+	t3, b := bits.Sub64(s[3], 0xffffffff00000000, b)
+	tMask := b - 1 // zero if subtraction underflowed
+	s[0] ^= (t0 ^ s[0]) & tMask
+	s[1] ^= (t1 ^ s[1]) & tMask
+	s[2] ^= (t2 ^ s[2]) & tMask
+	s[3] ^= (t3 ^ s[3]) & tMask
+}
+
 // Add sets q = p1 + p2, and returns q. The points may overlap.
 func (q *P256Point) Add(r1, r2 *P256Point) *P256Point {
 	var sum, double P256Point
"
GO-2022-1040,helm,helm,6ce9ba60b73013857e2e7c73d3f86ed70bc1ac9a," func newRepoUpdateCmd(out io.Writer) *cobra.Command {
 
 func (o *repoUpdateOptions) run(out io.Writer) error {
 	f, err := repo.LoadFile(o.repoFile)
-	if isNotExist(err) || len(f.Repositories) == 0 {
+	switch {
+	case isNotExist(err):
+		return errNoRepositories
+	case err != nil:
+		return errors.Wrapf(err, ""failed loading file: %s"", o.repoFile)
+	case len(f.Repositories) == 0:
 		return errNoRepositories
 	}
+
 	var repos []*repo.ChartRepository
 	for _, cfg := range f.Repositories {
 		r, err := repo.NewChartRepository(cfg, getter.All(settings))
"
GO-2022-1040,helm,helm,6ce9ba60b73013857e2e7c73d3f86ed70bc1ac9a," func (o *searchRepoOptions) setupSearchedVersion() {
 }
 
 func (o *searchRepoOptions) applyConstraint(res []*search.Result) ([]*search.Result, error) {
-	if len(o.version) == 0 {
+	if o.version == """" {
 		return res, nil
 	}
 
"
GO-2022-1040,helm,helm,6ce9ba60b73013857e2e7c73d3f86ed70bc1ac9a," func (o *searchRepoOptions) applyConstraint(res []*search.Result) ([]*search.Res
 
 	data := res[:0]
 	foundNames := map[string]bool{}
-	appendSearchResults := func(res *search.Result) {
-		data = append(data, res)
-		if !o.versions {
-			foundNames[res.Name] = true // If user hasn't requested all versions, only show the latest that matches
-		}
-	}
 	for _, r := range res {
-		if _, found := foundNames[r.Name]; found {
+		// if not returning all versions and already have found a result,
+		// you're done!
+		if !o.versions && foundNames[r.Name] {
 			continue
 		}
 		v, err := semver.NewVersion(r.Chart.Version)
-
 		if err != nil {
-			// If the current version number check appears ErrSegmentStartsZero or ErrInvalidPrerelease error and not devel mode, ignore
-			if (err == semver.ErrSegmentStartsZero || err == semver.ErrInvalidPrerelease) && !o.devel {
-				continue
-			}
-			appendSearchResults(r)
-		} else if constraint.Check(v) {
-			appendSearchResults(r)
+			continue
+		}
+		if constraint.Check(v) {
+			data = append(data, r)
+			foundNames[r.Name] = true
 		}
 	}
 
"
GO-2022-1040,helm,helm,6ce9ba60b73013857e2e7c73d3f86ed70bc1ac9a," func (o *searchRepoOptions) buildIndex() (*search.Index, error) {
 		ind, err := repo.LoadIndexFile(f)
 		if err != nil {
 			warning(""Repo %q is corrupt or missing. Try 'helm repo update'."", n)
+			warning(""%s"", err)
 			continue
 		}
 
"
GO-2022-1040,helm,helm,6ce9ba60b73013857e2e7c73d3f86ed70bc1ac9a," type Dependency struct {
 	Alias string `json:""alias,omitempty""`
 }
 
+// Validate checks for common problems with the dependency datastructure in
+// the chart. This check must be done at load time before the dependency's charts are
+// loaded.
+func (d *Dependency) Validate() error {
+	d.Name = sanitizeString(d.Name)
+	d.Version = sanitizeString(d.Version)
+	d.Repository = sanitizeString(d.Repository)
+	d.Condition = sanitizeString(d.Condition)
+	for i := range d.Tags {
+		d.Tags[i] = sanitizeString(d.Tags[i])
+	}
+	if d.Alias != """" && !aliasNameFormat.MatchString(d.Alias) {
+		return ValidationErrorf(""dependency %q has disallowed characters in the alias"", d.Name)
+	}
+	return nil
+}
+
 // Lock is a lock file for dependencies.
 //
 // It represents the state that the dependencies should be in.
"
GO-2022-1040,helm,helm,6ce9ba60b73013857e2e7c73d3f86ed70bc1ac9a," type Maintainer struct {
 	URL string `json:""url,omitempty""`
 }
 
+// Validate checks valid data and sanitizes string characters.
+func (m *Maintainer) Validate() error {
+	m.Name = sanitizeString(m.Name)
+	m.Email = sanitizeString(m.Email)
+	m.URL = sanitizeString(m.URL)
+	return nil
+}
+
 // Metadata for a Chart file. This models the structure of a Chart.yaml file.
 type Metadata struct {
-	// The name of the chart
+	// The name of the chart. Required.
 	Name string `json:""name,omitempty""`
 	// The URL to a relevant project page, git repo, or contact person
 	Home string `json:""home,omitempty""`
 	// Source is the URL to the source code of this chart
 	Sources []string `json:""sources,omitempty""`
-	// A SemVer 2 conformant version string of the chart
+	// A SemVer 2 conformant version string of the chart. Required.
 	Version string `json:""version,omitempty""`
 	// A one-sentence description of the chart
 	Description string `json:""description,omitempty""`
"
GO-2022-1040,helm,helm,6ce9ba60b73013857e2e7c73d3f86ed70bc1ac9a," func NewChartRepository(cfg *Entry, getters getter.Providers) (*ChartRepository,
 // Load loads a directory of charts as if it were a repository.
 //
 // It requires the presence of an index.yaml file in the directory.
+//
+// Deprecated: remove in Helm 4.
 func (r *ChartRepository) Load() error {
 	dirInfo, err := os.Stat(r.Config.Name)
 	if err != nil {
"
GO-2022-1040,helm,helm,6ce9ba60b73013857e2e7c73d3f86ed70bc1ac9a," func (r *ChartRepository) Load() error {
 			if strings.Contains(f.Name(), ""-index.yaml"") {
 				i, err := LoadIndexFile(path)
 				if err != nil {
-					return nil
+					return err
 				}
 				r.IndexFile = i
 			} else if strings.HasSuffix(f.Name(), "".tgz"") {
"
GO-2022-1040,helm,helm,6ce9ba60b73013857e2e7c73d3f86ed70bc1ac9a," func (r *ChartRepository) DownloadIndexFile() (string, error) {
 		return """", err
 	}
 
-	indexFile, err := loadIndex(index)
+	indexFile, err := loadIndex(index, r.Config.URL)
 	if err != nil {
 		return """", err
 	}
"
GO-2022-1040,helm,helm,6ce9ba60b73013857e2e7c73d3f86ed70bc1ac9a," func (r *ChartRepository) generateIndex() error {
 		}
 
 		if !r.IndexFile.Has(ch.Name(), ch.Metadata.Version) {
-			r.IndexFile.Add(ch.Metadata, path, r.Config.URL, digest)
+			if err := r.IndexFile.MustAdd(ch.Metadata, path, r.Config.URL, digest); err != nil {
+				return errors.Wrapf(err, ""failed adding to %s to index"", path)
+			}
 		}
 		// TODO: If a chart exists, but has a different Digest, should we error?
 	}
"
GO-2023-2098,Consensys,gnark,59a4087261a6c73f13e80d695c17b398c3d0934f," func WithUnconstrainedInputs() BaseConversionOption {
 		return nil
 	}
 }
+
+// OmitModulusCheck omits the comparison against native field modulus in
+// case the bitlength of the decomposed value (if [WithNbDigits] not set or set
+// to bitlength of the native modulus) eqals bitlength of the modulus.
+//
+// The check is otherwise required as there are possibly multiple correct binary
+// decompositions. For example, when decomposing small a the decomposition could
+// return the slices for both a or a+r, where r is the native modulus and the
+// enforced constraints are correct due to implicit modular reduction by r.
+//
+// This option can be used in case the decomposed output is manually checked to
+// be unique or if uniqueness is not required.
+func OmitModulusCheck() BaseConversionOption {
+	return func(opt *baseConversionConfig) error {
+		opt.omitModulusCheck = true
+		return nil
+	}
+}
"
GO-2023-2098,Consensys,gnark,59a4087261a6c73f13e80d695c17b398c3d0934f," func toBinary(api frontend.API, v frontend.Variable, opts ...BaseConversionOptio
 		}
 	}
 
+	// by default we also check that the value to be decomposed is less than the
+	// modulus. However, we can omit the check when the number of bits we want
+	// to decompose to is less than the modulus or it was strictly requested.
+	omitReducednessCheck := cfg.omitModulusCheck || cfg.NbDigits < api.Compiler().FieldBitLen()
+
 	// when cfg.NbDigits == 1, v itself has to be a binary digit. This if clause
 	// saves one constraint.
 	if cfg.NbDigits == 1 {
 		api.AssertIsBoolean(v)
 		return []frontend.Variable{v}
 	}
+	// if we decompose into more bits than fieldbitlen then the rest would be
+	// always zeros. Reduce the always-zeros to have fewer edge-cases elsewhere.
+	var paddingBits int
+	if cfg.NbDigits > api.Compiler().FieldBitLen() {
+		paddingBits = cfg.NbDigits - api.Compiler().FieldBitLen()
+		cfg.NbDigits = api.Compiler().FieldBitLen()
+	}
 
 	c := big.NewInt(1)
 
"
GO-2023-2098,Consensys,gnark,59a4087261a6c73f13e80d695c17b398c3d0934f," func toBinary(api frontend.API, v frontend.Variable, opts ...BaseConversionOptio
 
 	// record the constraint Σ (2**i * b[i]) == a
 	api.AssertIsEqual(Σbi, v)
+	if !omitReducednessCheck {
+		if cmper, ok := api.Compiler().(bitsComparatorConstant); ok {
+			bound := new(big.Int).Sub(api.Compiler().Field(), big.NewInt(1))
+			cmper.MustBeLessOrEqCst(bits, api.Compiler().Field(), bound)
+		} else {
+			panic(""builder does not expose comparison to constant"")
+		}
+	}
+
+	// restore the zero bits which exceed the field bit-length when requested by
+	// setting WithNbDigits larger than the field bitlength.
+	bits = append(bits, make([]frontend.Variable, paddingBits)...)
+	for i := cfg.NbDigits; i < len(bits); i++ {
+		bits[i] = 0 // frontend.Variable is interface{}, we get nil pointer err if trying to access it.
+	}
 
 	return bits
 }
"
GO-2022-0345,containers,buildah,a468ce0ffd347035d53ee0e26c205ef604097fb0," func runUsingChrootMain() {
 		os.Exit(1)
 	}
 
-	if options.Spec == nil {
+	if options.Spec == nil || options.Spec.Process == nil {
 		fmt.Fprintf(os.Stderr, ""invalid options spec in runUsingChrootMain\n"")
 		os.Exit(1)
 	}
"
GO-2022-0345,containers,buildah,a468ce0ffd347035d53ee0e26c205ef604097fb0," func runUsingChroot(spec *specs.Spec, bundlePath string, ctty *os.File, stdin io
 	cmd := unshare.Command(append([]string{runUsingChrootExecCommand}, spec.Process.Args...)...)
 	cmd.Stdin, cmd.Stdout, cmd.Stderr = stdin, stdout, stderr
 	cmd.Dir = ""/""
-	cmd.Env = append([]string{fmt.Sprintf(""LOGLEVEL=%d"", logrus.GetLevel())}, os.Environ()...)
+	cmd.Env = []string{fmt.Sprintf(""LOGLEVEL=%d"", logrus.GetLevel())}
 	cmd.UnshareFlags = syscall.CLONE_NEWUTS | syscall.CLONE_NEWNS
 	requestedUserNS := false
 	for _, ns := range spec.Linux.Namespaces {
"
GO-2022-0345,containers,buildah,a468ce0ffd347035d53ee0e26c205ef604097fb0," func runUsingChrootExecMain() {
 	// Set the hostname.  We're already in a distinct UTS namespace and are admins in the user
 	// namespace which created it, so we shouldn't get a permissions error, but seccomp policy
 	// might deny our attempt to call sethostname() anyway, so log a debug message for that.
-	if options.Spec == nil {
+	if options.Spec == nil || options.Spec.Process == nil {
 		fmt.Fprintf(os.Stderr, ""invalid options spec passed in\n"")
 		os.Exit(1)
 	}
"
GO-2022-0345,containers,buildah,a468ce0ffd347035d53ee0e26c205ef604097fb0," func logNamespaceDiagnostics(spec *specs.Spec) {
 			}
 		case specs.UserNamespace:
 			if ns.Path != """" {
-				logrus.Debugf(""unable to join user namespace %q, creating a new one"", ns.Path)
+				logrus.Debugf(""unable to join user namespace, sorry about that"")
 			}
-			sawUserNS = true
 		case specs.UTSNamespace:
 			if ns.Path != """" {
 				logrus.Debugf(""unable to join UTS namespace %q, creating a new one"", ns.Path)
"
GO-2022-0345,containers,buildah,a468ce0ffd347035d53ee0e26c205ef604097fb0," func runUsingChrootExecMain() {
 // Output debug messages when that differs from what we're being asked to do.
 func logNamespaceDiagnostics(spec *specs.Spec) {
 	sawMountNS := false
-	sawUserNS := false
 	sawUTSNS := false
 	for _, ns := range spec.Linux.Namespaces {
 		switch ns.Type {
"
GO-2022-0345,containers,buildah,a468ce0ffd347035d53ee0e26c205ef604097fb0," func logNamespaceDiagnostics(spec *specs.Spec) {
 	if !sawMountNS {
 		logrus.Debugf(""mount namespace not requested, but creating a new one anyway"")
 	}
-	if !sawUserNS {
-		logrus.Debugf(""user namespace not requested, but creating a new one anyway"")
-	}
 	if !sawUTSNS {
 		logrus.Debugf(""UTS namespace not requested, but creating a new one anyway"")
 	}
"
GO-2021-0052,gin-gonic,gin,5929d521715610c9dd14898ebbe1d188d5de8937," func (c *Context) ClientIP() string {
 	return remoteIP.String()
 }
 
+func (e *Engine) isTrustedProxy(ip net.IP) bool {
+	if e.trustedCIDRs != nil {
+		for _, cidr := range e.trustedCIDRs {
+			if cidr.Contains(ip) {
+				return true
+			}
+		}
+	}
+	return false
+}
+
 // RemoteIP parses the IP from Request.RemoteAddr, normalizes and returns the IP (without the port).
 // It also checks if the remoteIP is a trusted proxy or not.
 // In order to perform this validation, it will see if the IP is contained within at least one of the CIDR blocks
"
GO-2021-0052,gin-gonic,gin,bfc8ca285eb46dad60e037d57c545cd260636711," func New() *Engine {
 		RedirectFixedPath:      false,
 		HandleMethodNotAllowed: false,
 		ForwardedByClientIP:    true,
+		RemoteIPHeaders:        []string{""X-Forwarded-For"", ""X-Real-IP""},
+		TrustedProxies:         []string{""0.0.0.0/0""},
 		AppEngine:              defaultAppEngine,
 		UseRawPath:             false,
 		RemoveExtraSlash:       false,
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func maxUint64(a, b uint64) uint64 {
 	}
 	return a
 }
+
+func minUint64(a, b uint64) uint64 {
+	if a >= b {
+		return b
+	}
+	return a
+}
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func DualProofToProto(dualProof *store.DualProof) *DualProof {
 		TargetBlTxAlh:      dualProof.TargetBlTxAlh[:],
 		LastInclusionProof: DigestsToProto(dualProof.LastInclusionProof),
 		LinearProof:        LinearProofToProto(dualProof.LinearProof),
+		LinearAdvanceProof: LinearAdvanceProofToProto(dualProof.LinearAdvanceProof),
 	}
 }
 
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func DualProofFromProto(dproof *DualProof) *store.DualProof {
 		TargetBlTxAlh:      DigestFromProto(dproof.TargetBlTxAlh),
 		LastInclusionProof: DigestsFromProto(dproof.LastInclusionProof),
 		LinearProof:        LinearProofFromProto(dproof.LinearProof),
+		LinearAdvanceProof: LinearAdvanceProofFromProto(dproof.LinearAdvanceProof),
 	}
 }
 
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type DualProof struct {
 	LastInclusionProof [][]byte `protobuf:""bytes,6,rep,name=lastInclusionProof,proto3"" json:""lastInclusionProof,omitempty""`
 	// Linear proof starting from targetBlTxAlh to the final state value
 	LinearProof *LinearProof `protobuf:""bytes,7,opt,name=linearProof,proto3"" json:""linearProof,omitempty""`
+	// Proof of consistency between some part of older linear chain and newer Merkle Tree
+	LinearAdvanceProof *LinearAdvanceProof `protobuf:""bytes,8,opt,name=LinearAdvanceProof,proto3"" json:""LinearAdvanceProof,omitempty""`
 }
 
 func (x *DualProof) Reset() {
 	*x = DualProof{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[29]
+		mi := &file_schema_proto_msgTypes[30]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *DualProof) String() string {
 func (*DualProof) ProtoMessage() {}
 
 func (x *DualProof) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[29]
+	mi := &file_schema_proto_msgTypes[30]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *DualProof) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use DualProof.ProtoReflect.Descriptor instead.
 func (*DualProof) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{29}
+	return file_schema_proto_rawDescGZIP(), []int{30}
 }
 
 func (x *DualProof) GetSourceTxHeader() *TxHeader {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *DualProof) GetLinearProof() *LinearProof {
 	return nil
 }
 
+func (x *DualProof) GetLinearAdvanceProof() *LinearAdvanceProof {
+	if x != nil {
+		return x.LinearAdvanceProof
+	}
+	return nil
+}
+
 type Tx struct {
 	state         protoimpl.MessageState
 	sizeCache     protoimpl.SizeCache
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type Tx struct {
 func (x *Tx) Reset() {
 	*x = Tx{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[30]
+		mi := &file_schema_proto_msgTypes[31]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *Tx) String() string {
 func (*Tx) ProtoMessage() {}
 
 func (x *Tx) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[30]
+	mi := &file_schema_proto_msgTypes[31]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *Tx) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use Tx.ProtoReflect.Descriptor instead.
 func (*Tx) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{30}
+	return file_schema_proto_rawDescGZIP(), []int{31}
 }
 
 func (x *Tx) GetHeader() *TxHeader {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type TxEntry struct {
 func (x *TxEntry) Reset() {
 	*x = TxEntry{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[31]
+		mi := &file_schema_proto_msgTypes[32]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *TxEntry) String() string {
 func (*TxEntry) ProtoMessage() {}
 
 func (x *TxEntry) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[31]
+	mi := &file_schema_proto_msgTypes[32]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *TxEntry) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use TxEntry.ProtoReflect.Descriptor instead.
 func (*TxEntry) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{31}
+	return file_schema_proto_rawDescGZIP(), []int{32}
 }
 
 func (x *TxEntry) GetKey() []byte {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type KVMetadata struct {
 func (x *KVMetadata) Reset() {
 	*x = KVMetadata{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[32]
+		mi := &file_schema_proto_msgTypes[33]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *KVMetadata) String() string {
 func (*KVMetadata) ProtoMessage() {}
 
 func (x *KVMetadata) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[32]
+	mi := &file_schema_proto_msgTypes[33]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *KVMetadata) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use KVMetadata.ProtoReflect.Descriptor instead.
 func (*KVMetadata) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{32}
+	return file_schema_proto_rawDescGZIP(), []int{33}
 }
 
 func (x *KVMetadata) GetDeleted() bool {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type Expiration struct {
 func (x *Expiration) Reset() {
 	*x = Expiration{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[33]
+		mi := &file_schema_proto_msgTypes[34]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *Expiration) String() string {
 func (*Expiration) ProtoMessage() {}
 
 func (x *Expiration) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[33]
+	mi := &file_schema_proto_msgTypes[34]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *Expiration) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use Expiration.ProtoReflect.Descriptor instead.
 func (*Expiration) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{33}
+	return file_schema_proto_rawDescGZIP(), []int{34}
 }
 
 func (x *Expiration) GetExpiresAt() int64 {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type VerifiableTx struct {
 func (x *VerifiableTx) Reset() {
 	*x = VerifiableTx{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[34]
+		mi := &file_schema_proto_msgTypes[35]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *VerifiableTx) String() string {
 func (*VerifiableTx) ProtoMessage() {}
 
 func (x *VerifiableTx) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[34]
+	mi := &file_schema_proto_msgTypes[35]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *VerifiableTx) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use VerifiableTx.ProtoReflect.Descriptor instead.
 func (*VerifiableTx) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{34}
+	return file_schema_proto_rawDescGZIP(), []int{35}
 }
 
 func (x *VerifiableTx) GetTx() *Tx {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type VerifiableEntry struct {
 func (x *VerifiableEntry) Reset() {
 	*x = VerifiableEntry{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[35]
+		mi := &file_schema_proto_msgTypes[36]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *VerifiableEntry) String() string {
 func (*VerifiableEntry) ProtoMessage() {}
 
 func (x *VerifiableEntry) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[35]
+	mi := &file_schema_proto_msgTypes[36]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *VerifiableEntry) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use VerifiableEntry.ProtoReflect.Descriptor instead.
 func (*VerifiableEntry) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{35}
+	return file_schema_proto_rawDescGZIP(), []int{36}
 }
 
 func (x *VerifiableEntry) GetEntry() *Entry {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type InclusionProof struct {
 func (x *InclusionProof) Reset() {
 	*x = InclusionProof{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[36]
+		mi := &file_schema_proto_msgTypes[37]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *InclusionProof) String() string {
 func (*InclusionProof) ProtoMessage() {}
 
 func (x *InclusionProof) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[36]
+	mi := &file_schema_proto_msgTypes[37]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *InclusionProof) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use InclusionProof.ProtoReflect.Descriptor instead.
 func (*InclusionProof) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{36}
+	return file_schema_proto_rawDescGZIP(), []int{37}
 }
 
 func (x *InclusionProof) GetLeaf() int32 {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type SetRequest struct {
 func (x *SetRequest) Reset() {
 	*x = SetRequest{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[37]
+		mi := &file_schema_proto_msgTypes[38]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *SetRequest) String() string {
 func (*SetRequest) ProtoMessage() {}
 
 func (x *SetRequest) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[37]
+	mi := &file_schema_proto_msgTypes[38]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *SetRequest) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use SetRequest.ProtoReflect.Descriptor instead.
 func (*SetRequest) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{37}
+	return file_schema_proto_rawDescGZIP(), []int{38}
 }
 
 func (x *SetRequest) GetKVs() []*KeyValue {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type KeyRequest struct {
 func (x *KeyRequest) Reset() {
 	*x = KeyRequest{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[38]
+		mi := &file_schema_proto_msgTypes[39]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *KeyRequest) String() string {
 func (*KeyRequest) ProtoMessage() {}
 
 func (x *KeyRequest) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[38]
+	mi := &file_schema_proto_msgTypes[39]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *KeyRequest) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use KeyRequest.ProtoReflect.Descriptor instead.
 func (*KeyRequest) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{38}
+	return file_schema_proto_rawDescGZIP(), []int{39}
 }
 
 func (x *KeyRequest) GetKey() []byte {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type KeyListRequest struct {
 func (x *KeyListRequest) Reset() {
 	*x = KeyListRequest{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[39]
+		mi := &file_schema_proto_msgTypes[40]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *KeyListRequest) String() string {
 func (*KeyListRequest) ProtoMessage() {}
 
 func (x *KeyListRequest) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[39]
+	mi := &file_schema_proto_msgTypes[40]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *KeyListRequest) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use KeyListRequest.ProtoReflect.Descriptor instead.
 func (*KeyListRequest) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{39}
+	return file_schema_proto_rawDescGZIP(), []int{40}
 }
 
 func (x *KeyListRequest) GetKeys() [][]byte {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type DeleteKeysRequest struct {
 func (x *DeleteKeysRequest) Reset() {
 	*x = DeleteKeysRequest{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[40]
+		mi := &file_schema_proto_msgTypes[41]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *DeleteKeysRequest) String() string {
 func (*DeleteKeysRequest) ProtoMessage() {}
 
 func (x *DeleteKeysRequest) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[40]
+	mi := &file_schema_proto_msgTypes[41]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *DeleteKeysRequest) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use DeleteKeysRequest.ProtoReflect.Descriptor instead.
 func (*DeleteKeysRequest) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{40}
+	return file_schema_proto_rawDescGZIP(), []int{41}
 }
 
 func (x *DeleteKeysRequest) GetKeys() [][]byte {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type VerifiableSetRequest struct {
 func (x *VerifiableSetRequest) Reset() {
 	*x = VerifiableSetRequest{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[41]
+		mi := &file_schema_proto_msgTypes[42]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *VerifiableSetRequest) String() string {
 func (*VerifiableSetRequest) ProtoMessage() {}
 
 func (x *VerifiableSetRequest) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[41]
+	mi := &file_schema_proto_msgTypes[42]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *VerifiableSetRequest) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use VerifiableSetRequest.ProtoReflect.Descriptor instead.
 func (*VerifiableSetRequest) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{41}
+	return file_schema_proto_rawDescGZIP(), []int{42}
 }
 
 func (x *VerifiableSetRequest) GetSetRequest() *SetRequest {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type VerifiableGetRequest struct {
 func (x *VerifiableGetRequest) Reset() {
 	*x = VerifiableGetRequest{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[42]
+		mi := &file_schema_proto_msgTypes[43]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *VerifiableGetRequest) String() string {
 func (*VerifiableGetRequest) ProtoMessage() {}
 
 func (x *VerifiableGetRequest) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[42]
+	mi := &file_schema_proto_msgTypes[43]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *VerifiableGetRequest) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use VerifiableGetRequest.ProtoReflect.Descriptor instead.
 func (*VerifiableGetRequest) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{42}
+	return file_schema_proto_rawDescGZIP(), []int{43}
 }
 
 func (x *VerifiableGetRequest) GetKeyRequest() *KeyRequest {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type ServerInfoRequest struct {
 func (x *ServerInfoRequest) Reset() {
 	*x = ServerInfoRequest{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[43]
+		mi := &file_schema_proto_msgTypes[44]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *ServerInfoRequest) String() string {
 func (*ServerInfoRequest) ProtoMessage() {}
 
 func (x *ServerInfoRequest) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[43]
+	mi := &file_schema_proto_msgTypes[44]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *ServerInfoRequest) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use ServerInfoRequest.ProtoReflect.Descriptor instead.
 func (*ServerInfoRequest) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{43}
+	return file_schema_proto_rawDescGZIP(), []int{44}
 }
 
 // ServerInfoResponse contains information about the server instance.
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type ServerInfoResponse struct {
 func (x *ServerInfoResponse) Reset() {
 	*x = ServerInfoResponse{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[44]
+		mi := &file_schema_proto_msgTypes[45]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *ServerInfoResponse) String() string {
 func (*ServerInfoResponse) ProtoMessage() {}
 
 func (x *ServerInfoResponse) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[44]
+	mi := &file_schema_proto_msgTypes[45]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *ServerInfoResponse) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use ServerInfoResponse.ProtoReflect.Descriptor instead.
 func (*ServerInfoResponse) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{44}
+	return file_schema_proto_rawDescGZIP(), []int{45}
 }
 
 func (x *ServerInfoResponse) GetVersion() string {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type HealthResponse struct {
 func (x *HealthResponse) Reset() {
 	*x = HealthResponse{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[45]
+		mi := &file_schema_proto_msgTypes[46]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *HealthResponse) String() string {
 func (*HealthResponse) ProtoMessage() {}
 
 func (x *HealthResponse) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[45]
+	mi := &file_schema_proto_msgTypes[46]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *HealthResponse) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use HealthResponse.ProtoReflect.Descriptor instead.
 func (*HealthResponse) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{45}
+	return file_schema_proto_rawDescGZIP(), []int{46}
 }
 
 func (x *HealthResponse) GetStatus() bool {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type DatabaseHealthResponse struct {
 func (x *DatabaseHealthResponse) Reset() {
 	*x = DatabaseHealthResponse{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[46]
+		mi := &file_schema_proto_msgTypes[47]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *DatabaseHealthResponse) String() string {
 func (*DatabaseHealthResponse) ProtoMessage() {}
 
 func (x *DatabaseHealthResponse) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[46]
+	mi := &file_schema_proto_msgTypes[47]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *DatabaseHealthResponse) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use DatabaseHealthResponse.ProtoReflect.Descriptor instead.
 func (*DatabaseHealthResponse) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{46}
+	return file_schema_proto_rawDescGZIP(), []int{47}
 }
 
 func (x *DatabaseHealthResponse) GetPendingRequests() uint32 {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type ImmutableState struct {
 func (x *ImmutableState) Reset() {
 	*x = ImmutableState{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[47]
+		mi := &file_schema_proto_msgTypes[48]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *ImmutableState) String() string {
 func (*ImmutableState) ProtoMessage() {}
 
 func (x *ImmutableState) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[47]
+	mi := &file_schema_proto_msgTypes[48]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *ImmutableState) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use ImmutableState.ProtoReflect.Descriptor instead.
 func (*ImmutableState) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{47}
+	return file_schema_proto_rawDescGZIP(), []int{48}
 }
 
 func (x *ImmutableState) GetDb() string {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type ReferenceRequest struct {
 func (x *ReferenceRequest) Reset() {
 	*x = ReferenceRequest{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[48]
+		mi := &file_schema_proto_msgTypes[49]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *ReferenceRequest) String() string {
 func (*ReferenceRequest) ProtoMessage() {}
 
 func (x *ReferenceRequest) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[48]
+	mi := &file_schema_proto_msgTypes[49]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *ReferenceRequest) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use ReferenceRequest.ProtoReflect.Descriptor instead.
 func (*ReferenceRequest) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{48}
+	return file_schema_proto_rawDescGZIP(), []int{49}
 }
 
 func (x *ReferenceRequest) GetKey() []byte {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type VerifiableReferenceRequest struct {
 func (x *VerifiableReferenceRequest) Reset() {
 	*x = VerifiableReferenceRequest{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[49]
+		mi := &file_schema_proto_msgTypes[50]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *VerifiableReferenceRequest) String() string {
 func (*VerifiableReferenceRequest) ProtoMessage() {}
 
 func (x *VerifiableReferenceRequest) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[49]
+	mi := &file_schema_proto_msgTypes[50]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *VerifiableReferenceRequest) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use VerifiableReferenceRequest.ProtoReflect.Descriptor instead.
 func (*VerifiableReferenceRequest) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{49}
+	return file_schema_proto_rawDescGZIP(), []int{50}
 }
 
 func (x *VerifiableReferenceRequest) GetReferenceRequest() *ReferenceRequest {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type ZAddRequest struct {
 func (x *ZAddRequest) Reset() {
 	*x = ZAddRequest{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[50]
+		mi := &file_schema_proto_msgTypes[51]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *ZAddRequest) String() string {
 func (*ZAddRequest) ProtoMessage() {}
 
 func (x *ZAddRequest) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[50]
+	mi := &file_schema_proto_msgTypes[51]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *ZAddRequest) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use ZAddRequest.ProtoReflect.Descriptor instead.
 func (*ZAddRequest) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{50}
+	return file_schema_proto_rawDescGZIP(), []int{51}
 }
 
 func (x *ZAddRequest) GetSet() []byte {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type Score struct {
 func (x *Score) Reset() {
 	*x = Score{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[51]
+		mi := &file_schema_proto_msgTypes[52]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *Score) String() string {
 func (*Score) ProtoMessage() {}
 
 func (x *Score) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[51]
+	mi := &file_schema_proto_msgTypes[52]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *Score) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use Score.ProtoReflect.Descriptor instead.
 func (*Score) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{51}
+	return file_schema_proto_rawDescGZIP(), []int{52}
 }
 
 func (x *Score) GetScore() float64 {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type ZScanRequest struct {
 func (x *ZScanRequest) Reset() {
 	*x = ZScanRequest{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[52]
+		mi := &file_schema_proto_msgTypes[53]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *ZScanRequest) String() string {
 func (*ZScanRequest) ProtoMessage() {}
 
 func (x *ZScanRequest) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[52]
+	mi := &file_schema_proto_msgTypes[53]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *ZScanRequest) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use ZScanRequest.ProtoReflect.Descriptor instead.
 func (*ZScanRequest) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{52}
+	return file_schema_proto_rawDescGZIP(), []int{53}
 }
 
 func (x *ZScanRequest) GetSet() []byte {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type HistoryRequest struct {
 func (x *HistoryRequest) Reset() {
 	*x = HistoryRequest{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[53]
+		mi := &file_schema_proto_msgTypes[54]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *HistoryRequest) String() string {
 func (*HistoryRequest) ProtoMessage() {}
 
 func (x *HistoryRequest) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[53]
+	mi := &file_schema_proto_msgTypes[54]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *HistoryRequest) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use HistoryRequest.ProtoReflect.Descriptor instead.
 func (*HistoryRequest) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{53}
+	return file_schema_proto_rawDescGZIP(), []int{54}
 }
 
 func (x *HistoryRequest) GetKey() []byte {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type VerifiableZAddRequest struct {
 func (x *VerifiableZAddRequest) Reset() {
 	*x = VerifiableZAddRequest{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[54]
+		mi := &file_schema_proto_msgTypes[55]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *VerifiableZAddRequest) String() string {
 func (*VerifiableZAddRequest) ProtoMessage() {}
 
 func (x *VerifiableZAddRequest) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[54]
+	mi := &file_schema_proto_msgTypes[55]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *VerifiableZAddRequest) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use VerifiableZAddRequest.ProtoReflect.Descriptor instead.
 func (*VerifiableZAddRequest) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{54}
+	return file_schema_proto_rawDescGZIP(), []int{55}
 }
 
 func (x *VerifiableZAddRequest) GetZAddRequest() *ZAddRequest {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type TxRequest struct {
 func (x *TxRequest) Reset() {
 	*x = TxRequest{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[55]
+		mi := &file_schema_proto_msgTypes[56]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *TxRequest) String() string {
 func (*TxRequest) ProtoMessage() {}
 
 func (x *TxRequest) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[55]
+	mi := &file_schema_proto_msgTypes[56]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *TxRequest) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use TxRequest.ProtoReflect.Descriptor instead.
 func (*TxRequest) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{55}
+	return file_schema_proto_rawDescGZIP(), []int{56}
 }
 
 func (x *TxRequest) GetTx() uint64 {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type EntriesSpec struct {
 func (x *EntriesSpec) Reset() {
 	*x = EntriesSpec{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[56]
+		mi := &file_schema_proto_msgTypes[57]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *EntriesSpec) String() string {
 func (*EntriesSpec) ProtoMessage() {}
 
 func (x *EntriesSpec) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[56]
+	mi := &file_schema_proto_msgTypes[57]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *EntriesSpec) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use EntriesSpec.ProtoReflect.Descriptor instead.
 func (*EntriesSpec) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{56}
+	return file_schema_proto_rawDescGZIP(), []int{57}
 }
 
 func (x *EntriesSpec) GetKvEntriesSpec() *EntryTypeSpec {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type EntryTypeSpec struct {
 func (x *EntryTypeSpec) Reset() {
 	*x = EntryTypeSpec{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[57]
+		mi := &file_schema_proto_msgTypes[58]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *EntryTypeSpec) String() string {
 func (*EntryTypeSpec) ProtoMessage() {}
 
 func (x *EntryTypeSpec) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[57]
+	mi := &file_schema_proto_msgTypes[58]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *EntryTypeSpec) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use EntryTypeSpec.ProtoReflect.Descriptor instead.
 func (*EntryTypeSpec) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{57}
+	return file_schema_proto_rawDescGZIP(), []int{58}
 }
 
 func (x *EntryTypeSpec) GetAction() EntryTypeAction {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type VerifiableTxRequest struct {
 func (x *VerifiableTxRequest) Reset() {
 	*x = VerifiableTxRequest{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[58]
+		mi := &file_schema_proto_msgTypes[59]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *VerifiableTxRequest) String() string {
 func (*VerifiableTxRequest) ProtoMessage() {}
 
 func (x *VerifiableTxRequest) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[58]
+	mi := &file_schema_proto_msgTypes[59]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *VerifiableTxRequest) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use VerifiableTxRequest.ProtoReflect.Descriptor instead.
 func (*VerifiableTxRequest) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{58}
+	return file_schema_proto_rawDescGZIP(), []int{59}
 }
 
 func (x *VerifiableTxRequest) GetTx() uint64 {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type TxScanRequest struct {
 func (x *TxScanRequest) Reset() {
 	*x = TxScanRequest{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[59]
+		mi := &file_schema_proto_msgTypes[60]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *TxScanRequest) String() string {
 func (*TxScanRequest) ProtoMessage() {}
 
 func (x *TxScanRequest) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[59]
+	mi := &file_schema_proto_msgTypes[60]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *TxScanRequest) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use TxScanRequest.ProtoReflect.Descriptor instead.
 func (*TxScanRequest) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{59}
+	return file_schema_proto_rawDescGZIP(), []int{60}
 }
 
 func (x *TxScanRequest) GetInitialTx() uint64 {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type TxList struct {
 func (x *TxList) Reset() {
 	*x = TxList{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[60]
+		mi := &file_schema_proto_msgTypes[61]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *TxList) String() string {
 func (*TxList) ProtoMessage() {}
 
 func (x *TxList) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[60]
+	mi := &file_schema_proto_msgTypes[61]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *TxList) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use TxList.ProtoReflect.Descriptor instead.
 func (*TxList) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{60}
+	return file_schema_proto_rawDescGZIP(), []int{61}
 }
 
 func (x *TxList) GetTxs() []*Tx {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type ExportTxRequest struct {
 func (x *ExportTxRequest) Reset() {
 	*x = ExportTxRequest{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[61]
+		mi := &file_schema_proto_msgTypes[62]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *ExportTxRequest) String() string {
 func (*ExportTxRequest) ProtoMessage() {}
 
 func (x *ExportTxRequest) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[61]
+	mi := &file_schema_proto_msgTypes[62]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *ExportTxRequest) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use ExportTxRequest.ProtoReflect.Descriptor instead.
 func (*ExportTxRequest) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{61}
+	return file_schema_proto_rawDescGZIP(), []int{62}
 }
 
 func (x *ExportTxRequest) GetTx() uint64 {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type ReplicaState struct {
 func (x *ReplicaState) Reset() {
 	*x = ReplicaState{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[62]
+		mi := &file_schema_proto_msgTypes[63]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *ReplicaState) String() string {
 func (*ReplicaState) ProtoMessage() {}
 
 func (x *ReplicaState) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[62]
+	mi := &file_schema_proto_msgTypes[63]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *ReplicaState) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use ReplicaState.ProtoReflect.Descriptor instead.
 func (*ReplicaState) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{62}
+	return file_schema_proto_rawDescGZIP(), []int{63}
 }
 
 func (x *ReplicaState) GetUUID() string {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type Database struct {
 func (x *Database) Reset() {
 	*x = Database{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[63]
+		mi := &file_schema_proto_msgTypes[64]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *Database) String() string {
 func (*Database) ProtoMessage() {}
 
 func (x *Database) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[63]
+	mi := &file_schema_proto_msgTypes[64]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *Database) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use Database.ProtoReflect.Descriptor instead.
 func (*Database) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{63}
+	return file_schema_proto_rawDescGZIP(), []int{64}
 }
 
 func (x *Database) GetDatabaseName() string {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type DatabaseSettings struct {
 func (x *DatabaseSettings) Reset() {
 	*x = DatabaseSettings{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[64]
+		mi := &file_schema_proto_msgTypes[65]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *DatabaseSettings) String() string {
 func (*DatabaseSettings) ProtoMessage() {}
 
 func (x *DatabaseSettings) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[64]
+	mi := &file_schema_proto_msgTypes[65]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *DatabaseSettings) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use DatabaseSettings.ProtoReflect.Descriptor instead.
 func (*DatabaseSettings) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{64}
+	return file_schema_proto_rawDescGZIP(), []int{65}
 }
 
 func (x *DatabaseSettings) GetDatabaseName() string {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type CreateDatabaseRequest struct {
 func (x *CreateDatabaseRequest) Reset() {
 	*x = CreateDatabaseRequest{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[65]
+		mi := &file_schema_proto_msgTypes[66]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *CreateDatabaseRequest) String() string {
 func (*CreateDatabaseRequest) ProtoMessage() {}
 
 func (x *CreateDatabaseRequest) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[65]
+	mi := &file_schema_proto_msgTypes[66]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *CreateDatabaseRequest) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use CreateDatabaseRequest.ProtoReflect.Descriptor instead.
 func (*CreateDatabaseRequest) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{65}
+	return file_schema_proto_rawDescGZIP(), []int{66}
 }
 
 func (x *CreateDatabaseRequest) GetName() string {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type CreateDatabaseResponse struct {
 func (x *CreateDatabaseResponse) Reset() {
 	*x = CreateDatabaseResponse{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[66]
+		mi := &file_schema_proto_msgTypes[67]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *CreateDatabaseResponse) String() string {
 func (*CreateDatabaseResponse) ProtoMessage() {}
 
 func (x *CreateDatabaseResponse) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[66]
+	mi := &file_schema_proto_msgTypes[67]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *CreateDatabaseResponse) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use CreateDatabaseResponse.ProtoReflect.Descriptor instead.
 func (*CreateDatabaseResponse) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{66}
+	return file_schema_proto_rawDescGZIP(), []int{67}
 }
 
 func (x *CreateDatabaseResponse) GetName() string {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type UpdateDatabaseRequest struct {
 func (x *UpdateDatabaseRequest) Reset() {
 	*x = UpdateDatabaseRequest{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[67]
+		mi := &file_schema_proto_msgTypes[68]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *UpdateDatabaseRequest) String() string {
 func (*UpdateDatabaseRequest) ProtoMessage() {}
 
 func (x *UpdateDatabaseRequest) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[67]
+	mi := &file_schema_proto_msgTypes[68]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *UpdateDatabaseRequest) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use UpdateDatabaseRequest.ProtoReflect.Descriptor instead.
 func (*UpdateDatabaseRequest) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{67}
+	return file_schema_proto_rawDescGZIP(), []int{68}
 }
 
 func (x *UpdateDatabaseRequest) GetDatabase() string {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type UpdateDatabaseResponse struct {
 func (x *UpdateDatabaseResponse) Reset() {
 	*x = UpdateDatabaseResponse{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[68]
+		mi := &file_schema_proto_msgTypes[69]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *UpdateDatabaseResponse) String() string {
 func (*UpdateDatabaseResponse) ProtoMessage() {}
 
 func (x *UpdateDatabaseResponse) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[68]
+	mi := &file_schema_proto_msgTypes[69]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *UpdateDatabaseResponse) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use UpdateDatabaseResponse.ProtoReflect.Descriptor instead.
 func (*UpdateDatabaseResponse) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{68}
+	return file_schema_proto_rawDescGZIP(), []int{69}
 }
 
 func (x *UpdateDatabaseResponse) GetDatabase() string {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type DatabaseSettingsRequest struct {
 func (x *DatabaseSettingsRequest) Reset() {
 	*x = DatabaseSettingsRequest{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[69]
+		mi := &file_schema_proto_msgTypes[70]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *DatabaseSettingsRequest) String() string {
 func (*DatabaseSettingsRequest) ProtoMessage() {}
 
 func (x *DatabaseSettingsRequest) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[69]
+	mi := &file_schema_proto_msgTypes[70]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *DatabaseSettingsRequest) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use DatabaseSettingsRequest.ProtoReflect.Descriptor instead.
 func (*DatabaseSettingsRequest) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{69}
+	return file_schema_proto_rawDescGZIP(), []int{70}
 }
 
 type DatabaseSettingsResponse struct {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type DatabaseSettingsResponse struct {
 func (x *DatabaseSettingsResponse) Reset() {
 	*x = DatabaseSettingsResponse{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[70]
+		mi := &file_schema_proto_msgTypes[71]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *DatabaseSettingsResponse) String() string {
 func (*DatabaseSettingsResponse) ProtoMessage() {}
 
 func (x *DatabaseSettingsResponse) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[70]
+	mi := &file_schema_proto_msgTypes[71]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *DatabaseSettingsResponse) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use DatabaseSettingsResponse.ProtoReflect.Descriptor instead.
 func (*DatabaseSettingsResponse) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{70}
+	return file_schema_proto_rawDescGZIP(), []int{71}
 }
 
 func (x *DatabaseSettingsResponse) GetDatabase() string {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type NullableUint32 struct {
 func (x *NullableUint32) Reset() {
 	*x = NullableUint32{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[71]
+		mi := &file_schema_proto_msgTypes[72]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *NullableUint32) String() string {
 func (*NullableUint32) ProtoMessage() {}
 
 func (x *NullableUint32) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[71]
+	mi := &file_schema_proto_msgTypes[72]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *NullableUint32) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use NullableUint32.ProtoReflect.Descriptor instead.
 func (*NullableUint32) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{71}
+	return file_schema_proto_rawDescGZIP(), []int{72}
 }
 
 func (x *NullableUint32) GetValue() uint32 {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type NullableUint64 struct {
 func (x *NullableUint64) Reset() {
 	*x = NullableUint64{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[72]
+		mi := &file_schema_proto_msgTypes[73]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *NullableUint64) String() string {
 func (*NullableUint64) ProtoMessage() {}
 
 func (x *NullableUint64) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[72]
+	mi := &file_schema_proto_msgTypes[73]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *NullableUint64) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use NullableUint64.ProtoReflect.Descriptor instead.
 func (*NullableUint64) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{72}
+	return file_schema_proto_rawDescGZIP(), []int{73}
 }
 
 func (x *NullableUint64) GetValue() uint64 {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type NullableFloat struct {
 func (x *NullableFloat) Reset() {
 	*x = NullableFloat{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[73]
+		mi := &file_schema_proto_msgTypes[74]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *NullableFloat) String() string {
 func (*NullableFloat) ProtoMessage() {}
 
 func (x *NullableFloat) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[73]
+	mi := &file_schema_proto_msgTypes[74]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *NullableFloat) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use NullableFloat.ProtoReflect.Descriptor instead.
 func (*NullableFloat) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{73}
+	return file_schema_proto_rawDescGZIP(), []int{74}
 }
 
 func (x *NullableFloat) GetValue() float32 {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type NullableBool struct {
 func (x *NullableBool) Reset() {
 	*x = NullableBool{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[74]
+		mi := &file_schema_proto_msgTypes[75]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *NullableBool) String() string {
 func (*NullableBool) ProtoMessage() {}
 
 func (x *NullableBool) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[74]
+	mi := &file_schema_proto_msgTypes[75]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *NullableBool) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use NullableBool.ProtoReflect.Descriptor instead.
 func (*NullableBool) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{74}
+	return file_schema_proto_rawDescGZIP(), []int{75}
 }
 
 func (x *NullableBool) GetValue() bool {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type NullableString struct {
 func (x *NullableString) Reset() {
 	*x = NullableString{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[75]
+		mi := &file_schema_proto_msgTypes[76]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *NullableString) String() string {
 func (*NullableString) ProtoMessage() {}
 
 func (x *NullableString) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[75]
+	mi := &file_schema_proto_msgTypes[76]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *NullableString) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use NullableString.ProtoReflect.Descriptor instead.
 func (*NullableString) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{75}
+	return file_schema_proto_rawDescGZIP(), []int{76}
 }
 
 func (x *NullableString) GetValue() string {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type NullableMilliseconds struct {
 func (x *NullableMilliseconds) Reset() {
 	*x = NullableMilliseconds{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[76]
+		mi := &file_schema_proto_msgTypes[77]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *NullableMilliseconds) String() string {
 func (*NullableMilliseconds) ProtoMessage() {}
 
 func (x *NullableMilliseconds) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[76]
+	mi := &file_schema_proto_msgTypes[77]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *NullableMilliseconds) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use NullableMilliseconds.ProtoReflect.Descriptor instead.
 func (*NullableMilliseconds) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{76}
+	return file_schema_proto_rawDescGZIP(), []int{77}
 }
 
 func (x *NullableMilliseconds) GetValue() int64 {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type DatabaseNullableSettings struct {
 func (x *DatabaseNullableSettings) Reset() {
 	*x = DatabaseNullableSettings{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[77]
+		mi := &file_schema_proto_msgTypes[78]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *DatabaseNullableSettings) String() string {
 func (*DatabaseNullableSettings) ProtoMessage() {}
 
 func (x *DatabaseNullableSettings) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[77]
+	mi := &file_schema_proto_msgTypes[78]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *DatabaseNullableSettings) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use DatabaseNullableSettings.ProtoReflect.Descriptor instead.
 func (*DatabaseNullableSettings) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{77}
+	return file_schema_proto_rawDescGZIP(), []int{78}
 }
 
 func (x *DatabaseNullableSettings) GetReplicationSettings() *ReplicationNullableSettings {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type ReplicationNullableSettings struct {
 func (x *ReplicationNullableSettings) Reset() {
 	*x = ReplicationNullableSettings{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[78]
+		mi := &file_schema_proto_msgTypes[79]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *ReplicationNullableSettings) String() string {
 func (*ReplicationNullableSettings) ProtoMessage() {}
 
 func (x *ReplicationNullableSettings) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[78]
+	mi := &file_schema_proto_msgTypes[79]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *ReplicationNullableSettings) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use ReplicationNullableSettings.ProtoReflect.Descriptor instead.
 func (*ReplicationNullableSettings) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{78}
+	return file_schema_proto_rawDescGZIP(), []int{79}
 }
 
 func (x *ReplicationNullableSettings) GetReplica() *NullableBool {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type IndexNullableSettings struct {
 func (x *IndexNullableSettings) Reset() {
 	*x = IndexNullableSettings{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[79]
+		mi := &file_schema_proto_msgTypes[80]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *IndexNullableSettings) String() string {
 func (*IndexNullableSettings) ProtoMessage() {}
 
 func (x *IndexNullableSettings) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[79]
+	mi := &file_schema_proto_msgTypes[80]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *IndexNullableSettings) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use IndexNullableSettings.ProtoReflect.Descriptor instead.
 func (*IndexNullableSettings) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{79}
+	return file_schema_proto_rawDescGZIP(), []int{80}
 }
 
 func (x *IndexNullableSettings) GetFlushThreshold() *NullableUint32 {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type AHTNullableSettings struct {
 func (x *AHTNullableSettings) Reset() {
 	*x = AHTNullableSettings{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[80]
+		mi := &file_schema_proto_msgTypes[81]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *AHTNullableSettings) String() string {
 func (*AHTNullableSettings) ProtoMessage() {}
 
 func (x *AHTNullableSettings) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[80]
+	mi := &file_schema_proto_msgTypes[81]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *AHTNullableSettings) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use AHTNullableSettings.ProtoReflect.Descriptor instead.
 func (*AHTNullableSettings) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{80}
+	return file_schema_proto_rawDescGZIP(), []int{81}
 }
 
 func (x *AHTNullableSettings) GetSyncThreshold() *NullableUint32 {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type LoadDatabaseRequest struct {
 func (x *LoadDatabaseRequest) Reset() {
 	*x = LoadDatabaseRequest{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[81]
+		mi := &file_schema_proto_msgTypes[82]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *LoadDatabaseRequest) String() string {
 func (*LoadDatabaseRequest) ProtoMessage() {}
 
 func (x *LoadDatabaseRequest) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[81]
+	mi := &file_schema_proto_msgTypes[82]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *LoadDatabaseRequest) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use LoadDatabaseRequest.ProtoReflect.Descriptor instead.
 func (*LoadDatabaseRequest) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{81}
+	return file_schema_proto_rawDescGZIP(), []int{82}
 }
 
 func (x *LoadDatabaseRequest) GetDatabase() string {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type LoadDatabaseResponse struct {
 func (x *LoadDatabaseResponse) Reset() {
 	*x = LoadDatabaseResponse{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[82]
+		mi := &file_schema_proto_msgTypes[83]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *LoadDatabaseResponse) String() string {
 func (*LoadDatabaseResponse) ProtoMessage() {}
 
 func (x *LoadDatabaseResponse) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[82]
+	mi := &file_schema_proto_msgTypes[83]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *LoadDatabaseResponse) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use LoadDatabaseResponse.ProtoReflect.Descriptor instead.
 func (*LoadDatabaseResponse) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{82}
+	return file_schema_proto_rawDescGZIP(), []int{83}
 }
 
 func (x *LoadDatabaseResponse) GetDatabase() string {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type UnloadDatabaseRequest struct {
 func (x *UnloadDatabaseRequest) Reset() {
 	*x = UnloadDatabaseRequest{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[83]
+		mi := &file_schema_proto_msgTypes[84]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *UnloadDatabaseRequest) String() string {
 func (*UnloadDatabaseRequest) ProtoMessage() {}
 
 func (x *UnloadDatabaseRequest) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[83]
+	mi := &file_schema_proto_msgTypes[84]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *UnloadDatabaseRequest) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use UnloadDatabaseRequest.ProtoReflect.Descriptor instead.
 func (*UnloadDatabaseRequest) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{83}
+	return file_schema_proto_rawDescGZIP(), []int{84}
 }
 
 func (x *UnloadDatabaseRequest) GetDatabase() string {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type UnloadDatabaseResponse struct {
 func (x *UnloadDatabaseResponse) Reset() {
 	*x = UnloadDatabaseResponse{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[84]
+		mi := &file_schema_proto_msgTypes[85]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *UnloadDatabaseResponse) String() string {
 func (*UnloadDatabaseResponse) ProtoMessage() {}
 
 func (x *UnloadDatabaseResponse) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[84]
+	mi := &file_schema_proto_msgTypes[85]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *UnloadDatabaseResponse) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use UnloadDatabaseResponse.ProtoReflect.Descriptor instead.
 func (*UnloadDatabaseResponse) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{84}
+	return file_schema_proto_rawDescGZIP(), []int{85}
 }
 
 func (x *UnloadDatabaseResponse) GetDatabase() string {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type DeleteDatabaseRequest struct {
 func (x *DeleteDatabaseRequest) Reset() {
 	*x = DeleteDatabaseRequest{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[85]
+		mi := &file_schema_proto_msgTypes[86]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *DeleteDatabaseRequest) String() string {
 func (*DeleteDatabaseRequest) ProtoMessage() {}
 
 func (x *DeleteDatabaseRequest) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[85]
+	mi := &file_schema_proto_msgTypes[86]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *DeleteDatabaseRequest) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use DeleteDatabaseRequest.ProtoReflect.Descriptor instead.
 func (*DeleteDatabaseRequest) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{85}
+	return file_schema_proto_rawDescGZIP(), []int{86}
 }
 
 func (x *DeleteDatabaseRequest) GetDatabase() string {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type DeleteDatabaseResponse struct {
 func (x *DeleteDatabaseResponse) Reset() {
 	*x = DeleteDatabaseResponse{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[86]
+		mi := &file_schema_proto_msgTypes[87]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *DeleteDatabaseResponse) String() string {
 func (*DeleteDatabaseResponse) ProtoMessage() {}
 
 func (x *DeleteDatabaseResponse) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[86]
+	mi := &file_schema_proto_msgTypes[87]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *DeleteDatabaseResponse) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use DeleteDatabaseResponse.ProtoReflect.Descriptor instead.
 func (*DeleteDatabaseResponse) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{86}
+	return file_schema_proto_rawDescGZIP(), []int{87}
 }
 
 func (x *DeleteDatabaseResponse) GetDatabase() string {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type FlushIndexRequest struct {
 func (x *FlushIndexRequest) Reset() {
 	*x = FlushIndexRequest{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[87]
+		mi := &file_schema_proto_msgTypes[88]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *FlushIndexRequest) String() string {
 func (*FlushIndexRequest) ProtoMessage() {}
 
 func (x *FlushIndexRequest) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[87]
+	mi := &file_schema_proto_msgTypes[88]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *FlushIndexRequest) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use FlushIndexRequest.ProtoReflect.Descriptor instead.
 func (*FlushIndexRequest) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{87}
+	return file_schema_proto_rawDescGZIP(), []int{88}
 }
 
 func (x *FlushIndexRequest) GetCleanupPercentage() float32 {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type FlushIndexResponse struct {
 func (x *FlushIndexResponse) Reset() {
 	*x = FlushIndexResponse{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[88]
+		mi := &file_schema_proto_msgTypes[89]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *FlushIndexResponse) String() string {
 func (*FlushIndexResponse) ProtoMessage() {}
 
 func (x *FlushIndexResponse) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[88]
+	mi := &file_schema_proto_msgTypes[89]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *FlushIndexResponse) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use FlushIndexResponse.ProtoReflect.Descriptor instead.
 func (*FlushIndexResponse) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{88}
+	return file_schema_proto_rawDescGZIP(), []int{89}
 }
 
 func (x *FlushIndexResponse) GetDatabase() string {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type Table struct {
 func (x *Table) Reset() {
 	*x = Table{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[89]
+		mi := &file_schema_proto_msgTypes[90]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *Table) String() string {
 func (*Table) ProtoMessage() {}
 
 func (x *Table) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[89]
+	mi := &file_schema_proto_msgTypes[90]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *Table) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use Table.ProtoReflect.Descriptor instead.
 func (*Table) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{89}
+	return file_schema_proto_rawDescGZIP(), []int{90}
 }
 
 func (x *Table) GetTableName() string {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type SQLGetRequest struct {
 func (x *SQLGetRequest) Reset() {
 	*x = SQLGetRequest{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[90]
+		mi := &file_schema_proto_msgTypes[91]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *SQLGetRequest) String() string {
 func (*SQLGetRequest) ProtoMessage() {}
 
 func (x *SQLGetRequest) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[90]
+	mi := &file_schema_proto_msgTypes[91]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *SQLGetRequest) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use SQLGetRequest.ProtoReflect.Descriptor instead.
 func (*SQLGetRequest) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{90}
+	return file_schema_proto_rawDescGZIP(), []int{91}
 }
 
 func (x *SQLGetRequest) GetTable() string {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type VerifiableSQLGetRequest struct {
 func (x *VerifiableSQLGetRequest) Reset() {
 	*x = VerifiableSQLGetRequest{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[91]
+		mi := &file_schema_proto_msgTypes[92]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *VerifiableSQLGetRequest) String() string {
 func (*VerifiableSQLGetRequest) ProtoMessage() {}
 
 func (x *VerifiableSQLGetRequest) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[91]
+	mi := &file_schema_proto_msgTypes[92]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *VerifiableSQLGetRequest) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use VerifiableSQLGetRequest.ProtoReflect.Descriptor instead.
 func (*VerifiableSQLGetRequest) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{91}
+	return file_schema_proto_rawDescGZIP(), []int{92}
 }
 
 func (x *VerifiableSQLGetRequest) GetSqlGetRequest() *SQLGetRequest {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type SQLEntry struct {
 func (x *SQLEntry) Reset() {
 	*x = SQLEntry{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[92]
+		mi := &file_schema_proto_msgTypes[93]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *SQLEntry) String() string {
 func (*SQLEntry) ProtoMessage() {}
 
 func (x *SQLEntry) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[92]
+	mi := &file_schema_proto_msgTypes[93]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *SQLEntry) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use SQLEntry.ProtoReflect.Descriptor instead.
 func (*SQLEntry) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{92}
+	return file_schema_proto_rawDescGZIP(), []int{93}
 }
 
 func (x *SQLEntry) GetTx() uint64 {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type VerifiableSQLEntry struct {
 func (x *VerifiableSQLEntry) Reset() {
 	*x = VerifiableSQLEntry{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[93]
+		mi := &file_schema_proto_msgTypes[94]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *VerifiableSQLEntry) String() string {
 func (*VerifiableSQLEntry) ProtoMessage() {}
 
 func (x *VerifiableSQLEntry) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[93]
+	mi := &file_schema_proto_msgTypes[94]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *VerifiableSQLEntry) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use VerifiableSQLEntry.ProtoReflect.Descriptor instead.
 func (*VerifiableSQLEntry) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{93}
+	return file_schema_proto_rawDescGZIP(), []int{94}
 }
 
 func (x *VerifiableSQLEntry) GetSqlEntry() *SQLEntry {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type UseDatabaseReply struct {
 func (x *UseDatabaseReply) Reset() {
 	*x = UseDatabaseReply{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[94]
+		mi := &file_schema_proto_msgTypes[95]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *UseDatabaseReply) String() string {
 func (*UseDatabaseReply) ProtoMessage() {}
 
 func (x *UseDatabaseReply) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[94]
+	mi := &file_schema_proto_msgTypes[95]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *UseDatabaseReply) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use UseDatabaseReply.ProtoReflect.Descriptor instead.
 func (*UseDatabaseReply) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{94}
+	return file_schema_proto_rawDescGZIP(), []int{95}
 }
 
 func (x *UseDatabaseReply) GetToken() string {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type ChangePermissionRequest struct {
 func (x *ChangePermissionRequest) Reset() {
 	*x = ChangePermissionRequest{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[95]
+		mi := &file_schema_proto_msgTypes[96]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *ChangePermissionRequest) String() string {
 func (*ChangePermissionRequest) ProtoMessage() {}
 
 func (x *ChangePermissionRequest) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[95]
+	mi := &file_schema_proto_msgTypes[96]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *ChangePermissionRequest) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use ChangePermissionRequest.ProtoReflect.Descriptor instead.
 func (*ChangePermissionRequest) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{95}
+	return file_schema_proto_rawDescGZIP(), []int{96}
 }
 
 func (x *ChangePermissionRequest) GetAction() PermissionAction {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type SetActiveUserRequest struct {
 func (x *SetActiveUserRequest) Reset() {
 	*x = SetActiveUserRequest{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[96]
+		mi := &file_schema_proto_msgTypes[97]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *SetActiveUserRequest) String() string {
 func (*SetActiveUserRequest) ProtoMessage() {}
 
 func (x *SetActiveUserRequest) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[96]
+	mi := &file_schema_proto_msgTypes[97]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *SetActiveUserRequest) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use SetActiveUserRequest.ProtoReflect.Descriptor instead.
 func (*SetActiveUserRequest) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{96}
+	return file_schema_proto_rawDescGZIP(), []int{97}
 }
 
 func (x *SetActiveUserRequest) GetActive() bool {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type DatabaseListResponse struct {
 func (x *DatabaseListResponse) Reset() {
 	*x = DatabaseListResponse{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[97]
+		mi := &file_schema_proto_msgTypes[98]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *DatabaseListResponse) String() string {
 func (*DatabaseListResponse) ProtoMessage() {}
 
 func (x *DatabaseListResponse) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[97]
+	mi := &file_schema_proto_msgTypes[98]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *DatabaseListResponse) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use DatabaseListResponse.ProtoReflect.Descriptor instead.
 func (*DatabaseListResponse) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{97}
+	return file_schema_proto_rawDescGZIP(), []int{98}
 }
 
 func (x *DatabaseListResponse) GetDatabases() []*Database {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type DatabaseListRequestV2 struct {
 func (x *DatabaseListRequestV2) Reset() {
 	*x = DatabaseListRequestV2{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[98]
+		mi := &file_schema_proto_msgTypes[99]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *DatabaseListRequestV2) String() string {
 func (*DatabaseListRequestV2) ProtoMessage() {}
 
 func (x *DatabaseListRequestV2) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[98]
+	mi := &file_schema_proto_msgTypes[99]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *DatabaseListRequestV2) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use DatabaseListRequestV2.ProtoReflect.Descriptor instead.
 func (*DatabaseListRequestV2) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{98}
+	return file_schema_proto_rawDescGZIP(), []int{99}
 }
 
 type DatabaseListResponseV2 struct {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type DatabaseListResponseV2 struct {
 func (x *DatabaseListResponseV2) Reset() {
 	*x = DatabaseListResponseV2{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[99]
+		mi := &file_schema_proto_msgTypes[100]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *DatabaseListResponseV2) String() string {
 func (*DatabaseListResponseV2) ProtoMessage() {}
 
 func (x *DatabaseListResponseV2) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[99]
+	mi := &file_schema_proto_msgTypes[100]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *DatabaseListResponseV2) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use DatabaseListResponseV2.ProtoReflect.Descriptor instead.
 func (*DatabaseListResponseV2) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{99}
+	return file_schema_proto_rawDescGZIP(), []int{100}
 }
 
 func (x *DatabaseListResponseV2) GetDatabases() []*DatabaseWithSettings {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type DatabaseWithSettings struct {
 func (x *DatabaseWithSettings) Reset() {
 	*x = DatabaseWithSettings{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[100]
+		mi := &file_schema_proto_msgTypes[101]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *DatabaseWithSettings) String() string {
 func (*DatabaseWithSettings) ProtoMessage() {}
 
 func (x *DatabaseWithSettings) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[100]
+	mi := &file_schema_proto_msgTypes[101]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *DatabaseWithSettings) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use DatabaseWithSettings.ProtoReflect.Descriptor instead.
 func (*DatabaseWithSettings) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{100}
+	return file_schema_proto_rawDescGZIP(), []int{101}
 }
 
 func (x *DatabaseWithSettings) GetName() string {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type Chunk struct {
 func (x *Chunk) Reset() {
 	*x = Chunk{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[101]
+		mi := &file_schema_proto_msgTypes[102]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *Chunk) String() string {
 func (*Chunk) ProtoMessage() {}
 
 func (x *Chunk) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[101]
+	mi := &file_schema_proto_msgTypes[102]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *Chunk) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use Chunk.ProtoReflect.Descriptor instead.
 func (*Chunk) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{101}
+	return file_schema_proto_rawDescGZIP(), []int{102}
 }
 
 func (x *Chunk) GetContent() []byte {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type UseSnapshotRequest struct {
 func (x *UseSnapshotRequest) Reset() {
 	*x = UseSnapshotRequest{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[102]
+		mi := &file_schema_proto_msgTypes[103]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *UseSnapshotRequest) String() string {
 func (*UseSnapshotRequest) ProtoMessage() {}
 
 func (x *UseSnapshotRequest) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[102]
+	mi := &file_schema_proto_msgTypes[103]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *UseSnapshotRequest) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use UseSnapshotRequest.ProtoReflect.Descriptor instead.
 func (*UseSnapshotRequest) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{102}
+	return file_schema_proto_rawDescGZIP(), []int{103}
 }
 
 func (x *UseSnapshotRequest) GetSinceTx() uint64 {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type SQLExecRequest struct {
 func (x *SQLExecRequest) Reset() {
 	*x = SQLExecRequest{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[103]
+		mi := &file_schema_proto_msgTypes[104]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *SQLExecRequest) String() string {
 func (*SQLExecRequest) ProtoMessage() {}
 
 func (x *SQLExecRequest) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[103]
+	mi := &file_schema_proto_msgTypes[104]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *SQLExecRequest) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use SQLExecRequest.ProtoReflect.Descriptor instead.
 func (*SQLExecRequest) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{103}
+	return file_schema_proto_rawDescGZIP(), []int{104}
 }
 
 func (x *SQLExecRequest) GetSql() string {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type SQLQueryRequest struct {
 func (x *SQLQueryRequest) Reset() {
 	*x = SQLQueryRequest{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[104]
+		mi := &file_schema_proto_msgTypes[105]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *SQLQueryRequest) String() string {
 func (*SQLQueryRequest) ProtoMessage() {}
 
 func (x *SQLQueryRequest) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[104]
+	mi := &file_schema_proto_msgTypes[105]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *SQLQueryRequest) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use SQLQueryRequest.ProtoReflect.Descriptor instead.
 func (*SQLQueryRequest) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{104}
+	return file_schema_proto_rawDescGZIP(), []int{105}
 }
 
 func (x *SQLQueryRequest) GetSql() string {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type NamedParam struct {
 func (x *NamedParam) Reset() {
 	*x = NamedParam{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[105]
+		mi := &file_schema_proto_msgTypes[106]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *NamedParam) String() string {
 func (*NamedParam) ProtoMessage() {}
 
 func (x *NamedParam) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[105]
+	mi := &file_schema_proto_msgTypes[106]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *NamedParam) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use NamedParam.ProtoReflect.Descriptor instead.
 func (*NamedParam) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{105}
+	return file_schema_proto_rawDescGZIP(), []int{106}
 }
 
 func (x *NamedParam) GetName() string {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type SQLExecResult struct {
 func (x *SQLExecResult) Reset() {
 	*x = SQLExecResult{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[106]
+		mi := &file_schema_proto_msgTypes[107]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *SQLExecResult) String() string {
 func (*SQLExecResult) ProtoMessage() {}
 
 func (x *SQLExecResult) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[106]
+	mi := &file_schema_proto_msgTypes[107]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *SQLExecResult) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use SQLExecResult.ProtoReflect.Descriptor instead.
 func (*SQLExecResult) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{106}
+	return file_schema_proto_rawDescGZIP(), []int{107}
 }
 
 func (x *SQLExecResult) GetTxs() []*CommittedSQLTx {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type CommittedSQLTx struct {
 func (x *CommittedSQLTx) Reset() {
 	*x = CommittedSQLTx{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[107]
+		mi := &file_schema_proto_msgTypes[108]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *CommittedSQLTx) String() string {
 func (*CommittedSQLTx) ProtoMessage() {}
 
 func (x *CommittedSQLTx) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[107]
+	mi := &file_schema_proto_msgTypes[108]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *CommittedSQLTx) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use CommittedSQLTx.ProtoReflect.Descriptor instead.
 func (*CommittedSQLTx) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{107}
+	return file_schema_proto_rawDescGZIP(), []int{108}
 }
 
 func (x *CommittedSQLTx) GetHeader() *TxHeader {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type SQLQueryResult struct {
 func (x *SQLQueryResult) Reset() {
 	*x = SQLQueryResult{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[108]
+		mi := &file_schema_proto_msgTypes[109]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *SQLQueryResult) String() string {
 func (*SQLQueryResult) ProtoMessage() {}
 
 func (x *SQLQueryResult) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[108]
+	mi := &file_schema_proto_msgTypes[109]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *SQLQueryResult) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use SQLQueryResult.ProtoReflect.Descriptor instead.
 func (*SQLQueryResult) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{108}
+	return file_schema_proto_rawDescGZIP(), []int{109}
 }
 
 func (x *SQLQueryResult) GetColumns() []*Column {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type Column struct {
 func (x *Column) Reset() {
 	*x = Column{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[109]
+		mi := &file_schema_proto_msgTypes[110]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *Column) String() string {
 func (*Column) ProtoMessage() {}
 
 func (x *Column) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[109]
+	mi := &file_schema_proto_msgTypes[110]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *Column) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use Column.ProtoReflect.Descriptor instead.
 func (*Column) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{109}
+	return file_schema_proto_rawDescGZIP(), []int{110}
 }
 
 func (x *Column) GetName() string {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type Row struct {
 func (x *Row) Reset() {
 	*x = Row{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[110]
+		mi := &file_schema_proto_msgTypes[111]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *Row) String() string {
 func (*Row) ProtoMessage() {}
 
 func (x *Row) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[110]
+	mi := &file_schema_proto_msgTypes[111]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *Row) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use Row.ProtoReflect.Descriptor instead.
 func (*Row) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{110}
+	return file_schema_proto_rawDescGZIP(), []int{111}
 }
 
 func (x *Row) GetColumns() []string {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type SQLValue struct {
 func (x *SQLValue) Reset() {
 	*x = SQLValue{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[111]
+		mi := &file_schema_proto_msgTypes[112]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *SQLValue) String() string {
 func (*SQLValue) ProtoMessage() {}
 
 func (x *SQLValue) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[111]
+	mi := &file_schema_proto_msgTypes[112]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *SQLValue) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use SQLValue.ProtoReflect.Descriptor instead.
 func (*SQLValue) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{111}
+	return file_schema_proto_rawDescGZIP(), []int{112}
 }
 
 func (m *SQLValue) GetValue() isSQLValue_Value {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type NewTxRequest struct {
 func (x *NewTxRequest) Reset() {
 	*x = NewTxRequest{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[112]
+		mi := &file_schema_proto_msgTypes[113]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *NewTxRequest) String() string {
 func (*NewTxRequest) ProtoMessage() {}
 
 func (x *NewTxRequest) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[112]
+	mi := &file_schema_proto_msgTypes[113]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *NewTxRequest) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use NewTxRequest.ProtoReflect.Descriptor instead.
 func (*NewTxRequest) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{112}
+	return file_schema_proto_rawDescGZIP(), []int{113}
 }
 
 func (x *NewTxRequest) GetMode() TxMode {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type NewTxResponse struct {
 func (x *NewTxResponse) Reset() {
 	*x = NewTxResponse{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[113]
+		mi := &file_schema_proto_msgTypes[114]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *NewTxResponse) String() string {
 func (*NewTxResponse) ProtoMessage() {}
 
 func (x *NewTxResponse) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[113]
+	mi := &file_schema_proto_msgTypes[114]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *NewTxResponse) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use NewTxResponse.ProtoReflect.Descriptor instead.
 func (*NewTxResponse) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{113}
+	return file_schema_proto_rawDescGZIP(), []int{114}
 }
 
 func (x *NewTxResponse) GetTransactionID() string {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type ErrorInfo struct {
 func (x *ErrorInfo) Reset() {
 	*x = ErrorInfo{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[114]
+		mi := &file_schema_proto_msgTypes[115]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *ErrorInfo) String() string {
 func (*ErrorInfo) ProtoMessage() {}
 
 func (x *ErrorInfo) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[114]
+	mi := &file_schema_proto_msgTypes[115]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *ErrorInfo) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use ErrorInfo.ProtoReflect.Descriptor instead.
 func (*ErrorInfo) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{114}
+	return file_schema_proto_rawDescGZIP(), []int{115}
 }
 
 func (x *ErrorInfo) GetCode() string {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type DebugInfo struct {
 func (x *DebugInfo) Reset() {
 	*x = DebugInfo{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[115]
+		mi := &file_schema_proto_msgTypes[116]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *DebugInfo) String() string {
 func (*DebugInfo) ProtoMessage() {}
 
 func (x *DebugInfo) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[115]
+	mi := &file_schema_proto_msgTypes[116]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *DebugInfo) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use DebugInfo.ProtoReflect.Descriptor instead.
 func (*DebugInfo) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{115}
+	return file_schema_proto_rawDescGZIP(), []int{116}
 }
 
 func (x *DebugInfo) GetStack() string {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type RetryInfo struct {
 func (x *RetryInfo) Reset() {
 	*x = RetryInfo{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[116]
+		mi := &file_schema_proto_msgTypes[117]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *RetryInfo) String() string {
 func (*RetryInfo) ProtoMessage() {}
 
 func (x *RetryInfo) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[116]
+	mi := &file_schema_proto_msgTypes[117]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *RetryInfo) ProtoReflect() protoreflect.Message {
 
 // Deprecated: Use RetryInfo.ProtoReflect.Descriptor instead.
 func (*RetryInfo) Descriptor() ([]byte, []int) {
-	return file_schema_proto_rawDescGZIP(), []int{116}
+	return file_schema_proto_rawDescGZIP(), []int{117}
 }
 
 func (x *RetryInfo) GetRetryDelay() int32 {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type Precondition_KeyMustExistPrecondition struct {
 func (x *Precondition_KeyMustExistPrecondition) Reset() {
 	*x = Precondition_KeyMustExistPrecondition{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[117]
+		mi := &file_schema_proto_msgTypes[118]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *Precondition_KeyMustExistPrecondition) String() string {
 func (*Precondition_KeyMustExistPrecondition) ProtoMessage() {}
 
 func (x *Precondition_KeyMustExistPrecondition) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[117]
+	mi := &file_schema_proto_msgTypes[118]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type Precondition_KeyMustNotExistPrecondition struct {
 func (x *Precondition_KeyMustNotExistPrecondition) Reset() {
 	*x = Precondition_KeyMustNotExistPrecondition{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[118]
+		mi := &file_schema_proto_msgTypes[119]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *Precondition_KeyMustNotExistPrecondition) String() string {
 func (*Precondition_KeyMustNotExistPrecondition) ProtoMessage() {}
 
 func (x *Precondition_KeyMustNotExistPrecondition) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[118]
+	mi := &file_schema_proto_msgTypes[119]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," type Precondition_KeyNotModifiedAfterTXPrecondition struct {
 func (x *Precondition_KeyNotModifiedAfterTXPrecondition) Reset() {
 	*x = Precondition_KeyNotModifiedAfterTXPrecondition{}
 	if protoimpl.UnsafeEnabled {
-		mi := &file_schema_proto_msgTypes[119]
+		mi := &file_schema_proto_msgTypes[120]
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		ms.StoreMessageInfo(mi)
 	}
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func (x *Precondition_KeyNotModifiedAfterTXPrecondition) String() string {
 func (*Precondition_KeyNotModifiedAfterTXPrecondition) ProtoMessage() {}
 
 func (x *Precondition_KeyNotModifiedAfterTXPrecondition) ProtoReflect() protoreflect.Message {
-	mi := &file_schema_proto_msgTypes[119]
+	mi := &file_schema_proto_msgTypes[120]
 	if protoimpl.UnsafeEnabled && x != nil {
 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
 		if ms.LoadMessageInfo() == nil {
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[29].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*DualProof); i {
+			switch v := v.(*LinearAdvanceProof); i {
 			case 0:
 				return &v.state
 			case 1:
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[30].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*Tx); i {
+			switch v := v.(*DualProof); i {
 			case 0:
 				return &v.state
 			case 1:
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[31].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*TxEntry); i {
+			switch v := v.(*Tx); i {
 			case 0:
 				return &v.state
 			case 1:
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[32].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*KVMetadata); i {
+			switch v := v.(*TxEntry); i {
 			case 0:
 				return &v.state
 			case 1:
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[33].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*Expiration); i {
+			switch v := v.(*KVMetadata); i {
 			case 0:
 				return &v.state
 			case 1:
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[34].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*VerifiableTx); i {
+			switch v := v.(*Expiration); i {
 			case 0:
 				return &v.state
 			case 1:
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[35].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*VerifiableEntry); i {
+			switch v := v.(*VerifiableTx); i {
 			case 0:
 				return &v.state
 			case 1:
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[36].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*InclusionProof); i {
+			switch v := v.(*VerifiableEntry); i {
 			case 0:
 				return &v.state
 			case 1:
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[37].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*SetRequest); i {
+			switch v := v.(*InclusionProof); i {
 			case 0:
 				return &v.state
 			case 1:
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[38].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*KeyRequest); i {
+			switch v := v.(*SetRequest); i {
 			case 0:
 				return &v.state
 			case 1:
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[39].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*KeyListRequest); i {
+			switch v := v.(*KeyRequest); i {
 			case 0:
 				return &v.state
 			case 1:
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[40].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*DeleteKeysRequest); i {
+			switch v := v.(*KeyListRequest); i {
 			case 0:
 				return &v.state
 			case 1:
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[41].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*VerifiableSetRequest); i {
+			switch v := v.(*DeleteKeysRequest); i {
 			case 0:
 				return &v.state
 			case 1:
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[42].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*VerifiableGetRequest); i {
+			switch v := v.(*VerifiableSetRequest); i {
 			case 0:
 				return &v.state
 			case 1:
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[43].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*ServerInfoRequest); i {
+			switch v := v.(*VerifiableGetRequest); i {
 			case 0:
 				return &v.state
 			case 1:
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[44].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*ServerInfoResponse); i {
+			switch v := v.(*ServerInfoRequest); i {
 			case 0:
 				return &v.state
 			case 1:
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[45].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*HealthResponse); i {
+			switch v := v.(*ServerInfoResponse); i {
 			case 0:
 				return &v.state
 			case 1:
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[46].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*DatabaseHealthResponse); i {
+			switch v := v.(*HealthResponse); i {
 			case 0:
 				return &v.state
 			case 1:
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[47].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*ImmutableState); i {
+			switch v := v.(*DatabaseHealthResponse); i {
 			case 0:
 				return &v.state
 			case 1:
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[48].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*ReferenceRequest); i {
+			switch v := v.(*ImmutableState); i {
 			case 0:
 				return &v.state
 			case 1:
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[49].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*VerifiableReferenceRequest); i {
+			switch v := v.(*ReferenceRequest); i {
 			case 0:
 				return &v.state
 			case 1:
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[50].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*ZAddRequest); i {
+			switch v := v.(*VerifiableReferenceRequest); i {
 			case 0:
 				return &v.state
 			case 1:
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[51].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*Score); i {
+			switch v := v.(*ZAddRequest); i {
 			case 0:
 				return &v.state
 			case 1:
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[52].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*ZScanRequest); i {
+			switch v := v.(*Score); i {
 			case 0:
 				return &v.state
 			case 1:
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[53].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*HistoryRequest); i {
+			switch v := v.(*ZScanRequest); i {
 			case 0:
 				return &v.state
 			case 1:
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[54].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*VerifiableZAddRequest); i {
+			switch v := v.(*HistoryRequest); i {
 			case 0:
 				return &v.state
 			case 1:
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[55].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*TxRequest); i {
+			switch v := v.(*VerifiableZAddRequest); i {
 			case 0:
 				return &v.state
 			case 1:
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[56].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*EntriesSpec); i {
+			switch v := v.(*TxRequest); i {
 			case 0:
 				return &v.state
 			case 1:
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[57].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*EntryTypeSpec); i {
+			switch v := v.(*EntriesSpec); i {
 			case 0:
 				return &v.state
 			case 1:
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[58].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*VerifiableTxRequest); i {
+			switch v := v.(*EntryTypeSpec); i {
 			case 0:
 				return &v.state
 			case 1:
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[59].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*TxScanRequest); i {
+			switch v := v.(*VerifiableTxRequest); i {
 			case 0:
 				return &v.state
 			case 1:
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[60].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*TxList); i {
+			switch v := v.(*TxScanRequest); i {
 			case 0:
 				return &v.state
 			case 1:
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[61].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*ExportTxRequest); i {
+			switch v := v.(*TxList); i {
 			case 0:
 				return &v.state
 			case 1:
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[62].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*ReplicaState); i {
+			switch v := v.(*ExportTxRequest); i {
 			case 0:
 				return &v.state
 			case 1:
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[63].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*Database); i {
+			switch v := v.(*ReplicaState); i {
 			case 0:
 				return &v.state
 			case 1:
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[64].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*DatabaseSettings); i {
+			switch v := v.(*Database); i {
 			case 0:
 				return &v.state
 			case 1:
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[65].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*CreateDatabaseRequest); i {
+			switch v := v.(*DatabaseSettings); i {
 			case 0:
 				return &v.state
 			case 1:
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[66].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*CreateDatabaseResponse); i {
+			switch v := v.(*CreateDatabaseRequest); i {
 			case 0:
 				return &v.state
 			case 1:
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[67].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*UpdateDatabaseRequest); i {
+			switch v := v.(*CreateDatabaseResponse); i {
 			case 0:
 				return &v.state
 			case 1:
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[68].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*UpdateDatabaseResponse); i {
+			switch v := v.(*UpdateDatabaseRequest); i {
 			case 0:
 				return &v.state
 			case 1:
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[69].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*DatabaseSettingsRequest); i {
+			switch v := v.(*UpdateDatabaseResponse); i {
 			case 0:
 				return &v.state
 			case 1:
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[70].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*DatabaseSettingsResponse); i {
+			switch v := v.(*DatabaseSettingsRequest); i {
 			case 0:
 				return &v.state
 			case 1:
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[71].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*NullableUint32); i {
+			switch v := v.(*DatabaseSettingsResponse); i {
 			case 0:
 				return &v.state
 			case 1:
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[72].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*NullableUint64); i {
+			switch v := v.(*NullableUint32); i {
 			case 0:
 				return &v.state
 			case 1:
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[73].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*NullableFloat); i {
+			switch v := v.(*NullableUint64); i {
 			case 0:
 				return &v.state
 			case 1:
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[74].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*NullableBool); i {
+			switch v := v.(*NullableFloat); i {
 			case 0:
 				return &v.state
 			case 1:
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[75].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*NullableString); i {
+			switch v := v.(*NullableBool); i {
 			case 0:
 				return &v.state
 			case 1:
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[76].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*NullableMilliseconds); i {
+			switch v := v.(*NullableString); i {
 			case 0:
 				return &v.state
 			case 1:
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[77].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*DatabaseNullableSettings); i {
+			switch v := v.(*NullableMilliseconds); i {
 			case 0:
 				return &v.state
 			case 1:
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[78].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*ReplicationNullableSettings); i {
+			switch v := v.(*DatabaseNullableSettings); i {
 			case 0:
 				return &v.state
 			case 1:
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[79].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*IndexNullableSettings); i {
+			switch v := v.(*ReplicationNullableSettings); i {
 			case 0:
 				return &v.state
 			case 1:
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[80].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*AHTNullableSettings); i {
+			switch v := v.(*IndexNullableSettings); i {
 			case 0:
 				return &v.state
 			case 1:
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[81].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*LoadDatabaseRequest); i {
+			switch v := v.(*AHTNullableSettings); i {
 			case 0:
 				return &v.state
 			case 1:
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[82].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*LoadDatabaseResponse); i {
+			switch v := v.(*LoadDatabaseRequest); i {
 			case 0:
 				return &v.state
 			case 1:
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[83].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*UnloadDatabaseRequest); i {
+			switch v := v.(*LoadDatabaseResponse); i {
 			case 0:
 				return &v.state
 			case 1:
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[84].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*UnloadDatabaseResponse); i {
+			switch v := v.(*UnloadDatabaseRequest); i {
 			case 0:
 				return &v.state
 			case 1:
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[85].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*DeleteDatabaseRequest); i {
+			switch v := v.(*UnloadDatabaseResponse); i {
 			case 0:
 				return &v.state
 			case 1:
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[86].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*DeleteDatabaseResponse); i {
+			switch v := v.(*DeleteDatabaseRequest); i {
 			case 0:
 				return &v.state
 			case 1:
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[87].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*FlushIndexRequest); i {
+			switch v := v.(*DeleteDatabaseResponse); i {
 			case 0:
 				return &v.state
 			case 1:
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[88].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*FlushIndexResponse); i {
+			switch v := v.(*FlushIndexRequest); i {
 			case 0:
 				return &v.state
 			case 1:
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[89].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*Table); i {
+			switch v := v.(*FlushIndexResponse); i {
 			case 0:
 				return &v.state
 			case 1:
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[90].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*SQLGetRequest); i {
+			switch v := v.(*Table); i {
 			case 0:
 				return &v.state
 			case 1:
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[91].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*VerifiableSQLGetRequest); i {
+			switch v := v.(*SQLGetRequest); i {
 			case 0:
 				return &v.state
 			case 1:
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[92].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*SQLEntry); i {
+			switch v := v.(*VerifiableSQLGetRequest); i {
 			case 0:
 				return &v.state
 			case 1:
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[93].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*VerifiableSQLEntry); i {
+			switch v := v.(*SQLEntry); i {
 			case 0:
 				return &v.state
 			case 1:
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[94].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*UseDatabaseReply); i {
+			switch v := v.(*VerifiableSQLEntry); i {
 			case 0:
 				return &v.state
 			case 1:
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[95].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*ChangePermissionRequest); i {
+			switch v := v.(*UseDatabaseReply); i {
 			case 0:
 				return &v.state
 			case 1:
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[96].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*SetActiveUserRequest); i {
+			switch v := v.(*ChangePermissionRequest); i {
 			case 0:
 				return &v.state
 			case 1:
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[97].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*DatabaseListResponse); i {
+			switch v := v.(*SetActiveUserRequest); i {
 			case 0:
 				return &v.state
 			case 1:
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[98].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*DatabaseListRequestV2); i {
+			switch v := v.(*DatabaseListResponse); i {
 			case 0:
 				return &v.state
 			case 1:
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[99].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*DatabaseListResponseV2); i {
+			switch v := v.(*DatabaseListRequestV2); i {
 			case 0:
 				return &v.state
 			case 1:
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[100].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*DatabaseWithSettings); i {
+			switch v := v.(*DatabaseListResponseV2); i {
 			case 0:
 				return &v.state
 			case 1:
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[101].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*Chunk); i {
+			switch v := v.(*DatabaseWithSettings); i {
 			case 0:
 				return &v.state
 			case 1:
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[102].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*UseSnapshotRequest); i {
+			switch v := v.(*Chunk); i {
 			case 0:
 				return &v.state
 			case 1:
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[103].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*SQLExecRequest); i {
+			switch v := v.(*UseSnapshotRequest); i {
 			case 0:
 				return &v.state
 			case 1:
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[104].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*SQLQueryRequest); i {
+			switch v := v.(*SQLExecRequest); i {
 			case 0:
 				return &v.state
 			case 1:
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[105].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*NamedParam); i {
+			switch v := v.(*SQLQueryRequest); i {
 			case 0:
 				return &v.state
 			case 1:
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[106].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*SQLExecResult); i {
+			switch v := v.(*NamedParam); i {
 			case 0:
 				return &v.state
 			case 1:
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[107].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*CommittedSQLTx); i {
+			switch v := v.(*SQLExecResult); i {
 			case 0:
 				return &v.state
 			case 1:
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[108].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*SQLQueryResult); i {
+			switch v := v.(*CommittedSQLTx); i {
 			case 0:
 				return &v.state
 			case 1:
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[109].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*Column); i {
+			switch v := v.(*SQLQueryResult); i {
 			case 0:
 				return &v.state
 			case 1:
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[110].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*Row); i {
+			switch v := v.(*Column); i {
 			case 0:
 				return &v.state
 			case 1:
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[111].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*SQLValue); i {
+			switch v := v.(*Row); i {
 			case 0:
 				return &v.state
 			case 1:
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[112].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*NewTxRequest); i {
+			switch v := v.(*SQLValue); i {
 			case 0:
 				return &v.state
 			case 1:
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[113].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*NewTxResponse); i {
+			switch v := v.(*NewTxRequest); i {
 			case 0:
 				return &v.state
 			case 1:
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[114].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*ErrorInfo); i {
+			switch v := v.(*NewTxResponse); i {
 			case 0:
 				return &v.state
 			case 1:
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[115].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*DebugInfo); i {
+			switch v := v.(*ErrorInfo); i {
 			case 0:
 				return &v.state
 			case 1:
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[116].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*RetryInfo); i {
+			switch v := v.(*DebugInfo); i {
 			case 0:
 				return &v.state
 			case 1:
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[117].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*Precondition_KeyMustExistPrecondition); i {
+			switch v := v.(*RetryInfo); i {
 			case 0:
 				return &v.state
 			case 1:
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[118].Exporter = func(v interface{}, i int) interface{} {
-			switch v := v.(*Precondition_KeyMustNotExistPrecondition); i {
+			switch v := v.(*Precondition_KeyMustExistPrecondition); i {
 			case 0:
 				return &v.state
 			case 1:
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			}
 		}
 		file_schema_proto_msgTypes[119].Exporter = func(v interface{}, i int) interface{} {
+			switch v := v.(*Precondition_KeyMustNotExistPrecondition); i {
+			case 0:
+				return &v.state
+			case 1:
+				return &v.sizeCache
+			case 2:
+				return &v.unknownFields
+			default:
+				return nil
+			}
+		}
+		file_schema_proto_msgTypes[120].Exporter = func(v interface{}, i int) interface{} {
 			switch v := v.(*Precondition_KeyNotModifiedAfterTXPrecondition); i {
 			case 0:
 				return &v.state
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 		(*Op_ZAdd)(nil),
 		(*Op_Ref)(nil),
 	}
-	file_schema_proto_msgTypes[111].OneofWrappers = []interface{}{
+	file_schema_proto_msgTypes[112].OneofWrappers = []interface{}{
 		(*SQLValue_Null)(nil),
 		(*SQLValue_N)(nil),
 		(*SQLValue_S)(nil),
"
GO-2022-1117,codenotary,immudb,acf7f1b3d62436ea5e038acea1fc6394f90ab1c6," func file_schema_proto_init() {
 			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
 			RawDescriptor: file_schema_proto_rawDesc,
 			NumEnums:      3,
-			NumMessages:   126,
+			NumMessages:   127,
 			NumExtensions: 0,
 			NumServices:   1,
 		},
"
GO-2023-1681,containers,podman,6ca857feb07a5fdc96fd947afef03916291673d8," func (c *Container) export(out io.Writer) error {
 		}()
 	}
 
-	input, err := archive.Tar(mountPoint, archive.Uncompressed)
+	input, err := chrootarchive.Tar(mountPoint, nil, mountPoint)
 	if err != nil {
 		return fmt.Errorf(""reading container directory %q: %w"", c.ID(), err)
 	}
"
GO-2023-1547,helm,helm,293b50c65d4d56187cd4e2f390f0ada46b4c4737," func (i *Install) failRelease(rel *release.Release, err error) (*release.Release
 //
 // Roughly, this will return an error if name is
 //
-//	- empty
-//	- too long
-//	- already in use, and not deleted
-//	- used by a deleted release, and i.Replace is false
+//   - empty
+//   - too long
+//   - already in use, and not deleted
+//   - used by a deleted release, and i.Replace is false
 func (i *Install) availableName() error {
 	start := i.ReleaseName
 
"
GO-2023-1547,helm,helm,293b50c65d4d56187cd4e2f390f0ada46b4c4737," type Engine struct {
 	LintMode bool
 	// the rest config to connect to the kubernetes api
 	config *rest.Config
+	// EnableDNS tells the engine to allow DNS lookups when rendering templates
+	EnableDNS bool
+}
+
+// New creates a new instance of Engine using the passed in rest config.
+func New(config *rest.Config) Engine {
+	return Engine{
+		config: config,
+	}
 }
 
 // Render takes a chart, optional values, and value overrides, and attempts to render the Go templates.
"
GO-2023-1772,distribution,distribution,f55a6552b006a381d9167e328808565dd2bf77dc," func Parse(rd io.Reader) (*Configuration, error) {
 					if v0_1.Loglevel != Loglevel("""") {
 						v0_1.Loglevel = Loglevel("""")
 					}
+
+					if v0_1.Catalog.MaxEntries <= 0 {
+						v0_1.Catalog.MaxEntries = 1000
+					}
+
 					if v0_1.Storage.Type() == """" {
 						return nil, errors.New(""no storage configuration provided"")
 					}
"
GO-2021-0053,gogo,protobuf,b03c65ea87cdc3521ede29f62fe3ce239267c1bc," func (m *Any) Unmarshal(dAtA []byte) error {
 			if err != nil {
 				return err
 			}
-			if skippy < 0 {
-				return ErrInvalidLengthAny
-			}
-			if (iNdEx + skippy) < 0 {
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
 				return ErrInvalidLengthAny
 			}
 			if (iNdEx + skippy) > l {
"
GO-2021-0053,gogo,protobuf,b03c65ea87cdc3521ede29f62fe3ce239267c1bc," func (m *Api) Unmarshal(dAtA []byte) error {
 			if err != nil {
 				return err
 			}
-			if skippy < 0 {
-				return ErrInvalidLengthApi
-			}
-			if (iNdEx + skippy) < 0 {
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
 				return ErrInvalidLengthApi
 			}
 			if (iNdEx + skippy) > l {
"
GO-2021-0053,gogo,protobuf,b03c65ea87cdc3521ede29f62fe3ce239267c1bc," func (m *Method) Unmarshal(dAtA []byte) error {
 			if err != nil {
 				return err
 			}
-			if skippy < 0 {
-				return ErrInvalidLengthApi
-			}
-			if (iNdEx + skippy) < 0 {
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
 				return ErrInvalidLengthApi
 			}
 			if (iNdEx + skippy) > l {
"
GO-2021-0053,gogo,protobuf,b03c65ea87cdc3521ede29f62fe3ce239267c1bc," func (m *Mixin) Unmarshal(dAtA []byte) error {
 			if err != nil {
 				return err
 			}
-			if skippy < 0 {
-				return ErrInvalidLengthApi
-			}
-			if (iNdEx + skippy) < 0 {
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
 				return ErrInvalidLengthApi
 			}
 			if (iNdEx + skippy) > l {
"
GO-2021-0053,gogo,protobuf,b03c65ea87cdc3521ede29f62fe3ce239267c1bc," func (m *Duration) Unmarshal(dAtA []byte) error {
 			if err != nil {
 				return err
 			}
-			if skippy < 0 {
-				return ErrInvalidLengthDuration
-			}
-			if (iNdEx + skippy) < 0 {
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
 				return ErrInvalidLengthDuration
 			}
 			if (iNdEx + skippy) > l {
"
GO-2021-0053,gogo,protobuf,b03c65ea87cdc3521ede29f62fe3ce239267c1bc," func (m *Empty) Unmarshal(dAtA []byte) error {
 			if err != nil {
 				return err
 			}
-			if skippy < 0 {
-				return ErrInvalidLengthEmpty
-			}
-			if (iNdEx + skippy) < 0 {
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
 				return ErrInvalidLengthEmpty
 			}
 			if (iNdEx + skippy) > l {
"
GO-2021-0053,gogo,protobuf,b03c65ea87cdc3521ede29f62fe3ce239267c1bc," func (m *FieldMask) Unmarshal(dAtA []byte) error {
 			if err != nil {
 				return err
 			}
-			if skippy < 0 {
-				return ErrInvalidLengthFieldMask
-			}
-			if (iNdEx + skippy) < 0 {
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
 				return ErrInvalidLengthFieldMask
 			}
 			if (iNdEx + skippy) > l {
"
GO-2021-0053,gogo,protobuf,b03c65ea87cdc3521ede29f62fe3ce239267c1bc," func (m *SourceContext) Unmarshal(dAtA []byte) error {
 			if err != nil {
 				return err
 			}
-			if skippy < 0 {
-				return ErrInvalidLengthSourceContext
-			}
-			if (iNdEx + skippy) < 0 {
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
 				return ErrInvalidLengthSourceContext
 			}
 			if (iNdEx + skippy) > l {
"
GO-2021-0053,gogo,protobuf,b03c65ea87cdc3521ede29f62fe3ce239267c1bc," func (m *Struct) Unmarshal(dAtA []byte) error {
 					if err != nil {
 						return err
 					}
-					if skippy < 0 {
+					if (skippy < 0) || (iNdEx+skippy) < 0 {
 						return ErrInvalidLengthStruct
 					}
 					if (iNdEx + skippy) > postIndex {
"
GO-2021-0053,gogo,protobuf,b03c65ea87cdc3521ede29f62fe3ce239267c1bc," func (m *Struct) Unmarshal(dAtA []byte) error {
 			if err != nil {
 				return err
 			}
-			if skippy < 0 {
-				return ErrInvalidLengthStruct
-			}
-			if (iNdEx + skippy) < 0 {
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
 				return ErrInvalidLengthStruct
 			}
 			if (iNdEx + skippy) > l {
"
GO-2021-0053,gogo,protobuf,b03c65ea87cdc3521ede29f62fe3ce239267c1bc," func (m *Value) Unmarshal(dAtA []byte) error {
 			if err != nil {
 				return err
 			}
-			if skippy < 0 {
-				return ErrInvalidLengthStruct
-			}
-			if (iNdEx + skippy) < 0 {
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
 				return ErrInvalidLengthStruct
 			}
 			if (iNdEx + skippy) > l {
"
GO-2021-0053,gogo,protobuf,b03c65ea87cdc3521ede29f62fe3ce239267c1bc," func (m *ListValue) Unmarshal(dAtA []byte) error {
 			if err != nil {
 				return err
 			}
-			if skippy < 0 {
-				return ErrInvalidLengthStruct
-			}
-			if (iNdEx + skippy) < 0 {
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
 				return ErrInvalidLengthStruct
 			}
 			if (iNdEx + skippy) > l {
"
GO-2021-0053,gogo,protobuf,b03c65ea87cdc3521ede29f62fe3ce239267c1bc," func (m *Timestamp) Unmarshal(dAtA []byte) error {
 			if err != nil {
 				return err
 			}
-			if skippy < 0 {
-				return ErrInvalidLengthTimestamp
-			}
-			if (iNdEx + skippy) < 0 {
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
 				return ErrInvalidLengthTimestamp
 			}
 			if (iNdEx + skippy) > l {
"
GO-2021-0053,gogo,protobuf,b03c65ea87cdc3521ede29f62fe3ce239267c1bc," func (m *Type) Unmarshal(dAtA []byte) error {
 			if err != nil {
 				return err
 			}
-			if skippy < 0 {
-				return ErrInvalidLengthType
-			}
-			if (iNdEx + skippy) < 0 {
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
 				return ErrInvalidLengthType
 			}
 			if (iNdEx + skippy) > l {
"
GO-2021-0053,gogo,protobuf,b03c65ea87cdc3521ede29f62fe3ce239267c1bc," func (m *Field) Unmarshal(dAtA []byte) error {
 			if err != nil {
 				return err
 			}
-			if skippy < 0 {
-				return ErrInvalidLengthType
-			}
-			if (iNdEx + skippy) < 0 {
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
 				return ErrInvalidLengthType
 			}
 			if (iNdEx + skippy) > l {
"
GO-2021-0053,gogo,protobuf,b03c65ea87cdc3521ede29f62fe3ce239267c1bc," func (m *Enum) Unmarshal(dAtA []byte) error {
 			if err != nil {
 				return err
 			}
-			if skippy < 0 {
-				return ErrInvalidLengthType
-			}
-			if (iNdEx + skippy) < 0 {
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
 				return ErrInvalidLengthType
 			}
 			if (iNdEx + skippy) > l {
"
GO-2021-0053,gogo,protobuf,b03c65ea87cdc3521ede29f62fe3ce239267c1bc," func (m *EnumValue) Unmarshal(dAtA []byte) error {
 			if err != nil {
 				return err
 			}
-			if skippy < 0 {
-				return ErrInvalidLengthType
-			}
-			if (iNdEx + skippy) < 0 {
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
 				return ErrInvalidLengthType
 			}
 			if (iNdEx + skippy) > l {
"
GO-2021-0053,gogo,protobuf,b03c65ea87cdc3521ede29f62fe3ce239267c1bc," func (m *Option) Unmarshal(dAtA []byte) error {
 			if err != nil {
 				return err
 			}
-			if skippy < 0 {
-				return ErrInvalidLengthType
-			}
-			if (iNdEx + skippy) < 0 {
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
 				return ErrInvalidLengthType
 			}
 			if (iNdEx + skippy) > l {
"
GO-2021-0053,gogo,protobuf,b03c65ea87cdc3521ede29f62fe3ce239267c1bc," func (m *DoubleValue) Unmarshal(dAtA []byte) error {
 			if err != nil {
 				return err
 			}
-			if skippy < 0 {
-				return ErrInvalidLengthWrappers
-			}
-			if (iNdEx + skippy) < 0 {
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
 				return ErrInvalidLengthWrappers
 			}
 			if (iNdEx + skippy) > l {
"
GO-2021-0053,gogo,protobuf,b03c65ea87cdc3521ede29f62fe3ce239267c1bc," func (m *FloatValue) Unmarshal(dAtA []byte) error {
 			if err != nil {
 				return err
 			}
-			if skippy < 0 {
-				return ErrInvalidLengthWrappers
-			}
-			if (iNdEx + skippy) < 0 {
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
 				return ErrInvalidLengthWrappers
 			}
 			if (iNdEx + skippy) > l {
"
GO-2021-0053,gogo,protobuf,b03c65ea87cdc3521ede29f62fe3ce239267c1bc," func (m *Int64Value) Unmarshal(dAtA []byte) error {
 			if err != nil {
 				return err
 			}
-			if skippy < 0 {
-				return ErrInvalidLengthWrappers
-			}
-			if (iNdEx + skippy) < 0 {
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
 				return ErrInvalidLengthWrappers
 			}
 			if (iNdEx + skippy) > l {
"
GO-2021-0053,gogo,protobuf,b03c65ea87cdc3521ede29f62fe3ce239267c1bc," func (m *UInt64Value) Unmarshal(dAtA []byte) error {
 			if err != nil {
 				return err
 			}
-			if skippy < 0 {
-				return ErrInvalidLengthWrappers
-			}
-			if (iNdEx + skippy) < 0 {
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
 				return ErrInvalidLengthWrappers
 			}
 			if (iNdEx + skippy) > l {
"
GO-2021-0053,gogo,protobuf,b03c65ea87cdc3521ede29f62fe3ce239267c1bc," func (m *Int32Value) Unmarshal(dAtA []byte) error {
 			if err != nil {
 				return err
 			}
-			if skippy < 0 {
-				return ErrInvalidLengthWrappers
-			}
-			if (iNdEx + skippy) < 0 {
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
 				return ErrInvalidLengthWrappers
 			}
 			if (iNdEx + skippy) > l {
"
GO-2021-0053,gogo,protobuf,b03c65ea87cdc3521ede29f62fe3ce239267c1bc," func (m *UInt32Value) Unmarshal(dAtA []byte) error {
 			if err != nil {
 				return err
 			}
-			if skippy < 0 {
-				return ErrInvalidLengthWrappers
-			}
-			if (iNdEx + skippy) < 0 {
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
 				return ErrInvalidLengthWrappers
 			}
 			if (iNdEx + skippy) > l {
"
GO-2021-0053,gogo,protobuf,b03c65ea87cdc3521ede29f62fe3ce239267c1bc," func (m *BoolValue) Unmarshal(dAtA []byte) error {
 			if err != nil {
 				return err
 			}
-			if skippy < 0 {
-				return ErrInvalidLengthWrappers
-			}
-			if (iNdEx + skippy) < 0 {
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
 				return ErrInvalidLengthWrappers
 			}
 			if (iNdEx + skippy) > l {
"
GO-2021-0053,gogo,protobuf,b03c65ea87cdc3521ede29f62fe3ce239267c1bc," func (m *StringValue) Unmarshal(dAtA []byte) error {
 			if err != nil {
 				return err
 			}
-			if skippy < 0 {
-				return ErrInvalidLengthWrappers
-			}
-			if (iNdEx + skippy) < 0 {
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
 				return ErrInvalidLengthWrappers
 			}
 			if (iNdEx + skippy) > l {
"
GO-2021-0053,gogo,protobuf,b03c65ea87cdc3521ede29f62fe3ce239267c1bc," func (m *BytesValue) Unmarshal(dAtA []byte) error {
 			if err != nil {
 				return err
 			}
-			if skippy < 0 {
-				return ErrInvalidLengthWrappers
-			}
-			if (iNdEx + skippy) < 0 {
+			if (skippy < 0) || (iNdEx+skippy) < 0 {
 				return ErrInvalidLengthWrappers
 			}
 			if (iNdEx + skippy) > l {
"
GO-2022-0272,kataras,iris,e213dba0d32ff66653e0ef124bc5088817264b08," func (ctx *Context) FormFiles(key string, before ...func(*Context, *multipart.Fi
 
 		innerLoop:
 			for _, header := range fhs[key] {
-				// Fix an issue that net/http has,
-				// an attacker can push a filename
-				// which could lead to override existing system files
-				// by ../../$header.
-				// Reported by Frank through security reports.
-				header.Filename = strings.ReplaceAll(header.Filename, ""../"", """")
-				header.Filename = strings.ReplaceAll(header.Filename, ""..\\"", """")
+				header.Filename = filepath.Base(header.Filename)
 
 				for _, b := range before {
 					if !b(ctx, header) {
"
GO-2022-0316,open-policy-agent,opa,932e4ffc37a590ace79e9b75ca4340288c220239," func squashTrailingNewlines(bs []byte) []byte {
 }
 
 func defaultLocation(x ast.Node) *ast.Location {
-	return ast.NewLocation([]byte(x.String()), """", 1, 1)
+	return ast.NewLocation([]byte(x.String()), defaultLocationFile, 1, 1)
 }
 
 type writer struct {
"
GO-2022-0411,Masterminds,goutils,869801f20f9f1e7ecdbdb6422049d8241270d5e1," func CryptoRandom(count int, start int, end int, letters bool, numbers bool, cha
 		if chars == nil {
 			ch = rune(getCryptoRandomInt(gap) + int64(start))
 		} else {
-			ch = chars[getCryptoRandomInt(gap) + int64(start)]
+			ch = chars[getCryptoRandomInt(gap)+int64(start)]
 		}
 
 		if letters && unicode.IsLetter(ch) || numbers && unicode.IsDigit(ch) || !letters && !numbers {
"
GO-2022-0528,containrrr,shoutrrr,6a27056f9d7522a8b493216195cb7634bf4b5c42," const (
 )
 
 // Send a notification message to discord
-func (service *Service) Send(message string, params *types.Params) error {
-
+func (service *Service) Send(message string, params *types.Params) (err error) {
 	if service.config.JSON {
 		postURL := CreateAPIURLFromConfig(service.config)
-		return doSend([]byte(message), postURL)
+		err = doSend([]byte(message), postURL)
+	} else {
+		items, omitted := CreateItemsFromPlain(message, service.config.SplitLines)
+		err = service.sendItems(items, params, omitted)
 	}
 
-	items, omitted := CreateItemsFromPlain(message, service.config.SplitLines)
-	return service.sendItems(items, params, omitted)
+	if err != nil {
+		err = fmt.Errorf(""failed to send discord notification: %v"", err)
+	}
+
+	return
 }
 
 // SendItems sends items with additional meta data and richer appearance
"
GO-2022-0528,containrrr,shoutrrr,6a27056f9d7522a8b493216195cb7634bf4b5c42," func doSend(payload []byte, postURL string) error {
 		err = fmt.Errorf(""response status code %s"", res.Status)
 	}
 
-	if err != nil {
-		return fmt.Errorf(""failed to send discord notification: %v"", err)
-	}
-
-	return nil
+	return err
 }
"
GO-2022-0528,containrrr,shoutrrr,6a27056f9d7522a8b493216195cb7634bf4b5c42," type embedFooter struct {
 // CreatePayloadFromItems creates a JSON payload to be sent to the discord webhook API
 func CreatePayloadFromItems(items []types.MessageItem, title string, colors [types.MessageLevelCount]uint, omitted int) (WebhookPayload, error) {
 
+	if len(items) < 1 {
+		return WebhookPayload{}, fmt.Errorf(""message is empty"")
+	}
+
 	metaCount := 1
 	if omitted < 1 && len(title) < 1 {
 		metaCount = 0
"
GO-2022-0528,containrrr,shoutrrr,6a27056f9d7522a8b493216195cb7634bf4b5c42," func CreatePayloadFromItems(items []types.MessageItem, title string, colors [typ
 		embeds = append(embeds, ei)
 	}
 
-	embeds[0].Title = title
-	if omitted > 0 {
-		embeds[0].Footer = &embedFooter{
-			Text: fmt.Sprintf(""... (%v character(s) where omitted)"", omitted),
+	// This should not happen, but it's better to leave the index check before dereferencing the array
+	if len(embeds) > 0 {
+		embeds[0].Title = title
+
+		if omitted > 0 {
+			embeds[0].Footer = &embedFooter{
+				Text: fmt.Sprintf(""... (%v character(s) were omitted)"", omitted),
+			}
 		}
 	}
 
"
GO-2022-1118,codenotary,immudb,cade04756ff3f0a3b9e8d24149062744574adf5d," func (o *Options) WithHeartBeatFrequency(heartBeatFrequency time.Duration) *Opti
 	return o
 }
 
+func (o *Options) WithDisableIdentityCheck(disableIdentityCheck bool) *Options {
+	o.DisableIdentityCheck = disableIdentityCheck
+	return o
+}
+
 // String converts options object to a json string
 func (o *Options) String() string {
 	optionsJSON, err := json.Marshal(o)
"
GO-2022-0384,helm,helm,61d8e8c4a6f95540c15c6a65f36a6dd0a45e7a2f," func addChartPathOptionsFlags(f *pflag.FlagSet, c *action.ChartPathOptions) {
 	f.StringVar(&c.KeyFile, ""key-file"", """", ""identify HTTPS client using this SSL key file"")
 	f.BoolVar(&c.InsecureSkipTLSverify, ""insecure-skip-tls-verify"", false, ""skip tls certificate checks for the chart download"")
 	f.StringVar(&c.CaFile, ""ca-file"", """", ""verify certificates of HTTPS-enabled servers using this CA bundle"")
+	f.BoolVar(&c.PassCredentialsAll, ""pass-credentials"", false, ""pass credentials to all domains"")
 }
 
 // bindOutputFlag will add the output flag to the given command and bind the
"
GO-2022-0384,helm,helm,61d8e8c4a6f95540c15c6a65f36a6dd0a45e7a2f," func newRepoAddCmd(out io.Writer) *cobra.Command {
 	f.StringVar(&o.caFile, ""ca-file"", """", ""verify certificates of HTTPS-enabled servers using this CA bundle"")
 	f.BoolVar(&o.insecureSkipTLSverify, ""insecure-skip-tls-verify"", false, ""skip tls certificate checks for the repository"")
 	f.BoolVar(&o.allowDeprecatedRepos, ""allow-deprecated-repos"", false, ""by default, this command will not allow adding official repos that have been permanently deleted. This disables that behavior"")
+	f.BoolVar(&o.passCredentialsAll, ""pass-credentials"", false, ""pass credentials to all domains"")
 
 	return cmd
 }
"
GO-2022-0384,helm,helm,61d8e8c4a6f95540c15c6a65f36a6dd0a45e7a2f," func (o *repoAddOptions) run(out io.Writer) error {
 		URL:                   o.url,
 		Username:              o.username,
 		Password:              o.password,
+		PassCredentialsAll:    o.passCredentialsAll,
 		CertFile:              o.certFile,
 		KeyFile:               o.keyFile,
 		CAFile:                o.caFile,
"
GO-2022-0384,helm,helm,61d8e8c4a6f95540c15c6a65f36a6dd0a45e7a2f," func (c *ChartPathOptions) LocateChart(name string, settings *cli.EnvSettings) (
 		Keyring: c.Keyring,
 		Getters: getter.All(settings),
 		Options: []getter.Option{
-			getter.WithBasicAuth(c.Username, c.Password),
+			getter.WithPassCredentialsAll(c.PassCredentialsAll),
 			getter.WithTLSClientConfig(c.CertFile, c.KeyFile, c.CaFile),
 			getter.WithInsecureSkipVerifyTLS(c.InsecureSkipTLSverify),
 		},
"
GO-2022-0384,helm,helm,61d8e8c4a6f95540c15c6a65f36a6dd0a45e7a2f," func (c *ChartPathOptions) LocateChart(name string, settings *cli.EnvSettings) (
 		dl.Verify = downloader.VerifyAlways
 	}
 	if c.RepoURL != """" {
-		chartURL, err := repo.FindChartInAuthAndTLSRepoURL(c.RepoURL, c.Username, c.Password, name, version,
-			c.CertFile, c.KeyFile, c.CaFile, c.InsecureSkipTLSverify, getter.All(settings))
+		chartURL, err := repo.FindChartInAuthAndTLSAndPassRepoURL(c.RepoURL, c.Username, c.Password, name, version,
+			c.CertFile, c.KeyFile, c.CaFile, c.InsecureSkipTLSverify, c.PassCredentialsAll, getter.All(settings))
 		if err != nil {
 			return """", err
 		}
 		name = chartURL
+
+		// Only pass the user/pass on when the user has said to or when the
+		// location of the chart repo and the chart are the same domain.
+		u1, err := url.Parse(c.RepoURL)
+		if err != nil {
+			return """", err
+		}
+		u2, err := url.Parse(chartURL)
+		if err != nil {
+			return """", err
+		}
+
+		// Host on URL (returned from url.Parse) contains the port if present.
+		// This check ensures credentials are not passed between different
+		// services on different ports.
+		if c.PassCredentialsAll || (u1.Scheme == u2.Scheme && u1.Host == u2.Host) {
+			dl.Options = append(dl.Options, getter.WithBasicAuth(c.Username, c.Password))
+		} else {
+			dl.Options = append(dl.Options, getter.WithBasicAuth("""", """"))
+		}
+	} else {
+		dl.Options = append(dl.Options, getter.WithBasicAuth(c.Username, c.Password))
 	}
 
 	if err := os.MkdirAll(settings.RepositoryCache, 0755); err != nil {
"
GO-2022-0384,helm,helm,61d8e8c4a6f95540c15c6a65f36a6dd0a45e7a2f," func (p *Pull) Run(chartRef string) (string, error) {
 		Getters: getter.All(p.Settings),
 		Options: []getter.Option{
 			getter.WithBasicAuth(p.Username, p.Password),
+			getter.WithPassCredentialsAll(p.PassCredentialsAll),
 			getter.WithTLSClientConfig(p.CertFile, p.KeyFile, p.CaFile),
 			getter.WithInsecureSkipVerifyTLS(p.InsecureSkipTLSverify),
 		},
"
GO-2022-0384,helm,helm,61d8e8c4a6f95540c15c6a65f36a6dd0a45e7a2f," func (p *Pull) Run(chartRef string) (string, error) {
 	}
 
 	if p.RepoURL != """" {
-		chartURL, err := repo.FindChartInAuthAndTLSRepoURL(p.RepoURL, p.Username, p.Password, chartRef, p.Version, p.CertFile, p.KeyFile, p.CaFile, p.InsecureSkipTLSverify, getter.All(p.Settings))
+		chartURL, err := repo.FindChartInAuthAndTLSAndPassRepoURL(p.RepoURL, p.Username, p.Password, chartRef, p.Version, p.CertFile, p.KeyFile, p.CaFile, p.InsecureSkipTLSverify, p.PassCredentialsAll, getter.All(p.Settings))
 		if err != nil {
 			return out.String(), err
 		}
"
GO-2022-0384,helm,helm,61d8e8c4a6f95540c15c6a65f36a6dd0a45e7a2f," func (m *Manager) downloadAll(deps []*chart.Dependency) error {
 
 		// Any failure to resolve/download a chart should fail:
 		// https://github.com/helm/helm/issues/1439
-		churl, username, password, err := m.findChartURL(dep.Name, dep.Version, dep.Repository, repos)
+		churl, username, password, passcredentialsall, err := m.findChartURL(dep.Name, dep.Version, dep.Repository, repos)
 		if err != nil {
 			saveError = errors.Wrapf(err, ""could not find %s"", churl)
 			break
"
GO-2022-0384,helm,helm,61d8e8c4a6f95540c15c6a65f36a6dd0a45e7a2f," func (m *Manager) downloadAll(deps []*chart.Dependency) error {
 			Getters:          m.Getters,
 			Options: []getter.Option{
 				getter.WithBasicAuth(username, password),
+				getter.WithPassCredentialsAll(passcredentialsall),
 			},
 		}
 
"
GO-2022-0384,helm,helm,61d8e8c4a6f95540c15c6a65f36a6dd0a45e7a2f," func (m *Manager) parallelRepoUpdate(repos []*repo.Entry) error {
 // repoURL is the repository to search
 //
 // If it finds a URL that is ""relative"", it will prepend the repoURL.
-func (m *Manager) findChartURL(name, version, repoURL string, repos map[string]*repo.ChartRepository) (url, username, password string, err error) {
+func (m *Manager) findChartURL(name, version, repoURL string, repos map[string]*repo.ChartRepository) (url, username, password string, passcredentialsall bool, err error) {
 	if strings.HasPrefix(repoURL, ""oci://"") {
-		return fmt.Sprintf(""%s/%s:%s"", repoURL, name, version), """", """", nil
+		return fmt.Sprintf(""%s/%s:%s"", repoURL, name, version), """", """", false, nil
 	}
 
 	for _, cr := range repos {
"
GO-2022-0384,helm,helm,61d8e8c4a6f95540c15c6a65f36a6dd0a45e7a2f," func (m *Manager) findChartURL(name, version, repoURL string, repos map[string]*
 			}
 			username = cr.Config.Username
 			password = cr.Config.Password
+			passcredentialsall = cr.Config.PassCredentialsAll
 			return
 		}
 	}
 	url, err = repo.FindChartInRepoURL(repoURL, name, version, """", """", """", m.Getters)
 	if err == nil {
-		return url, username, password, err
+		return url, username, password, false, err
 	}
 	err = errors.Errorf(""chart %s not found in %s: %s"", name, repoURL, err)
-	return url, username, password, err
+	return url, username, password, false, err
 }
 
 // findEntryByName finds an entry in the chart repository whose name matches the given name.
"
GO-2022-0384,helm,helm,61d8e8c4a6f95540c15c6a65f36a6dd0a45e7a2f," func WithBasicAuth(username, password string) Option {
 	}
 }
 
+func WithPassCredentialsAll(pass bool) Option {
+	return func(opts *options) {
+		opts.passCredentialsAll = pass
+	}
+}
+
 // WithUserAgent sets the request's User-Agent header to use the provided agent name.
 func WithUserAgent(userAgent string) Option {
 	return func(opts *options) {
"
GO-2022-0384,helm,helm,61d8e8c4a6f95540c15c6a65f36a6dd0a45e7a2f," func (g *HTTPGetter) get(href string) (*bytes.Buffer, error) {
 		req.Header.Set(""User-Agent"", g.opts.userAgent)
 	}
 
-	if g.opts.username != """" && g.opts.password != """" {
-		req.SetBasicAuth(g.opts.username, g.opts.password)
+	// Before setting the basic auth credentials, make sure the URL associated
+	// with the basic auth is the one being fetched.
+	u1, err := url.Parse(g.opts.url)
+	if err != nil {
+		return buf, errors.Wrap(err, ""Unable to parse getter URL"")
+	}
+	u2, err := url.Parse(href)
+	if err != nil {
+		return buf, errors.Wrap(err, ""Unable to parse URL getting from"")
+	}
+
+	// Host on URL (returned from url.Parse) contains the port if present.
+	// This check ensures credentials are not passed between different
+	// services on different ports.
+	if g.opts.passCredentialsAll || (u1.Scheme == u2.Scheme && u1.Host == u2.Host) {
+		if g.opts.username != """" && g.opts.password != """" {
+			req.SetBasicAuth(g.opts.username, g.opts.password)
+		}
 	}
 
 	client, err := g.httpClient()
"
GO-2022-0384,helm,helm,61d8e8c4a6f95540c15c6a65f36a6dd0a45e7a2f," func (r *ChartRepository) DownloadIndexFile() (string, error) {
 		getter.WithInsecureSkipVerifyTLS(r.Config.InsecureSkipTLSverify),
 		getter.WithTLSClientConfig(r.Config.CertFile, r.Config.KeyFile, r.Config.CAFile),
 		getter.WithBasicAuth(r.Config.Username, r.Config.Password),
+		getter.WithPassCredentialsAll(r.Config.PassCredentialsAll),
 	)
 	if err != nil {
 		return """", err
"
GO-2022-0384,helm,helm,61d8e8c4a6f95540c15c6a65f36a6dd0a45e7a2f," func FindChartInAuthAndTLSRepoURL(repoURL, username, password, chartName, chartV
 		URL:                   repoURL,
 		Username:              username,
 		Password:              password,
+		PassCredentialsAll:    passCredentialsAll,
 		CertFile:              certFile,
 		KeyFile:               keyFile,
 		CAFile:                caFile,
"
GO-2022-1187,go-macaron,i18n,329b0c4844cc16a5a253c011b55180598e707735," func initLocales(opt Options) language.Matcher {
 		// Append custom locale file.
 		custom := []interface{}{}
 		customPath := path.Join(opt.CustomDirectory, fname)
-		if com.IsFile(customPath) {
+		if isFile(customPath) {
 			custom = append(custom, customPath)
 		}
 
"
GO-2022-0391,aws,aws-sdk-go,35fa6ddf45c061e0f08d3a3b5119f8f4da38f6d1," type gcmContentCipherBuilder struct {
 	generator CipherDataGenerator
 }
 
+func (builder gcmContentCipherBuilder) isUsingDeprecatedFeatures() error {
+	if feature, ok := builder.generator.(deprecatedFeatures); ok {
+		return feature.isUsingDeprecatedFeatures()
+	}
+	return nil
+}
+
 // AESGCMContentCipherBuilder returns a new encryption only mode structure with a specific cipher
 // for the master key
 func AESGCMContentCipherBuilder(generator CipherDataGenerator) ContentCipherBuilder {
"
GO-2022-0391,aws,aws-sdk-go,35fa6ddf45c061e0f08d3a3b5119f8f4da38f6d1," func (builder gcmContentCipherBuilder) ContentCipherWithContext(ctx aws.Context)
 	var cd CipherData
 	var err error
 
-	if v, ok := builder.generator.(CipherDataGeneratorWithContext); ok {
+	switch v := builder.generator.(type) {
+	case CipherDataGeneratorWithCEKAlgWithContext:
+		cd, err = v.GenerateCipherDataWithCEKAlgWithContext(ctx, gcmKeySize, gcmNonceSize, AESGCMNoPadding)
+	case CipherDataGeneratorWithCEKAlg:
+		cd, err = v.GenerateCipherDataWithCEKAlg(gcmKeySize, gcmNonceSize, AESGCMNoPadding)
+	case CipherDataGeneratorWithContext:
 		cd, err = v.GenerateCipherDataWithContext(ctx, gcmKeySize, gcmNonceSize)
-	} else {
+	default:
 		cd, err = builder.generator.GenerateCipherData(gcmKeySize, gcmNonceSize)
 	}
 	if err != nil {
"
GO-2022-0391,aws,aws-sdk-go,35fa6ddf45c061e0f08d3a3b5119f8f4da38f6d1," type DecryptionClient struct {
 //	svc := s3crypto.NewDecryptionClient(sess, func(svc *s3crypto.DecryptionClient{
 //		// Custom client options here
 //	}))
+//
+// deprecated: see NewDecryptionClientV2
 func NewDecryptionClient(prov client.ConfigProvider, options ...func(*DecryptionClient)) *DecryptionClient {
 	s3client := s3.New(prov)
 
"
GO-2022-0391,aws,aws-sdk-go,35fa6ddf45c061e0f08d3a3b5119f8f4da38f6d1," type EncryptionClient struct {
 //
 // Example:
 //	cmkID := ""arn:aws:kms:region:000000000000:key/00000000-0000-0000-0000-000000000000""
-//	sess := session.New()
+//  sess := session.Must(session.NewSession())
 //	handler := s3crypto.NewKMSKeyGenerator(kms.New(sess), cmkID)
-//	svc := s3crypto.New(sess, s3crypto.AESGCMContentCipherBuilder(handler))
+//	svc := s3crypto.NewEncryptionClient(sess, s3crypto.AESGCMContentCipherBuilder(handler))
+//
+// deprecated: See NewEncryptionClientV2
 func NewEncryptionClient(prov client.ConfigProvider, builder ContentCipherBuilder, options ...func(*EncryptionClient)) *EncryptionClient {
 	s3client := s3.New(prov)
 
"
GO-2022-0391,aws,aws-sdk-go,35fa6ddf45c061e0f08d3a3b5119f8f4da38f6d1," type CipherDataDecrypterWithContext interface {
 	DecryptKeyWithContext(aws.Context, []byte) ([]byte, error)
 }
 
-func generateBytes(n int) []byte {
+func generateBytes(n int) ([]byte, error) {
 	b := make([]byte, n)
-	rand.Read(b)
-	return b
+	_, err := rand.Read(b)
+	if err != nil {
+		return nil, err
+	}
+	return b, nil
 }
"
GO-2022-0391,aws,aws-sdk-go,35fa6ddf45c061e0f08d3a3b5119f8f4da38f6d1," func NewKMSKeyGeneratorWithMatDesc(kmsClient kmsiface.KMSAPI, cmkID string, matd
 //	svc := s3crypto.NewDecryptionClient(sess, func(svc *s3crypto.DecryptionClient) {
 //		svc.WrapRegistry[s3crypto.KMSWrap] = decryptHandler
 //	}))
+//
+// deprecated: See NewKMSContextWrapEntry
 func NewKMSWrapEntry(kmsClient kmsiface.KMSAPI) WrapEntry {
 	// These values are read only making them thread safe
 	kp := &kmsKeyHandler{
"
GO-2022-0391,aws,aws-sdk-go,35fa6ddf45c061e0f08d3a3b5119f8f4da38f6d1," func NewKMSWrapEntry(kmsClient kmsiface.KMSAPI) WrapEntry {
 	return kp.decryptHandler
 }
 
+// NewKMSContextWrapEntry builds returns a new KMS key provider and its decrypt handler.
+//
+// Example:
+//	sess := session.New(&aws.Config{})
+//	customKMSClient := kms.New(sess)
+//	decryptHandler := s3crypto.NewKMSContextWrapEntry(customKMSClient)
+//
+//	svc := s3crypto.NewDecryptionClient(sess, func(svc *s3crypto.DecryptionClient) {
+//		svc.WrapRegistry[s3crypto.KMSContextWrap] = decryptHandler
+//	}))
+func NewKMSContextWrapEntry(kmsClient kmsiface.KMSAPI) WrapEntry {
+	// These values are read only making them thread safe
+	kp := &kmsKeyHandler{
+		kms:         kmsClient,
+		withContext: true,
+	}
+
+	return kp.decryptHandler
+}
+
 // decryptHandler initializes a KMS keyprovider with a material description. This
 // is used with Decrypting kms content, due to the cmkID being in the material description.
 func (kp kmsKeyHandler) decryptHandler(env Envelope) (CipherDataDecrypter, error) {
"
GO-2022-0391,aws,aws-sdk-go,35fa6ddf45c061e0f08d3a3b5119f8f4da38f6d1," func (kp kmsKeyHandler) decryptHandler(env Envelope) (CipherDataDecrypter, error
 	}
 
 	cmkID, ok := m[""kms_cmk_id""]
-	if !ok {
+	if !kp.withContext && !ok {
 		return nil, awserr.New(""MissingCMKIDError"", ""Material description is missing CMK ID"", nil)
 	}
 
 	kp.CipherData.MaterialDescription = m
 	kp.cmkID = cmkID
 	kp.WrapAlgorithm = KMSWrap
+	if kp.withContext {
+		kp.WrapAlgorithm = KMSContextWrap
+	}
 	return &kp, nil
 }
 
"
GO-2022-0391,aws,aws-sdk-go,35fa6ddf45c061e0f08d3a3b5119f8f4da38f6d1," func (strat HeaderV2SaveStrategy) Save(env Envelope, req *request.Request) error
 	input.Metadata[http.CanonicalHeaderKey(matDescHeader)] = &env.MatDesc
 	input.Metadata[http.CanonicalHeaderKey(wrapAlgorithmHeader)] = &env.WrapAlg
 	input.Metadata[http.CanonicalHeaderKey(cekAlgorithmHeader)] = &env.CEKAlg
-	input.Metadata[http.CanonicalHeaderKey(unencryptedMD5Header)] = &env.UnencryptedMD5
 	input.Metadata[http.CanonicalHeaderKey(unencryptedContentLengthHeader)] = &env.UnencryptedContentLen
 
 	if len(env.TagLen) > 0 {
"
GO-2022-0629,kubernetes-sigs,secrets-store-csi-driver,c2cbb19e2eef16638fa0523383788a4bc22231fd,"
+/*
+Copyright 2020 The Kubernetes Authors.
+
+Licensed under the Apache License, Version 2.0 (the ""License"");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an ""AS IS"" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+// Package k8sutil holds Secrets CSI Driver utilities for dealing with k8s
+// types.
+package k8sutil
+
+import (
+	v1 ""k8s.io/api/core/v1""
+)
+
+// SPCVolume finds the Secret Provider Class volume from a Pod, or returns nil
+// if a volume could not be found.
+func SPCVolume(pod *v1.Pod, spcName string) *v1.Volume {
+	for i, vol := range pod.Spec.Volumes {
+		if vol.CSI == nil {
+			continue
+		}
+		if vol.CSI.Driver != ""secrets-store.csi.k8s.io"" {
+			continue
+		}
+		if vol.CSI.VolumeAttributes[""secretProviderClass""] != spcName {
+			continue
+		}
+		return &pod.Spec.Volumes[i]
+	}
+	return nil
+}
"
GO-2022-1148,libp2p,go-libp2p,15d7dfbf54264ead8e6f49ca658d79c90635e2de," func (cfg *Config) makeSwarm() (*swarm.Swarm, error) {
 	if cfg.DialTimeout != 0 {
 		opts = append(opts, swarm.WithDialTimeout(cfg.DialTimeout))
 	}
+	if cfg.ResourceManager != nil {
+		opts = append(opts, swarm.WithResourceManager(cfg.ResourceManager))
+	}
 	// TODO: Make the swarm implementation configurable.
 	return swarm.NewSwarm(pid, cfg.Peerstore, opts...)
 }
"
GO-2022-1148,libp2p,go-libp2p,15d7dfbf54264ead8e6f49ca658d79c90635e2de," func (cfg *Config) addTransports(h host.Host) error {
 	if cfg.ConnectionGater != nil {
 		opts = append(opts, tptu.WithConnectionGater(cfg.ConnectionGater))
 	}
+	if cfg.ResourceManager != nil {
+		opts = append(opts, tptu.WithResourceManager(cfg.ResourceManager))
+	}
 	upgrader, err := tptu.New(secure, muxer, opts...)
 	if err != nil {
 		return err
 	}
-	tpts, err := makeTransports(h, upgrader, cfg.ConnectionGater, cfg.PSK, cfg.Transports)
+	tpts, err := makeTransports(h, upgrader, cfg.ConnectionGater, cfg.PSK, cfg.ResourceManager, cfg.Transports)
 	if err != nil {
 		return err
 	}
"
GO-2022-1148,libp2p,go-libp2p,15d7dfbf54264ead8e6f49ca658d79c90635e2de," func ConnectionGater(cg connmgr.ConnectionGater) Option {
 	}
 }
 
+// ResourceManager configures libp2p to use the given ResourceManager.
+func ResourceManager(rcmgr network.ResourceManager) Option {
+	return func(cfg *Config) error {
+		if cfg.ResourceManager != nil {
+			return errors.New(""cannot configure multiple resource managers"")
+		}
+		cfg.ResourceManager = rcmgr
+		return nil
+	}
+}
+
 // NATPortMap configures libp2p to use the default NATManager. The default
 // NATManager will attempt to open a port in your network's firewall using UPnP.
 func NATPortMap() Option {
"
GO-2022-1148,libp2p,go-libp2p,15d7dfbf54264ead8e6f49ca658d79c90635e2de," func (h *BasicHost) SetAutoNat(a autonat.AutoNAT) {
 	}
 }
 
-// Return the host's AutoNAT service, if AutoNAT is enabled.
+// GetAutoNat returns the host's AutoNAT service, if AutoNAT is enabled.
 func (h *BasicHost) GetAutoNat() autonat.AutoNAT {
 	h.addrMu.Lock()
 	defer h.addrMu.Unlock()
"
GO-2022-1148,libp2p,go-libp2p,15d7dfbf54264ead8e6f49ca658d79c90635e2de," func (c *conn) RemotePublicKey() ic.PubKey {
 func (c *conn) Stat() network.ConnStats {
 	return c.stat
 }
+
+func (c *conn) Scope() network.ConnScope {
+	return network.NullScope
+}
"
GO-2022-1148,libp2p,go-libp2p,15d7dfbf54264ead8e6f49ca658d79c90635e2de," func (pn *peernet) notifyAll(notification func(f network.Notifiee)) {
 	pn.notifmu.Unlock()
 	wg.Wait()
 }
+
+func (pn *peernet) ResourceManager() network.ResourceManager {
+	return network.NullResourceManager
+}
"
GO-2022-1148,libp2p,go-libp2p,15d7dfbf54264ead8e6f49ca658d79c90635e2de," func (s *stream) Stat() network.Stats {
 	return s.stat
 }
 
-func (s *stream) SetProtocol(proto protocol.ID) {
+func (s *stream) SetProtocol(proto protocol.ID) error {
 	s.protocol.Store(proto)
+	return nil
 }
 
 func (s *stream) CloseWrite() error {
"
GO-2022-1148,libp2p,go-libp2p,15d7dfbf54264ead8e6f49ca658d79c90635e2de," func (s *stream) Close() error {
 
 func (s *stream) Reset() error {
 	// Cancel any pending reads/writes with an error.
-	s.write.CloseWithError(mux.ErrReset)
-	s.read.CloseWithError(mux.ErrReset)
+	s.write.CloseWithError(network.ErrReset)
+	s.read.CloseWithError(network.ErrReset)
 
 	select {
 	case s.reset <- struct{}{}:
"
GO-2022-1148,libp2p,go-libp2p,15d7dfbf54264ead8e6f49ca658d79c90635e2de," func (s *stream) transport() {
 				case s.reset <- struct{}{}:
 				default:
 				}
-				return mux.ErrReset
+				return network.ErrReset
 			}
 			if err := drainBuf(); err != nil {
 				return err
"
GO-2022-1148,libp2p,go-libp2p,15d7dfbf54264ead8e6f49ca658d79c90635e2de," func (s *stream) transport() {
 		// Reset takes precedent.
 		select {
 		case <-s.reset:
-			s.writeErr = mux.ErrReset
+			s.writeErr = network.ErrReset
 			return
 		default:
 		}
 
 		select {
 		case <-s.reset:
-			s.writeErr = mux.ErrReset
+			s.writeErr = network.ErrReset
 			return
 		case <-s.close:
 			if err := drainBuf(); err != nil {
"
GO-2022-1148,libp2p,go-libp2p,15d7dfbf54264ead8e6f49ca658d79c90635e2de," func (r *Relay) handleStream(s network.Stream) {
 }
 
 func (r *Relay) handleHopStream(s network.Stream, msg *pb.CircuitRelay) {
+	span, err := r.scope.BeginSpan()
+	if err != nil {
+		log.Debugf(""failed to begin relay transaction: %s"", err)
+		r.handleError(s, pb.CircuitRelay_HOP_CANT_SPEAK_RELAY)
+		return
+	}
+
+	fail := func(code pb.CircuitRelay_Status) {
+		span.Done()
+		r.handleError(s, code)
+	}
+
+	// reserve buffers for the relay
+	if err := span.ReserveMemory(2*r.rc.BufferSize, network.ReservationPriorityHigh); err != nil {
+		log.Debugf(""error reserving memory for relay: %s"", err)
+		fail(pb.CircuitRelay_HOP_CANT_SPEAK_RELAY)
+		return
+	}
+
 	src, err := peerToPeerInfo(msg.GetSrcPeer())
 	if err != nil {
-		r.handleError(s, pb.CircuitRelay_HOP_SRC_MULTIADDR_INVALID)
+		fail(pb.CircuitRelay_HOP_SRC_MULTIADDR_INVALID)
 		return
 	}
 
 	if src.ID != s.Conn().RemotePeer() {
-		r.handleError(s, pb.CircuitRelay_HOP_SRC_MULTIADDR_INVALID)
+		fail(pb.CircuitRelay_HOP_SRC_MULTIADDR_INVALID)
 		return
 	}
 
 	dest, err := peerToPeerInfo(msg.GetDstPeer())
 	if err != nil {
-		r.handleError(s, pb.CircuitRelay_HOP_DST_MULTIADDR_INVALID)
+		fail(pb.CircuitRelay_HOP_DST_MULTIADDR_INVALID)
 		return
 	}
 
 	if dest.ID == r.host.ID() {
-		r.handleError(s, pb.CircuitRelay_HOP_CANT_RELAY_TO_SELF)
+		fail(pb.CircuitRelay_HOP_CANT_RELAY_TO_SELF)
 		return
 	}
 
 	if r.acl != nil && !r.acl.AllowHop(src.ID, dest.ID) {
 		log.Debugf(""refusing hop from %s to %s; ACL refused"", src.ID, dest.ID)
-		r.handleError(s, pb.CircuitRelay_HOP_CANT_SPEAK_RELAY)
+		fail(pb.CircuitRelay_HOP_CANT_SPEAK_RELAY)
 		return
 	}
 
"
GO-2022-1148,libp2p,go-libp2p,15d7dfbf54264ead8e6f49ca658d79c90635e2de," func (r *Relay) handleHopStream(s network.Stream, msg *pb.CircuitRelay) {
 	if r.active >= r.rc.MaxCircuits {
 		r.mx.Unlock()
 		log.Debugf(""refusing connection from %s to %s; too many active circuits"", src.ID, dest.ID)
-		r.handleError(s, pb.CircuitRelay_HOP_CANT_SPEAK_RELAY)
+		fail(pb.CircuitRelay_HOP_CANT_SPEAK_RELAY)
 		return
 	}
 
"
GO-2022-1148,libp2p,go-libp2p,15d7dfbf54264ead8e6f49ca658d79c90635e2de," func (r *Relay) handleHopStream(s network.Stream, msg *pb.CircuitRelay) {
 	if srcConns >= r.rc.MaxCircuitsPerPeer {
 		r.mx.Unlock()
 		log.Debugf(""refusing connection from %s to %s; too many connections from %s"", src.ID, dest.ID, src)
-		r.handleError(s, pb.CircuitRelay_HOP_CANT_SPEAK_RELAY)
+		fail(pb.CircuitRelay_HOP_CANT_SPEAK_RELAY)
 		return
 	}
 
"
GO-2022-1148,libp2p,go-libp2p,15d7dfbf54264ead8e6f49ca658d79c90635e2de," func (r *Relay) handleHopStream(s network.Stream, msg *pb.CircuitRelay) {
 	if destConns >= r.rc.MaxCircuitsPerPeer {
 		r.mx.Unlock()
 		log.Debugf(""refusing connection from %s to %s; too many connecitons to %s"", src.ID, dest.ID, dest.ID)
-		r.handleError(s, pb.CircuitRelay_HOP_CANT_SPEAK_RELAY)
+		fail(pb.CircuitRelay_HOP_CANT_SPEAK_RELAY)
 		return
 	}
 
"
GO-2022-1148,libp2p,go-libp2p,15d7dfbf54264ead8e6f49ca658d79c90635e2de," func (r *Relay) handleHopStream(s network.Stream, msg *pb.CircuitRelay) {
 	r.mx.Unlock()
 
 	cleanup := func() {
+		span.Done()
 		r.mx.Lock()
 		r.active--
 		r.rmConn(src.ID)
"
GO-2022-1148,libp2p,go-libp2p,15d7dfbf54264ead8e6f49ca658d79c90635e2de," func (r *Relay) handleHopStream(s network.Stream, msg *pb.CircuitRelay) {
 		return
 	}
 
+	fail = func(code pb.CircuitRelay_Status) {
+		bs.Reset()
+		cleanup()
+		r.handleError(s, code)
+	}
+
+	if err := bs.Scope().SetService(ServiceName); err != nil {
+		log.Debugf(""error attaching stream to relay service: %s"", err)
+		fail(pb.CircuitRelay_HOP_CANT_SPEAK_RELAY)
+		return
+	}
+
 	// stop handshake
+	if err := bs.Scope().ReserveMemory(maxMessageSize, network.ReservationPriorityAlways); err != nil {
+		log.Debugf(""failed to reserve memory for stream: %s"", err)
+		fail(pb.CircuitRelay_HOP_CANT_SPEAK_RELAY)
+		return
+	}
+	defer bs.Scope().ReleaseMemory(maxMessageSize)
+
 	rd := util.NewDelimitedReader(bs, maxMessageSize)
 	wr := util.NewDelimitedWriter(bs)
 	defer rd.Close()
"
GO-2022-1148,libp2p,go-libp2p,15d7dfbf54264ead8e6f49ca658d79c90635e2de," func (r *Relay) handleHopStream(s network.Stream, msg *pb.CircuitRelay) {
 	err = wr.WriteMsg(msg)
 	if err != nil {
 		log.Debugf(""error writing stop handshake: %s"", err.Error())
-		bs.Reset()
-		r.handleError(s, pb.CircuitRelay_HOP_CANT_OPEN_DST_STREAM)
-		cleanup()
+		fail(pb.CircuitRelay_HOP_CANT_OPEN_DST_STREAM)
 		return
 	}
 
"
GO-2022-1148,libp2p,go-libp2p,15d7dfbf54264ead8e6f49ca658d79c90635e2de," func (r *Relay) handleHopStream(s network.Stream, msg *pb.CircuitRelay) {
 	err = rd.ReadMsg(msg)
 	if err != nil {
 		log.Debugf(""error reading stop response: %s"", err.Error())
-		bs.Reset()
-		r.handleError(s, pb.CircuitRelay_HOP_CANT_OPEN_DST_STREAM)
-		cleanup()
+		fail(pb.CircuitRelay_HOP_CANT_OPEN_DST_STREAM)
 		return
 	}
 
 	if msg.GetType() != pb.CircuitRelay_STATUS {
 		log.Debugf(""unexpected relay stop response: not a status message (%d)"", msg.GetType())
-		bs.Reset()
-		r.handleError(s, pb.CircuitRelay_HOP_CANT_OPEN_DST_STREAM)
-		cleanup()
+		fail(pb.CircuitRelay_HOP_CANT_OPEN_DST_STREAM)
 		return
 	}
 
 	if msg.GetCode() != pb.CircuitRelay_SUCCESS {
 		log.Debugf(""relay stop failure: %d"", msg.GetCode())
-		bs.Reset()
-		r.handleError(s, msg.GetCode())
-		cleanup()
+		fail(msg.GetCode())
 		return
 	}
 
"
GO-2022-1148,libp2p,go-libp2p,15d7dfbf54264ead8e6f49ca658d79c90635e2de," func (ids *idService) identifyConn(c network.Conn) error {
 		ids.removeConn(c)
 		return err
 	}
-	s.SetProtocol(ID)
+
+	if err := s.SetProtocol(ID); err != nil {
+		log.Warnf(""error setting identify protocol for stream: %s"", err)
+		s.Reset()
+	}
 
 	// ok give the response to our handler.
 	if err := msmux.SelectProtoOrFail(ID, s); err != nil {
"
GO-2022-1148,libp2p,go-libp2p,15d7dfbf54264ead8e6f49ca658d79c90635e2de," func (ids *idService) identifyConn(c network.Conn) error {
 }
 
 func (ids *idService) sendIdentifyResp(s network.Stream) {
+	if err := s.Scope().SetService(ServiceName); err != nil {
+		log.Warnf(""error attaching stream to identify service: %s"", err)
+		s.Reset()
+		return
+	}
+
 	defer s.Close()
 
 	c := s.Conn()
"
GO-2022-1148,libp2p,go-libp2p,15d7dfbf54264ead8e6f49ca658d79c90635e2de," func (ids *idService) sendIdentifyResp(s network.Stream) {
 }
 
 func (ids *idService) handleIdentifyResponse(s network.Stream) error {
+	if err := s.Scope().SetService(ServiceName); err != nil {
+		log.Warnf(""error attaching stream to identify service: %s"", err)
+		s.Reset()
+		return err
+	}
+
+	if err := s.Scope().ReserveMemory(signedIDSize, network.ReservationPriorityAlways); err != nil {
+		log.Warnf(""error reserving memory for identify stream: %s"", err)
+		s.Reset()
+		return err
+	}
+	defer s.Scope().ReleaseMemory(signedIDSize)
+
 	_ = s.SetReadDeadline(time.Now().Add(StreamReadTimeout))
 
 	c := s.Conn()
"
GO-2022-1148,libp2p,go-libp2p,15d7dfbf54264ead8e6f49ca658d79c90635e2de," import (
 
 const IDDelta = ""/p2p/id/delta/1.0.0""
 
+const deltaMsgSize = 2048
+
 // deltaHandler handles incoming delta updates from peers.
 func (ids *idService) deltaHandler(s network.Stream) {
+	if err := s.Scope().SetService(ServiceName); err != nil {
+		log.Warnf(""error attaching stream to identify service: %s"", err)
+		s.Reset()
+		return
+	}
+
+	if err := s.Scope().ReserveMemory(deltaMsgSize, network.ReservationPriorityAlways); err != nil {
+		log.Warnf(""error reserving memory for identify stream: %s"", err)
+		s.Reset()
+		return
+	}
+	defer s.Scope().ReleaseMemory(deltaMsgSize)
+
 	_ = s.SetReadDeadline(time.Now().Add(StreamReadTimeout))
 
 	c := s.Conn()
 
-	r := protoio.NewDelimitedReader(s, 2048)
+	r := protoio.NewDelimitedReader(s, deltaMsgSize)
 	mes := pb.Identify{}
 	if err := r.ReadMsg(&mes); err != nil {
 		log.Warn(""error reading identify message: "", err)
"
GO-2022-1148,libp2p,go-libp2p,15d7dfbf54264ead8e6f49ca658d79c90635e2de," func NewPingService(h host.Host) *PingService {
 }
 
 func (p *PingService) PingHandler(s network.Stream) {
-	buf := make([]byte, PingSize)
+	if err := s.Scope().SetService(ServiceName); err != nil {
+		log.Debugf(""error attaching stream to ping service: %s"", err)
+		s.Reset()
+		return
+	}
+
+	if err := s.Scope().ReserveMemory(PingSize, network.ReservationPriorityAlways); err != nil {
+		log.Debugf(""error reserving memory for ping stream: %s"", err)
+		s.Reset()
+		return
+	}
+	defer s.Scope().ReleaseMemory(PingSize)
+
+	buf := pool.Get(PingSize)
+	defer pool.Put(buf)
 
 	errCh := make(chan error, 1)
 	defer close(errCh)
"
GO-2022-1148,libp2p,go-libp2p,15d7dfbf54264ead8e6f49ca658d79c90635e2de," func Ping(ctx context.Context, h host.Host, p peer.ID) <-chan Result {
 }
 
 func ping(s network.Stream) (time.Duration, error) {
-	buf := make([]byte, PingSize)
+	if err := s.Scope().ReserveMemory(2*PingSize, network.ReservationPriorityAlways); err != nil {
+		log.Debugf(""error reserving memory for ping stream: %s"", err)
+		s.Reset()
+		return 0, err
+	}
+	defer s.Scope().ReleaseMemory(2 * PingSize)
+
+	buf := pool.Get(PingSize)
+	defer pool.Put(buf)
+
 	u.NewTimeSeededRand().Read(buf)
 
 	before := time.Now()
"
GO-2022-1148,libp2p,go-libp2p,15d7dfbf54264ead8e6f49ca658d79c90635e2de," func ping(s network.Stream) (time.Duration, error) {
 		return 0, err
 	}
 
-	rbuf := make([]byte, PingSize)
+	rbuf := pool.Get(PingSize)
+	defer pool.Put(rbuf)
+
 	_, err = io.ReadFull(s, rbuf)
 	if err != nil {
 		return 0, err
"
GO-2021-0073,git-lfs,git-lfs,f913f5f9c7c6d1301785fdf9884a2942d59cdf19," func sshGetExeAndArgs(osEnv Env, e Endpoint) (exe string, baseargs []string) {
 	}
 
 	if ssh == """" {
-		ssh = ""ssh""
-	} else {
-		basessh := filepath.Base(ssh)
+		ssh = defaultSSHCmd
+	}
+
+	basessh := filepath.Base(ssh)
+
+	if basessh != defaultSSHCmd {
 		// Strip extension for easier comparison
 		if ext := filepath.Ext(basessh); len(ext) > 0 {
 			basessh = basessh[:len(basessh)-len(ext)]
"
GO-2021-0073,git-lfs,git-lfs,f913f5f9c7c6d1301785fdf9884a2942d59cdf19," func sshGetExeAndArgs(osEnv Env, e Endpoint) (exe string, baseargs []string) {
 		isTortoise = strings.EqualFold(basessh, ""tortoiseplink"")
 	}
 
-	args := make([]string, 0, 4+len(cmdArgs))
+	args := make([]string, 0, 5+len(cmdArgs))
 	if len(cmdArgs) > 0 {
 		args = append(args, cmdArgs...)
 	}
"
GO-2021-0073,git-lfs,git-lfs,f913f5f9c7c6d1301785fdf9884a2942d59cdf19," func sshGetExeAndArgs(osEnv Env, e Endpoint) (exe string, baseargs []string) {
 		}
 		args = append(args, e.SshPort)
 	}
-	args = append(args, e.SshUserAndHost)
+
+	if sep, ok := sshSeparators[basessh]; ok {
+		// inserts a separator between cli -options and host/cmd commands
+		// example: $ ssh -p 12345 -- user@host.com git-lfs-authenticate ...
+		args = append(args, sep, e.SshUserAndHost)
+	} else {
+		// no prefix supported, strip leading - off host to prevent cmd like:
+		// $ git config lfs.url ssh://-proxycmd=whatever
+		// $ plink -P 12345 -proxycmd=foo git-lfs-authenticate ...
+		//
+		// Instead, it'll attempt this, and eventually return an error
+		// $ plink -P 12345 proxycmd=foo git-lfs-authenticate ...
+		args = append(args, sshOptPrefixRE.ReplaceAllString(e.SshUserAndHost, """"))
+	}
 
 	return ssh, args
 }
+
+const defaultSSHCmd = ""ssh""
+
+var (
+	sshOptPrefixRE = regexp.MustCompile(`\A\-+`)
+	sshSeparators  = map[string]string{
+		""ssh"":          ""--"",
+		""lfs-ssh-echo"": ""--"", // used in lfs integration tests only
+	}
+)
"
GO-2021-0104,pion,webrtc,545613dcdeb5dedb01cce94175f40bcbe045df2e," func (api *API) NewDTLSTransport(transport *ICETransport, certificates []Certifi
 		state:        DTLSTransportStateNew,
 		dtlsMatcher:  mux.MatchDTLS,
 		srtpReady:    make(chan struct{}),
+		log:          api.settingEngine.LoggerFactory.NewLogger(""DTLSTransport""),
 	}
 
 	if len(certificates) > 0 {
"
GO-2022-1167,helm,helm,3636f6824757ff734cb265b8770efe48c1fb3737," func newFileParser(sc *bytes.Buffer, data map[string]interface{}, reader RunesVa
 
 func (t *parser) parse() error {
 	for {
-		err := t.key(t.data)
+		err := t.key(t.data, 0)
 		if err == nil {
 			continue
 		}
"
GO-2022-1167,helm,helm,3636f6824757ff734cb265b8770efe48c1fb3737," func (t *parser) keyIndex() (int, error) {
 	return strconv.Atoi(string(v))
 
 }
-func (t *parser) listItem(list []interface{}, i int) ([]interface{}, error) {
+func (t *parser) listItem(list []interface{}, i, nestedNameLevel int) ([]interface{}, error) {
 	if i < 0 {
 		return list, fmt.Errorf(""negative %d index not allowed"", i)
 	}
"
GO-2022-1167,helm,helm,3636f6824757ff734cb265b8770efe48c1fb3737," func (t *parser) listItem(list []interface{}, i int) ([]interface{}, error) {
 			}
 		}
 		// Now we need to get the value after the ].
-		list2, err := t.listItem(crtList, nextI)
+		list2, err := t.listItem(crtList, nextI, nestedNameLevel)
 		if err != nil {
 			return list, err
 		}
"
GO-2022-1167,helm,helm,3636f6824757ff734cb265b8770efe48c1fb3737," func (t *parser) listItem(list []interface{}, i int) ([]interface{}, error) {
 		}
 
 		// Recurse
-		e := t.key(inner)
+		e := t.key(inner, nestedNameLevel)
 		if e != nil {
 			return list, e
 		}
"
GO-2021-0412,containerd,imgcrypt,6fdd9818a4d8142107b7ecd767d839c9707700d9," const (
 // LayerFilter allows to select Layers by certain criteria
 type LayerFilter func(desc ocispec.Descriptor) bool
 
+// isLocalPlatform determines whether the given platform matches the local one
+func isLocalPlatform(platform *ocispec.Platform) bool {
+	matcher := platforms.NewMatcher(*platform)
+
+	return matcher.Match(platforms.DefaultSpec())
+}
+
 // IsEncryptedDiff returns true if mediaType is a known encrypted media type.
 func IsEncryptedDiff(ctx context.Context, mediaType string) bool {
 	switch mediaType {
"
GO-2022-0619,emicklei,go-restful,f292efff46ae17e9d104f865a60a39a2ae9402f1," func (c CrossOriginResourceSharing) isValidAccessControlRequestHeader(header str
 	return false
 }
 
-// Take a list of strings and compile them into a list of regular expressions.
-func compileRegexps(regexpStrings []string) ([]*regexp.Regexp, error) {
+// Take a list of allowed domains as strings and compile them into a list of regular expressions.
+func compileRegexps(allowedDomains []string) ([]*regexp.Regexp, error) {
 	regexps := []*regexp.Regexp{}
-	for _, regexpStr := range regexpStrings {
-		r, err := regexp.Compile(regexpStr)
+	for _, each := range allowedDomains {
+		// make sure the expression represents an exact match
+		if !strings.HasPrefix(each, ""^"") {
+			each = fmt.Sprintf(""^%s$"", each)
+		}
+		r, err := regexp.Compile(each)
 		if err != nil {
 			return regexps, err
 		}
"
GO-2022-0220,go.googlesource.com,go,9b6e9f0c8c66355c0f0575d808b32f52c8c6d21c," func Syscall12(trap, nargs, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12 ui
 func Syscall15(trap, nargs, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15 uintptr) (r1, r2 uintptr, err Errno)
 func Syscall18(trap, nargs, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18 uintptr) (r1, r2 uintptr, err Errno)
 func loadlibrary(filename *uint16) (handle uintptr, err Errno)
-func loadsystemlibrary(filename *uint16) (handle uintptr, err Errno)
+func loadsystemlibrary(filename *uint16, absoluteFilepath *uint16) (handle uintptr, err Errno)
 func getprocaddress(handle uintptr, procname *uint8) (proc uintptr, err Errno)
 
 // A DLL implements access to a single DLL.
"
GO-2022-0220,go.googlesource.com,go,9b6e9f0c8c66355c0f0575d808b32f52c8c6d21c," type DLL struct {
 	Handle Handle
 }
 
+// We use this for computing the absolute path for system DLLs on systems
+// where SEARCH_SYSTEM32 is not available.
+var systemDirectoryPrefix string
+
+func init() {
+	n := uint32(MAX_PATH)
+	for {
+		b := make([]uint16, n)
+		l, e := getSystemDirectory(&b[0], n)
+		if e != nil {
+			panic(""Unable to determine system directory: "" + e.Error())
+		}
+		if l <= n {
+			systemDirectoryPrefix = UTF16ToString(b[:l]) + ""\\""
+			break
+		}
+		n = l
+	}
+}
+
 // LoadDLL loads the named DLL file into memory.
 //
 // If name is not an absolute path and is not a known system DLL used by
"
GO-2022-0220,go.googlesource.com,go,9b6e9f0c8c66355c0f0575d808b32f52c8c6d21c," func GetUserProfileDirectory(t Token, dir *uint16, dirLen *uint32) (err error) {
 	}
 	return
 }
+
+func getSystemDirectory(dir *uint16, dirLen uint32) (len uint32, err error) {
+	r0, _, e1 := Syscall(procGetSystemDirectoryW.Addr(), 2, uintptr(unsafe.Pointer(dir)), uintptr(dirLen), 0)
+	len = uint32(r0)
+	if len == 0 {
+		if e1 != 0 {
+			err = errnoErr(e1)
+		} else {
+			err = EINVAL
+		}
+	}
+	return
+}
"
GO-2022-0536,go.googlesource.com,go,145e193131eb486077b66009beb051aba07c52a5," func (s *http2Server) maxConcurrentStreams() uint32 {
 	return http2defaultMaxStreams
 }
 
+// maxQueuedControlFrames is the maximum number of control frames like
+// SETTINGS, PING and RST_STREAM that will be queued for writing before
+// the connection is closed to prevent memory exhaustion attacks.
+func (s *http2Server) maxQueuedControlFrames() int {
+	// TODO: if anybody asks, add a Server field, and remember to define the
+	// behavior of negative values.
+	return http2maxQueuedControlFrames
+}
+
 type http2serverInternalState struct {
 	mu          sync.Mutex
 	activeConns map[*http2serverConn]struct{}
"
GO-2022-0536,go.googlesource.com,go,145e193131eb486077b66009beb051aba07c52a5," func (sc *http2serverConn) processSettings(f *http2SettingsFrame) error {
 	if err := f.ForeachSetting(sc.processSetting); err != nil {
 		return err
 	}
+	// TODO: judging by RFC 7540, Section 6.5.3 each SETTINGS frame should be
+	// acknowledged individually, even if multiple are received before the ACK.
 	sc.needToSendSettingsAck = true
 	sc.scheduleFrameWrite()
 	return nil
"
GO-2022-0536,go.googlesource.com,go,145e193131eb486077b66009beb051aba07c52a5," func (cc *http2ClientConn) roundTrip(req *Request) (res *Response, gotErrAfterRe
 		req.Method != ""HEAD"" {
 		// Request gzip only, not deflate. Deflate is ambiguous and
 		// not as universally supported anyway.
-		// See: http://www.gzip.org/zlib/zlib_faq.html#faq38
+		// See: https://zlib.net/zlib_faq.html#faq39
 		//
 		// Note that we don't request this for HEAD requests,
 		// due to a bug in nginx:
"
GO-2022-0536,go.googlesource.com,go,145e193131eb486077b66009beb051aba07c52a5," func (wr http2FrameWriteRequest) StreamID() uint32 {
 	return wr.stream.id
 }
 
+// isControl reports whether wr is a control frame for MaxQueuedControlFrames
+// purposes. That includes non-stream frames and RST_STREAM frames.
+func (wr http2FrameWriteRequest) isControl() bool {
+	return wr.stream == nil
+}
+
 // DataSize returns the number of flow control bytes that must be consumed
 // to write this entire frame. This is 0 for non-DATA frames.
 func (wr http2FrameWriteRequest) DataSize() int {
"
GO-2022-0217,go.googlesource.com,go,193c16a3648b8670a762e925b6ac6e074f468a20," func (curve *CurveParams) doubleJacobian(x, y, z *big.Int) (*big.Int, *big.Int,
 
 	x3 := new(big.Int).Mul(alpha, alpha)
 	beta8 := new(big.Int).Lsh(beta, 3)
+	beta8.Mod(beta8, curve.P)
 	x3.Sub(x3, beta8)
-	for x3.Sign() == -1 {
+	if x3.Sign() == -1 {
 		x3.Add(x3, curve.P)
 	}
 	x3.Mod(x3, curve.P)
"
GO-2021-0223,go.googlesource.com,go,82175e699a2e2cd83d3aa34949e9b922d66d52f5," func checkChainTrustStatus(c *Certificate, chainCtx *syscall.CertChainContext) e
 		switch status {
 		case syscall.CERT_TRUST_IS_NOT_TIME_VALID:
 			return CertificateInvalidError{c, Expired, """"}
+		case syscall.CERT_TRUST_IS_NOT_VALID_FOR_USAGE:
+			return CertificateInvalidError{c, IncompatibleUsage, """"}
+		// TODO(filippo): surface more error statuses.
 		default:
 			return UnknownAuthorityError{c, nil, nil}
 		}
"
GO-2022-0209,go.googlesource.com,crypto,b7391e95e576cacdcdd422573063bc057239113d,"
 
 package salsa
 
-// This function is implemented in salsa2020_amd64.s.
-
 //go:noescape
 
+// salsa2020XORKeyStream is implemented in salsa20_amd64.s.
 func salsa2020XORKeyStream(out, in *byte, n uint64, nonce, key *byte)
 
 // XORKeyStream crypts bytes from in to out using the given key and counters.
"
GO-2021-0224,go.googlesource.com,go,fa98f46741f818913a8c11b877520a548715131f," func (cw *chunkWriter) writeHeader(p []byte) {
 	// because we don't know if the next bytes on the wire will be
 	// the body-following-the-timer or the subsequent request.
 	// See Issue 11549.
-	if ecr, ok := w.req.Body.(*expectContinueReader); ok && !ecr.sawEOF {
+	if ecr, ok := w.req.Body.(*expectContinueReader); ok && !ecr.sawEOF.isSet() {
 		w.closeAfterReply = true
 	}
 
"
GO-2021-0224,go.googlesource.com,go,fa98f46741f818913a8c11b877520a548715131f," func (w *response) write(lenData int, dataB []byte, dataS string) (n int, err er
 		}
 		return 0, ErrHijacked
 	}
+
+	if w.canWriteContinue.isSet() {
+		// Body reader wants to write 100 Continue but hasn't yet.
+		// Tell it not to. The store must be done while holding the lock
+		// because the lock makes sure that there is not an active write
+		// this very moment.
+		w.writeContinueMu.Lock()
+		w.canWriteContinue.setFalse()
+		w.writeContinueMu.Unlock()
+	}
+
 	if !w.wroteHeader {
 		w.WriteHeader(StatusOK)
 	}
"
GO-2021-0224,go.googlesource.com,go,fa98f46741f818913a8c11b877520a548715131f," func (c *conn) serve(ctx context.Context) {
 			if req.ProtoAtLeast(1, 1) && req.ContentLength != 0 {
 				// Wrap the Body reader with one that replies on the connection
 				req.Body = &expectContinueReader{readCloser: req.Body, resp: w}
+				w.canWriteContinue.setTrue()
 			}
 		} else if req.Header.get(""Expect"") != """" {
 			w.sendExpectationFailed()
"
GO-2021-0319,go.googlesource.com,go,7f9494c277a471f6f47f4af3036285c0b1419816," func p224PointFromAffine(x, y *big.Int) (p *nistec.P224Point, ok bool) {
 	if x.Sign() == 0 && y.Sign() == 0 {
 		return nistec.NewP224Point(), true
 	}
+	if x.Sign() < 0 || y.Sign() < 0 {
+		return nil, false
+	}
 	if x.BitLen() > 224 || y.BitLen() > 224 {
 		return nil, false
 	}
"
GO-2021-0159,go.googlesource.com,go,117ddcb83d7f42d6aa72241240af99ded81118e9," func (h Header) WriteSubset(w io.Writer, exclude map[string]bool) error {
 // letter and any letter following a hyphen to upper case;
 // the rest are converted to lowercase.  For example, the
 // canonical key for ""accept-encoding"" is ""Accept-Encoding"".
+// If s contains a space or invalid header field bytes, it is
+// returned without modifications.
 func CanonicalHeaderKey(s string) string { return textproto.CanonicalMIMEHeaderKey(s) }
 
 // hasToken reports whether token appears with v, ASCII
"
GO-2022-0273,go.googlesource.com,go,bacbc33439b124ffd7392c91a5f5d96eca8c0c0b," func (z *Reader) init(r io.ReaderAt, size int64) error {
 	// indicate it contains up to 1 << 128 - 1 files. Since each file has a
 	// header which will be _at least_ 30 bytes we can safely preallocate
 	// if (data size / 30) >= end.directoryRecords.
-	if (uint64(size)-end.directorySize)/30 >= end.directoryRecords {
+	if end.directorySize < uint64(size) && (uint64(size)-end.directorySize)/30 >= end.directoryRecords {
 		z.File = make([]*File, 0, end.directoryRecords)
 	}
 	z.Comment = end.comment
"
GO-2022-0212,go.googlesource.com,go,41b1f88efab9d263408448bf139659119002ea50," func (r *Reader) ReadMIMEHeader() (MIMEHeader, error) {
 			return m, err
 		}
 
-		// Key ends at first colon; should not have trailing spaces
-		// but they appear in the wild, violating specs, so we remove
-		// them if present.
+		// Key ends at first colon.
 		i := bytes.IndexByte(kv, ':')
 		if i < 0 {
 			return m, ProtocolError(""malformed MIME header line: "" + string(kv))
 		}
-		endKey := i
-		for endKey > 0 && kv[endKey-1] == ' ' {
-			endKey--
-		}
-		key := canonicalMIMEHeaderKey(kv[:endKey])
+		key := canonicalMIMEHeaderKey(kv[:i])
 
 		// As per RFC 7230 field-name is a token, tokens consist of one or more chars.
 		// We could return a ProtocolError here, but better to be liberal in what we
"
GO-2022-0477,go.googlesource.com,go,bb1f4416180511231de6d17a1f2f55c82aafc863," var Reader io.Reader
 func Read(b []byte) (n int, err error) {
 	return io.ReadFull(Reader, b)
 }
+
+// batched returns a function that calls f to populate a []byte by chunking it
+// into subslices of, at most, readMax bytes.
+func batched(f func([]byte) error, readMax int) func([]byte) error {
+	return func(out []byte) error {
+		for len(out) > 0 {
+			read := len(out)
+			if read > readMax {
+				read = readMax
+			}
+			if err := f(out[:read]); err != nil {
+				return err
+			}
+			out = out[read:]
+		}
+		return nil
+	}
+}
"
GO-2022-0477,go.googlesource.com,go,bb1f4416180511231de6d17a1f2f55c82aafc863," type reader struct {
 
 // altGetRandom if non-nil specifies an OS-specific function to get
 // urandom-style randomness.
-var altGetRandom func([]byte) (ok bool)
-
-// batched returns a function that calls f to populate a []byte by chunking it
-// into subslices of, at most, readMax bytes.
-func batched(f func([]byte) error, readMax int) func([]byte) bool {
-	return func(out []byte) bool {
-		for len(out) > 0 {
-			read := len(out)
-			if read > readMax {
-				read = readMax
-			}
-			if f(out[:read]) != nil {
-				return false
-			}
-			out = out[read:]
-		}
-		return true
-	}
-}
+var altGetRandom func([]byte) (err error)
 
 func warnBlocked() {
 	println(""crypto/rand: blocked for 60 seconds waiting to read random data from the kernel"")
"
GO-2022-0477,go.googlesource.com,go,bb1f4416180511231de6d17a1f2f55c82aafc863," func (r *reader) Read(b []byte) (n int, err error) {
 		t := time.AfterFunc(time.Minute, warnBlocked)
 		defer t.Stop()
 	}
-	if altGetRandom != nil && altGetRandom(b) {
+	if altGetRandom != nil && altGetRandom(b) == nil {
 		return len(b), nil
 	}
 	if atomic.LoadUint32(&r.used) != 2 {
"
GO-2022-0477,go.googlesource.com,go,bb1f4416180511231de6d17a1f2f55c82aafc863," func init() { Reader = &rngReader{} }
 type rngReader struct{}
 
 func (r *rngReader) Read(b []byte) (n int, err error) {
-	// RtlGenRandom only accepts 2**32-1 bytes at a time, so truncate.
-	inputLen := uint32(len(b))
-
-	if inputLen == 0 {
-		return 0, nil
-	}
-
-	err = windows.RtlGenRandom(b)
-	if err != nil {
-		return 0, os.NewSyscallError(""RtlGenRandom"", err)
+	// RtlGenRandom only returns 1<<32-1 bytes at a time. We only read at
+	// most 1<<31-1 bytes at a time so that  this works the same on 32-bit
+	// and 64-bit systems.
+	if err := batched(windows.RtlGenRandom, 1<<31-1)(b); err != nil {
+		return 0, err
 	}
-	return int(inputLen), nil
+	return len(b), nil
 }
"
GO-2021-0238,go.googlesource.com,net,37e1c6afe02340126705deced573a85ab75209d7," func afterAfterFramesetIM(p *parser) bool {
 	return true
 }
 
+func ignoreTheRemainingTokens(p *parser) bool {
+	return true
+}
+
 const whitespaceOrNUL = whitespace + ""\x00""
 
 // Section 12.2.6.5
"
GO-2022-0475,go.googlesource.com,go,062e0e5ce6df339dc26732438ad771f73dbf2292," func dynimport(obj string) {
 	fatalf(""cannot parse %s as ELF, Mach-O, PE or XCOFF"", obj)
 }
 
+// checkImportSymName checks a symbol name we are going to emit as part
+// of a //go:cgo_import_dynamic pragma. These names come from object
+// files, so they may be corrupt. We are going to emit them unquoted,
+// so while they don't need to be valid symbol names (and in some cases,
+// involving symbol versions, they won't be) they must contain only
+// graphic characters and must not contain Go comments.
+func checkImportSymName(s string) {
+	for _, c := range s {
+		if !unicode.IsGraphic(c) || unicode.IsSpace(c) {
+			fatalf(""dynamic symbol %q contains unsupported character"", s)
+		}
+	}
+	if strings.Index(s, ""//"") >= 0 || strings.Index(s, ""/*"") >= 0 {
+		fatalf(""dynamic symbol %q contains Go comment"")
+	}
+}
+
 // Construct a gcc struct matching the gc argument frame.
 // Assumes that in gcc, char is 1 byte, short 2 bytes, int 4 bytes, long long 8 bytes.
 // These assumptions are checked by the gccProlog.
"
GO-2021-0154,go.googlesource.com,go,64df53ed7f," Curves:
 func (hs *serverHandshakeState) checkForResumption() bool {
 	c := hs.c
 
+	if c.config.SessionTicketsDisabled {
+		return false
+	}
+
 	var ok bool
 	if hs.sessionState, ok = c.decryptTicket(hs.clientHello.sessionTicket); !ok {
 		return false
"
GO-2021-0154,go.googlesource.com,go,64df53ed7f," func (c *Conn) encryptTicket(state *sessionState) ([]byte, error) {
 }
 
 func (c *Conn) decryptTicket(encrypted []byte) (*sessionState, bool) {
-	if len(encrypted) < aes.BlockSize+sha256.Size {
+	if c.config.SessionTicketsDisabled ||
+		len(encrypted) < aes.BlockSize+sha256.Size {
 		return nil, false
 	}
 
"
GO-2021-0226,go.googlesource.com,go,4f5cd0c0331943c7ec72df3b827d972584f77833," func (c *child) serveRequest(req *request, body io.ReadCloser) {
 		httpReq = httpReq.WithContext(envVarCtx)
 		c.handler.ServeHTTP(r, httpReq)
 	}
+	// Make sure we serve something even if nothing was written to r
+	r.Write(nil)
 	r.Close()
 	c.mu.Lock()
 	delete(c.requests, req.reqId)
"
GO-2021-0356,go.googlesource.com,crypto,1baeb1ce4c0b006eff0f294c47cb7617598dfb3d," func (c *Certificate) SignCert(rand io.Reader, authority Signer) error {
 	}
 	c.SignatureKey = authority.PublicKey()
 
-	if v, ok := authority.(AlgorithmSigner); ok {
-		if v.PublicKey().Type() == KeyAlgoRSA {
-			authority = &rsaSigner{v, KeyAlgoRSASHA512}
+	// Default to KeyAlgoRSASHA512 for ssh-rsa signers.
+	if v, ok := authority.(AlgorithmSigner); ok && v.PublicKey().Type() == KeyAlgoRSA {
+		sig, err := v.SignWithAlgorithm(rand, c.bytesForSigning(), KeyAlgoRSASHA512)
+		if err != nil {
+			return err
 		}
+		c.Signature = sig
+		return nil
 	}
 
 	sig, err := authority.Sign(rand, c.bytesForSigning())
"
GO-2021-0356,go.googlesource.com,crypto,1baeb1ce4c0b006eff0f294c47cb7617598dfb3d," func (c *Certificate) Marshal() []byte {
 
 // Type returns the certificate algorithm name. It is part of the PublicKey interface.
 func (c *Certificate) Type() string {
-	algo, ok := certAlgoNames[c.Key.Type()]
-	if !ok {
-		panic(""unknown cert key type "" + c.Key.Type())
+	keyType := c.Key.Type()
+	for certName, keyName := range certKeyAlgoNames {
+		if keyName == keyType {
+			return certName
+		}
 	}
-	return algo
+	panic(""unknown certificate type for key type "" + keyType)
 }
 
 // Verify verifies a signature against the certificate's public
"
GO-2021-0356,go.googlesource.com,crypto,1baeb1ce4c0b006eff0f294c47cb7617598dfb3d," func (c *connection) clientHandshake(dialAddress string, config *ClientConfig) e
 	return c.clientAuthenticate(config)
 }
 
-// verifyHostKeySignature verifies the host key obtained in the key
-// exchange.
+// verifyHostKeySignature verifies the host key obtained in the key exchange.
+// algo is the negotiated algorithm, and may be a certificate type.
 func verifyHostKeySignature(hostKey PublicKey, algo string, result *kexResult) error {
 	sig, rest, ok := parseSignatureBody(result.Signature)
 	if len(rest) > 0 || !ok {
 		return errors.New(""ssh: signature parse error"")
 	}
 
-	// For keys, underlyingAlgo is exactly algo. For certificates,
-	// we have to look up the underlying key algorithm that SSH
-	// uses to evaluate signatures.
-	underlyingAlgo := algo
-	for sigAlgo, certAlgo := range certAlgoNames {
-		if certAlgo == algo {
-			underlyingAlgo = sigAlgo
-		}
-	}
-	if sig.Format != underlyingAlgo {
-		return fmt.Errorf(""ssh: invalid signature algorithm %q, expected %q"", sig.Format, underlyingAlgo)
+	if a := underlyingAlgo(algo); sig.Format != a {
+		return fmt.Errorf(""ssh: invalid signature algorithm %q, expected %q"", sig.Format, a)
 	}
 
 	return hostKey.Verify(result.H, sig)
"
GO-2021-0356,go.googlesource.com,crypto,1baeb1ce4c0b006eff0f294c47cb7617598dfb3d," var supportedMACs = []string{
 
 var supportedCompressions = []string{compressionNone}
 
-// hashFuncs keeps the mapping of supported algorithms to their respective
-// hashes needed for signature verification.
+// hashFuncs keeps the mapping of supported signature algorithms to their
+// respective hashes needed for signing and verification.
 var hashFuncs = map[string]crypto.Hash{
-	KeyAlgoRSA:           crypto.SHA1,
-	KeyAlgoRSASHA256:     crypto.SHA256,
-	KeyAlgoRSASHA512:     crypto.SHA512,
-	KeyAlgoDSA:           crypto.SHA1,
-	KeyAlgoECDSA256:      crypto.SHA256,
-	KeyAlgoECDSA384:      crypto.SHA384,
-	KeyAlgoECDSA521:      crypto.SHA512,
-	CertAlgoRSAv01:       crypto.SHA1,
-	CertAlgoRSASHA256v01: crypto.SHA256,
-	CertAlgoRSASHA512v01: crypto.SHA512,
-	CertAlgoDSAv01:       crypto.SHA1,
-	CertAlgoECDSA256v01:  crypto.SHA256,
-	CertAlgoECDSA384v01:  crypto.SHA384,
-	CertAlgoECDSA521v01:  crypto.SHA512,
+	KeyAlgoRSA:       crypto.SHA1,
+	KeyAlgoRSASHA256: crypto.SHA256,
+	KeyAlgoRSASHA512: crypto.SHA512,
+	KeyAlgoDSA:       crypto.SHA1,
+	KeyAlgoECDSA256:  crypto.SHA256,
+	KeyAlgoECDSA384:  crypto.SHA384,
+	KeyAlgoECDSA521:  crypto.SHA512,
+	// KeyAlgoED25519 doesn't pre-hash.
+	KeyAlgoSKECDSA256: crypto.SHA256,
+	KeyAlgoSKED25519:  crypto.SHA256,
+}
+
+// algorithmsForKeyFormat returns the supported signature algorithms for a given
+// public key format (PublicKey.Type), in order of preference. See RFC 8332,
+// Section 2. See also the note in sendKexInit on backwards compatibility.
+func algorithmsForKeyFormat(keyFormat string) []string {
+	switch keyFormat {
+	case KeyAlgoRSA:
+		return []string{KeyAlgoRSASHA256, KeyAlgoRSASHA512, KeyAlgoRSA}
+	case CertAlgoRSAv01:
+		return []string{CertAlgoRSASHA256v01, CertAlgoRSASHA512v01, CertAlgoRSAv01}
+	default:
+		return []string{keyFormat}
+	}
 }
 
 // unexpectedMessageError results when the SSH message that we received didn't
"
GO-2021-0356,go.googlesource.com,crypto,1baeb1ce4c0b006eff0f294c47cb7617598dfb3d," func (t *handshakeTransport) sendKexInit() error {
 	}
 	io.ReadFull(rand.Reader, msg.Cookie[:])
 
-	if len(t.hostKeys) > 0 {
+	isServer := len(t.hostKeys) > 0
+	if isServer {
 		for _, k := range t.hostKeys {
-			algo := k.PublicKey().Type()
-			switch algo {
-			case KeyAlgoRSA:
-				msg.ServerHostKeyAlgos = append(msg.ServerHostKeyAlgos, []string{KeyAlgoRSASHA512, KeyAlgoRSASHA256, KeyAlgoRSA}...)
-			case CertAlgoRSAv01:
-				msg.ServerHostKeyAlgos = append(msg.ServerHostKeyAlgos, []string{CertAlgoRSASHA512v01, CertAlgoRSASHA256v01, CertAlgoRSAv01}...)
-			default:
-				msg.ServerHostKeyAlgos = append(msg.ServerHostKeyAlgos, algo)
+			// If k is an AlgorithmSigner, presume it supports all signature algorithms
+			// associated with the key format. (Ideally AlgorithmSigner would have a
+			// method to advertise supported algorithms, but it doesn't. This means that
+			// adding support for a new algorithm is a breaking change, as we will
+			// immediately negotiate it even if existing implementations don't support
+			// it. If that ever happens, we'll have to figure something out.)
+			// If k is not an AlgorithmSigner, we can only assume it only supports the
+			// algorithms that matches the key format. (This means that Sign can't pick
+			// a different default.)
+			keyFormat := k.PublicKey().Type()
+			if _, ok := k.(AlgorithmSigner); ok {
+				msg.ServerHostKeyAlgos = append(msg.ServerHostKeyAlgos, algorithmsForKeyFormat(keyFormat)...)
+			} else {
+				msg.ServerHostKeyAlgos = append(msg.ServerHostKeyAlgos, keyFormat)
 			}
 		}
 	} else {
 		msg.ServerHostKeyAlgos = t.hostKeyAlgorithms
 	}
+
 	packet := Marshal(msg)
 
 	// writePacket destroys the contents, so save a copy.
"
GO-2021-0356,go.googlesource.com,crypto,1baeb1ce4c0b006eff0f294c47cb7617598dfb3d," func (t *handshakeTransport) enterKeyExchange(otherInitPacket []byte) error {
 
 	var result *kexResult
 	if len(t.hostKeys) > 0 {
-		result, err = t.server(kex, t.algorithms, &magics)
+		result, err = t.server(kex, &magics)
 	} else {
-		result, err = t.client(kex, t.algorithms, &magics)
+		result, err = t.client(kex, &magics)
 	}
 
 	if err != nil {
"
GO-2021-0356,go.googlesource.com,crypto,1baeb1ce4c0b006eff0f294c47cb7617598dfb3d," func (t *handshakeTransport) client(kex kexAlgorithm, algs *algorithms, magics *
 		return nil, err
 	}
 
-	if err := verifyHostKeySignature(hostKey, algs.hostKey, result); err != nil {
+	if err := verifyHostKeySignature(hostKey, t.algorithms.hostKey, result); err != nil {
 		return nil, err
 	}
 
"
GO-2021-0356,go.googlesource.com,crypto,1baeb1ce4c0b006eff0f294c47cb7617598dfb3d," func (group *dhGroup) Client(c packetConn, randSource io.Reader, magics *handsha
 	}, nil
 }
 
-func (group *dhGroup) Server(c packetConn, randSource io.Reader, magics *handshakeMagics, priv Signer) (result *kexResult, err error) {
+func (group *dhGroup) Server(c packetConn, randSource io.Reader, magics *handshakeMagics, priv AlgorithmSigner, algo string) (result *kexResult, err error) {
 	packet, err := c.readPacket()
 	if err != nil {
 		return
"
GO-2021-0356,go.googlesource.com,crypto,1baeb1ce4c0b006eff0f294c47cb7617598dfb3d," func (group *dhGroup) Server(c packetConn, randSource io.Reader, magics *handsha
 
 	// H is already a hash, but the hostkey signing will apply its
 	// own key-specific hash algorithm.
-	sig, err := signAndMarshal(priv, randSource, H)
+	sig, err := signAndMarshal(priv, randSource, H, algo)
 	if err != nil {
 		return nil, err
 	}
"
GO-2021-0356,go.googlesource.com,crypto,1baeb1ce4c0b006eff0f294c47cb7617598dfb3d," func validateECPublicKey(curve elliptic.Curve, x, y *big.Int) bool {
 	return true
 }
 
-func (kex *ecdh) Server(c packetConn, rand io.Reader, magics *handshakeMagics, priv Signer) (result *kexResult, err error) {
+func (kex *ecdh) Server(c packetConn, rand io.Reader, magics *handshakeMagics, priv AlgorithmSigner, algo string) (result *kexResult, err error) {
 	packet, err := c.readPacket()
 	if err != nil {
 		return nil, err
"
GO-2021-0356,go.googlesource.com,crypto,1baeb1ce4c0b006eff0f294c47cb7617598dfb3d," func (kex *ecdh) Server(c packetConn, rand io.Reader, magics *handshakeMagics, p
 
 	// H is already a hash, but the hostkey signing will apply its
 	// own key-specific hash algorithm.
-	sig, err := signAndMarshal(priv, rand, H)
+	sig, err := signAndMarshal(priv, rand, H, algo)
 	if err != nil {
 		return nil, err
 	}
"
GO-2021-0356,go.googlesource.com,crypto,1baeb1ce4c0b006eff0f294c47cb7617598dfb3d," func (kex *ecdh) Server(c packetConn, rand io.Reader, magics *handshakeMagics, p
 	}, nil
 }
 
+// ecHash returns the hash to match the given elliptic curve, see RFC
+// 5656, section 6.2.1
+func ecHash(curve elliptic.Curve) crypto.Hash {
+	bitSize := curve.Params().BitSize
+	switch {
+	case bitSize <= 256:
+		return crypto.SHA256
+	case bitSize <= 384:
+		return crypto.SHA384
+	}
+	return crypto.SHA512
+}
+
 var kexAlgoMap = map[string]kexAlgorithm{}
 
 func init() {
"
GO-2021-0356,go.googlesource.com,crypto,1baeb1ce4c0b006eff0f294c47cb7617598dfb3d," func (kex *curve25519sha256) Client(c packetConn, rand io.Reader, magics *handsh
 	}, nil
 }
 
-func (kex *curve25519sha256) Server(c packetConn, rand io.Reader, magics *handshakeMagics, priv Signer) (result *kexResult, err error) {
+func (kex *curve25519sha256) Server(c packetConn, rand io.Reader, magics *handshakeMagics, priv AlgorithmSigner, algo string) (result *kexResult, err error) {
 	packet, err := c.readPacket()
 	if err != nil {
 		return
"
GO-2021-0356,go.googlesource.com,crypto,1baeb1ce4c0b006eff0f294c47cb7617598dfb3d," func (kex *curve25519sha256) Server(c packetConn, rand io.Reader, magics *handsh
 
 	H := h.Sum(nil)
 
-	sig, err := signAndMarshal(priv, rand, H)
+	sig, err := signAndMarshal(priv, rand, H, algo)
 	if err != nil {
 		return nil, err
 	}
"
GO-2021-0356,go.googlesource.com,crypto,1baeb1ce4c0b006eff0f294c47cb7617598dfb3d," func (gex *dhGEXSHA) Client(c packetConn, randSource io.Reader, magics *handshak
 // Server half implementation of the Diffie Hellman Key Exchange with SHA1 and SHA256.
 //
 // This is a minimal implementation to satisfy the automated tests.
-func (gex dhGEXSHA) Server(c packetConn, randSource io.Reader, magics *handshakeMagics, priv Signer) (result *kexResult, err error) {
+func (gex dhGEXSHA) Server(c packetConn, randSource io.Reader, magics *handshakeMagics, priv AlgorithmSigner, algo string) (result *kexResult, err error) {
 	// Receive GexRequest
 	packet, err := c.readPacket()
 	if err != nil {
"
GO-2021-0356,go.googlesource.com,crypto,1baeb1ce4c0b006eff0f294c47cb7617598dfb3d," func (gex dhGEXSHA) Server(c packetConn, randSource io.Reader, magics *handshake
 
 	// H is already a hash, but the hostkey signing will apply its
 	// own key-specific hash algorithm.
-	sig, err := signAndMarshal(priv, randSource, H)
+	sig, err := signAndMarshal(priv, randSource, H, algo)
 	if err != nil {
 		return nil, err
 	}
"
GO-2021-0356,go.googlesource.com,crypto,1baeb1ce4c0b006eff0f294c47cb7617598dfb3d," func parsePubKey(in []byte, algo string) (pubKey PublicKey, rest []byte, err err
 	case KeyAlgoSKED25519:
 		return parseSKEd25519(in)
 	case CertAlgoRSAv01, CertAlgoDSAv01, CertAlgoECDSA256v01, CertAlgoECDSA384v01, CertAlgoECDSA521v01, CertAlgoSKECDSA256v01, CertAlgoED25519v01, CertAlgoSKED25519v01:
-		cert, err := parseCert(in, certToPrivAlgo(algo))
+		cert, err := parseCert(in, certKeyAlgoNames[algo])
 		if err != nil {
 			return nil, nil, err
 		}
"
GO-2021-0356,go.googlesource.com,crypto,1baeb1ce4c0b006eff0f294c47cb7617598dfb3d," func (r *rsaPublicKey) Marshal() []byte {
 }
 
 func (r *rsaPublicKey) Verify(data []byte, sig *Signature) error {
-	var hash crypto.Hash
-	switch sig.Format {
-	case KeyAlgoRSA:
-		hash = crypto.SHA1
-	case KeyAlgoRSASHA256:
-		hash = crypto.SHA256
-	case KeyAlgoRSASHA512:
-		hash = crypto.SHA512
-	default:
+	supportedAlgos := algorithmsForKeyFormat(r.Type())
+	if !contains(supportedAlgos, sig.Format) {
 		return fmt.Errorf(""ssh: signature type %s for key type %s"", sig.Format, r.Type())
 	}
+	hash := hashFuncs[sig.Format]
 	h := hash.New()
 	h.Write(data)
 	digest := h.Sum(nil)
"
GO-2021-0356,go.googlesource.com,crypto,1baeb1ce4c0b006eff0f294c47cb7617598dfb3d," func (k *dsaPublicKey) Verify(data []byte, sig *Signature) error {
 	if sig.Format != k.Type() {
 		return fmt.Errorf(""ssh: signature type %s for key type %s"", sig.Format, k.Type())
 	}
-	h := crypto.SHA1.New()
+	h := hashFuncs[sig.Format].New()
 	h.Write(data)
 	digest := h.Sum(nil)
 
"
GO-2021-0356,go.googlesource.com,crypto,1baeb1ce4c0b006eff0f294c47cb7617598dfb3d," func (k *dsaPrivateKey) PublicKey() PublicKey {
 }
 
 func (k *dsaPrivateKey) Sign(rand io.Reader, data []byte) (*Signature, error) {
-	return k.SignWithAlgorithm(rand, data, """")
+	return k.SignWithAlgorithm(rand, data, k.PublicKey().Type())
 }
 
 func (k *dsaPrivateKey) SignWithAlgorithm(rand io.Reader, data []byte, algorithm string) (*Signature, error) {
"
GO-2021-0356,go.googlesource.com,crypto,1baeb1ce4c0b006eff0f294c47cb7617598dfb3d," func (k *dsaPrivateKey) SignWithAlgorithm(rand io.Reader, data []byte, algorithm
 		return nil, fmt.Errorf(""ssh: unsupported signature algorithm %s"", algorithm)
 	}
 
-	h := crypto.SHA1.New()
+	h := hashFuncs[k.PublicKey().Type()].New()
 	h.Write(data)
 	digest := h.Sum(nil)
 	r, s, err := dsa.Sign(rand, k.PrivateKey, digest)
"
GO-2021-0356,go.googlesource.com,crypto,1baeb1ce4c0b006eff0f294c47cb7617598dfb3d," func (k *ecdsaPublicKey) Verify(data []byte, sig *Signature) error {
 		return fmt.Errorf(""ssh: signature type %s for key type %s"", sig.Format, k.Type())
 	}
 
-	h := ecHash(k.Curve).New()
+	h := hashFuncs[sig.Format].New()
 	h.Write(data)
 	digest := h.Sum(nil)
 
"
GO-2021-0356,go.googlesource.com,crypto,1baeb1ce4c0b006eff0f294c47cb7617598dfb3d," func (k *skECDSAPublicKey) Verify(data []byte, sig *Signature) error {
 		return fmt.Errorf(""ssh: signature type %s for key type %s"", sig.Format, k.Type())
 	}
 
-	h := ecHash(k.Curve).New()
+	h := hashFuncs[sig.Format].New()
 	h.Write([]byte(k.application))
 	appDigest := h.Sum(nil)
 
"
GO-2021-0356,go.googlesource.com,crypto,1baeb1ce4c0b006eff0f294c47cb7617598dfb3d," func (k *skEd25519PublicKey) Verify(data []byte, sig *Signature) error {
 		return fmt.Errorf(""invalid size %d for Ed25519 public key"", l)
 	}
 
-	h := sha256.New()
+	h := hashFuncs[sig.Format].New()
 	h.Write([]byte(k.application))
 	appDigest := h.Sum(nil)
 
"
GO-2021-0356,go.googlesource.com,crypto,1baeb1ce4c0b006eff0f294c47cb7617598dfb3d," func NewServerConn(c net.Conn, config *ServerConfig) (*ServerConn, <-chan NewCha
 }
 
 // signAndMarshal signs the data with the appropriate algorithm,
-// and serializes the result in SSH wire format.
-func signAndMarshal(k Signer, rand io.Reader, data []byte) ([]byte, error) {
-	sig, err := k.Sign(rand, data)
+// and serializes the result in SSH wire format. algo is the negotiate
+// algorithm and may be a certificate type.
+func signAndMarshal(k AlgorithmSigner, rand io.Reader, data []byte, algo string) ([]byte, error) {
+	sig, err := k.SignWithAlgorithm(rand, data, underlyingAlgo(algo))
 	if err != nil {
 		return nil, err
 	}
"
GO-2021-0356,go.googlesource.com,crypto,1baeb1ce4c0b006eff0f294c47cb7617598dfb3d," func supportedEllipticCurve(curve elliptic.Curve) bool {
 	return curve == elliptic.P256() || curve == elliptic.P384() || curve == elliptic.P521()
 }
 
-// ecHash returns the hash to match the given elliptic curve, see RFC
-// 5656, section 6.2.1
-func ecHash(curve elliptic.Curve) crypto.Hash {
-	bitSize := curve.Params().BitSize
-	switch {
-	case bitSize <= 256:
-		return crypto.SHA256
-	case bitSize <= 384:
-		return crypto.SHA384
-	}
-	return crypto.SHA512
-}
-
 // parseECDSA parses an ECDSA key according to RFC 5656, section 3.1.
 func parseECDSA(in []byte) (out PublicKey, rest []byte, err error) {
 	var w struct {
"
GO-2021-0356,go.googlesource.com,crypto,1baeb1ce4c0b006eff0f294c47cb7617598dfb3d," func newDSAPrivateKey(key *dsa.PrivateKey) (Signer, error) {
 	return &dsaPrivateKey{key}, nil
 }
 
-type rsaSigner struct {
-	AlgorithmSigner
-	defaultAlgorithm string
-}
-
-func (s *rsaSigner) Sign(rand io.Reader, data []byte) (*Signature, error) {
-	return s.AlgorithmSigner.SignWithAlgorithm(rand, data, s.defaultAlgorithm)
-}
-
 type wrappedSigner struct {
 	signer crypto.Signer
 	pubKey PublicKey
"
GO-2022-0434,go.googlesource.com,go,0fca8a8f25cf4636fd980e72ba0bded4230922de," func (c *Certificate) systemVerify(opts *VerifyOptions) (chains [][]*Certificate
 	certs := macOS.CFArrayCreateMutable()
 	defer macOS.ReleaseCFArray(certs)
 	leaf := macOS.SecCertificateCreateWithData(c.Raw)
+	if leaf == 0 {
+		return nil, errors.New(""invalid leaf certificate"")
+	}
 	macOS.CFArrayAppendValue(certs, leaf)
 	if opts.Intermediates != nil {
 		for _, lc := range opts.Intermediates.lazyCerts {
"
GO-2022-0434,go.googlesource.com,go,0fca8a8f25cf4636fd980e72ba0bded4230922de," func (c *Certificate) systemVerify(opts *VerifyOptions) (chains [][]*Certificate
 				return nil, err
 			}
 			sc := macOS.SecCertificateCreateWithData(c.Raw)
-			macOS.CFArrayAppendValue(certs, sc)
+			if sc != 0 {
+				macOS.CFArrayAppendValue(certs, sc)
+			}
 		}
 	}
 
"
GO-2020-0012,go.googlesource.com,crypto,bac4c82f69751a6dd76e702d54b3ceb88adab236," func parseOpenSSHPrivateKey(key []byte, decrypt openSSHDecryptFunc) (crypto.Priv
 		return nil, errors.New(""ssh: malformed OpenSSH key"")
 	}
 
-	// we only handle ed25519 and rsa keys currently
 	switch pk1.Keytype {
 	case KeyAlgoRSA:
 		// https://github.com/openssh/openssh-portable/blob/master/sshkey.c#L2760-L2773
"
GO-2022-0191,go.googlesource.com,go,770130659b6fb2acf271476579a3644e093dda7f," func (c *Certificate) Verify(opts VerifyOptions) (chains [][]*Certificate, err e
 	if opts.Roots.contains(c) {
 		candidateChains = append(candidateChains, []*Certificate{c})
 	} else {
-		if candidateChains, err = c.buildChains(make(map[int][][]*Certificate), []*Certificate{c}, &opts); err != nil {
+		if candidateChains, err = c.buildChains(nil, []*Certificate{c}, nil, &opts); err != nil {
 			return nil, err
 		}
 	}
"
GO-2021-0347,go.googlesource.com,go,452f24ae94f38afa3704d4361d91d51218405c0a," func (p *parser) push(re *Regexp) *Regexp {
 	}
 
 	p.stack = append(p.stack, re)
+	p.checkHeight(re)
 	return re
 }
 
"
GO-2021-0347,go.googlesource.com,go,452f24ae94f38afa3704d4361d91d51218405c0a," func (p *parser) repeat(op Op, min, max int, before, after, lastRepeat string) (
 	re.Sub = re.Sub0[:1]
 	re.Sub[0] = sub
 	p.stack[n-1] = re
+	p.checkHeight(re)
 
 	if op == OpRepeat && (min >= 2 || max >= 2) && !repeatIsValid(re, 1000) {
 		return """", &Error{ErrInvalidRepeatSize, before[:len(before)-len(after)]}
"
GO-2021-0347,go.googlesource.com,go,452f24ae94f38afa3704d4361d91d51218405c0a," func Parse(s string, flags Flags) (*Regexp, error) {
 	// Otherwise, must do real work.
 	var (
 		p          parser
-		err        error
 		c          rune
 		op         Op
 		lastRepeat string
"
GO-2022-0289,go.googlesource.com,go,a76511f3a40ea69ee4f5cd86e735e1c8a84f0aa2," func forkExec(argv0 string, argv []string, attr *ProcAttr) (pid int, err error)
 
 	// Allocate child status pipe close on exec.
 	if err = forkExecPipe(p[:]); err != nil {
-		goto error
+		ForkLock.Unlock()
+		return 0, err
 	}
 
 	// Kick off child.
 	pid, err1 = forkAndExecInChild(argv0p, argvp, envvp, chroot, dir, attr, sys, p[1])
 	if err1 != 0 {
-		err = Errno(err1)
-		goto error
+		Close(p[0])
+		Close(p[1])
+		ForkLock.Unlock()
+		return 0, Errno(err1)
 	}
 	ForkLock.Unlock()
 
"
GO-2022-0289,go.googlesource.com,go,a76511f3a40ea69ee4f5cd86e735e1c8a84f0aa2," func forkExec(argv0 string, argv []string, attr *ProcAttr) (pid int, err error)
 		sys = &zeroSysProcAttr
 	}
 
-	p[0] = -1
-	p[1] = -1
-
 	// Convert args to C form.
 	argv0p, err := BytePtrFromString(argv0)
 	if err != nil {
"
GO-2022-0289,go.googlesource.com,go,a76511f3a40ea69ee4f5cd86e735e1c8a84f0aa2," func forkExec(argv0 string, argv []string, attr *ProcAttr) (pid int, err error)
 
 	// Read got EOF, so pipe closed on exec, so exec succeeded.
 	return pid, nil
-
-error:
-	if p[0] >= 0 {
-		Close(p[0])
-		Close(p[1])
-	}
-	ForkLock.Unlock()
-	return 0, err
 }
 
 // Combination of fork and exec, careful to be thread safe.
"
GO-2022-0171,go.googlesource.com,go,7e5b2e0ec144d5f5b2923a7d5db0b9143f79a35a," func loadSystemRoots() (*CertPool, error) {
 	roots := NewCertPool()
 
 	var data C.CFDataRef = nil
-	err := C.FetchPEMRoots(&data)
+	var untrustedData C.CFDataRef = nil
+	err := C.FetchPEMRoots(&data, &untrustedData)
 	if err == -1 {
 		// TODO: better error message
 		return nil, errors.New(""crypto/x509: failed to load darwin system roots with cgo"")
"
GO-2022-0171,go.googlesource.com,go,7e5b2e0ec144d5f5b2923a7d5db0b9143f79a35a," func loadSystemRoots() (*CertPool, error) {
 	defer C.CFRelease(C.CFTypeRef(data))
 	buf := C.GoBytes(unsafe.Pointer(C.CFDataGetBytePtr(data)), C.int(C.CFDataGetLength(data)))
 	roots.AppendCertsFromPEM(buf)
-	return roots, nil
+	if untrustedData == nil {
+		return roots, nil
+	}
+	defer C.CFRelease(C.CFTypeRef(untrustedData))
+	buf = C.GoBytes(unsafe.Pointer(C.CFDataGetBytePtr(untrustedData)), C.int(C.CFDataGetLength(untrustedData)))
+	untrustedRoots := NewCertPool()
+	untrustedRoots.AppendCertsFromPEM(buf)
+
+	trustedRoots := NewCertPool()
+	for _, c := range roots.certs {
+		if !untrustedRoots.contains(c) {
+			trustedRoots.AddCert(c)
+		}
+	}
+	return trustedRoots, nil
 }
"
GO-2021-0163,go.googlesource.com,go,6a0bb87bd0bf0fdf8ddbd35f77a75ebd412f61b0," type DLL struct {
 }
 
 // LoadDLL loads the named DLL file into memory.
+//
+// If name is not an absolute path and is not a known system DLL used by
+// Go, Windows will search for the named DLL in many locations, causing
+// potential DLL preloading attacks.
+//
+// Use LazyDLL in golang.org/x/sys/windows for a secure way to
+// load system DLLs.
 func LoadDLL(name string) (*DLL, error) {
 	namep, err := UTF16PtrFromString(name)
 	if err != nil {
"
GO-2021-0163,go.googlesource.com,go,6a0bb87bd0bf0fdf8ddbd35f77a75ebd412f61b0," func (src *Source) Generate(w io.Writer) error {
 			}
 			if *sysRepo {
 				if packageName == ""windows"" {
-					return ""&LazyDLL{Name: "" + arg + "", Flags: LoadLibrarySearchSystem32}""
+					return ""&LazyDLL{Name: "" + arg + "", System: true}""
 				} else {
-					return ""&windows.LazyDLL{Name: "" + arg + "", Flags: windows.LoadLibrarySearchSystem32}""
+					return ""&windows.LazyDLL{Name: "" + arg + "", System: true}""
 				}
 			} else {
 				return syscalldot() + ""NewLazyDLL("" + arg + "")""
"
GO-2021-0113,go.googlesource.com,text,383b2e75a7a4198c42f8f87833eefb772868a56f," func (t Tag) Parent() Tag {
 
 // ParseExtension parses s as an extension and returns it on success.
 func ParseExtension(s string) (ext string, err error) {
+	defer func() {
+		if recover() != nil {
+			ext = """"
+			err = ErrSyntax
+		}
+	}()
+
 	scan := makeScannerString(s)
 	var end int
 	if n := len(scan.token); n != 1 {
"
GO-2021-0113,go.googlesource.com,text,383b2e75a7a4198c42f8f87833eefb772868a56f," func (t Tag) findTypeForKey(key string) (start, sep, end int, hasExt bool) {
 // ParseBase parses a 2- or 3-letter ISO 639 code.
 // It returns a ValueError if s is a well-formed but unknown language identifier
 // or another error if another error occurred.
-func ParseBase(s string) (Language, error) {
+func ParseBase(s string) (l Language, err error) {
+	defer func() {
+		if recover() != nil {
+			l = 0
+			err = ErrSyntax
+		}
+	}()
+
 	if n := len(s); n < 2 || 3 < n {
 		return 0, ErrSyntax
 	}
"
GO-2021-0113,go.googlesource.com,text,383b2e75a7a4198c42f8f87833eefb772868a56f," func ParseBase(s string) (Language, error) {
 // ParseScript parses a 4-letter ISO 15924 code.
 // It returns a ValueError if s is a well-formed but unknown script identifier
 // or another error if another error occurred.
-func ParseScript(s string) (Script, error) {
+func ParseScript(s string) (scr Script, err error) {
+	defer func() {
+		if recover() != nil {
+			scr = 0
+			err = ErrSyntax
+		}
+	}()
+
 	if len(s) != 4 {
 		return 0, ErrSyntax
 	}
"
GO-2021-0113,go.googlesource.com,text,383b2e75a7a4198c42f8f87833eefb772868a56f," func EncodeM49(r int) (Region, error) {
 // ParseRegion parses a 2- or 3-letter ISO 3166-1 or a UN M.49 code.
 // It returns a ValueError if s is a well-formed but unknown region identifier
 // or another error if another error occurred.
-func ParseRegion(s string) (Region, error) {
+func ParseRegion(s string) (r Region, err error) {
+	defer func() {
+		if recover() != nil {
+			r = 0
+			err = ErrSyntax
+		}
+	}()
+
 	if n := len(s); n < 2 || 3 < n {
 		return 0, ErrSyntax
 	}
"
GO-2021-0113,go.googlesource.com,text,383b2e75a7a4198c42f8f87833eefb772868a56f," type Variant struct {
 
 // ParseVariant parses and returns a Variant. An error is returned if s is not
 // a valid variant.
-func ParseVariant(s string) (Variant, error) {
+func ParseVariant(s string) (v Variant, err error) {
+	defer func() {
+		if recover() != nil {
+			v = Variant{}
+			err = ErrSyntax
+		}
+	}()
+
 	s = strings.ToLower(s)
 	if id, ok := variantIndex[s]; ok {
 		return Variant{id, s}, nil
"
GO-2021-0113,go.googlesource.com,text,383b2e75a7a4198c42f8f87833eefb772868a56f," var errInvalidWeight = errors.New(""ParseAcceptLanguage: invalid weight"")
 // Tags with a weight of zero will be dropped. An error will be returned if the
 // input could not be parsed.
 func ParseAcceptLanguage(s string) (tag []Tag, q []float32, err error) {
+	defer func() {
+		if recover() != nil {
+			tag = nil
+			q = nil
+			err = language.ErrSyntax
+		}
+	}()
+
 	var entry string
 	for s != """" {
 		if entry, s = split(s, ','); entry == """" {
"
GO-2021-0239,go.googlesource.com,go,c89f1224a544cde464fcb86e78ebb0cc97eedba2," func (r *Resolver) LookupCNAME(ctx context.Context, host string) (cname string,
 // That is, it looks up _service._proto.name. To accommodate services
 // publishing SRV records under non-standard names, if both service
 // and proto are empty strings, LookupSRV looks up name directly.
+//
+// The returned service names are validated to be properly
+// formatted presentation-format domain names.
 func LookupSRV(service, proto, name string) (cname string, addrs []*SRV, err error) {
 	return DefaultResolver.lookupSRV(context.Background(), service, proto, name)
 }
"
GO-2020-0013,go.googlesource.com,crypto,e4e2799dd7aab89f583e1d898300d96367750991," func (t *handshakeTransport) client(kex kexAlgorithm, algs *algorithms, magics *
 		return nil, err
 	}
 
-	if t.hostKeyCallback != nil {
-		err = t.hostKeyCallback(t.dialAddress, t.remoteAddr, hostKey)
-		if err != nil {
-			return nil, err
-		}
+	err = t.hostKeyCallback(t.dialAddress, t.remoteAddr, hostKey)
+	if err != nil {
+		return nil, err
 	}
 
 	return result, nil
"
GO-2021-0264,go.googlesource.com,go,b24687394b55a93449e2be4e6892ead58ea9a10f," func (r *Reader) initFileList() {
 		for _, file := range r.File {
 			isDir := len(file.Name) > 0 && file.Name[len(file.Name)-1] == '/'
 			name := toValidName(file.Name)
+			if name == """" {
+				continue
+			}
 			for dir := path.Dir(name); dir != "".""; dir = path.Dir(dir) {
 				dirs[dir] = true
 			}
"
GO-2022-0211,go.googlesource.com,go,61bb56ad63992a3199acc55b2537c8355ef887b6," func resetProxyConfig() {
 }
 
 func (t *Transport) connectMethodForRequest(treq *transportRequest) (cm connectMethod, err error) {
+	// TODO: the validPort check is redundant after CL 189258, as url.URL.Port
+	// only returns valid ports now. golang.org/issue/33600
 	if port := treq.URL.Port(); !validPort(port) {
 		return cm, fmt.Errorf(""invalid URL port %q"", port)
 	}
"
